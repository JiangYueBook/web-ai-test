/*!
 * ONNX Runtime Web v1.17.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
"use strict";var ort=(()=>{var Sn=Object.defineProperty;var wl=Object.getOwnPropertyDescriptor;var vl=Object.getOwnPropertyNames;var $l=Object.prototype.hasOwnProperty;var L=(e,t)=>()=>(e&&(t=e(e=0)),t);var Gt=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),_t=(e,t)=>{for(var r in t)Sn(e,r,{get:t[r],enumerable:!0})},xl=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of vl(t))!$l.call(e,n)&&n!==r&&Sn(e,n,{get:()=>t[n],enumerable:!(o=wl(t,n))||o.enumerable});return e};var bt=e=>xl(Sn({},"__esModule",{value:!0}),e);var Br,Et,pt,Mr,Dr=L(()=>{Br=new Map,Et=[],pt=(e,t,r)=>{if(t&&typeof t.init=="function"&&typeof t.createInferenceSessionHandler=="function"){let o=Br.get(e);if(o===void 0)Br.set(e,{backend:t,priority:r});else{if(o.priority>r)return;if(o.priority===r&&o.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${r}`)}if(r>=0){let n=Et.indexOf(e);n!==-1&&Et.splice(n,1);for(let s=0;s<Et.length;s++)if(Br.get(Et[s]).priority<=r){Et.splice(s,0,e);return}Et.push(e)}return}throw new TypeError("not a valid backend")},Mr=async e=>{let t=e.length===0?Et:e,r=[];for(let o of t){let n=Br.get(o);if(n){if(n.initialized)return n.backend;if(n.aborted)continue;let s=!!n.initPromise;try{return s||(n.initPromise=n.backend.init()),await n.initPromise,n.initialized=!0,n.backend}catch(u){s||r.push({name:o,err:u}),n.aborted=!0}finally{delete n.initPromise}}}throw new Error(`no available backend found. ERR: ${r.map(o=>`[${o.name}] ${o.err}`).join(", ")}`)}});var Ua=L(()=>{Dr()});var Va,La=L(()=>{Va="1.17.0"});var Ha,Cn,Fa=L(()=>{La();Ha="warning",Cn={wasm:{},webgl:{},webgpu:{},versions:{common:Va},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);Ha=e}},get logLevel(){return Ha}};Object.defineProperty(Cn,"logLevel",{enumerable:!0})});var Ie,ja=L(()=>{Fa();Ie=Cn});var qa,Ka,Ya=L(()=>{qa=(e,t)=>{let r=document.createElement("canvas");r.width=e.dims[3],r.height=e.dims[2];let o=r.getContext("2d");if(o!=null){let n,s;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(n=e.dims[2],s=e.dims[3]):(n=e.dims[3],s=e.dims[2]);let u=t?.format!==void 0?t.format:"RGB",l=t?.norm,a,p;l===void 0||l.mean===void 0?a=[255,255,255,255]:typeof l.mean=="number"?a=[l.mean,l.mean,l.mean,l.mean]:(a=[l.mean[0],l.mean[1],l.mean[2],0],l.mean[3]!==void 0&&(a[3]=l.mean[3])),l===void 0||l.bias===void 0?p=[0,0,0,0]:typeof l.bias=="number"?p=[l.bias,l.bias,l.bias,l.bias]:(p=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(p[3]=l.bias[3]));let h=s*n,b=0,g=h,v=h*2,$=-1;u==="RGBA"?(b=0,g=h,v=h*2,$=h*3):u==="RGB"?(b=0,g=h,v=h*2):u==="RBG"&&(b=0,v=h,g=h*2);for(let w=0;w<s;w++)for(let S=0;S<n;S++){let I=(e.data[b++]-p[0])*a[0],T=(e.data[g++]-p[1])*a[1],B=(e.data[v++]-p[2])*a[2],P=$===-1?255:(e.data[$++]-p[3])*a[3];o.fillStyle="rgba("+I+","+T+","+B+","+P+")",o.fillRect(S,w,1,1)}return r.toDataURL()}else throw new Error("Can not access image data")},Ka=(e,t)=>{let r=document.createElement("canvas").getContext("2d"),o;if(r!=null){let n,s,u;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(n=e.dims[2],s=e.dims[1],u=e.dims[3]):(n=e.dims[3],s=e.dims[2],u=e.dims[1]);let l=t!==void 0&&t.format!==void 0?t.format:"RGB",a=t?.norm,p,h;a===void 0||a.mean===void 0?p=[255,255,255,255]:typeof a.mean=="number"?p=[a.mean,a.mean,a.mean,a.mean]:(p=[a.mean[0],a.mean[1],a.mean[2],255],a.mean[3]!==void 0&&(p[3]=a.mean[3])),a===void 0||a.bias===void 0?h=[0,0,0,0]:typeof a.bias=="number"?h=[a.bias,a.bias,a.bias,a.bias]:(h=[a.bias[0],a.bias[1],a.bias[2],0],a.bias[3]!==void 0&&(h[3]=a.bias[3]));let b=s*n;if(t!==void 0&&(t.format!==void 0&&u===4&&t.format!=="RGBA"||u===3&&t.format!=="RGB"&&t.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let g=4,v=0,$=1,w=2,S=3,I=0,T=b,B=b*2,P=-1;l==="RGBA"?(I=0,T=b,B=b*2,P=b*3):l==="RGB"?(I=0,T=b,B=b*2):l==="RBG"&&(I=0,B=b,T=b*2),o=r.createImageData(n,s);for(let M=0;M<s*n;v+=g,$+=g,w+=g,S+=g,M++)o.data[v]=(e.data[I++]-h[0])*p[0],o.data[$]=(e.data[T++]-h[1])*p[1],o.data[w]=(e.data[B++]-h[2])*p[2],o.data[S]=P===-1?255:(e.data[P++]-h[3])*p[3]}else throw new Error("Can not access image data");return o}});var In,Xa,Ja,Qa,Za,eo=L(()=>{zr();In=(e,t)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(t.height===void 0||t.width===void 0)throw new Error("Image height and width must be defined");if(t.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:r,width:o}=t,n=t.norm??{mean:255,bias:0},s,u;typeof n.mean=="number"?s=[n.mean,n.mean,n.mean,n.mean]:s=[n.mean[0],n.mean[1],n.mean[2],n.mean[3]??255],typeof n.bias=="number"?u=[n.bias,n.bias,n.bias,n.bias]:u=[n.bias[0],n.bias[1],n.bias[2],n.bias[3]??0];let l=t.format!==void 0?t.format:"RGBA",a=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:"RGB",p=r*o,h=a==="RGBA"?new Float32Array(p*4):new Float32Array(p*3),b=4,g=0,v=1,$=2,w=3,S=0,I=p,T=p*2,B=-1;l==="RGB"&&(b=3,g=0,v=1,$=2,w=-1),a==="RGBA"?B=p*3:a==="RBG"?(S=0,T=p,I=p*2):a==="BGR"&&(T=0,I=p,S=p*2);for(let M=0;M<p;M++,g+=b,$+=b,v+=b,w+=b)h[S++]=(e[g]+u[0])/s[0],h[I++]=(e[v]+u[1])/s[1],h[T++]=(e[$]+u[2])/s[2],B!==-1&&w!==-1&&(h[B++]=(e[w]+u[3])/s[3]);return a==="RGBA"?new Ve("float32",h,[1,4,r,o]):new Ve("float32",h,[1,3,r,o])},Xa=async(e,t)=>{let r=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,o=typeof ImageData<"u"&&e instanceof ImageData,n=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,s=typeof e=="string",u,l=t??{};if(r){let a=document.createElement("canvas");a.width=e.width,a.height=e.height;let p=a.getContext("2d");if(p!=null){let h=e.height,b=e.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(h=t.resizedHeight,b=t.resizedWidth),t!==void 0){if(l=t,t.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");l.tensorFormat="RGBA",l.height=h,l.width=b}else l.tensorFormat="RGBA",l.height=h,l.width=b;p.drawImage(e,0,0),u=p.getImageData(0,0,b,h).data}else throw new Error("Can not access image data")}else if(o){let a,p;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(a=t.resizedHeight,p=t.resizedWidth):(a=e.height,p=e.width),t!==void 0&&(l=t),l.format="RGBA",l.height=a,l.width=p,t!==void 0){let h=document.createElement("canvas");h.width=p,h.height=a;let b=h.getContext("2d");if(b!=null)b.putImageData(e,0,0),u=b.getImageData(0,0,p,a).data;else throw new Error("Can not access image data")}else u=e.data}else if(n){if(t===void 0)throw new Error("Please provide image config with format for Imagebitmap");let a=document.createElement("canvas");a.width=e.width,a.height=e.height;let p=a.getContext("2d");if(p!=null){let h=e.height,b=e.width;return p.drawImage(e,0,0,b,h),u=p.getImageData(0,0,b,h).data,l.height=h,l.width=b,In(u,l)}else throw new Error("Can not access image data")}else{if(s)return new Promise((a,p)=>{let h=document.createElement("canvas"),b=h.getContext("2d");if(!e||!b)return p();let g=new Image;g.crossOrigin="Anonymous",g.src=e,g.onload=()=>{h.width=g.width,h.height=g.height,b.drawImage(g,0,0,h.width,h.height);let v=b.getImageData(0,0,h.width,h.height);l.height=h.height,l.width=h.width,a(In(v.data,l))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(u!==void 0)return In(u,l);throw new Error("Input data provided is not supported - aborted tensor creation")},Ja=(e,t)=>{let{width:r,height:o,download:n,dispose:s}=t,u=[1,o,r,4];return new Ve({location:"texture",type:"float32",texture:e,dims:u,download:n,dispose:s})},Qa=(e,t)=>{let{dataType:r,dims:o,download:n,dispose:s}=t;return new Ve({location:"gpu-buffer",type:r??"float32",gpuBuffer:e,dims:o,download:n,dispose:s})},Za=(e,t,r)=>new Ve({location:"cpu-pinned",type:e,data:t,dims:r??[t.length]})});var sr,Wr,to,ro,no=L(()=>{sr=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),Wr=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),to=!1,ro=()=>{if(!to){to=!0;let e=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",t=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function";e&&(sr.set("int64",BigInt64Array),Wr.set(BigInt64Array,"int64")),t&&(sr.set("uint64",BigUint64Array),Wr.set(BigUint64Array,"uint64"))}}});var ao,oo,io=L(()=>{zr();ao=e=>{let t=1;for(let r=0;r<e.length;r++){let o=e[r];if(typeof o!="number"||!Number.isSafeInteger(o))throw new TypeError(`dims[${r}] must be an integer, got: ${o}`);if(o<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${o}`);t*=o}return t},oo=(e,t)=>{switch(e.location){case"cpu":return new Ve(e.type,e.data,t);case"cpu-pinned":return new Ve({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new Ve({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new Ve({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}});var Ve,zr=L(()=>{Ya();eo();no();io();Ve=class{constructor(t,r,o){ro();let n,s;if(typeof t=="object"&&"location"in t)switch(this.dataLocation=t.location,n=t.type,s=t.dims,t.location){case"cpu-pinned":{let l=sr.get(n);if(!l)throw new TypeError(`unsupported type "${n}" to create tensor from pinned buffer`);if(!(t.data instanceof l))throw new TypeError(`buffer should be of type ${l.name}`);this.cpuData=t.data;break}case"texture":{if(n!=="float32")throw new TypeError(`unsupported type "${n}" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case"gpu-buffer":{if(n!=="float32"&&n!=="float16"&&n!=="int32"&&n!=="int64"&&n!=="uint32"&&n!=="bool")throw new TypeError(`unsupported type "${n}" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let l,a;if(typeof t=="string")if(n=t,a=o,t==="string"){if(!Array.isArray(r))throw new TypeError("A string tensor's data must be a string array.");l=r}else{let p=sr.get(t);if(p===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(r)){if(t==="float16")throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");t==="uint64"||t==="int64"?l=p.from(r,BigInt):l=p.from(r)}else if(r instanceof p)l=r;else throw new TypeError(`A ${n} tensor's data must be type of ${p}`)}else if(a=r,Array.isArray(t)){if(t.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let p=typeof t[0];if(p==="string")n="string",l=t;else if(p==="boolean")n="bool",l=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${p}.`)}else{let p=Wr.get(t.constructor);if(p===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);n=p,l=t}if(a===void 0)a=[l.length];else if(!Array.isArray(a))throw new TypeError("A tensor's dims must be a number array");s=a,this.cpuData=l,this.dataLocation="cpu"}let u=ao(s);if(this.cpuData&&u!==this.cpuData.length)throw new Error(`Tensor's size(${u}) does not match data length(${this.cpuData.length}).`);this.type=n,this.dims=s,this.size=u}static async fromImage(t,r){return Xa(t,r)}static fromTexture(t,r){return Ja(t,r)}static fromGpuBuffer(t,r){return Qa(t,r)}static fromPinnedBuffer(t,r,o){return Za(t,r,o)}toDataURL(t){return qa(this,t)}toImageData(t){return Ka(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(t){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let r=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=r,t&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return oo(this,t)}}});var Ze,An=L(()=>{zr();Ze=Ve});var Nr,so=L(()=>{Dr();An();Nr=class e{constructor(t){this.handler=t}async run(t,r,o){let n={},s={};if(typeof t!="object"||t===null||t instanceof Ze||Array.isArray(t))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let u=!0;if(typeof r=="object"){if(r===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof Ze)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(r.length===0)throw new TypeError("'fetches' cannot be an empty array.");u=!1;for(let p of r){if(typeof p!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(p)===-1)throw new RangeError(`'fetches' contains invalid output name: ${p}.`);n[p]=null}if(typeof o=="object"&&o!==null)s=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else{let p=!1,h=Object.getOwnPropertyNames(r);for(let b of this.outputNames)if(h.indexOf(b)!==-1){let g=r[b];(g===null||g instanceof Ze)&&(p=!0,u=!1,n[b]=g)}if(p){if(typeof o=="object"&&o!==null)s=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else s=r}}else if(typeof r<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let p of this.inputNames)if(typeof t[p]>"u")throw new Error(`input '${p}' is missing in 'feeds'.`);if(u)for(let p of this.outputNames)n[p]=null;let l=await this.handler.run(t,n,s),a={};for(let p in l)if(Object.hasOwnProperty.call(l,p)){let h=l[p];h instanceof Ze?a[p]=h:a[p]=new Ze(h.type,h.data,h.dims)}return a}async release(){return this.handler.dispose()}static async create(t,r,o,n){let s,u={};if(typeof t=="string"){if(s=t,typeof r=="object"&&r!==null)u=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(s=t,typeof r=="object"&&r!==null)u=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer){let b=t,g=0,v=t.byteLength;if(typeof r=="object"&&r!==null)u=r;else if(typeof r=="number"){if(g=r,!Number.isSafeInteger(g))throw new RangeError("'byteOffset' must be an integer.");if(g<0||g>=b.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${b.byteLength}).`);if(v=t.byteLength-g,typeof o=="number"){if(v=o,!Number.isSafeInteger(v))throw new RangeError("'byteLength' must be an integer.");if(v<=0||g+v>b.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${b.byteLength-g}].`);if(typeof n=="object"&&n!==null)u=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(typeof o<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof r<"u")throw new TypeError("'options' must be an object.");s=new Uint8Array(b,g,v)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let a=(u.executionProviders||[]).map(b=>typeof b=="string"?b:b.name),h=await(await Mr(a)).createInferenceSessionHandler(s,u);return new e(h)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var uo,lo=L(()=>{so();uo=Nr});var co=L(()=>{});var Sl,Gr,po=L(()=>{Dr();Sl="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",Gr=class e{constructor(t){this.handler=t}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}static async create(t,r){let o=t.evalModel||"",n=t.optimizerModel||"",s=r||{},l=(s.executionProviders||[]).map(p=>typeof p=="string"?p:p.name),a=await Mr(l);if(a.createTrainingSessionHandler){let p=await a.createTrainingSessionHandler(t.checkpointState,t.trainModel,o,n,s);return new e(p)}else throw new Error(Sl)}async loadParametersBuffer(t,r){throw new Error("Method not implemented.")}async getContiguousParameters(t){throw new Error("Method not implemented.")}async runTrainStep(t,r,o){throw new Error("Method not implemented.")}async release(){return this.handler.dispose()}}});var fo,mo=L(()=>{po();fo=Gr});var _n={};_t(_n,{InferenceSession:()=>uo,Tensor:()=>Ze,TrainingSession:()=>fo,env:()=>Ie,registerBackend:()=>pt});var wt=L(()=>{Ua();ja();lo();An();co();mo()});var En={};_t(En,{readFile:()=>Cl});var Cl,On=L(()=>{Cl=void 0});var Tn={};_t(Tn,{join:()=>Il});var Il,Rn=L(()=>{Il=void 0});var bo=Gt((yo,Pn)=>{"use strict";var go=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){var r=t,o,n;r.ready=new Promise((d,f)=>{o=d,n=f}),r.jsepInit=(d,f,y,C,_,U,F,j)=>{r.Za=d,r.Oa=f,r.Qa=y,r.Ja=C,r.Pa=_,r.ra=U,r.Ra=F,r.Sa=j,f=(X,J,Z)=>(...ce)=>{let me=Fe,E=J?.();ce=X(...ce);let se=J?.();return E!==se&&(X=se,Z(E),J=Z=null),Fe!=me?Sr():ce},y=X=>async(...J)=>{try{if(r.Da)throw Error("Session already started");let Z=r.Da={Ta:J[0],errors:[]},ce=await X(...J);if(r.Da!==Z)throw Error("Session mismatch");d.flush();let me=Z.errors;if(0<me.length){let E=await Promise.all(me);if(E=E.filter(se=>se),0<E.length)throw Error(E.join(`
`))}return ce}finally{r.Da=null}},r._OrtRun=y(f(r._OrtRun,()=>r._OrtRun,X=>r._OrtRun=X)),r._OrtRunWithBinding=y(f(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,X=>r._OrtRunWithBinding=X)),r._OrtBindInput=f(r._OrtBindInput,()=>r._OrtBindInput,X=>r._OrtBindInput=X),r.jsepRegisterBuffer=(X,J,Z,ce)=>d.registerBuffer(X,J,Z,ce),r.jsepUnregisterBuffers=X=>{d.unregisterBuffers(X)},r.jsepGetBuffer=X=>d.getBuffer(X),r.jsepCreateDownloader=(X,J,Z)=>d.createDownloader(X,J,Z)};var s=Object.assign({},r),u="./this.program",l=(d,f)=>{throw f},a=typeof window=="object",p=typeof importScripts=="function",h=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",b="",g,v,$;if(h){var w=(On(),bt(En)),S=(Rn(),bt(Tn));b=p?S.dirname(b)+"/":__dirname+"/",g=(d,f)=>(d=d.startsWith("file://")?new URL(d):S.normalize(d),w.readFileSync(d,f?void 0:"utf8")),$=d=>(d=g(d,!0),d.buffer||(d=new Uint8Array(d)),d),v=(d,f,y,C=!0)=>{d=d.startsWith("file://")?new URL(d):S.normalize(d),w.readFile(d,C?void 0:"utf8",(_,U)=>{_?y(_):f(C?U.buffer:U)})},!r.thisProgram&&1<process.argv.length&&(u=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),l=(d,f)=>{throw process.exitCode=d,f},r.inspect=()=>"[Emscripten Module object]"}else(a||p)&&(p?b=self.location.href:typeof document<"u"&&document.currentScript&&(b=document.currentScript.src),e&&(b=e),b.indexOf("blob:")!==0?b=b.substr(0,b.replace(/[?#].*/,"").lastIndexOf("/")+1):b="",g=d=>{var f=new XMLHttpRequest;return f.open("GET",d,!1),f.send(null),f.responseText},p&&($=d=>{var f=new XMLHttpRequest;return f.open("GET",d,!1),f.responseType="arraybuffer",f.send(null),new Uint8Array(f.response)}),v=(d,f,y)=>{var C=new XMLHttpRequest;C.open("GET",d,!0),C.responseType="arraybuffer",C.onload=()=>{C.status==200||C.status==0&&C.response?f(C.response):y()},C.onerror=y,C.send(null)});var I=r.print||console.log.bind(console),T=r.printErr||console.error.bind(console);Object.assign(r,s),s=null,r.thisProgram&&(u=r.thisProgram),r.quit&&(l=r.quit);var B;r.wasmBinary&&(B=r.wasmBinary);var P=r.noExitRuntime||!0;typeof WebAssembly!="object"&&Ge("no native wasm support detected");var M,R,W=!1,V,Y,le,D,K,Se;function oe(){var d=M.buffer;r.HEAP8=Y=new Int8Array(d),r.HEAP16=new Int16Array(d),r.HEAP32=D=new Int32Array(d),r.HEAPU8=le=new Uint8Array(d),r.HEAPU16=new Uint16Array(d),r.HEAPU32=K=new Uint32Array(d),r.HEAPF32=new Float32Array(d),r.HEAPF64=Se=new Float64Array(d)}var we=[],q=[],Ce=[];function Be(){var d=r.preRun.shift();we.unshift(d)}var xe=0,_e=null,rt=null;function Ge(d){throw r.onAbort&&r.onAbort(d),d="Aborted("+d+")",T(d),W=!0,V=1,d=new WebAssembly.RuntimeError(d+". Build with -sASSERTIONS for more info."),n(d),d}function dt(d){return d.startsWith("data:application/octet-stream;base64,")}var G;if(G="ort-wasm-simd.wasm",!dt(G)){var de=G;G=r.locateFile?r.locateFile(de,b):b+de}function pe(d){if(d==G&&B)return new Uint8Array(B);if($)return $(d);throw"both async and sync fetching of the wasm failed"}function Ne(d){if(!B&&(a||p)){if(typeof fetch=="function"&&!d.startsWith("file://"))return fetch(d,{credentials:"same-origin"}).then(f=>{if(!f.ok)throw"failed to load wasm binary file at '"+d+"'";return f.arrayBuffer()}).catch(()=>pe(d));if(v)return new Promise((f,y)=>{v(d,C=>f(new Uint8Array(C)),y)})}return Promise.resolve().then(()=>pe(d))}function Ue(d,f,y){return Ne(d).then(C=>WebAssembly.instantiate(C,f)).then(C=>C).then(y,C=>{T("failed to asynchronously prepare wasm: "+C),Ge(C)})}function Te(d,f){var y=G;return B||typeof WebAssembly.instantiateStreaming!="function"||dt(y)||y.startsWith("file://")||h||typeof fetch!="function"?Ue(y,d,f):fetch(y,{credentials:"same-origin"}).then(C=>WebAssembly.instantiateStreaming(C,d).then(f,function(_){return T("wasm streaming compile failed: "+_),T("falling back to ArrayBuffer instantiation"),Ue(y,d,f)}))}var Ee,qe={915152:d=>{r.ra("Abs",d,void 0)},915203:d=>{r.ra("Neg",d,void 0)},915254:d=>{r.ra("Floor",d,void 0)},915307:d=>{r.ra("Ceil",d,void 0)},915359:d=>{r.ra("Reciprocal",d,void 0)},915417:d=>{r.ra("Sqrt",d,void 0)},915469:d=>{r.ra("Exp",d,void 0)},915520:d=>{r.ra("Erf",d,void 0)},915571:d=>{r.ra("Sigmoid",d,void 0)},915626:d=>{r.ra("Log",d,void 0)},915677:d=>{r.ra("Sin",d,void 0)},915728:d=>{r.ra("Cos",d,void 0)},915779:d=>{r.ra("Tan",d,void 0)},915830:d=>{r.ra("Asin",d,void 0)},915882:d=>{r.ra("Acos",d,void 0)},915934:d=>{r.ra("Atan",d,void 0)},915986:d=>{r.ra("Sinh",d,void 0)},916038:d=>{r.ra("Cosh",d,void 0)},916090:d=>{r.ra("Asinh",d,void 0)},916143:d=>{r.ra("Acosh",d,void 0)},916196:d=>{r.ra("Atanh",d,void 0)},916249:d=>{r.ra("Tanh",d,void 0)},916301:d=>{r.ra("Not",d,void 0)},916352:(d,f,y)=>{r.ra("ClipV10",d,{min:f,max:y})},916424:d=>{r.ra("Clip",d,void 0)},916476:(d,f)=>{r.ra("Elu",d,{alpha:f})},916534:d=>{r.ra("Relu",d,void 0)},916586:(d,f)=>{r.ra("LeakyRelu",d,{alpha:f})},916650:(d,f)=>{r.ra("ThresholdedRelu",d,{alpha:f})},916720:(d,f)=>{r.ra("Cast",d,{to:f})},916778:d=>{r.ra("Add",d,void 0)},916829:d=>{r.ra("Sub",d,void 0)},916880:d=>{r.ra("Mul",d,void 0)},916931:d=>{r.ra("Div",d,void 0)},916982:d=>{r.ra("Pow",d,void 0)},917033:d=>{r.ra("Equal",d,void 0)},917086:d=>{r.ra("Greater",d,void 0)},917141:d=>{r.ra("GreaterOrEqual",d,void 0)},917203:d=>{r.ra("Less",d,void 0)},917255:d=>{r.ra("LessOrEqual",d,void 0)},917314:(d,f,y,C,_)=>{r.ra("ReduceMean",d,{keepDims:!!f,noopWithEmptyAxes:!!y,axes:C?Array.from(D.subarray(_>>>0,_+C>>>0)):[]})},917478:(d,f,y,C,_)=>{r.ra("ReduceMax",d,{keepDims:!!f,noopWithEmptyAxes:!!y,axes:C?Array.from(D.subarray(_>>>0,_+C>>>0)):[]})},917641:(d,f,y,C,_)=>{r.ra("ReduceMin",d,{keepDims:!!f,noopWithEmptyAxes:!!y,axes:C?Array.from(D.subarray(_>>>0,_+C>>>0)):[]})},917804:(d,f,y,C,_)=>{r.ra("ReduceProd",d,{keepDims:!!f,noopWithEmptyAxes:!!y,axes:C?Array.from(D.subarray(_>>>0,_+C>>>0)):[]})},917968:(d,f,y,C,_)=>{r.ra("ReduceSum",d,{keepDims:!!f,noopWithEmptyAxes:!!y,axes:C?Array.from(D.subarray(_>>>0,_+C>>>0)):[]})},918131:(d,f,y,C,_)=>{r.ra("ReduceL1",d,{keepDims:!!f,noopWithEmptyAxes:!!y,axes:C?Array.from(D.subarray(_>>>0,_+C>>>0)):[]})},918293:(d,f,y,C,_)=>{r.ra("ReduceL2",d,{keepDims:!!f,noopWithEmptyAxes:!!y,axes:C?Array.from(D.subarray(_>>>0,_+C>>>0)):[]})},918455:(d,f,y,C,_)=>{r.ra("ReduceLogSum",d,{keepDims:!!f,noopWithEmptyAxes:!!y,axes:C?Array.from(D.subarray(_>>>0,_+C>>>0)):[]})},918621:(d,f,y,C,_)=>{r.ra("ReduceSumSquare",d,{keepDims:!!f,noopWithEmptyAxes:!!y,axes:C?Array.from(D.subarray(_>>>0,_+C>>>0)):[]})},918790:(d,f,y,C,_)=>{r.ra("ReduceLogSumExp",d,{keepDims:!!f,noopWithEmptyAxes:!!y,axes:C?Array.from(D.subarray(_>>>0,_+C>>>0)):[]})},918959:d=>{r.ra("Where",d,void 0)},919012:(d,f,y)=>{r.ra("Transpose",d,{perm:f?Array.from(D.subarray(y>>>0,y+f>>>0)):[]})},919125:(d,f,y,C,_,U,F,j,X,J)=>{r.ra("Conv",d,{format:X?"NHWC":"NCHW",auto_pad:f,dilations:[y],group:C,kernel_shape:[_],pads:[U,F],strides:[j],w_is_const:()=>!!Y[J>>>0]})},919353:(d,f,y,C,_,U,F,j,X,J,Z,ce,me,E,se)=>{r.ra("Conv",d,{format:E?"NHWC":"NCHW",auto_pad:f,dilations:[y,C],group:_,kernel_shape:[U,F],pads:[j,X,J,Z],strides:[ce,me],w_is_const:()=>!!Y[se>>>0]})},919612:(d,f,y,C,_,U,F,j,X,J)=>{r.ra("Conv",d,{format:X?"NHWC":"NCHW",auto_pad:f,dilations:[y],group:C,kernel_shape:[_],pads:[U,F],strides:[j],w_is_const:()=>!!Y[J>>>0]})},919840:(d,f,y,C,_,U,F,j,X,J,Z,ce,me,E,se)=>{r.ra("Conv",d,{format:E?"NHWC":"NCHW",auto_pad:f,dilations:[y,C],group:_,kernel_shape:[U,F],pads:[j,X,J,Z],strides:[ce,me],w_is_const:()=>!!Y[se>>>0]})},920099:(d,f,y,C,_,U,F,j,X,J,Z,ce,me,E)=>{r.ra("ConvTranspose",d,{format:X?"NHWC":"NCHW",autoPad:f,dilations:[y],group:C,kernel_shape:[_],pads:[U,F],strides:[j],wIsConst:()=>!!Y[J>>>0],outputPadding:Z?Array.from(D.subarray(ce>>>0,ce+Z>>>0)):[],outputShape:me?Array.from(D.subarray(E>>>0,E+me>>>0)):[]})},920479:(d,f,y,C,_,U,F,j,X,J,Z,ce,me)=>{r.ra("ConvTranspose",d,{format:j?"NHWC":"NCHW",autoPad:f,dilations:Array.from(D.subarray(y>>>0,y+2>>>0)),group:C,kernelShape:Array.from(D.subarray(_>>>0,_+2>>>0)),pads:Array.from(D.subarray(U>>>0,U+4>>>0)),strides:Array.from(D.subarray(F>>>0,F+2>>>0)),wIsConst:()=>!!Y[X>>>0],outputPadding:0<J?Array.from(D.subarray(Z>>>0,Z+J>>>0)):[],outputShape:0<ce?Array.from(D.subarray(me>>>0,me+ce>>>0)):[]})},921002:(d,f,y,C,_,U,F,j,X,J,Z,ce,me,E)=>{r.ra("ConvTranspose",d,{format:X?"NHWC":"NCHW",autoPad:f,dilations:[y],group:C,kernel_shape:[_],pads:[U,F],strides:[j],wIsConst:()=>!!Y[J>>>0],outputPadding:Z?Array.from(D.subarray(ce>>>0,ce+Z>>>0)):[],outputShape:me?Array.from(D.subarray(E>>>0,E+me>>>0)):[]})},921382:(d,f,y,C,_,U,F,j,X,J,Z,ce,me)=>{r.ra("ConvTranspose",d,{format:j?"NHWC":"NCHW",autoPad:f,dilations:Array.from(D.subarray(y>>>0,y+2>>>0)),group:C,kernelShape:Array.from(D.subarray(_>>>0,_+2>>>0)),pads:Array.from(D.subarray(U>>>0,U+4>>>0)),strides:Array.from(D.subarray(F>>>0,F+2>>>0)),wIsConst:()=>!!Y[X>>>0],outputPadding:0<J?Array.from(D.subarray(Z>>>0,Z+J>>>0)):[],outputShape:0<ce?Array.from(D.subarray(me>>>0,me+ce>>>0)):[]})},921905:(d,f)=>{r.ra("GlobalAveragePool",d,{format:f?"NHWC":"NCHW"})},921996:(d,f,y,C,_,U,F,j,X,J,Z,ce,me,E,se,ge)=>{r.ra("AveragePool",d,{format:ge?"NHWC":"NCHW",auto_pad:f,ceil_mode:y,count_include_pad:C,storage_order:_,dilations:[U,F],kernel_shape:[j,X],pads:[J,Z,ce,me],strides:[E,se]})},922280:(d,f)=>{r.ra("GlobalAveragePool",d,{format:f?"NHWC":"NCHW"})},922371:(d,f,y,C,_,U,F,j,X,J,Z,ce,me,E,se,ge)=>{r.ra("AveragePool",d,{format:ge?"NHWC":"NCHW",auto_pad:f,ceil_mode:y,count_include_pad:C,storage_order:_,dilations:[U,F],kernel_shape:[j,X],pads:[J,Z,ce,me],strides:[E,se]})},922655:(d,f)=>{r.ra("GlobalMaxPool",d,{format:f?"NHWC":"NCHW"})},922742:(d,f,y,C,_,U,F,j,X,J,Z,ce,me,E,se,ge)=>{r.ra("MaxPool",d,{format:ge?"NHWC":"NCHW",auto_pad:f,ceil_mode:y,count_include_pad:C,storage_order:_,dilations:[U,F],kernel_shape:[j,X],pads:[J,Z,ce,me],strides:[E,se]})},923022:(d,f)=>{r.ra("GlobalMaxPool",d,{format:f?"NHWC":"NCHW"})},923109:(d,f,y,C,_,U,F,j,X,J,Z,ce,me,E,se,ge)=>{r.ra("MaxPool",d,{format:ge?"NHWC":"NCHW",auto_pad:f,ceil_mode:y,count_include_pad:C,storage_order:_,dilations:[U,F],kernel_shape:[j,X],pads:[J,Z,ce,me],strides:[E,se]})},923389:(d,f,y,C,_)=>{r.ra("Gemm",d,{alpha:f,beta:y,transA:C,transB:_})},923493:d=>{r.ra("MatMul",d,void 0)},923547:(d,f,y,C)=>{r.ra("ArgMax",d,{keepDims:!!f,selectLastIndex:!!y,axis:C})},923655:(d,f,y,C)=>{r.ra("ArgMin",d,{keepDims:!!f,selectLastIndex:!!y,axis:C})},923763:(d,f)=>{r.ra("Softmax",d,{axis:f})},923826:(d,f)=>{r.ra("Concat",d,{axis:f})},923886:(d,f,y,C,_)=>{r.ra("Split",d,{axis:f,numOutputs:y,splitSizes:C?Array.from(D.subarray(_>>>0,_+C>>>0)):[]})},924031:d=>{r.ra("Expand",d,void 0)},924085:(d,f)=>{r.ra("Gather",d,{axis:Number(f)})},924156:(d,f)=>{r.ra("GatherElements",d,{axis:Number(f)})},924235:(d,f,y,C,_,U,F,j,X,J,Z)=>{r.ra("Resize",d,{antialias:f,axes:y?Array.from(D.subarray(C>>>0,C+y>>>0)):[],coordinateTransformMode:Xe(_),cubicCoeffA:U,excludeOutside:F,extrapolationValue:j,keepAspectRatioPolicy:Xe(X),mode:Xe(J),nearestMode:Xe(Z)})},924586:(d,f,y,C,_,U,F)=>{r.ra("Slice",d,{starts:f?Array.from(D.subarray(y>>>0,y+f>>>0)):[],ends:C?Array.from(D.subarray(_>>>0,_+C>>>0)):[],axes:U?Array.from(D.subarray(F>>>0,F+U>>>0)):[]})},924817:d=>{r.ra("Tile",d,void 0)},924869:(d,f,y)=>{r.ra("LayerNormalization",d,{axis:Number(f),epsilon:Number(y)})},924976:(d,f,y)=>{r.ra("InstanceNormalization",d,{epsilon:f,format:y?"NHWC":"NCHW"})},925090:(d,f,y)=>{r.ra("InstanceNormalization",d,{epsilon:f,format:y?"NHWC":"NCHW"})},925204:d=>{r.ra("Range",d,void 0)},925257:(d,f)=>{r.ra("Einsum",d,{equation:Xe(f)})},925338:(d,f,y,C,_)=>{r.ra("Pad",d,{mode:f,value:y,pads:C?Array.from(D.subarray(_>>>0,_+C>>>0)):[]})},925470:d=>{r.ra("Gelu",d,void 0)},925522:d=>{r.ra("BiasAdd",d,void 0)},925577:d=>{r.ra("BiasSplitGelu",d,void 0)},925638:(d,f)=>{r.ra("SkipLayerNormalization",d,{epsilon:f})},925719:d=>{r.Ra(d)},925753:(d,f)=>r.Sa(d,f,r.Da.Ta,r.Da.errors),925865:d=>r.Oa(d),925898:d=>r.Qa(d),925930:(d,f,y)=>{r.Ja(d,f,y,!0)},925969:(d,f,y)=>{r.Ja(d,f,y)}};function Ke(d){this.name="ExitStatus",this.message=`Program terminated with exit(${d})`,this.status=d}var He=d=>{for(;0<d.length;)d.shift()(r)};function Lt(d){this.Ha=d-24,this.Ma=function(f){K[this.Ha+4>>2>>>0]=f},this.La=function(f){K[this.Ha+8>>2>>>0]=f},this.Ya=function(f,y){this.Ka(),this.Ma(f),this.La(y)},this.Ka=function(){K[this.Ha+16>>2>>>0]=0}}var ht=0,br=0,Ht=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Ye=(d,f,y)=>{f>>>=0;var C=f+y;for(y=f;d[y]&&!(y>=C);)++y;if(16<y-f&&d.buffer&&Ht)return Ht.decode(d.subarray(f,y));for(C="";f<y;){var _=d[f++];if(_&128){var U=d[f++]&63;if((_&224)==192)C+=String.fromCharCode((_&31)<<6|U);else{var F=d[f++]&63;_=(_&240)==224?(_&15)<<12|U<<6|F:(_&7)<<18|U<<12|F<<6|d[f++]&63,65536>_?C+=String.fromCharCode(_):(_-=65536,C+=String.fromCharCode(55296|_>>10,56320|_&1023))}}else C+=String.fromCharCode(_)}return C},Xe=(d,f)=>(d>>>=0)?Ye(le,d,f):"",nt=d=>{for(var f=0,y=0;y<d.length;++y){var C=d.charCodeAt(y);127>=C?f++:2047>=C?f+=2:55296<=C&&57343>=C?(f+=4,++y):f+=3}return f},Rt=(d,f,y,C)=>{if(y>>>=0,!(0<C))return 0;var _=y;C=y+C-1;for(var U=0;U<d.length;++U){var F=d.charCodeAt(U);if(55296<=F&&57343>=F){var j=d.charCodeAt(++U);F=65536+((F&1023)<<10)|j&1023}if(127>=F){if(y>=C)break;f[y++>>>0]=F}else{if(2047>=F){if(y+1>=C)break;f[y++>>>0]=192|F>>6}else{if(65535>=F){if(y+2>=C)break;f[y++>>>0]=224|F>>12}else{if(y+3>=C)break;f[y++>>>0]=240|F>>18,f[y++>>>0]=128|F>>12&63}f[y++>>>0]=128|F>>6&63}f[y++>>>0]=128|F&63}}return f[y>>>0]=0,y-_},gt=d=>d%4===0&&(d%100!==0||d%400===0),Ft=[0,31,60,91,121,152,182,213,244,274,305,335],wr=[0,31,59,90,120,151,181,212,243,273,304,334],ct=d=>{var f=nt(d)+1,y=zt(f);return y&&Rt(d,le,y,f),y},St=[],Ct=(d,f)=>{St.length=0;var y;for(f>>=2;y=le[d++>>>0];)f+=y!=105&f,St.push(y==105?D[f>>>0]:Se[f++>>>1]),++f;return St},It={},jt=()=>{if(!Pt){var d={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:u||"./this.program"},f;for(f in It)It[f]===void 0?delete d[f]:d[f]=It[f];var y=[];for(f in d)y.push(`${f}=${d[f]}`);Pt=y}return Pt},Pt,vr=[null,[],[]],qt=[31,29,31,30,31,30,31,31,30,31,30,31],We=[31,28,31,30,31,30,31,31,30,31,30,31];function $r(d){var f=Array(nt(d)+1);return Rt(d,f,0,f.length),f}function kt(d,f,y,C){function _(E,se,ge){for(E=typeof E=="number"?E.toString():E||"";E.length<se;)E=ge[0]+E;return E}function U(E,se){return _(E,se,"0")}function F(E,se){function ge(Er){return 0>Er?-1:0<Er?1:0}var at;return(at=ge(E.getFullYear()-se.getFullYear()))===0&&(at=ge(E.getMonth()-se.getMonth()))===0&&(at=ge(E.getDate()-se.getDate())),at}function j(E){switch(E.getDay()){case 0:return new Date(E.getFullYear()-1,11,29);case 1:return E;case 2:return new Date(E.getFullYear(),0,3);case 3:return new Date(E.getFullYear(),0,2);case 4:return new Date(E.getFullYear(),0,1);case 5:return new Date(E.getFullYear()-1,11,31);case 6:return new Date(E.getFullYear()-1,11,30)}}function X(E){var se=E.Ba;for(E=new Date(new Date(E.Ca+1900,0,1).getTime());0<se;){var ge=E.getMonth(),at=(gt(E.getFullYear())?qt:We)[ge];if(se>at-E.getDate())se-=at-E.getDate()+1,E.setDate(1),11>ge?E.setMonth(ge+1):(E.setMonth(0),E.setFullYear(E.getFullYear()+1));else{E.setDate(E.getDate()+se);break}}return ge=new Date(E.getFullYear()+1,0,4),se=j(new Date(E.getFullYear(),0,4)),ge=j(ge),0>=F(se,E)?0>=F(ge,E)?E.getFullYear()+1:E.getFullYear():E.getFullYear()-1}d>>>=0,f>>>=0,y>>>=0,C>>>=0;var J=D[C+40>>2>>>0];C={Wa:D[C>>2>>>0],Va:D[C+4>>2>>>0],Ea:D[C+8>>2>>>0],Ia:D[C+12>>2>>>0],Fa:D[C+16>>2>>>0],Ca:D[C+20>>2>>>0],wa:D[C+24>>2>>>0],Ba:D[C+28>>2>>>0],$a:D[C+32>>2>>>0],Ua:D[C+36>>2>>>0],Xa:J?Xe(J):""},y=Xe(y),J={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var Z in J)y=y.replace(new RegExp(Z,"g"),J[Z]);var ce="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),me="January February March April May June July August September October November December".split(" ");J={"%a":E=>ce[E.wa].substring(0,3),"%A":E=>ce[E.wa],"%b":E=>me[E.Fa].substring(0,3),"%B":E=>me[E.Fa],"%C":E=>U((E.Ca+1900)/100|0,2),"%d":E=>U(E.Ia,2),"%e":E=>_(E.Ia,2," "),"%g":E=>X(E).toString().substring(2),"%G":E=>X(E),"%H":E=>U(E.Ea,2),"%I":E=>(E=E.Ea,E==0?E=12:12<E&&(E-=12),U(E,2)),"%j":E=>{for(var se=0,ge=0;ge<=E.Fa-1;se+=(gt(E.Ca+1900)?qt:We)[ge++]);return U(E.Ia+se,3)},"%m":E=>U(E.Fa+1,2),"%M":E=>U(E.Va,2),"%n":()=>`
`,"%p":E=>0<=E.Ea&&12>E.Ea?"AM":"PM","%S":E=>U(E.Wa,2),"%t":()=>"	","%u":E=>E.wa||7,"%U":E=>U(Math.floor((E.Ba+7-E.wa)/7),2),"%V":E=>{var se=Math.floor((E.Ba+7-(E.wa+6)%7)/7);if(2>=(E.wa+371-E.Ba-2)%7&&se++,se)se==53&&(ge=(E.wa+371-E.Ba)%7,ge==4||ge==3&&gt(E.Ca)||(se=1));else{se=52;var ge=(E.wa+7-E.Ba-1)%7;(ge==4||ge==5&&gt(E.Ca%400-1))&&se++}return U(se,2)},"%w":E=>E.wa,"%W":E=>U(Math.floor((E.Ba+7-(E.wa+6)%7)/7),2),"%y":E=>(E.Ca+1900).toString().substring(2),"%Y":E=>E.Ca+1900,"%z":E=>{E=E.Ua;var se=0<=E;return E=Math.abs(E)/60,(se?"+":"-")+("0000"+(E/60*100+E%60)).slice(-4)},"%Z":E=>E.Xa,"%%":()=>"%"},y=y.replace(/%%/g,"\0\0");for(Z in J)y.includes(Z)&&(y=y.replace(new RegExp(Z,"g"),J[Z](C)));return y=y.replace(/\0\0/g,"%"),Z=$r(y),Z.length>f?0:(Y.set(Z,d>>>0),Z.length-1)}function re(d){try{d()}catch(f){Ge(f)}}function Bt(d){var f={},y;for(y in d)(function(C){var _=d[C];f[C]=typeof _=="function"?function(){Mt.push(C);try{return _.apply(null,arguments)}finally{W||(Mt.pop()===C||Ge(),Fe&&Je===1&&Mt.length===0&&(Je=0,re(ar),typeof Fibers<"u"&&Fibers.ab()))}}:_})(y);return f}var Je=0,Fe=null,Kt=0,Mt=[],Yt={},Xt={},xr=0,Dt=null,Jt=[];function Sr(){return new Promise((d,f)=>{Dt={resolve:d,reject:f}})}function Cr(){var d=zt(65548),f=d+12;K[d>>2>>>0]=f,K[d+4>>2>>>0]=f+65536,f=Mt[0];var y=Yt[f];return y===void 0&&(y=xr++,Yt[f]=y,Xt[y]=f),D[d+8>>2>>>0]=y,d}function Ir(d){if(!W){if(Je===0){var f=!1,y=!1;d((C=0)=>{if(!W&&(Kt=C,f=!0,y)){Je=2,re(()=>or(Fe)),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.resume(),C=!1;try{var _=(0,R[Xt[D[Fe+8>>2>>>0]]])()}catch(j){_=j,C=!0}var U=!1;if(!Fe){var F=Dt;F&&(Dt=null,(C?F.reject:F.resolve)(_),U=!0)}if(C&&!U)throw _}}),y=!0,f||(Je=1,Fe=Cr(),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.pause(),re(()=>nr(Fe)))}else Je===2?(Je=0,re(Wt),Qt(Fe),Fe=null,Jt.forEach(C=>{if(!W)try{if(C(),!P)try{V=V=C=V,P||(r.onExit&&r.onExit(C),W=!0),l(C,new Ke(C))}catch(_){_ instanceof Ke||_=="unwind"||l(1,_)}}catch(_){_ instanceof Ke||_=="unwind"||l(1,_)}})):Ge(`invalid state: ${Je}`);return Kt}}function Ar(d){return Ir(f=>{d().then(f)})}var _r={n:function(d,f,y){return Ar(async()=>{await r.Pa(d,f,y)})},a:function(d,f,y){throw d>>>=0,new Lt(d).Ya(f>>>0,y>>>0),ht=d,br++,ht},g:function(){return 0},J:function(){},z:function(){},B:function(){},L:function(){return 0},H:function(){},C:function(){},G:function(){},l:function(){},A:function(){},x:function(){},I:function(){},y:function(){},m:()=>!0,q:function(d,f,y){d=f+2097152>>>0<4194305-!!d?(d>>>0)+4294967296*f:NaN,y>>>=0,d=new Date(1e3*d),D[y>>2>>>0]=d.getUTCSeconds(),D[y+4>>2>>>0]=d.getUTCMinutes(),D[y+8>>2>>>0]=d.getUTCHours(),D[y+12>>2>>>0]=d.getUTCDate(),D[y+16>>2>>>0]=d.getUTCMonth(),D[y+20>>2>>>0]=d.getUTCFullYear()-1900,D[y+24>>2>>>0]=d.getUTCDay(),D[y+28>>2>>>0]=(d.getTime()-Date.UTC(d.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(d,f,y){d=f+2097152>>>0<4194305-!!d?(d>>>0)+4294967296*f:NaN,y>>>=0,d=new Date(1e3*d),D[y>>2>>>0]=d.getSeconds(),D[y+4>>2>>>0]=d.getMinutes(),D[y+8>>2>>>0]=d.getHours(),D[y+12>>2>>>0]=d.getDate(),D[y+16>>2>>>0]=d.getMonth(),D[y+20>>2>>>0]=d.getFullYear()-1900,D[y+24>>2>>>0]=d.getDay(),D[y+28>>2>>>0]=(gt(d.getFullYear())?Ft:wr)[d.getMonth()]+d.getDate()-1|0,D[y+36>>2>>>0]=-(60*d.getTimezoneOffset()),f=new Date(d.getFullYear(),6,1).getTimezoneOffset();var C=new Date(d.getFullYear(),0,1).getTimezoneOffset();D[y+32>>2>>>0]=(f!=C&&d.getTimezoneOffset()==Math.min(C,f))|0},s:function(d){d>>>=0;var f=new Date(D[d+20>>2>>>0]+1900,D[d+16>>2>>>0],D[d+12>>2>>>0],D[d+8>>2>>>0],D[d+4>>2>>>0],D[d>>2>>>0],0),y=D[d+32>>2>>>0],C=f.getTimezoneOffset(),_=new Date(f.getFullYear(),6,1).getTimezoneOffset(),U=new Date(f.getFullYear(),0,1).getTimezoneOffset(),F=Math.min(U,_);return 0>y?D[d+32>>2>>>0]=+(_!=U&&F==C):0<y!=(F==C)&&(_=Math.max(U,_),f.setTime(f.getTime()+6e4*((0<y?F:_)-C))),D[d+24>>2>>>0]=f.getDay(),D[d+28>>2>>>0]=(gt(f.getFullYear())?Ft:wr)[f.getMonth()]+f.getDate()-1|0,D[d>>2>>>0]=f.getSeconds(),D[d+4>>2>>>0]=f.getMinutes(),D[d+8>>2>>>0]=f.getHours(),D[d+12>>2>>>0]=f.getDate(),D[d+16>>2>>>0]=f.getMonth(),D[d+20>>2>>>0]=f.getYear(),d=f.getTime()/1e3,Zt((Ee=d,1<=+Math.abs(Ee)?0<Ee?+Math.floor(Ee/4294967296)>>>0:~~+Math.ceil((Ee-+(~~Ee>>>0))/4294967296)>>>0:0)),d>>>0},o:function(){return-52},p:function(){},v:function(d,f,y){function C(X){return(X=X.toTimeString().match(/\(([A-Za-z ]+)\)$/))?X[1]:"GMT"}y>>>=0;var _=new Date().getFullYear(),U=new Date(_,0,1),F=new Date(_,6,1);_=U.getTimezoneOffset();var j=F.getTimezoneOffset();K[d>>>0>>2>>>0]=60*Math.max(_,j),D[f>>>0>>2>>>0]=+(_!=j),d=C(U),f=C(F),d=ct(d),f=ct(f),j<_?(K[y>>2>>>0]=d,K[y+4>>2>>>0]=f):(K[y>>2>>>0]=f,K[y+4>>2>>>0]=d)},e:()=>{Ge("")},b:function(d,f,y){return d>>>=0,f=Ct(f>>>0,y>>>0),qe[d].apply(null,f)},i:function(d,f,y){return d>>>=0,f=Ct(f>>>0,y>>>0),qe[d].apply(null,f)},h:function(){return Date.now()},w:function(){return 4294901760},c:()=>performance.now(),K:function(d,f,y){return f>>>=0,le.copyWithin(d>>>0>>>0,f>>>0,f+(y>>>0)>>>0)},u:function(d){d>>>=0;var f=le.length;if(4294901760<d)return!1;for(var y=1;4>=y;y*=2){var C=f*(1+.2/y);C=Math.min(C,d+100663296);var _=Math;C=Math.max(d,C);e:{_=_.min.call(_,4294901760,C+(65536-C%65536)%65536)-M.buffer.byteLength+65535>>>16;try{M.grow(_),oe();var U=1;break e}catch{}U=void 0}if(U)return!0}return!1},D:function(d,f){d>>>=0,f>>>=0;var y=0;return jt().forEach(function(C,_){var U=f+y;for(_=K[d+4*_>>2>>>0]=U,U=0;U<C.length;++U)Y[_++>>0>>>0]=C.charCodeAt(U);Y[_>>0>>>0]=0,y+=C.length+1}),0},E:function(d,f){d>>>=0,f>>>=0;var y=jt();K[d>>2>>>0]=y.length;var C=0;return y.forEach(function(_){C+=_.length+1}),K[f>>2>>>0]=C,0},f:()=>52,k:function(){return 52},t:function(){return 70},j:function(d,f,y,C){f>>>=0,y>>>=0,C>>>=0;for(var _=0,U=0;U<y;U++){var F=K[f>>2>>>0],j=K[f+4>>2>>>0];f+=8;for(var X=0;X<j;X++){var J=le[F+X>>>0],Z=vr[d];J===0||J===10?((d===1?I:T)(Ye(Z,0)),Z.length=0):Z.push(J)}_+=j}return K[C>>2>>>0]=_,0},F:kt,d:function(d,f,y,C){return kt(d>>>0,f>>>0,y>>>0,C>>>0)}};(function(){function d(y){if(y=y.exports,y=Bt(y),R=y=Nt(y),M=R.M,oe(),q.unshift(R.N),xe--,r.monitorRunDependencies&&r.monitorRunDependencies(xe),xe==0&&(_e!==null&&(clearInterval(_e),_e=null),rt)){var C=rt;rt=null,C()}return y}var f={a:_r};if(xe++,r.monitorRunDependencies&&r.monitorRunDependencies(xe),r.instantiateWasm)try{return r.instantiateWasm(f,d)}catch(y){T("Module.instantiateWasm callback failed with error: "+y),n(y)}return Te(f,function(y){d(y.instance)}).catch(n),{}})(),r._OrtInit=(d,f)=>(r._OrtInit=R.O)(d,f),r._OrtGetLastError=(d,f)=>(r._OrtGetLastError=R.P)(d,f),r._OrtCreateSessionOptions=(d,f,y,C,_,U,F,j,X,J)=>(r._OrtCreateSessionOptions=R.Q)(d,f,y,C,_,U,F,j,X,J),r._OrtAppendExecutionProvider=(d,f)=>(r._OrtAppendExecutionProvider=R.R)(d,f),r._OrtAddFreeDimensionOverride=(d,f,y)=>(r._OrtAddFreeDimensionOverride=R.S)(d,f,y),r._OrtAddSessionConfigEntry=(d,f,y)=>(r._OrtAddSessionConfigEntry=R.T)(d,f,y),r._OrtReleaseSessionOptions=d=>(r._OrtReleaseSessionOptions=R.U)(d),r._OrtCreateSession=(d,f,y)=>(r._OrtCreateSession=R.V)(d,f,y),r._OrtReleaseSession=d=>(r._OrtReleaseSession=R.W)(d),r._OrtGetInputOutputCount=(d,f,y)=>(r._OrtGetInputOutputCount=R.X)(d,f,y),r._OrtGetInputName=(d,f)=>(r._OrtGetInputName=R.Y)(d,f),r._OrtGetOutputName=(d,f)=>(r._OrtGetOutputName=R.Z)(d,f),r._OrtFree=d=>(r._OrtFree=R._)(d),r._OrtCreateTensor=(d,f,y,C,_,U)=>(r._OrtCreateTensor=R.$)(d,f,y,C,_,U),r._OrtGetTensorData=(d,f,y,C,_)=>(r._OrtGetTensorData=R.aa)(d,f,y,C,_),r._OrtReleaseTensor=d=>(r._OrtReleaseTensor=R.ba)(d),r._OrtCreateRunOptions=(d,f,y,C)=>(r._OrtCreateRunOptions=R.ca)(d,f,y,C),r._OrtAddRunConfigEntry=(d,f,y)=>(r._OrtAddRunConfigEntry=R.da)(d,f,y),r._OrtReleaseRunOptions=d=>(r._OrtReleaseRunOptions=R.ea)(d),r._OrtCreateBinding=d=>(r._OrtCreateBinding=R.fa)(d),r._OrtBindInput=(d,f,y)=>(r._OrtBindInput=R.ga)(d,f,y),r._OrtBindOutput=(d,f,y,C)=>(r._OrtBindOutput=R.ha)(d,f,y,C),r._OrtClearBoundOutputs=d=>(r._OrtClearBoundOutputs=R.ia)(d),r._OrtReleaseBinding=d=>(r._OrtReleaseBinding=R.ja)(d),r._OrtRunWithBinding=(d,f,y,C,_)=>(r._OrtRunWithBinding=R.ka)(d,f,y,C,_),r._OrtRun=(d,f,y,C,_,U,F,j)=>(r._OrtRun=R.la)(d,f,y,C,_,U,F,j),r._OrtEndProfiling=d=>(r._OrtEndProfiling=R.ma)(d),r._JsepOutput=(d,f,y)=>(r._JsepOutput=R.na)(d,f,y),r._JsepGetNodeName=d=>(r._JsepGetNodeName=R.oa)(d);var zt=r._malloc=d=>(zt=r._malloc=R.pa)(d),Qt=r._free=d=>(Qt=r._free=R.qa)(d),Zt=d=>(Zt=R.sa)(d),er=()=>(er=R.ta)(),tr=d=>(tr=R.ua)(d),rr=d=>(rr=R.va)(d),nr=d=>(nr=R.xa)(d),ar=()=>(ar=R.ya)(),or=d=>(or=R.za)(d),Wt=()=>(Wt=R.Aa)();r.___start_em_js=926002,r.___stop_em_js=926163;function Nt(d){d=Object.assign({},d);var f=C=>()=>C()>>>0,y=C=>_=>C(_)>>>0;return d.__errno_location=f(d.__errno_location),d.malloc=y(d.malloc),d.stackSave=f(d.stackSave),d.stackAlloc=y(d.stackAlloc),d}r.stackAlloc=rr,r.stackSave=er,r.stackRestore=tr,r.UTF8ToString=Xe,r.stringToUTF8=(d,f,y)=>Rt(d,le,f,y),r.lengthBytesUTF8=nt;var Qe;rt=function d(){Qe||ir(),Qe||(rt=d)};function ir(){function d(){if(!Qe&&(Qe=!0,r.calledRun=!0,!W)){if(He(q),o(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),r.postRun)for(typeof r.postRun=="function"&&(r.postRun=[r.postRun]);r.postRun.length;){var f=r.postRun.shift();Ce.unshift(f)}He(Ce)}}if(!(0<xe)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;)Be();He(we),0<xe||(r.setStatus?(r.setStatus("Running..."),setTimeout(function(){setTimeout(function(){r.setStatus("")},1),d()},1)):d())}}if(r.preInit)for(typeof r.preInit=="function"&&(r.preInit=[r.preInit]);0<r.preInit.length;)r.preInit.pop()();return ir(),t.ready}})();typeof yo=="object"&&typeof Pn=="object"?Pn.exports=go:typeof define=="function"&&define.amd&&define([],()=>go)});var wo=Gt(()=>{});var vo=Gt(()=>{});var $o={};_t($o,{cpus:()=>Al});var Al,xo=L(()=>{Al=void 0});var Io=Gt((Co,kn)=>{"use strict";var So=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){function r(){return we.buffer!=_e.buffer&&pe(),_e}function o(){return we.buffer!=_e.buffer&&pe(),rt}function n(){return we.buffer!=_e.buffer&&pe(),Ge}function s(){return we.buffer!=_e.buffer&&pe(),dt}function u(){return we.buffer!=_e.buffer&&pe(),G}function l(){return we.buffer!=_e.buffer&&pe(),de}var a=t,p,h;a.ready=new Promise((i,c)=>{p=i,h=c}),a.jsepInit=(i,c,m,x,A,k,N,ae)=>{a.Qb=i,a.wb=c,a.yb=m,a.jb=x,a.xb=A,a.Ea=k,a.zb=N,a.Ab=ae,c=(te,ee,ne)=>(...fe)=>{let be=ot,O=ee?.();fe=te(...fe);let ue=ee?.();return O!==ue&&(te=ue,ne(O),ee=ne=null),ot!=be?cl():fe},m=te=>async(...ee)=>{try{if(a.bb)throw Error("Session already started");let ne=a.bb={Fb:ee[0],errors:[]},fe=await te(...ee);if(a.bb!==ne)throw Error("Session mismatch");i.flush();let be=ne.errors;if(0<be.length){let O=await Promise.all(be);if(O=O.filter(ue=>ue),0<O.length)throw Error(O.join(`
`))}return fe}finally{a.bb=null}},a._OrtRun=m(c(a._OrtRun,()=>a._OrtRun,te=>a._OrtRun=te)),a._OrtRunWithBinding=m(c(a._OrtRunWithBinding,()=>a._OrtRunWithBinding,te=>a._OrtRunWithBinding=te)),a._OrtBindInput=c(a._OrtBindInput,()=>a._OrtBindInput,te=>a._OrtBindInput=te),a.jsepRegisterBuffer=(te,ee,ne,fe)=>i.registerBuffer(te,ee,ne,fe),a.jsepUnregisterBuffers=te=>{i.unregisterBuffers(te)},a.jsepGetBuffer=te=>i.getBuffer(te),a.jsepCreateDownloader=(te,ee,ne)=>i.createDownloader(te,ee,ne)};var b=Object.assign({},a),g="./this.program",v=(i,c)=>{throw c},$=typeof window=="object",w=typeof importScripts=="function",S=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",I=a.ENVIRONMENT_IS_PTHREAD||!1,T="";function B(i){return a.locateFile?a.locateFile(i,T):T+i}var P,M,R;if(S){var W=(On(),bt(En)),V=(Rn(),bt(Tn));T=w?V.dirname(T)+"/":__dirname+"/",P=(c,m)=>(c=c.startsWith("file://")?new URL(c):V.normalize(c),W.readFileSync(c,m?void 0:"utf8")),R=c=>(c=P(c,!0),c.buffer||(c=new Uint8Array(c)),c),M=(c,m,x,A=!0)=>{c=c.startsWith("file://")?new URL(c):V.normalize(c),W.readFile(c,A?void 0:"utf8",(k,N)=>{k?x(k):m(A?N.buffer:N)})},!a.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),v=(c,m)=>{throw process.exitCode=c,m},a.inspect=()=>"[Emscripten Module object]";let i;try{i=wo()}catch(c){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),c}global.Worker=i.Worker}else($||w)&&(w?T=self.location.href:typeof document<"u"&&document.currentScript&&(T=document.currentScript.src),typeof e<"u"&&e&&(T=e),T.indexOf("blob:")!==0?T=T.substr(0,T.replace(/[?#].*/,"").lastIndexOf("/")+1):T="",S||(P=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.send(null),c.responseText},w&&(R=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.responseType="arraybuffer",c.send(null),new Uint8Array(c.response)}),M=(i,c,m)=>{var x=new XMLHttpRequest;x.open("GET",i,!0),x.responseType="arraybuffer",x.onload=()=>{x.status==200||x.status==0&&x.response?c(x.response):m()},x.onerror=m,x.send(null)}));S&&typeof performance>"u"&&(global.performance=vo().performance);var Y=console.log.bind(console),le=console.error.bind(console);S&&(Y=(...i)=>W.writeSync(1,i.join(" ")+`
`),le=(...i)=>W.writeSync(2,i.join(" ")+`
`));var D=a.print||Y,K=a.printErr||le;Object.assign(a,b),b=null,a.thisProgram&&(g=a.thisProgram),a.quit&&(v=a.quit);var Se;a.wasmBinary&&(Se=a.wasmBinary);var oe=a.noExitRuntime||!0;typeof WebAssembly!="object"&&Ye("no native wasm support detected");var we,q,Ce,Be=!1,xe,_e,rt,Ge,dt,G,de;function pe(){var i=we.buffer;a.HEAP8=_e=new Int8Array(i),a.HEAP16=new Int16Array(i),a.HEAP32=Ge=new Int32Array(i),a.HEAPU8=rt=new Uint8Array(i),a.HEAPU16=new Uint16Array(i),a.HEAPU32=dt=new Uint32Array(i),a.HEAPF32=G=new Float32Array(i),a.HEAPF64=de=new Float64Array(i)}var Ne=a.INITIAL_MEMORY||16777216;if(5242880<=Ne||Ye("INITIAL_MEMORY should be larger than STACK_SIZE, was "+Ne+"! (STACK_SIZE=5242880)"),I)we=a.wasmMemory;else if(a.wasmMemory)we=a.wasmMemory;else if(we=new WebAssembly.Memory({initial:Ne/65536,maximum:65536,shared:!0}),!(we.buffer instanceof SharedArrayBuffer))throw K("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),S&&K("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");pe(),Ne=we.buffer.byteLength;var Ue=[],Te=[],Ee=[],qe=0;function Ke(){return oe||0<qe}var He=0,Lt=null,ht=null;function br(){He++,a.monitorRunDependencies&&a.monitorRunDependencies(He)}function Ht(){if(He--,a.monitorRunDependencies&&a.monitorRunDependencies(He),He==0&&(Lt!==null&&(clearInterval(Lt),Lt=null),ht)){var i=ht;ht=null,i()}}function Ye(i){throw a.onAbort&&a.onAbort(i),i="Aborted("+i+")",K(i),Be=!0,xe=1,i=new WebAssembly.RuntimeError(i+". Build with -sASSERTIONS for more info."),h(i),i}function Xe(i){return i.startsWith("data:application/octet-stream;base64,")}var nt;nt="ort-wasm-simd-threaded.wasm",Xe(nt)||(nt=B(nt));function Rt(i){if(i==nt&&Se)return new Uint8Array(Se);if(R)return R(i);throw"both async and sync fetching of the wasm failed"}function gt(i){if(!Se&&($||w)){if(typeof fetch=="function"&&!i.startsWith("file://"))return fetch(i,{credentials:"same-origin"}).then(c=>{if(!c.ok)throw"failed to load wasm binary file at '"+i+"'";return c.arrayBuffer()}).catch(()=>Rt(i));if(M)return new Promise((c,m)=>{M(i,x=>c(new Uint8Array(x)),m)})}return Promise.resolve().then(()=>Rt(i))}function Ft(i,c,m){return gt(i).then(x=>WebAssembly.instantiate(x,c)).then(x=>x).then(m,x=>{K("failed to asynchronously prepare wasm: "+x),Ye(x)})}function wr(i,c){var m=nt;return Se||typeof WebAssembly.instantiateStreaming!="function"||Xe(m)||m.startsWith("file://")||S||typeof fetch!="function"?Ft(m,i,c):fetch(m,{credentials:"same-origin"}).then(x=>WebAssembly.instantiateStreaming(x,i).then(c,function(A){return K("wasm streaming compile failed: "+A),K("falling back to ArrayBuffer instantiation"),Ft(m,i,c)}))}var ct,St={1420080:i=>{a.Ea("Abs",i,void 0)},1420131:i=>{a.Ea("Neg",i,void 0)},1420182:i=>{a.Ea("Floor",i,void 0)},1420235:i=>{a.Ea("Ceil",i,void 0)},1420287:i=>{a.Ea("Reciprocal",i,void 0)},1420345:i=>{a.Ea("Sqrt",i,void 0)},1420397:i=>{a.Ea("Exp",i,void 0)},1420448:i=>{a.Ea("Erf",i,void 0)},1420499:i=>{a.Ea("Sigmoid",i,void 0)},1420554:i=>{a.Ea("Log",i,void 0)},1420605:i=>{a.Ea("Sin",i,void 0)},1420656:i=>{a.Ea("Cos",i,void 0)},1420707:i=>{a.Ea("Tan",i,void 0)},1420758:i=>{a.Ea("Asin",i,void 0)},1420810:i=>{a.Ea("Acos",i,void 0)},1420862:i=>{a.Ea("Atan",i,void 0)},1420914:i=>{a.Ea("Sinh",i,void 0)},1420966:i=>{a.Ea("Cosh",i,void 0)},1421018:i=>{a.Ea("Asinh",i,void 0)},1421071:i=>{a.Ea("Acosh",i,void 0)},1421124:i=>{a.Ea("Atanh",i,void 0)},1421177:i=>{a.Ea("Tanh",i,void 0)},1421229:i=>{a.Ea("Not",i,void 0)},1421280:(i,c,m)=>{a.Ea("ClipV10",i,{min:c,max:m})},1421352:i=>{a.Ea("Clip",i,void 0)},1421404:(i,c)=>{a.Ea("Elu",i,{alpha:c})},1421462:i=>{a.Ea("Relu",i,void 0)},1421514:(i,c)=>{a.Ea("LeakyRelu",i,{alpha:c})},1421578:(i,c)=>{a.Ea("ThresholdedRelu",i,{alpha:c})},1421648:i=>{a.zb(i)},1421682:(i,c)=>a.Ab(i,c,a.bb.Fb,a.bb.errors),1421794:(i,c)=>{a.Ea("Cast",i,{to:c})},1421852:i=>{a.Ea("Add",i,void 0)},1421903:i=>{a.Ea("Sub",i,void 0)},1421954:i=>{a.Ea("Mul",i,void 0)},1422005:i=>{a.Ea("Div",i,void 0)},1422056:i=>{a.Ea("Pow",i,void 0)},1422107:i=>{a.Ea("Equal",i,void 0)},1422160:i=>{a.Ea("Greater",i,void 0)},1422215:i=>{a.Ea("GreaterOrEqual",i,void 0)},1422277:i=>{a.Ea("Less",i,void 0)},1422329:i=>{a.Ea("LessOrEqual",i,void 0)},1422388:(i,c,m,x,A)=>{a.Ea("ReduceMean",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:x?Array.from(n().subarray(A>>>0,A+x>>>0)):[]})},1422552:(i,c,m,x,A)=>{a.Ea("ReduceMax",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:x?Array.from(n().subarray(A>>>0,A+x>>>0)):[]})},1422715:(i,c,m,x,A)=>{a.Ea("ReduceMin",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:x?Array.from(n().subarray(A>>>0,A+x>>>0)):[]})},1422878:(i,c,m,x,A)=>{a.Ea("ReduceProd",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:x?Array.from(n().subarray(A>>>0,A+x>>>0)):[]})},1423042:(i,c,m,x,A)=>{a.Ea("ReduceSum",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:x?Array.from(n().subarray(A>>>0,A+x>>>0)):[]})},1423205:(i,c,m,x,A)=>{a.Ea("ReduceL1",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:x?Array.from(n().subarray(A>>>0,A+x>>>0)):[]})},1423367:(i,c,m,x,A)=>{a.Ea("ReduceL2",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:x?Array.from(n().subarray(A>>>0,A+x>>>0)):[]})},1423529:(i,c,m,x,A)=>{a.Ea("ReduceLogSum",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:x?Array.from(n().subarray(A>>>0,A+x>>>0)):[]})},1423695:(i,c,m,x,A)=>{a.Ea("ReduceSumSquare",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:x?Array.from(n().subarray(A>>>0,A+x>>>0)):[]})},1423864:(i,c,m,x,A)=>{a.Ea("ReduceLogSumExp",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:x?Array.from(n().subarray(A>>>0,A+x>>>0)):[]})},1424033:i=>{a.Ea("Where",i,void 0)},1424086:(i,c,m)=>{a.Ea("Transpose",i,{perm:c?Array.from(n().subarray(m>>>0,m+c>>>0)):[]})},1424199:(i,c,m,x,A,k,N,ae,te,ee,ne,fe,be)=>{a.Ea("Conv",i,{format:te?"NHWC":"NCHW",auto_pad:c,dilations:[m],group:x,kernel_shape:[A],pads:k?Array.from(n().subarray(N>>>0,N+k>>>0)):[],strides:[ae],w_is_const:()=>!!r()[ee>>>0],activation:We(ne),activation_params:fe?Array.from(u().subarray(be>>>0,be+fe>>>0)):[]})},1424580:(i,c,m,x,A,k,N,ae,te,ee,ne,fe,be,O,ue,ye)=>{a.Ea("Conv",i,{format:fe?"NHWC":"NCHW",auto_pad:c,dilations:[m,x],group:A,kernel_shape:[k,N],pads:ae?Array.from(n().subarray(te>>>0,te+ae>>>0)):[],strides:[ee,ne],w_is_const:()=>!!r()[be>>>0],activation:We(O),activation_params:ue?Array.from(u().subarray(ye>>>0,ye+ue>>>0)):[]})},1424982:(i,c,m,x,A,k,N,ae,te,ee,ne,fe,be,O,ue)=>{a.Ea("ConvTranspose",i,{format:te?"NHWC":"NCHW",autoPad:c,dilations:[m],group:x,kernel_shape:[A],pads:[k,N],strides:[ae],wIsConst:()=>!!r()[ee>>>0],outputPadding:ne?Array.from(n().subarray(fe>>>0,fe+ne>>>0)):[],outputShape:be?Array.from(n().subarray(O>>>0,O+be>>>0)):[],activation:We(ue)})},1425396:(i,c,m,x,A,k,N,ae,te,ee,ne,fe,be,O)=>{a.Ea("ConvTranspose",i,{format:ae?"NHWC":"NCHW",autoPad:c,dilations:Array.from(n().subarray(m>>>0,m+2>>>0)),group:x,kernelShape:Array.from(n().subarray(A>>>0,A+2>>>0)),pads:Array.from(n().subarray(k>>>0,k+4>>>0)),strides:Array.from(n().subarray(N>>>0,N+2>>>0)),wIsConst:()=>!!r()[te>>>0],outputPadding:0<ee?Array.from(n().subarray(ne>>>0,ne+ee>>>0)):[],outputShape:0<fe?Array.from(n().subarray(be>>>0,be+fe>>>0)):[],activation:We(O)})},1425953:(i,c,m,x,A,k,N,ae,te,ee,ne,fe,be,O,ue)=>{a.Ea("ConvTranspose",i,{format:te?"NHWC":"NCHW",autoPad:c,dilations:[m],group:x,kernel_shape:[A],pads:[k,N],strides:[ae],wIsConst:()=>!!r()[ee>>>0],outputPadding:ne?Array.from(n().subarray(fe>>>0,fe+ne>>>0)):[],outputShape:be?Array.from(n().subarray(O>>>0,O+be>>>0)):[],activation:We(ue)})},1426367:(i,c,m,x,A,k,N,ae,te,ee,ne,fe,be,O)=>{a.Ea("ConvTranspose",i,{format:ae?"NHWC":"NCHW",autoPad:c,dilations:Array.from(n().subarray(m>>>0,m+2>>>0)),group:x,kernelShape:Array.from(n().subarray(A>>>0,A+2>>>0)),pads:Array.from(n().subarray(k>>>0,k+4>>>0)),strides:Array.from(n().subarray(N>>>0,N+2>>>0)),wIsConst:()=>!!r()[te>>>0],outputPadding:0<ee?Array.from(n().subarray(ne>>>0,ne+ee>>>0)):[],outputShape:0<fe?Array.from(n().subarray(be>>>0,be+fe>>>0)):[],activation:We(O)})},1426924:(i,c)=>{a.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},1427015:(i,c,m,x,A,k,N,ae,te,ee,ne,fe,be,O,ue,ye)=>{a.Ea("AveragePool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:m,count_include_pad:x,storage_order:A,dilations:[k,N],kernel_shape:[ae,te],pads:[ee,ne,fe,be],strides:[O,ue]})},1427299:(i,c)=>{a.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},1427390:(i,c,m,x,A,k,N,ae,te,ee,ne,fe,be,O,ue,ye)=>{a.Ea("AveragePool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:m,count_include_pad:x,storage_order:A,dilations:[k,N],kernel_shape:[ae,te],pads:[ee,ne,fe,be],strides:[O,ue]})},1427674:(i,c)=>{a.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},1427761:(i,c,m,x,A,k,N,ae,te,ee,ne,fe,be,O,ue,ye)=>{a.Ea("MaxPool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:m,count_include_pad:x,storage_order:A,dilations:[k,N],kernel_shape:[ae,te],pads:[ee,ne,fe,be],strides:[O,ue]})},1428041:(i,c)=>{a.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},1428128:(i,c,m,x,A,k,N,ae,te,ee,ne,fe,be,O,ue,ye)=>{a.Ea("MaxPool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:m,count_include_pad:x,storage_order:A,dilations:[k,N],kernel_shape:[ae,te],pads:[ee,ne,fe,be],strides:[O,ue]})},1428408:(i,c,m,x,A)=>{a.Ea("Gemm",i,{alpha:c,beta:m,transA:x,transB:A})},1428512:i=>{a.Ea("MatMul",i,void 0)},1428566:(i,c,m,x)=>{a.Ea("ArgMax",i,{keepDims:!!c,selectLastIndex:!!m,axis:x})},1428674:(i,c,m,x)=>{a.Ea("ArgMin",i,{keepDims:!!c,selectLastIndex:!!m,axis:x})},1428782:(i,c)=>{a.Ea("Softmax",i,{axis:c})},1428845:(i,c)=>{a.Ea("Concat",i,{axis:c})},1428905:(i,c,m,x,A)=>{a.Ea("Split",i,{axis:c,numOutputs:m,splitSizes:x?Array.from(n().subarray(A>>>0,A+x>>>0)):[]})},1429050:i=>{a.Ea("Expand",i,void 0)},1429104:(i,c)=>{a.Ea("Gather",i,{axis:Number(c)})},1429175:(i,c)=>{a.Ea("GatherElements",i,{axis:Number(c)})},1429254:(i,c,m,x,A,k,N,ae,te,ee,ne)=>{a.Ea("Resize",i,{antialias:c,axes:m?Array.from(n().subarray(x>>>0,x+m>>>0)):[],coordinateTransformMode:We(A),cubicCoeffA:k,excludeOutside:N,extrapolationValue:ae,keepAspectRatioPolicy:We(te),mode:We(ee),nearestMode:We(ne)})},1429605:(i,c,m,x,A,k,N)=>{a.Ea("Slice",i,{starts:c?Array.from(n().subarray(m>>>0,m+c>>>0)):[],ends:x?Array.from(n().subarray(A>>>0,A+x>>>0)):[],axes:k?Array.from(n().subarray(N>>>0,N+k>>>0)):[]})},1429836:i=>{a.Ea("Tile",i,void 0)},1429888:(i,c,m)=>{a.Ea("LayerNormalization",i,{axis:Number(c),epsilon:Number(m)})},1429995:(i,c,m)=>{a.Ea("InstanceNormalization",i,{epsilon:c,format:m?"NHWC":"NCHW"})},1430109:(i,c,m)=>{a.Ea("InstanceNormalization",i,{epsilon:c,format:m?"NHWC":"NCHW"})},1430223:i=>{a.Ea("Range",i,void 0)},1430276:(i,c)=>{a.Ea("Einsum",i,{equation:We(c)})},1430357:(i,c,m,x,A)=>{a.Ea("Pad",i,{mode:c,value:m,pads:x?Array.from(n().subarray(A>>>0,A+x>>>0)):[]})},1430489:i=>{a.Ea("Gelu",i,void 0)},1430541:i=>{a.Ea("BiasAdd",i,void 0)},1430596:i=>{a.Ea("BiasSplitGelu",i,void 0)},1430657:(i,c)=>{a.Ea("SkipLayerNormalization",i,{epsilon:c})},1430738:i=>a.wb(i),1430771:i=>a.yb(i),1430803:(i,c,m)=>{a.jb(i,c,m,!0)},1430842:(i,c,m)=>{a.jb(i,c,m)}};function Ct(i){this.name="ExitStatus",this.message=`Program terminated with exit(${i})`,this.status=i}function It(i){i.terminate(),i.onmessage=()=>{}}function jt(i){(i=re.Qa[i])||Ye(),re.Eb(i)}function Pt(i){var c=re.tb();if(!c)return 6;re.Ya.push(c),re.Qa[i.Xa]=c,c.Xa=i.Xa;var m={cmd:"run",start_routine:i.Gb,arg:i.rb,pthread_ptr:i.Xa};return S&&c.unref(),c.postMessage(m,i.Mb),0}var vr=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,qt=(i,c,m)=>{c>>>=0;var x=c+m;for(m=c;i[m]&&!(m>=x);)++m;if(16<m-c&&i.buffer&&vr)return vr.decode(i.buffer instanceof SharedArrayBuffer?i.slice(c,m):i.subarray(c,m));for(x="";c<m;){var A=i[c++];if(A&128){var k=i[c++]&63;if((A&224)==192)x+=String.fromCharCode((A&31)<<6|k);else{var N=i[c++]&63;A=(A&240)==224?(A&15)<<12|k<<6|N:(A&7)<<18|k<<12|N<<6|i[c++]&63,65536>A?x+=String.fromCharCode(A):(A-=65536,x+=String.fromCharCode(55296|A>>10,56320|A&1023))}}else x+=String.fromCharCode(A)}return x},We=(i,c)=>(i>>>=0)?qt(o(),i,c):"";function $r(i){if(I)return j(1,1,i);xe=i,Ke()||(re.Hb(),a.onExit&&a.onExit(i),Be=!0),v(i,new Ct(i))}var kt=i=>{if(xe=i,I)throw Je(i),"unwind";$r(i)},re={ab:[],Ya:[],mb:[],Qa:{},gb:function(){I?re.vb():re.ub()},ub:function(){Ue.unshift(()=>{br(),re.Bb(()=>Ht())})},vb:function(){re.receiveObjectTransfer=re.Db,re.threadInitTLS=re.lb,re.setExitStatus=re.kb,oe=!1},kb:function(i){xe=i},Sb:["$terminateWorker"],Hb:function(){for(var i of re.Ya)It(i);for(i of re.ab)It(i);re.ab=[],re.Ya=[],re.Qa=[]},Eb:function(i){var c=i.Xa;delete re.Qa[c],re.ab.push(i),re.Ya.splice(re.Ya.indexOf(i),1),i.Xa=0,wn(c)},Db:function(){},lb:function(){re.mb.forEach(i=>i())},Cb:i=>new Promise(c=>{i.onmessage=k=>{k=k.data;var N=k.cmd;if(k.targetThread&&k.targetThread!=Rr()){var ae=re.Qa[k.Rb];ae?ae.postMessage(k,k.transferList):K('Internal error! Worker sent a message "'+N+'" to target pthread '+k.targetThread+", but that thread no longer exists!")}else N==="checkMailbox"?Nt():N==="spawnThread"?Pt(k):N==="cleanupThread"?jt(k.thread):N==="killThread"?(k=k.thread,N=re.Qa[k],delete re.Qa[k],It(N),wn(k),re.Ya.splice(re.Ya.indexOf(N),1),N.Xa=0):N==="cancelThread"?re.Qa[k.thread].postMessage({cmd:"cancel"}):N==="loaded"?(i.loaded=!0,c(i)):N==="alert"?alert("Thread "+k.threadId+": "+k.text):k.target==="setimmediate"?i.postMessage(k):N==="callHandler"?a[k.handler](...k.args):N&&K("worker sent an unknown command "+N)},i.onerror=k=>{throw K("worker sent an error! "+k.filename+":"+k.lineno+": "+k.message),k},S&&(i.on("message",function(k){i.onmessage({data:k})}),i.on("error",function(k){i.onerror(k)}));var m=[],x=["onExit","onAbort","print","printErr"],A;for(A of x)a.hasOwnProperty(A)&&m.push(A);i.postMessage({cmd:"load",handlers:m,urlOrBlob:a.mainScriptUrlOrBlob||e,wasmMemory:we,wasmModule:Ce})}),Bb:function(i){i()},qb:function(){var i=B("ort-wasm-simd-threaded.worker.js");i=new Worker(i),re.ab.push(i)},tb:function(){return re.ab.length==0&&(re.qb(),re.Cb(re.ab[0])),re.ab.pop()}};a.PThread=re;var Bt=i=>{for(;0<i.length;)i.shift()(a)};a.establishStackSpace=function(){var i=Rr(),c=n()[i+52>>2>>>0];i=n()[i+56>>2>>>0],ka(c,c-i),Pr(c)};function Je(i){if(I)return j(2,0,i);kt(i)}a.invokeEntryPoint=function(i,c){i=Ba.apply(null,[i,c]),Ke()?re.kb(i):vn(i)};function Fe(i){this.fb=i-24,this.pb=function(c){s()[this.fb+4>>2>>>0]=c},this.ob=function(c){s()[this.fb+8>>2>>>0]=c},this.gb=function(c,m){this.nb(),this.pb(c),this.ob(m)},this.nb=function(){s()[this.fb+16>>2>>>0]=0}}var Kt=0,Mt=0;function Yt(i,c,m,x){return I?j(3,1,i,c,m,x):Xt(i,c,m,x)}function Xt(i,c,m,x){if(i>>>=0,c>>>=0,m>>>=0,x>>>=0,typeof SharedArrayBuffer>"u")return K("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var A=[];return I&&A.length===0?Yt(i,c,m,x):(i={Gb:m,Xa:i,rb:x,Mb:A},I?(i.Ob="spawnThread",postMessage(i,A),0):Pt(i))}function xr(i,c,m){return I?j(4,1,i,c,m):0}function Dt(i,c){if(I)return j(5,1,i,c)}var Jt=i=>{for(var c=0,m=0;m<i.length;++m){var x=i.charCodeAt(m);127>=x?c++:2047>=x?c+=2:55296<=x&&57343>=x?(c+=4,++m):c+=3}return c},Sr=(i,c,m,x)=>{if(m>>>=0,!(0<x))return 0;var A=m;x=m+x-1;for(var k=0;k<i.length;++k){var N=i.charCodeAt(k);if(55296<=N&&57343>=N){var ae=i.charCodeAt(++k);N=65536+((N&1023)<<10)|ae&1023}if(127>=N){if(m>=x)break;c[m++>>>0]=N}else{if(2047>=N){if(m+1>=x)break;c[m++>>>0]=192|N>>6}else{if(65535>=N){if(m+2>=x)break;c[m++>>>0]=224|N>>12}else{if(m+3>=x)break;c[m++>>>0]=240|N>>18,c[m++>>>0]=128|N>>12&63}c[m++>>>0]=128|N>>6&63}c[m++>>>0]=128|N&63}}return c[m>>>0]=0,m-A},Cr=(i,c,m)=>Sr(i,o(),c,m);function Ir(i,c){if(I)return j(6,1,i,c)}function Ar(i,c,m){if(I)return j(7,1,i,c,m)}function _r(i,c,m){return I?j(8,1,i,c,m):0}function zt(i,c){if(I)return j(9,1,i,c)}function Qt(i,c,m){if(I)return j(10,1,i,c,m)}function Zt(i,c,m,x){if(I)return j(11,1,i,c,m,x)}function er(i,c,m,x){if(I)return j(12,1,i,c,m,x)}function tr(i,c,m,x){if(I)return j(13,1,i,c,m,x)}function rr(i){if(I)return j(14,1,i)}function nr(i,c){if(I)return j(15,1,i,c)}function ar(i,c,m){if(I)return j(16,1,i,c,m)}var or=i=>{if(!Be)try{if(i(),!Ke())try{I?vn(xe):kt(xe)}catch(c){c instanceof Ct||c=="unwind"||v(1,c)}}catch(c){c instanceof Ct||c=="unwind"||v(1,c)}};function Wt(i){i>>>=0,typeof Atomics.Nb=="function"&&(Atomics.Nb(n(),i>>2,i).value.then(Nt),i+=128,Atomics.store(n(),i>>2,1))}a.__emscripten_thread_mailbox_await=Wt;function Nt(){var i=Rr();i&&(Wt(i),or(()=>Ra()))}a.checkMailbox=Nt;var Qe=i=>i%4===0&&(i%100!==0||i%400===0),ir=[0,31,60,91,121,152,182,213,244,274,305,335],d=[0,31,59,90,120,151,181,212,243,273,304,334];function f(i,c,m,x,A,k,N,ae){return I?j(17,1,i,c,m,x,A,k,N,ae):-52}function y(i,c,m,x,A,k,N){if(I)return j(18,1,i,c,m,x,A,k,N)}var C=i=>{var c=Jt(i)+1,m=bn(c);return m&&Cr(i,m,c),m},_=[],U=(i,c)=>{_.length=0;var m;for(c>>=2;m=o()[i++>>>0];)c+=m!=105&c,_.push(m==105?n()[c>>>0]:l()[c++>>>1]),++c;return _},F=i=>{var c=$n();return i=i(),Pr(c),i};function j(i,c){var m=arguments.length-2,x=arguments;return F(()=>{for(var A=xn(8*m),k=A>>3,N=0;N<m;N++){var ae=x[2+N];l()[k+N>>>0]=ae}return Ta(i,m,A,c)})}var X=[],J={},Z=()=>{if(!ce){var i={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:g||"./this.program"},c;for(c in J)J[c]===void 0?delete i[c]:i[c]=J[c];var m=[];for(c in i)m.push(`${c}=${i[c]}`);ce=m}return ce},ce;function me(i,c){if(I)return j(19,1,i,c);i>>>=0,c>>>=0;var m=0;return Z().forEach(function(x,A){var k=c+m;for(A=s()[i+4*A>>2>>>0]=k,k=0;k<x.length;++k)r()[A++>>0>>>0]=x.charCodeAt(k);r()[A>>0>>>0]=0,m+=x.length+1}),0}function E(i,c){if(I)return j(20,1,i,c);i>>>=0,c>>>=0;var m=Z();s()[i>>2>>>0]=m.length;var x=0;return m.forEach(function(A){x+=A.length+1}),s()[c>>2>>>0]=x,0}function se(i){return I?j(21,1,i):52}function ge(i,c,m,x){return I?j(22,1,i,c,m,x):52}function at(i,c,m,x,A){return I?j(23,1,i,c,m,x,A):70}var Er=[null,[],[]];function $a(i,c,m,x){if(I)return j(24,1,i,c,m,x);c>>>=0,m>>>=0,x>>>=0;for(var A=0,k=0;k<m;k++){var N=s()[c>>2>>>0],ae=s()[c+4>>2>>>0];c+=8;for(var te=0;te<ae;te++){var ee=o()[N+te>>>0],ne=Er[i];ee===0||ee===10?((i===1?D:K)(qt(ne,0)),ne.length=0):ne.push(ee)}A+=ae}return s()[x>>2>>>0]=A,0}var xa=[31,29,31,30,31,30,31,31,30,31,30,31],Sa=[31,28,31,30,31,30,31,31,30,31,30,31];function il(i){var c=Array(Jt(i)+1);return Sr(i,c,0,c.length),c}var sl=(i,c)=>{r().set(i,c>>>0)};function Ca(i,c,m,x){function A(O,ue,ye){for(O=typeof O=="number"?O.toString():O||"";O.length<ue;)O=ye[0]+O;return O}function k(O,ue){return A(O,ue,"0")}function N(O,ue){function ye(Ga){return 0>Ga?-1:0<Ga?1:0}var At;return(At=ye(O.getFullYear()-ue.getFullYear()))===0&&(At=ye(O.getMonth()-ue.getMonth()))===0&&(At=ye(O.getDate()-ue.getDate())),At}function ae(O){switch(O.getDay()){case 0:return new Date(O.getFullYear()-1,11,29);case 1:return O;case 2:return new Date(O.getFullYear(),0,3);case 3:return new Date(O.getFullYear(),0,2);case 4:return new Date(O.getFullYear(),0,1);case 5:return new Date(O.getFullYear()-1,11,31);case 6:return new Date(O.getFullYear()-1,11,30)}}function te(O){var ue=O.Za;for(O=new Date(new Date(O.$a+1900,0,1).getTime());0<ue;){var ye=O.getMonth(),At=(Qe(O.getFullYear())?xa:Sa)[ye];if(ue>At-O.getDate())ue-=At-O.getDate()+1,O.setDate(1),11>ye?O.setMonth(ye+1):(O.setMonth(0),O.setFullYear(O.getFullYear()+1));else{O.setDate(O.getDate()+ue);break}}return ye=new Date(O.getFullYear()+1,0,4),ue=ae(new Date(O.getFullYear(),0,4)),ye=ae(ye),0>=N(ue,O)?0>=N(ye,O)?O.getFullYear()+1:O.getFullYear():O.getFullYear()-1}i>>>=0,c>>>=0,m>>>=0,x>>>=0;var ee=n()[x+40>>2>>>0];x={Kb:n()[x>>2>>>0],Jb:n()[x+4>>2>>>0],cb:n()[x+8>>2>>>0],ib:n()[x+12>>2>>>0],eb:n()[x+16>>2>>>0],$a:n()[x+20>>2>>>0],Wa:n()[x+24>>2>>>0],Za:n()[x+28>>2>>>0],Tb:n()[x+32>>2>>>0],Ib:n()[x+36>>2>>>0],Lb:ee?We(ee):""},m=We(m),ee={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ne in ee)m=m.replace(new RegExp(ne,"g"),ee[ne]);var fe="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),be="January February March April May June July August September October November December".split(" ");ee={"%a":O=>fe[O.Wa].substring(0,3),"%A":O=>fe[O.Wa],"%b":O=>be[O.eb].substring(0,3),"%B":O=>be[O.eb],"%C":O=>k((O.$a+1900)/100|0,2),"%d":O=>k(O.ib,2),"%e":O=>A(O.ib,2," "),"%g":O=>te(O).toString().substring(2),"%G":O=>te(O),"%H":O=>k(O.cb,2),"%I":O=>(O=O.cb,O==0?O=12:12<O&&(O-=12),k(O,2)),"%j":O=>{for(var ue=0,ye=0;ye<=O.eb-1;ue+=(Qe(O.$a+1900)?xa:Sa)[ye++]);return k(O.ib+ue,3)},"%m":O=>k(O.eb+1,2),"%M":O=>k(O.Jb,2),"%n":()=>`
`,"%p":O=>0<=O.cb&&12>O.cb?"AM":"PM","%S":O=>k(O.Kb,2),"%t":()=>"	","%u":O=>O.Wa||7,"%U":O=>k(Math.floor((O.Za+7-O.Wa)/7),2),"%V":O=>{var ue=Math.floor((O.Za+7-(O.Wa+6)%7)/7);if(2>=(O.Wa+371-O.Za-2)%7&&ue++,ue)ue==53&&(ye=(O.Wa+371-O.Za)%7,ye==4||ye==3&&Qe(O.$a)||(ue=1));else{ue=52;var ye=(O.Wa+7-O.Za-1)%7;(ye==4||ye==5&&Qe(O.$a%400-1))&&ue++}return k(ue,2)},"%w":O=>O.Wa,"%W":O=>k(Math.floor((O.Za+7-(O.Wa+6)%7)/7),2),"%y":O=>(O.$a+1900).toString().substring(2),"%Y":O=>O.$a+1900,"%z":O=>{O=O.Ib;var ue=0<=O;return O=Math.abs(O)/60,(ue?"+":"-")+("0000"+(O/60*100+O%60)).slice(-4)},"%Z":O=>O.Lb,"%%":()=>"%"},m=m.replace(/%%/g,"\0\0");for(ne in ee)m.includes(ne)&&(m=m.replace(new RegExp(ne,"g"),ee[ne](x)));return m=m.replace(/\0\0/g,"%"),ne=il(m),ne.length>c?0:(sl(ne,i),ne.length-1)}function Or(i){try{i()}catch(c){Ye(c)}}function ul(i){var c={},m;for(m in i)(function(x){var A=i[x];c[x]=typeof A=="function"?function(){Tr.push(x);try{return A.apply(null,arguments)}finally{Be||(Tr.pop()===x||Ye(),ot&&yt===1&&Tr.length===0&&(yt=0,qe+=1,Or(Da),typeof Fibers<"u"&&Fibers.Ub()))}}:A})(m);return c}var yt=0,ot=null,Ia=0,Tr=[],Aa={},_a={},ll=0,yn=null,dl=[];function cl(){return new Promise((i,c)=>{yn={resolve:i,reject:c}})}function pl(){var i=bn(65548),c=i+12;s()[i>>2>>>0]=c,s()[i+4>>2>>>0]=c+65536,c=Tr[0];var m=Aa[c];return m===void 0&&(m=ll++,Aa[c]=m,_a[m]=c),c=m,n()[i+8>>2>>>0]=c,i}function fl(){var i=n()[ot+8>>2>>>0];return i=q[_a[i]],--qe,i()}function ml(i){if(!Be){if(yt===0){var c=!1,m=!1;i((x=0)=>{if(!Be&&(Ia=x,c=!0,m)){yt=2,Or(()=>za(ot)),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),x=!1;try{var A=fl()}catch(ae){A=ae,x=!0}var k=!1;if(!ot){var N=yn;N&&(yn=null,(x?N.reject:N.resolve)(A),k=!0)}if(x&&!k)throw A}}),m=!0,c||(yt=1,ot=pl(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),Or(()=>Ma(ot)))}else yt===2?(yt=0,Or(Wa),Ea(ot),ot=null,dl.forEach(x=>or(x))):Ye(`invalid state: ${yt}`);return Ia}}function hl(i){return ml(c=>{i().then(c)})}re.gb();var gl=[null,$r,Je,Yt,xr,Dt,Ir,Ar,_r,zt,Qt,Zt,er,tr,rr,nr,ar,f,y,me,E,se,ge,at,$a],yl={r:function(i,c,m){return hl(async()=>{await a.xb(i,c,m)})},b:function(i,c,m){throw i>>>=0,new Fe(i).gb(c>>>0,m>>>0),Kt=i,Mt++,Kt},P:function(i){Oa(i>>>0,!w,1,!$,131072,!1),re.lb()},n:function(i){i>>>=0,I?postMessage({cmd:"cleanupThread",thread:i}):jt(i)},K:Xt,g:xr,V:Dt,F:Ir,H:Ar,y:_r,T:zt,L:Qt,S:Zt,p:er,G:tr,D:rr,U:nr,E:ar,q:()=>!0,B:function(i,c){i>>>=0,i==c>>>0?setTimeout(()=>Nt()):I?postMessage({targetThread:i,cmd:"checkMailbox"}):(i=re.Qa[i])&&i.postMessage({cmd:"checkMailbox"})},N:function(){return-1},O:Wt,X:function(i){S&&re.Qa[i>>>0].ref()},u:function(i,c,m){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,m>>>=0,i=new Date(1e3*i),n()[m>>2>>>0]=i.getUTCSeconds(),n()[m+4>>2>>>0]=i.getUTCMinutes(),n()[m+8>>2>>>0]=i.getUTCHours(),n()[m+12>>2>>>0]=i.getUTCDate(),n()[m+16>>2>>>0]=i.getUTCMonth(),n()[m+20>>2>>>0]=i.getUTCFullYear()-1900,n()[m+24>>2>>>0]=i.getUTCDay(),i=(i.getTime()-Date.UTC(i.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,n()[m+28>>2>>>0]=i},v:function(i,c,m){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,m>>>=0,i=new Date(1e3*i),n()[m>>2>>>0]=i.getSeconds(),n()[m+4>>2>>>0]=i.getMinutes(),n()[m+8>>2>>>0]=i.getHours(),n()[m+12>>2>>>0]=i.getDate(),n()[m+16>>2>>>0]=i.getMonth(),n()[m+20>>2>>>0]=i.getFullYear()-1900,n()[m+24>>2>>>0]=i.getDay(),c=(Qe(i.getFullYear())?ir:d)[i.getMonth()]+i.getDate()-1|0,n()[m+28>>2>>>0]=c,n()[m+36>>2>>>0]=-(60*i.getTimezoneOffset()),c=new Date(i.getFullYear(),6,1).getTimezoneOffset();var x=new Date(i.getFullYear(),0,1).getTimezoneOffset();i=(c!=x&&i.getTimezoneOffset()==Math.min(x,c))|0,n()[m+32>>2>>>0]=i},w:function(i){i>>>=0;var c=new Date(n()[i+20>>2>>>0]+1900,n()[i+16>>2>>>0],n()[i+12>>2>>>0],n()[i+8>>2>>>0],n()[i+4>>2>>>0],n()[i>>2>>>0],0),m=n()[i+32>>2>>>0],x=c.getTimezoneOffset(),A=new Date(c.getFullYear(),6,1).getTimezoneOffset(),k=new Date(c.getFullYear(),0,1).getTimezoneOffset(),N=Math.min(k,A);return 0>m?n()[i+32>>2>>>0]=+(A!=k&&N==x):0<m!=(N==x)&&(A=Math.max(k,A),c.setTime(c.getTime()+6e4*((0<m?N:A)-x))),n()[i+24>>2>>>0]=c.getDay(),m=(Qe(c.getFullYear())?ir:d)[c.getMonth()]+c.getDate()-1|0,n()[i+28>>2>>>0]=m,n()[i>>2>>>0]=c.getSeconds(),n()[i+4>>2>>>0]=c.getMinutes(),n()[i+8>>2>>>0]=c.getHours(),n()[i+12>>2>>>0]=c.getDate(),n()[i+16>>2>>>0]=c.getMonth(),n()[i+20>>2>>>0]=c.getYear(),i=c.getTime()/1e3,Pa((ct=i,1<=+Math.abs(ct)?0<ct?+Math.floor(ct/4294967296)>>>0:~~+Math.ceil((ct-+(~~ct>>>0))/4294967296)>>>0:0)),i>>>0},s:f,t:y,A:function(i,c,m){function x(ee){return(ee=ee.toTimeString().match(/\(([A-Za-z ]+)\)$/))?ee[1]:"GMT"}i>>>=0,c>>>=0,m>>>=0;var A=new Date().getFullYear(),k=new Date(A,0,1),N=new Date(A,6,1);A=k.getTimezoneOffset();var ae=N.getTimezoneOffset(),te=Math.max(A,ae);s()[i>>2>>>0]=60*te,n()[c>>2>>>0]=+(A!=ae),i=x(k),c=x(N),i=C(i),c=C(c),ae<A?(s()[m>>2>>>0]=i,s()[m+4>>2>>>0]=c):(s()[m>>2>>>0]=c,s()[m+4>>2>>>0]=i)},e:()=>{Ye("")},c:function(i,c,m){return i>>>=0,c=U(c>>>0,m>>>0),St[i].apply(null,c)},l:function(i,c,m){return i>>>=0,c=U(c>>>0,m>>>0),St[i].apply(null,c)},o:function(){},k:function(){return Date.now()},W:()=>{throw qe+=1,"unwind"},C:function(){return 4294901760},d:()=>performance.timeOrigin+performance.now(),i:function(){return S?(xo(),bt($o)).cpus().length:navigator.hardwareConcurrency},M:function(i,c,m,x){for(re.Pb=c>>>0,X.length=m,c=x>>>0>>3,x=0;x<m;x++)X[x]=l()[c+x>>>0];return(0>i?St[-i-1]:gl[i]).apply(null,X)},z:function(i){i>>>=0;var c=o().length;if(i<=c||4294901760<i)return!1;for(var m=1;4>=m;m*=2){var x=c*(1+.2/m);x=Math.min(x,i+100663296);var A=Math;x=Math.max(i,x);e:{A=A.min.call(A,4294901760,x+(65536-x%65536)%65536)-we.buffer.byteLength+65535>>>16;try{we.grow(A),pe();var k=1;break e}catch{}k=void 0}if(k)return!0}return!1},Q:me,R:E,J:kt,h:se,m:ge,x:at,j:$a,a:we||a.wasmMemory,I:Ca,f:function(i,c,m,x){return Ca(i>>>0,c>>>0,m>>>0,x>>>0)}};(function(){function i(m,x){return m=m.exports,m=ul(m),q=m=bl(m),re.mb.push(q.Da),Te.unshift(q.Y),Ce=x,Ht(),m}var c={a:yl};if(br(),a.instantiateWasm)try{return a.instantiateWasm(c,i)}catch(m){K("Module.instantiateWasm callback failed with error: "+m),h(m)}return wr(c,function(m){i(m.instance,m.module)}).catch(h),{}})(),a._OrtInit=(i,c)=>(a._OrtInit=q.Z)(i,c),a._OrtGetLastError=(i,c)=>(a._OrtGetLastError=q._)(i,c),a._OrtCreateSessionOptions=(i,c,m,x,A,k,N,ae,te,ee)=>(a._OrtCreateSessionOptions=q.$)(i,c,m,x,A,k,N,ae,te,ee),a._OrtAppendExecutionProvider=(i,c)=>(a._OrtAppendExecutionProvider=q.aa)(i,c),a._OrtAddFreeDimensionOverride=(i,c,m)=>(a._OrtAddFreeDimensionOverride=q.ba)(i,c,m),a._OrtAddSessionConfigEntry=(i,c,m)=>(a._OrtAddSessionConfigEntry=q.ca)(i,c,m),a._OrtReleaseSessionOptions=i=>(a._OrtReleaseSessionOptions=q.da)(i),a._OrtCreateSession=(i,c,m)=>(a._OrtCreateSession=q.ea)(i,c,m),a._OrtReleaseSession=i=>(a._OrtReleaseSession=q.fa)(i),a._OrtGetInputOutputCount=(i,c,m)=>(a._OrtGetInputOutputCount=q.ga)(i,c,m),a._OrtGetInputName=(i,c)=>(a._OrtGetInputName=q.ha)(i,c),a._OrtGetOutputName=(i,c)=>(a._OrtGetOutputName=q.ia)(i,c),a._OrtFree=i=>(a._OrtFree=q.ja)(i),a._OrtCreateTensor=(i,c,m,x,A,k)=>(a._OrtCreateTensor=q.ka)(i,c,m,x,A,k),a._OrtGetTensorData=(i,c,m,x,A)=>(a._OrtGetTensorData=q.la)(i,c,m,x,A),a._OrtReleaseTensor=i=>(a._OrtReleaseTensor=q.ma)(i),a._OrtCreateRunOptions=(i,c,m,x)=>(a._OrtCreateRunOptions=q.na)(i,c,m,x),a._OrtAddRunConfigEntry=(i,c,m)=>(a._OrtAddRunConfigEntry=q.oa)(i,c,m),a._OrtReleaseRunOptions=i=>(a._OrtReleaseRunOptions=q.pa)(i),a._OrtCreateBinding=i=>(a._OrtCreateBinding=q.qa)(i),a._OrtBindInput=(i,c,m)=>(a._OrtBindInput=q.ra)(i,c,m),a._OrtBindOutput=(i,c,m,x)=>(a._OrtBindOutput=q.sa)(i,c,m,x),a._OrtClearBoundOutputs=i=>(a._OrtClearBoundOutputs=q.ta)(i),a._OrtReleaseBinding=i=>(a._OrtReleaseBinding=q.ua)(i),a._OrtRunWithBinding=(i,c,m,x,A)=>(a._OrtRunWithBinding=q.va)(i,c,m,x,A),a._OrtRun=(i,c,m,x,A,k,N,ae)=>(a._OrtRun=q.wa)(i,c,m,x,A,k,N,ae),a._OrtEndProfiling=i=>(a._OrtEndProfiling=q.xa)(i),a._JsepOutput=(i,c,m)=>(a._JsepOutput=q.ya)(i,c,m),a._JsepGetNodeName=i=>(a._JsepGetNodeName=q.za)(i);var Rr=a._pthread_self=()=>(Rr=a._pthread_self=q.Aa)(),bn=a._malloc=i=>(bn=a._malloc=q.Ba)(i),Ea=a._free=i=>(Ea=a._free=q.Ca)(i);a.__emscripten_tls_init=()=>(a.__emscripten_tls_init=q.Da)();var Oa=a.__emscripten_thread_init=(i,c,m,x,A,k)=>(Oa=a.__emscripten_thread_init=q.Fa)(i,c,m,x,A,k);a.__emscripten_thread_crashed=()=>(a.__emscripten_thread_crashed=q.Ga)();var Ta=(i,c,m,x)=>(Ta=q.Ha)(i,c,m,x),wn=i=>(wn=q.Ia)(i),vn=a.__emscripten_thread_exit=i=>(vn=a.__emscripten_thread_exit=q.Ja)(i),Ra=a.__emscripten_check_mailbox=()=>(Ra=a.__emscripten_check_mailbox=q.Ka)(),Pa=i=>(Pa=q.La)(i),ka=(i,c)=>(ka=q.Ma)(i,c),$n=()=>($n=q.Na)(),Pr=i=>(Pr=q.Oa)(i),xn=i=>(xn=q.Pa)(i),Ba=a.dynCall_ii=(i,c)=>(Ba=a.dynCall_ii=q.Ra)(i,c),Ma=i=>(Ma=q.Sa)(i),Da=()=>(Da=q.Ta)(),za=i=>(za=q.Ua)(i),Wa=()=>(Wa=q.Va)();a.___start_em_js=1430875,a.___stop_em_js=1431036;function bl(i){i=Object.assign({},i);var c=x=>()=>x()>>>0,m=x=>A=>x(A)>>>0;return i.__errno_location=c(i.__errno_location),i.pthread_self=c(i.pthread_self),i.malloc=m(i.malloc),i.stackSave=c(i.stackSave),i.stackAlloc=m(i.stackAlloc),i}a.keepRuntimeAlive=Ke,a.wasmMemory=we,a.stackAlloc=xn,a.stackSave=$n,a.stackRestore=Pr,a.UTF8ToString=We,a.stringToUTF8=Cr,a.lengthBytesUTF8=Jt,a.ExitStatus=Ct,a.PThread=re;var kr;ht=function i(){kr||Na(),kr||(ht=i)};function Na(){function i(){if(!kr&&(kr=!0,a.calledRun=!0,!Be)&&(I||Bt(Te),p(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),!I)){if(a.postRun)for(typeof a.postRun=="function"&&(a.postRun=[a.postRun]);a.postRun.length;){var c=a.postRun.shift();Ee.unshift(c)}Bt(Ee)}}if(!(0<He))if(I)p(a),I||Bt(Te),startWorker(a);else{if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;)Ue.unshift(a.preRun.shift());Bt(Ue),0<He||(a.setStatus?(a.setStatus("Running..."),setTimeout(function(){setTimeout(function(){a.setStatus("")},1),i()},1)):i())}}if(a.preInit)for(typeof a.preInit=="function"&&(a.preInit=[a.preInit]);0<a.preInit.length;)a.preInit.pop()();return Na(),t.ready}})();typeof Co=="object"&&typeof kn=="object"?kn.exports=So:typeof define=="function"&&define.amd&&define([],()=>So)});var Ao=Gt((Mp,_l)=>{_l.exports='"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\n'});var Eo,El,Bn,Mn,Ur,_o,Ol,Tl,Rl,Oo,Re,Ut=L(()=>{"use strict";Eo=bo();El=Io(),Mn=!1,Ur=!1,_o=!1,Ol=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},Tl=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Rl=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Oo=async e=>{if(Mn)return Promise.resolve();if(Ur)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(_o)throw new Error("previous call to 'initializeWebAssembly()' failed.");Ur=!0;let t=e.initTimeout,r=e.numThreads,o=e.simd,n=r>1&&Ol(),s=o&&Tl(),u=e.wasmPaths,l=typeof u=="string"?u:void 0,a=Rl(s,n),p=typeof u=="object"?u[a]:void 0,h=!1,b=[];if(t>0&&b.push(new Promise(g=>{setTimeout(()=>{h=!0,g()},t)})),b.push(new Promise((g,v)=>{let $=n?El:Eo,w={locateFile:(S,I)=>{if(n&&S.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Ao()],{type:"text/javascript"}));if(S.endsWith(".wasm")){if(p)return p;let T=l??I;return a==="ort-wasm-simd.wasm"?T+"ort-wasm-simd.jsep.wasm":a==="ort-wasm-simd-threaded.wasm"?T+"ort-wasm-simd-threaded.jsep.wasm":T+a}return I+S}};if(n)if(typeof Blob>"u")w.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let S=`var ortWasmThreaded=${$.toString()};`;w.mainScriptUrlOrBlob=new Blob([S],{type:"text/javascript"})}$(w).then(S=>{Ur=!1,Mn=!0,Bn=S,g()},S=>{Ur=!1,_o=!0,v(S)})})),await Promise.race(b),h)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Re=()=>{if(Mn&&Bn)return Bn;throw new Error("WebAssembly is not initialized yet.")}});var Me,ur,Ae,Vr=L(()=>{"use strict";Ut();Me=(e,t)=>{let r=Re(),o=r.lengthBytesUTF8(e)+1,n=r._malloc(o);return r.stringToUTF8(e,n,o),t.push(n),n},ur=(e,t,r,o)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([n,s])=>{let u=t?t+n:n;if(typeof s=="object")ur(s,u+".",r,o);else if(typeof s=="string"||typeof s=="number")o(u,s.toString());else if(typeof s=="boolean")o(u,s?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof s}`)})},Ae=e=>{let t=Re(),r=t.stackSave();try{let o=t.stackAlloc(8);t._OrtGetLastError(o,o+4);let n=t.HEAP32[o/4],s=t.HEAPU32[o/4+1],u=s?t.UTF8ToString(s):"";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${u}`)}finally{t.stackRestore(r)}}});var To,Ro=L(()=>{"use strict";Ut();Vr();To=e=>{let t=Re(),r=0,o=[],n=e||{};try{if(e?.logSeverityLevel===void 0)n.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)n.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(n.terminate=!1);let s=0;return e?.tag!==void 0&&(s=Me(e.tag,o)),r=t._OrtCreateRunOptions(n.logSeverityLevel,n.logVerbosityLevel,!!n.terminate,s),r===0&&Ae("Can't create run options."),e?.extra!==void 0&&ur(e.extra,"",new WeakSet,(u,l)=>{let a=Me(u,o),p=Me(l,o);t._OrtAddRunConfigEntry(r,a,p)!==0&&Ae(`Can't set a run config entry: ${u} - ${l}.`)}),[r,o]}catch(s){throw r!==0&&t._OrtReleaseRunOptions(r),o.forEach(u=>t._free(u)),s}}});var Pl,kl,Bl,Ml,Po,ko=L(()=>{"use strict";Ut();Vr();Pl=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},kl=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Bl=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},Ml=(e,t,r)=>{for(let o of t){let n=typeof o=="string"?o:o.name;switch(n){case"xnnpack":n="XNNPACK";break;case"webnn":if(n="WEBNN",typeof o!="string"){let u=o;if(u?.deviceType){let l=Me("deviceType",r),a=Me(u.deviceType,r);Re()._OrtAddSessionConfigEntry(e,l,a)!==0&&Ae(`Can't set a session config entry: 'deviceType' - ${u.deviceType}.`)}if(u?.powerPreference){let l=Me("powerPreference",r),a=Me(u.powerPreference,r);Re()._OrtAddSessionConfigEntry(e,l,a)!==0&&Ae(`Can't set a session config entry: 'powerPreference' - ${u.powerPreference}.`)}}break;case"webgpu":if(n="JS",typeof o!="string"){let u=o;if(u?.preferredLayout){if(u.preferredLayout!=="NCHW"&&u.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${u.preferredLayout}`);let l=Me("preferredLayout",r),a=Me(u.preferredLayout,r);Re()._OrtAddSessionConfigEntry(e,l,a)!==0&&Ae(`Can't set a session config entry: 'preferredLayout' - ${u.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${n}`)}let s=Me(n,r);Re()._OrtAppendExecutionProvider(e,s)!==0&&Ae(`Can't append execution provider: ${n}.`)}},Po=e=>{let t=Re(),r=0,o=[],n=e||{};Bl(n);try{let s=Pl(n.graphOptimizationLevel??"all"),u=kl(n.executionMode??"sequential"),l=typeof n.logId=="string"?Me(n.logId,o):0,a=n.logSeverityLevel??2;if(!Number.isInteger(a)||a<0||a>4)throw new Error(`log serverity level is not valid: ${a}`);let p=n.logVerbosityLevel??0;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log verbosity level is not valid: ${p}`);let h=typeof n.optimizedModelFilePath=="string"?Me(n.optimizedModelFilePath,o):0;if(r=t._OrtCreateSessionOptions(s,!!n.enableCpuMemArena,!!n.enableMemPattern,u,!!n.enableProfiling,0,l,a,p,h),r===0&&Ae("Can't create session options."),n.executionProviders&&Ml(r,n.executionProviders,o),n.freeDimensionOverrides)for(let[b,g]of Object.entries(n.freeDimensionOverrides)){if(typeof b!="string")throw new Error(`free dimension override name must be a string: ${b}`);if(typeof g!="number"||!Number.isInteger(g)||g<0)throw new Error(`free dimension override value must be a non-negative integer: ${g}`);let v=Me(b,o);t._OrtAddFreeDimensionOverride(r,v,g)!==0&&Ae(`Can't set a free dimension override: ${b} - ${g}.`)}return n.extra!==void 0&&ur(n.extra,"",new WeakSet,(b,g)=>{let v=Me(b,o),$=Me(g,o);t._OrtAddSessionConfigEntry(r,v,$)!==0&&Ae(`Can't set a session config entry: ${b} - ${g}.`)}),[r,o]}catch(s){throw r!==0&&t._OrtReleaseSessionOptions(r),o.forEach(u=>t._free(u)),s}}});var Dn,lr,dr,Lr,cr,Hr,zn,De=L(()=>{"use strict";Dn=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},lr=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},dr=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],Lr=e=>{switch(e){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},cr=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Hr=e=>e==="float32"||e==="int32"||e==="int64"||e==="bool"||e==="float16"||e==="uint32",zn=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var Dl,zl,Bo,Mo,Do,Wl,Oe,vt=L(()=>{"use strict";De();Dl=["V","I","W","E","F"],zl=(e,t)=>{console.log(`[${Dl[e]},${new Date().toISOString()}]${t}`)},Do=(e,t)=>{Bo=e,Mo=t},Wl=(e,t)=>{let r=cr(e),o=cr(Bo);r>=o&&zl(r,typeof t=="function"?t():t)},Oe=(...e)=>{Mo&&Wl(...e)}});var zo,Wo=L(()=>{"use strict";De();zo=(e,t)=>new(Lr(t))(e)});var No=L(()=>{"use strict"});var Fr,Nl,Go,Nn,Wn,Uo,Vo=L(()=>{"use strict";vt();No();Fr=e=>Math.ceil(e/16)*16,Nl=1,Go=()=>Nl++,Nn=async(e,t,r,o)=>{let n=Fr(r),s=e.device.createBuffer({size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let u=e.getCommandEncoder();e.endComputePass(),u.copyBufferToBuffer(t,0,s,0,n),e.flush(),await s.mapAsync(GPUMapMode.READ);let l=s.getMappedRange();if(o){let a=o();return a.set(new Uint8Array(l,0,r)),a}else return new Uint8Array(l.slice(0,r))}finally{s.destroy()}},Wn=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(t,r){let o=r.buffer,n=r.byteOffset,s=r.byteLength,u=Fr(s),l=this.storageCache.get(t);if(!l)throw new Error("gpu data for uploading does not exist");if(l.originalSize!==s)throw new Error(`inconsistent data size. gpu data size=${l.originalSize}, data size=${s}`);let a=this.backend.device.createBuffer({mappedAtCreation:!0,size:u,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),p=a.getMappedRange();new Uint8Array(p).set(new Uint8Array(o,n,s)),a.unmap();let h=this.backend.getCommandEncoder();this.backend.endComputePass(),h.copyBufferToBuffer(a,0,l.gpuData.buffer,0,u),Oe("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(a)}memcpy(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("source gpu data for memcpy does not exist");let n=this.storageCache.get(r);if(!n)throw new Error("destination gpu data for memcpy does not exist");if(o.originalSize!==n.originalSize)throw new Error("inconsistent source and destination gpu data size");let s=Fr(o.originalSize),u=this.backend.getCommandEncoder();this.backend.endComputePass(),u.copyBufferToBuffer(o.gpuData.buffer,0,n.gpuData.buffer,0,s)}registerExternalBuffer(t,r,o){let n;if(o){if(n=this.externalBuffers.get(o),n===void 0)throw new Error("previous buffer is not registered");if(t===o)return Oe("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, buffer is the same, skip.`),n;this.externalBuffers.delete(o)}else n=Go();return this.storageCache.set(n,{gpuData:{id:n,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,n),Oe("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, registered.`),n}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),Oe("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let o=Fr(t),n,s=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,u=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||u){let a=s?this.freeBuffers:this.freeUniformBuffers,p=a.get(o);p||(p=[],a.set(o,p)),p.length>0?n=p.pop():n=this.backend.device.createBuffer({size:o,usage:r})}else n=this.backend.device.createBuffer({size:o,usage:r});let l={id:Go(),type:0,buffer:n};return this.storageCache.set(l.id,{gpuData:l,originalSize:t}),Oe("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${l.id}`),l}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error("releasing data does not exist");return Oe("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("data does not exist");await Nn(this.backend,o.gpuData.buffer,o.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();this.buffersForUploadingPending=[];for(let t of this.buffersPending)(t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(t.size).push(t):(t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(t.size).push(t):t.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},Uo=(...e)=>new Wn(...e)});var Gn,ie,Pe=L(()=>{"use strict";Gn=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this._cacheKey}},ie=e=>new Gn(e)});var Un,it,z,Ot,jr,qr,Kr,he=L(()=>{"use strict";Un=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},it=class{static calcShape(t,r,o=!1){let n=t.length,s=r.length;if(n===0)return r;if(s===0)return t;let u=Math.max(t.length,r.length),l=new Array(u);if(o){if(n<2||s<2)return;let a=Un.calcMatMulShape([t[n-2],t[n-1]],[r[s-2],r[s-1]]);if(a===void 0)return;[l[u-2],l[u-1]]=a}for(let a=o?3:1;a<=u;a++){let p=n-a<0?1:t[n-a],h=s-a<0?1:r[s-a];if(p!==h&&p>1&&h>1)return;l[u-a]=Math.max(p,h)}return l}static isValidBroadcast(t,r){let o=t.length,n=r.length;if(o>n)return!1;for(let s=1;s<=o;s++)if(t[o-s]!==1&&t[o-s]!==r[n-s])return!1;return!0}},z=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,o){let n=1;for(let s=r;s<o;s++){if(t[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");n*=t[s]}return n}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let o=new Array(r);o[r-1]=1,o[r-2]=t[r-1];for(let n=r-3;n>=0;--n)o[n]=o[n+1]*t[n+1];return o}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(o=>this.normalizeAxis(o,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(o=>t[o]):t.slice().reverse()}static padShape(t,r){let o=t.length;return t.map((n,s)=>n+r[s]+r[s+o])}static areEqual(t,r){return t.length!==r.length?!1:t.every((o,n)=>o===r[n])}},Ot=class e{static adjustPoolAttributes(t,r,o,n,s,u){if(!t&&o.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let l=0;l<r.length-2;l++)l>=o.length?o.push(r[l+2]):o[l]=r[l+2];for(let l=0;l<o.length;l++)if(l<n.length){if(n[l]<0)throw new Error("strides should be greater than or equal to 1")}else n.push(1);for(let l=0;l<o.length;l++)if(l<s.length){if(s[l]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let l=0;l<o.length*2;l++)if(l<u.length){if(u[l]<0)throw new Error("pad should be greater than or equal to 1")}else u.push(0);for(let l=0;l<o.length;l++){if(o[l]<=0)throw new Error("kernel shapes need to be greater than 0");if(u[l]>=o[l]||u[l+o.length]>=o[l])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,o,n,s,u,l){if(l){if(s.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let a=0;a<t.length-2;a++)e.adjustPadAndReturnShape(t[a+(u?1:2)],r[a],o[a],n[a],s,a,a+t.length-2,l)}}static computePoolOutputShape(t,r,o,n,s,u,l){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let a=[r[0],r[1]];return e.computeShapeHelper(t,r,a,o,n,s,u,l),a}static computeConvOutputShape(t,r,o,n,s,u,l){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let a=[t[0],r[0]];return e.computeShapeHelper(!1,t,a,o,n,s,u,l),a}static computeShapeHelper(t,r,o,n,s,u,l,a){if(t)for(let p=0;p<r.length-2;p++)o.push(1);else for(let p=0;p<r.length-2;p++)o.push(e.adjustPadAndReturnShape(r[p+2],n[p],s[p],u[p],l,p,p+r.length-2,a))}static adjustPadAndReturnShape(t,r,o,n,s,u,l,a){let p=o*(n-1)+1;if(a&&a!=="NOTSET")switch(a){case"VALID":return s[u]=0,s[l]=0,Math.floor((t-p)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(o!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let b=((t+r-1)/r-1)*r+n-t;return s[u]=Math.floor(a==="SAME_LOWER"?(b+1)/2:b/2),s[l]=b-s[u],Math.floor((t+b-n)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+s[u]+s[l]-p)/r+1)}},jr=class{static getShapeOfGemmResult(t,r,o,n,s){if(t.length!==2||o.length!==2)throw new Error("shape need to be of size 2");let u,l,a;r?(u=t[1],l=t[0]):(u=t[0],l=t[1]);let p=-1;if(n?(a=o[0],p=1):(a=o[1],p=0),o[p]!==l)throw new Error("dimension mismatch");if(u<=0||a<=0||l<=0)throw new Error("invalid shape specified");if(s&&!it.isValidBroadcast(s,[u,a]))throw new Error("gemm: invalid bias shape for broadcast");return[u,a,l]}},qr=-34028234663852886e22,Kr=34028234663852886e22});var Gl,Lo,ke,Ln,ft,et,Tt,$t,Ho,H,Q,Vn,Fo,Hn,jo,ve=L(()=>{"use strict";De();he();Gl=64,Lo=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},ke=(e,t=1)=>{let r=Lo(e,t);return typeof r=="string"?r:r[0]},Ln=e=>[{type:"uint32",data:e},{type:"uint32",data:z.computeStrides(e)}],ft=e=>e%4===0?4:e%2===0?2:1,et=(e="f32",t,r="0")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,Tt=(e,t,r)=>e==="f32"?r:t===1?`f32(${r})`:`vec${t}f(${r})`,$t=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,Ho=(e,t,r,o,n)=>{let s=typeof r=="number",u=s?r:r.length,l=[...new Array(u).keys()],a=u<2?"u32":u<=4?`vec${u}<u32>`:`array<u32, ${u}>`,p=Lo(t,n),h=typeof p=="string"?p:p[1],b=typeof p=="string"?p:p[0],g={indices:a,value:h,storage:b,tensor:t},v=G=>typeof G=="string"?G:`${G}u`,$={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},w=s?"uniforms.":"",S=`${w}${e}_shape`,I=`${w}${e}_strides`,T="";for(let G=0;G<u-1;G++)T+=`
    let dim${G} = current / ${I}[${G}];
    let rest${G} = current % ${I}[${G}];
    indices[${G}] = dim${G};
    current = rest${G};
    `;T+=`indices[${u-1}] = current;`;let B=u<2?"":`
  fn o2i_${e}(offset: u32) -> ${g.indices} {
    var indices: ${g.indices};
    var current = offset;
    ${T}
    return indices;
  }`,P=G=>($.offsetToIndices=!0,u<2?G:`o2i_${e}(${G})`),M=[];if(u>=2)for(let G=u-1;G>=0;G--)M.push(`${I}[${G}] * (indices[${G}])`);let R=u<2?"":`
  fn i2o_${e}(indices: ${g.indices}) -> u32 {
    return ${M.join("+")};
  }`,W=G=>($.indicesToOffset=!0,u<2?G:`i2o_${e}(${G})`),V=(...G)=>u===0?"0u":`${g.indices}(${G.map(v).join(",")})`,Y=(G,de)=>u<2?`${G}`:`${G}[${de}]`,le=(G,de,pe)=>u<2?`${G}=${pe};`:`${G}[${de}]=${pe};`,D={},K=(G,de)=>{$.broadcastedIndicesToOffset=!0;let pe=`${de.name}broadcastedIndicesTo${e}Offset`;if(pe in D)return`${pe}(${G})`;let Ne=[];for(let Ue=u-1;Ue>=0;Ue--){let Te=de.indicesGet("outputIndices",Ue+de.rank-u);Ne.push(`${Y(I,Ue)} * (${Te} % ${Y(S,Ue)})`)}return D[pe]=`fn ${pe}(outputIndices: ${de.type.indices}) -> u32 {
             return ${Ne.length>0?Ne.join("+"):"0u"};
           }`,`${pe}(${G})`},Se=(G,de)=>(()=>{if(g.storage===g.value)return`${e}[${G}]=${de};`;if(g.storage==="vec2<u32>"&&g.value==="i32")return`${e}[${G}]=vec2<u32>(u32(${de}), select(0u, 0xFFFFFFFFu, ${de} < 0));`;if(g.storage==="vec2<u32>"&&g.value==="u32")return`${e}[${G}]=vec2<u32>(u32(${de}), 0u);`;if(g.storage==="u32"&&g.value==="vec4<bool>")return`${e}[${G}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${de}));`;throw new Error(`not supported combination of storage type ${g.storage} and value type ${g.value} yet`)})(),oe=G=>(()=>{if(g.storage===g.value)return`${e}[${G}]`;if(g.storage==="vec2<u32>"&&g.value==="i32")return`i32(${e}[${G}].x)`;if(g.storage==="vec2<u32>"&&g.value==="u32")return`u32(${e}[${G}].x)`;if(g.storage==="u32"&&g.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${G}] & 0xFFu), bool(${e}[${G}] & 0xFF00u), bool(${e}[${G}] & 0xFF0000u), bool(${e}[${G}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${g.storage} and value type ${g.value} yet`)})(),we=u<2?"":`
  fn get_${e}ByIndices(indices: ${g.indices}) -> ${h} {
    return ${oe(`i2o_${e}(indices)`)};
  }`,q=u<2?"":(()=>{let G=l.map(pe=>`d${pe}: u32`).join(", "),de=l.map(pe=>`d${pe}`).join(", ");return`
  fn get_${e}(${G}) -> ${h} {
    return get_${e}ByIndices(${V(de)});
  }`})(),Ce=(...G)=>{if(G.length!==u)throw new Error(`indices length must be ${u}`);let de=G.map(v).join(",");return u===0?oe("0u"):u===1?oe(de[0]):($.get=!0,$.getByIndices=!0,$.indicesToOffset=!0,`get_${e}(${de})`)},Be=G=>u<2?oe(G):($.getByIndices=!0,$.indicesToOffset=!0,`get_${e}ByIndices(${G})`),xe=u<2?"":`
  fn set_${e}ByIndices(indices: ${g.indices}, value: ${h}) {
    ${Se(`i2o_${e}(indices)`,"value")}
  }`,_e=u<2?"":(()=>{let G=l.map(pe=>`d${pe}: u32`).join(", "),de=l.map(pe=>`d${pe}`).join(", ");return`
  fn set_${e}(${G}, value: ${h}) {
    set_${e}ByIndices(${V(de)}, value);
  }`})();return{impl:()=>{let G=[];return s||(G.push(`const ${S} = ${g.indices}(${r.join(",")});`),G.push(`const ${I} = ${g.indices}(${z.computeStrides(r).join(",")});`)),$.offsetToIndices&&G.push(B),$.indicesToOffset&&G.push(R),$.broadcastedIndicesToOffset&&Object.values(D).forEach(de=>G.push(de)),$.set&&G.push(_e),$.setByIndices&&G.push(xe),$.get&&G.push(q),$.getByIndices&&G.push(we),G.join(`
`)},type:g,offsetToIndices:P,indicesToOffset:W,broadcastedIndicesToOffset:K,indices:V,indicesGet:Y,indicesSet:le,set:(...G)=>{if(G.length!==u+1)throw new Error(`indices length must be ${u}`);let de=G[u];if(typeof de!="string")throw new Error("value must be string");let pe=G.slice(0,u).map(v).join(",");return u===0?Se("0u",de):u===1?Se(pe[0],de):($.set=!0,$.setByIndices=!0,$.indicesToOffset=!0,`set_${e}(${pe}, ${de})`)},setByOffset:Se,setByIndices:(G,de)=>u<2?Se(G,de):($.setByIndices=!0,$.indicesToOffset=!0,`set_${e}ByIndices(${G}, ${de});`),get:Ce,getByOffset:oe,getByIndices:Be,usage:o?"input":"output",name:e,strides:I,shape:S,rank:u}},H=(e,t,r,o=1)=>Ho(e,t,r,!0,o),Q=(e,t,r,o=1)=>Ho(e,t,r,!1,o),Vn=class{constructor(t){this.normalizedDispatchGroup=t;this.indicesHelpers=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=Gl){let r=typeof t=="number"?t:t[0],o=typeof t=="number"?1:t[1],n=typeof t=="number"?1:t[2],s=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,u=s?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>`,l=s?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +
          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${r*o*n}u + local_index;`;return`@compute @workgroup_size(${r}, ${o}, ${n})
  fn main(${u}) {
    ${l}
  `}declareVariable(t,r){this.indicesHelpers.push(t),t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:t.type.indices}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:t.type.indices});let o=t.usage==="input"?"read":"read_write",n=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${o}> ${t.name}: array<${n}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`
`)}registerUniform(t,r){return this.uniforms.push({name:t,type:r}),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:r,type:o}of this.uniforms)t.push(`${r}:${o}`);return`
      struct Uniforms { ${t.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.indicesHelpers.map(t=>t.impl()).join(`
`)}},Fo=e=>new Vn(e),Hn=(e,t)=>{let r=e.length,o=[];for(let n=0;n<r;n++){let s=r-1-n,u=e[s]||1;(t[t.length-1-n]||1)>1&&u===1&&o.unshift(s)}return o},jo=e=>e<=4});var st,Ul,Yr,Vl,ut,qo,Ko,Yo,Xo,Jo,Qo,Zo,ei,ti,ri,tt,Fn=L(()=>{"use strict";he();Pe();ve();st=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Ul=e=>["","",`var value = ${e.getByOffset("inputOffset")};`,""],Yr=(e,t,r,o,n,s,u=!1,l=!1)=>{let a=[],p=r[0].dims,h=z.normalizeAxes(n,r[0].dims.length),b=!l&&h.length===0;p.forEach((W,V)=>{b||h.indexOf(V)>=0?u&&a.push(1):a.push(W)});let g=[],v=H("_A",r[0].dataType,p),$=Q("output",s,a),w=o(v,$,h),S=`inputOffset = ${v.indicesToOffset("inputIndices")};`,I=`let ${S};`,T=`var ${S};`,B=w[1]===""?"":T,P=(w[1]===""?I:S)+`
`+w[2];for(let W=0,V=0;W<r[0].dims.length;W++)b||h.indexOf(W)>=0?(u&&V++,P=`for(var j${W}: u32 = 0; j${W} < ${r[0].dims[W]}; j${W}++) {
                ${w[2].includes("lastIndex")?`let lastIndex = j${W};`:""}
                ${v.indicesSet("inputIndices",W,`j${W}`)}
                ${P}
              }`):(g.push(`${v.indicesSet("inputIndices",W,$.indicesGet("outputIndices",V))};`),V++);let M=z.size(a);return{name:e,shaderCache:t,getShaderSource:W=>`
        ${W.declareVariables(v,$)}

        ${W.mainStart()}
          ${W.guardAgainstOutOfBoundsWorkgroupSizes(M)}
          var inputIndices: ${v.type.indices};
          let outputIndices = ${$.offsetToIndices("global_idx")};

          ${g.join(`
`)}
          ${w[0]}       // init ops for reduce max/min
          ${B}
          ${w[1]}
          ${P}
          ${w[3]}
          ${w.length===4?$.setByOffset("global_idx","value"):w.slice(4).join(`
`)}
        }`,getRunData:()=>({outputs:[{dims:a,dataType:s}],dispatchGroup:{x:Math.ceil(M/64)}})}},Vl=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(o=>r.push(Number(o))),ie({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},ut=(e,t,r,o)=>{let n=e.inputs,s=n.length===1?r:Vl(n,r);e.compute(Yr(t,{hint:s.cacheKey},[n[0]],s.noopWithEmptyAxes&&s.axes.length===0?Ul:o,s.axes,n[0].dataType,s.keepDims,s.noopWithEmptyAxes),{inputs:[0]})},qo=(e,t)=>{st(e.inputs),ut(e,"ReduceLogSum",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${o.getByOffset("inputOffset")};`,"value = log(value);"])},Ko=(e,t)=>{st(e.inputs),ut(e,"ReduceL1",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += abs(${o.getByOffset("inputOffset")});`,""])},Yo=(e,t)=>{st(e.inputs),ut(e,"ReduceL2",t,(o,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${o.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])},Xo=(e,t)=>{st(e.inputs),ut(e,"ReduceLogSumExp",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += exp(${o.getByOffset("inputOffset")});`,"value = log(value);"])},Jo=(e,t)=>{st(e.inputs),ut(e,"ReduceMax",t,(o,n,s)=>{let u=[];for(let l=0;l<o.rank;l++)(s.indexOf(l)>=0||s.length===0)&&u.push(o.indicesSet("inputIndices",l,0));return[`${u.join(`
`)}`,`var value = ${o.getByOffset("inputOffset")};`,`value = max(value, ${o.getByOffset("inputOffset")});`,""]})},Qo=(e,t)=>{st(e.inputs),ut(e,"ReduceMean",t,(o,n,s)=>{let u=1;for(let l=0;l<o.rank;l++)(s.indexOf(l)>=0||s.length===0)&&(u*=e.inputs[0].dims[l]);return["var sum = f32(0);","",`sum += f32(${o.getByOffset("inputOffset")});`,`let value = ${n.type.value}(sum / ${u});`]})},Zo=(e,t)=>{st(e.inputs),ut(e,"ReduceMin",t,(o,n,s)=>{let u=[];for(let l=0;l<o.rank;l++)(s.indexOf(l)>=0||s.length===0)&&u.push(`inputIndices[${l}] = 0;`);return[`${u.join(`
`)}`,`var value = ${o.getByOffset("inputOffset")};`,`value = min(value, ${o.getByOffset("inputOffset")});`,""]})},ei=(e,t)=>{st(e.inputs),ut(e,"ReduceProd",t,(o,n)=>[`var value = ${n.type.storage}(1);`,"",`value *= ${o.getByOffset("inputOffset")};`,""])},ti=(e,t)=>{st(e.inputs),ut(e,"ReduceSum",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${o.getByOffset("inputOffset")};`,""])},ri=(e,t)=>{st(e.inputs),ut(e,"ReduceSumSquare",t,(o,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${o.getByOffset("inputOffset")}; value += t * t;`,""])},tt=e=>ie(e)});var ni,ai,oi,ii,jn,si=L(()=>{"use strict";De();Pe();Fn();ni=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},ai=(e,t)=>ie({axis:t.axis,keepDims:t.keepDims,selectLastIndex:t.selectLastIndex}),oi=(e,t)=>{ni(e.inputs);let r=(n,s,u)=>{let l=[];for(let a=0;a<n.rank;a++)(u.indexOf(a)>=0||u.length===0)&&l.push(`inputIndices[${a}] = 0;`);return[`${l.join(`
`)}`,`var value = ${n.getByOffset("inputOffset")};
var bestIndex : i32 = 0;`,`if (${n.getByOffset("inputOffset")} ${t.selectLastIndex>0?"<=":"<"} value) {
         value = ${n.getByOffset("inputOffset")};
         bestIndex = i32(lastIndex);
       }`,"",s.setByOffset("global_idx","bestIndex")]},o=e.inputs.length===1?t:ai(e.inputs,t);e.compute(Yr("ArgMin",{hint:o.cacheKey},[e.inputs[0]],r,[o.axis],7,o.keepDims),{inputs:[0]})},ii=(e,t)=>{ni(e.inputs);let r=(n,s,u)=>{let l=[];for(let a=0;a<n.rank;a++)(u.indexOf(a)>=0||u.length===0)&&l.push(`inputIndices[${a}] = 0;`);return[`${l.join(`
`)}`,`var value = ${n.getByOffset("inputOffset")};
var bestIndex : i32 = 0;`,`if (${n.getByOffset("inputOffset")} ${t.selectLastIndex>0?">=":">"} value) {
         value = ${n.getByOffset("inputOffset")};
         bestIndex = i32(lastIndex);
       }`,"",s.setByOffset("global_idx","bestIndex")]},o=e.inputs.length===1?t:ai(e.inputs,t);e.compute(Yr("argMax",{hint:o.cacheKey},[e.inputs[0]],r,[o.axis],7,o.keepDims),{inputs:[0]})},jn=e=>ie(e)});var Ll,Hl,ui,li=L(()=>{"use strict";he();ve();Ll=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Hl=e=>{let t=e[0].dims,r=e[0].dims[2],o=z.size(t)/4,n=e[0].dataType,s=H("input",n,t,4),u=H("bias",n,[r],4),l=H("residual",n,t,4),a=Q("output",n,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:h=>`
  const channels = ${r}u / 4;
  ${h.declareVariables(s,u,l,a)}

  ${h.mainStart()}
    ${h.guardAgainstOutOfBoundsWorkgroupSizes(o)}
    let value = ${s.getByOffset("global_idx")}
      + ${u.getByOffset("global_idx % channels")} + ${l.getByOffset("global_idx")};
    ${a.setByOffset("global_idx","value")}
  }`}},ui=e=>{Ll(e.inputs),e.compute(Hl(e.inputs))}});var Fl,$e,di,ci,pi,fi,mi,hi,gi,yi,bi,qn,jl,wi,vi,$i,xi,Xr,Si,Jr,Ci,Ii,Ai,_i,Ei,Oi,Ti,Ri,Pi,ki,Bi,Mi,Di,zi,Wi,Ni,Gi,Kn=L(()=>{"use strict";De();he();Pe();ve();Fl=(e,t,r,o,n,s)=>{let u=Math.ceil(t/4),l="";typeof n=="string"?l=`${n}(a)`:l=n("a");let a=H("inputData",r,[u],4),p=Q("outputData",o,[u],4);return`
  ${e.declareVariables(a,p)}

  ${s??""}

  ${e.mainStart()}
    ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}

    let a = ${a.getByOffset("global_idx")};
    ${p.setByOffset("global_idx",l)}
  }`},$e=(e,t,r,o,n,s=e.dataType)=>({name:t,shaderCache:{hint:n},getShaderSource:u=>Fl(u,z.size(e.dims),e.dataType,s,r,o),getRunData:u=>({outputs:[{dims:e.dims,dataType:s}],dispatchGroup:{x:Math.ceil(z.size(u[0].dims)/64/4)}})}),di=e=>{e.compute($e(e.inputs[0],"Abs","abs"))},ci=e=>{e.compute($e(e.inputs[0],"Acos","acos"))},pi=e=>{e.compute($e(e.inputs[0],"Acosh","acosh"))},fi=e=>{e.compute($e(e.inputs[0],"Asin","asin"))},mi=e=>{e.compute($e(e.inputs[0],"Asinh","asinh"))},hi=e=>{e.compute($e(e.inputs[0],"Atan","atan"))},gi=e=>{e.compute($e(e.inputs[0],"Atanh","atanh"))},yi=e=>ie(e),bi=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute($e(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},qn=(e,t)=>{let r=ke(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Clip",o=>`clamp(${o}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<${r}> = vec4(${r}(${t.min}));
    const clip_max_: vec4<${r}> = vec4(${r}(${t.max}));
`,t.cacheKey),{inputs:[0]})},jl=e=>{let t=e.length>=2?e[1].getFloat32Array()[0]:qr,r=e.length>=3?e[2].getFloat32Array()[0]:Kr;return ie({min:t,max:r})},wi=e=>{let t=jl(e.inputs);qn(e,t)},vi=e=>{e.compute($e(e.inputs[0],"Ceil","ceil"))},$i=e=>{e.compute($e(e.inputs[0],"Cos","cos"))},xi=e=>{e.compute($e(e.inputs[0],"Cosh","cosh"))},Xr=e=>ie(e),Si=(e,t)=>{e.compute($e(e.inputs[0],"Elu",r=>`elu_vf32(${r})`,`
  const elu_alpha_: f32 = f32(${t.alpha});

  fn elu_f32(a: f32) -> f32 {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,t.cacheKey))},Jr=(e,t="f32")=>`
const r0: ${t} = 0.3275911;
const r1: ${t} = 0.254829592;
const r2: ${t} = -0.284496736;
const r3: ${t} = 1.421413741;
const r4: ${t} = -1.453152027;
const r5: ${t} = 1.061405429;

fn erf_vf32(v: ${e}) -> ${e} {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,Ci=e=>{let t=ke(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,Jr(`vec4<${t}>`,t)))},Ii=e=>{e.compute($e(e.inputs[0],"Exp","exp"))},Ai=e=>{e.compute($e(e.inputs[0],"Floor","floor"))},_i=e=>{let t=ke(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,Jr(`vec4<${t}>`,t)))},Ei=(e,t)=>{e.compute($e(e.inputs[0],"LeakyRelu",r=>`select(leaky_relu_alpha_ * ${r}, ${r}, ${r} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${t.alpha});`,t.cacheKey))},Oi=e=>{e.compute($e(e.inputs[0],"Not",t=>`!${t}`))},Ti=e=>{e.compute($e(e.inputs[0],"Neg",t=>`-${t}`))},Ri=e=>{e.compute($e(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},Pi=e=>{e.compute($e(e.inputs[0],"Relu",t=>`select(vec4<f32>(0.0), ${t}, ${t} > vec4<f32>(0.0))`))},ki=e=>{e.compute($e(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},Bi=e=>{e.compute($e(e.inputs[0],"Sin","sin"))},Mi=e=>{e.compute($e(e.inputs[0],"Sinh","sinh"))},Di=e=>{e.compute($e(e.inputs[0],"Sqrt","sqrt"))},zi=e=>{e.compute($e(e.inputs[0],"Tan","tan"))},Wi=e=>{e.compute($e(e.inputs[0],"Tanh","tanh"))},Ni=(e,t)=>(e.compute($e(e.inputs[0],"ThresholdedRelu",r=>`select(vec4<f32>(0.0), ${r}, ${r} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${t.alpha});`,t.cacheKey)),0),Gi=e=>{e.compute($e(e.inputs[0],"Log","log"))}});var Kl,Yl,Ui,Vi=L(()=>{"use strict";he();ve();Kn();Kl=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Yl=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=H("input",e[0].dataType,e[0].dims,4),o=H("bias",e[0].dataType,[e[0].dims[2]],4),n=Q("output",e[0].dataType,t,4),s=z.size(t)/4;return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:l=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${e[0].dims[2]/4/2}u;

  ${l.declareVariables(r,o,n)}

  ${Jr("vec4f")}

  ${l.mainStart()}
    ${l.guardAgainstOutOfBoundsWorkgroupSizes(s)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${n.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},Ui=e=>{Kl(e.inputs),e.compute(Yl(e.inputs))}});var Xl,Jl,lt,Li,Hi,Fi,ji,qi,Ki,Yi,Xi,Ji,Qi,Zi=L(()=>{"use strict";De();he();ve();Xl=(e,t,r,o,n,s,u,l,a,p,h)=>{let b=z.size(o),g=Math.ceil(b/4),v,$;typeof u=="string"?v=$=(P,M)=>`${u}((${P}),(${M}))`:typeof u=="function"?v=$=u:(v=u.scalar,$=u.vector);let w="",S=Q("outputData",p,o,4),I=H("aData",l,t,4),T=H("bData",a,r,4);if(s){let P=M=>{let R=z.computeStrides(M),W=[];for(let V=M.length-1;V>=0;V--){let Y=S.indicesGet("outputIndices",V+o.length-M.length);W.push(`${R[V]}u * (${Y} % ${M[V]}u)`)}return W.length>0?W.join("+"):"0u"};w=`
          fn calcOffsetA(outputIndices: ${S.type.indices}) -> u32 {
            return ${P(t)};
          }

          fn calcOffsetB(outputIndices: ${S.type.indices}) -> u32 {
            return ${P(r)};
          }
        `}let B;if(n)if(s){let P=z.size(t)===1,M=z.size(r)===1;P||M?B=S.setByOffset("global_idx",$(P?`${I.type.value}(${I.getByOffset("0")}.x)`:I.getByOffset("global_idx"),M?`${T.type.value}(${T.getByOffset("0")}.x)`:T.getByOffset("global_idx"))):B=`
            let outputIndices = ${S.offsetToIndices("global_idx * 4u")};
            let offsetA = calcOffsetA(outputIndices);
            let offsetB = calcOffsetB(outputIndices);
            ${S.setByOffset("global_idx",$(I.getByOffset("offsetA / 4u"),T.getByOffset("offsetB / 4u")))}
          `}else B=S.setByOffset("global_idx",$(I.getByOffset("global_idx"),T.getByOffset("global_idx")));else{if(!s)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let P=(M,R,W="")=>{let V=`aData[indexA${R}][componentA${R}]`,Y=`bData[indexB${R}][componentB${R}]`;return`
            let outputIndices${R} = ${S.offsetToIndices(`global_idx * 4u + ${R}u`)};
            let offsetA${R} = calcOffsetA(outputIndices${R});
            let offsetB${R} = calcOffsetB(outputIndices${R});
            let indexA${R} = offsetA${R} / 4u;
            let indexB${R} = offsetB${R} / 4u;
            let componentA${R} = offsetA${R} % 4u;
            let componentB${R} = offsetB${R} % 4u;
            ${M}[${R}] = ${W}(${v(V,Y)});
          `};p===9?B=`
            var data = vec4<u32>(0);
            ${P("data",0,"u32")}
            ${P("data",1,"u32")}
            ${P("data",2,"u32")}
            ${P("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:B=`
            ${P("outputData[global_idx]",0)}
            ${P("outputData[global_idx]",1)}
            ${P("outputData[global_idx]",2)}
            ${P("outputData[global_idx]",3)}
          `}return`
        ${e.declareVariables(I,T,S)}

        ${h??""}
        ${w}

        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes(g)}
        ${B}
      }`},Jl=(e,t,r,o,n,s,u=r.dataType)=>{let l=!z.areEqual(r.dims,o.dims),a=r.dims,p=z.size(r.dims),h=!1;if(l){let b=it.calcShape(r.dims,o.dims,!1);if(!b)throw new Error("Can't perform binary op on the given tensors");a=b,p=z.size(a);let g=z.size(r.dims)===1,v=z.size(o.dims)===1,$=1;for(let w=1;w<a.length;w++){let S=r.dims[r.dims.length-w]??1,I=o.dims[o.dims.length-w]??1;if(S===I)$*=S;else break}($%4===0||g||v)&&(h=!0)}else h=!0;return{name:e,shaderCache:{hint:t},getShaderSource:b=>Xl(b,r.dims,o.dims,a,h,l,n,r.dataType,o.dataType,u,s),getRunData:()=>({outputs:[{dims:a,dataType:u}],dispatchGroup:{x:Math.ceil(p/64/4)}})}},lt=(e,t,r,o,n,s)=>{e.compute(Jl(t,n??"",e.inputs[0],e.inputs[1],r,o,s))},Li=e=>{lt(e,"Add",(t,r)=>`${t}+${r}`)},Hi=e=>{lt(e,"Div",(t,r)=>`${t}/${r}`)},Fi=e=>{lt(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},ji=e=>{lt(e,"Mul",(t,r)=>`${t}*${r}`)},qi=e=>{let t=H("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;lt(e,"Pow",{scalar:(o,n)=>`pow_custom(${o},${n})`,vector:(o,n)=>`pow_vector_custom(${o},${n})`},`
    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {
      if (b == ${t}(0.0)) {
        return ${t}(1.0);
      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {
        return ${t}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {
      // TODO: implement vectorized pow
      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},Ki=e=>{lt(e,"Sub",(t,r)=>`${t}-${r}`)},Yi=e=>{lt(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},Xi=e=>{lt(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},Ji=e=>{lt(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},Qi=e=>{lt(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var Zl,ed,td,rd,es,ts,rs=L(()=>{"use strict";he();Pe();ve();Zl=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].dataType,r=e[0].dims.length;for(let o of e){if(o.dataType!==t)throw new Error("input tensors should be one type");if(o.dims.length!==r)throw new Error("input tensors should have the same shape")}},ed=e=>`
  fn calculateInputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${e}u;
  }`,td=(e,t)=>{let r=e.length,o=[];for(let n=0;n<r;++n){let s=t.setByOffset("global_idx",e[n].getByIndices("indices"));r===1?o.push(s):n===0?o.push(`if (inputIndex == ${n}u) { ${s} }`):n===r-1?o.push(`else { ${s} }`):o.push(`else if (inputIndex == ${n}) { ${s} }`)}return o.join(`
`)},rd=(e,t)=>{let r=e[0].dims.slice();if(t>=r.length||t<-1*r.length)throw new Error("axis specified for concat doesn't match input dimensionality");let o=t<0?r.length+t:t,n=r.slice(0);for(let v=1;v<e.length;v++){let $=e[v].dims.slice();for(let w=0;w<r.length;w++)if(w===o)n[o]+=$[w];else if(r[w]!==$[w])throw new Error("non concat dimensions must match")}let s=z.size(n),u=new Array(e.length),l=new Array(e.length),a=e[0].dataType,p=0;for(let v=0;v<e.length;++v)p+=e[v].dims[o],u[v]=p,l[v]=H(`input${v}`,a,e[v].dims);let h=Q("output",a,n),b=h.indicesGet("indices",o),g=v=>`
  ${v.declareVariables(...l,h)}

  const sizeInConcatAxis = array<u32, ${u.length}>(${u.map($=>`${$}u`).join(",")});
  ${ed(u.length)}

  ${v.mainStart()}
    ${v.guardAgainstOutOfBoundsWorkgroupSizes(s)}

    var indices = ${h.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${b});
    if (inputIndex != 0u) {
      ${b} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${td(l,h)}
  }`;return{name:"Concat",shaderCache:{hint:`${t}`},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:g}},es=(e,t)=>{Zl(e.inputs),e.compute(rd(e.inputs,t.axis))},ts=e=>ie({axis:e.axis})});var ze,Qr,Zr,en=L(()=>{"use strict";ze=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Qr=(e,t=!1,r=!1,o=3)=>"",Zr=(e,t)=>`
      ${e?"value = value + getBiasByOutputCoords(coords);":""}
      // TODO uncomment the following line when activation is supported above.
      // ${t?"value = activation(value, coords);":""}
      `});var tn,Yn=L(()=>{"use strict";tn=`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));
}
`});var rn,nn,pr=L(()=>{"use strict";he();rn=(e,t=!1)=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${e.clipMin});const clip_max_=f32(${e.clipMax});`,applyActivation:t?"value = clamp(value, vec4(clip_min_), vec4(clip_max_));":"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},nn=e=>{let t=e?.activation||"";if(t==="Clip"){let[r,o]=e?.activation_params||[qr,Kr];return{activation:t,clipMax:o,clipMin:r,activationCacheKey:`${t}:${r},${o}`}}return{activation:t,activationCacheKey:t}}});var nd,ad,fr,ns,od,mr,id,an,hr=L(()=>{"use strict";he();ve();pr();en();nd=(e,t)=>e?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${t?", batchIndices":""});
        `,ad=(e,t)=>e?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,fr=(e,t,r="f32",o,n=!1,s=32,u=!1,l=32)=>{let a=t[1]*e[1],p=t[0]*e[0],h=n?a:s,b=n?s:a,g=h/t[0],v=s/t[1];if(!((n&&g===4&&e[1]===4||!n&&(g===3||g===4))&&h%t[0]===0&&s%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${n} is true, innerElementSize ${g} and workPerThread[1] ${e[1]} must be 4.
      Otherwise, innerElementSize ${g} must be 3 or 4.
  tileAWidth ${h} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${g}<${r}>, ${h/g}>, ${b}>;
var<workgroup> mm_Bsub: array<array<vec4<${r}>, ${p/e[0]}>, ${s}>;

const rowPerThread = ${e[1]};
const colPerThread = ${e[0]};
const innerElementSize = ${g};
const tileInner = ${s};

@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${u?"0":"i32(globalId.z)"};
  ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${a};

  let numTiles = ${u?`${Math.ceil(l/s)}`:"(dimInner - 1) / tileInner + 1"};
  var kStart = ${u?`i32(globalId.z) * ${l}`:"0"};

  var acc: array<vec4<${r}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${v};
  for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${nd(n,o)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${v}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${o?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${g===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${ad(n,g)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},ns=(e,t)=>e?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${t?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${t?", batchIndices":""});
            `,od=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",mr=(e,t,r="f32",o,n=!1,s=32,u=!1,l=32,a=!1)=>{let p=e[1]*t[1],h=e[0]*t[0],b=n?p:s,g=n?s:p;if(!(g%t[1]===0&&b%t[0]===0&&s%t[1]===0))throw new Error(`tileAHight ${g} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${b} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`);let v=g/t[1],$=b/t[0],w=s/t[1],S=a?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${p};
    let globalColStart = i32(workgroupId.x) * ${h};

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${g}; inputRow = inputRow + ${t[1]}) {
        for (var inputCol = localCol; inputCol < ${b}; inputCol = inputCol + ${t[0]}) {
          ${ns(n,o)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {
            for (var inputCol = localCol; inputCol < ${h}; inputCol = inputCol + ${t[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${o?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${r}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${t[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${t[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${p};

let tileRowA = i32(localId.y) * ${v};
let tileColA = i32(localId.x) * ${$};
let tileRowB = i32(localId.y) * ${w};
// Loop over shared dimension.
for (var t = 0; t < numTiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${v}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${$}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${ns(n,o)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${o?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${r}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${od(n)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${r}, ${b}>, ${g}>;
  var<workgroup> mm_Bsub : array<array<${r}, ${h}>, ${s}>;
  const rowPerThread = ${e[1]};
  const colPerThread = ${e[0]};
  const tileInner = ${s};

@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${u?"0":"i32(globalId.z)"};
    ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}
    let numTiles = ${u?`${Math.ceil(l/s)}`:"(dimInner - 1) / tileInner + 1"};
    var kStart = ${u?`i32(globalId.z) * ${l}`:"0"};

    var acc : array<array<${r}, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${S}
  }
`},id=(e,t,r,o,n,s=!1)=>{let u=n[0],l=n[1],a=n[2],p=o[0],h=o[1],b=o[2],g=o[3],v=Hn(u,a),$=Hn(l,a),w=ke(o[0].type.tensor),S=()=>{let B=h.rank,P=p.rank,M=`var aIndices: ${h.type.indices};`;for(let R=B-2-1,W=P-1;R>=0;R--,W--)M+=`
aIndices[${R}] = ${P>1?`batchIndices[${W}]`:"batchIndices"};`;return v.forEach(R=>{M+=`
aIndices[${R}] = 0;`}),M+=`
aIndices[${B-2}] = u32(row);
                   aIndices[${B-1}] = u32(colIn);`,M},I=()=>{let B=b.rank,P=p.rank,M=`var bIndices: ${b.type.indices};`;for(let R=B-2-1,W=P-1;R>=0;R--,W--)M+=`
bIndices[${R}] = ${P>1?`batchIndices[${W}]`:"batchIndices"};`;return $.forEach(R=>{M+=`
bIndices[${R}] = 0;`}),M+=`
bIndices[${B-2}] = u32(row);
                   bIndices[${B-1}] = u32(colIn);`,M};return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${p.type.indices}) -> ${ze(e,w)} {
      var value = ${ze(e,w)}(0.0);
      let col = colIn * ${e};
      if(row < dimAOuter && col < dimInner)
      {
        ${S()}
        value = ${h.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${p.type.indices}) -> ${ze(e,w)} {
      var value = ${ze(e,w)}(0.0);
      let col = colIn * ${e};
      if(row < dimInner && col < dimBOuter)
      {
        ${I()}
        value = ${b.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${ze(e,w)}) {
      let col = colIn * ${e};
      if (row < dimAOuter && col < dimBOuter) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${t?`value = value + ${s?"bias[colIn]":`${ze(e,w)}(bias[row])`};`:""}
        ${r}
        ${g.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},an=(e,t,r,o,n=!1)=>{let s=e[0].dims,u=e[1].dims,l=s.slice(0,-2),a=u.slice(0,-2),p=o?o.slice(0,-2):r.slice(0,-2),h=H("batchDims",e[0].dataType,p),b=[h],g=[l,a,p],v=z.size(p),$=s[s.length-2],w=s[s.length-1],S=u[u.length-1],I=w%4===0&&S%4===0,{activationFunction:T,applyActivation:B}=rn(t,I),P=$<=8?[4,1,1]:[4,4,1],M=[8,8,1],R=[Math.ceil(S/M[0]/P[0]),Math.ceil($/M[1]/P[1]),Math.ceil(v/M[2]/P[2])],W=ke(e[0].dataType),V=I?4:1,Y=H("a",e[0].dataType,[...l,$,w/V],V),le=H("b",e[1].dataType,[...a,w,S/V],V),D=Q("result",e[0].dataType,[v,$,S/V],V);b.push(Y),b.push(le),b.push(D);let K=[Y,le],Se=e.length>2,oe=id(V,Se,B,b,g,n);if(Se){let q=n?V:1;K.push(H("bias",e[2].dataType,e[2].dims,q))}let we=q=>`
  const dimAOuter: i32 = ${$};
  const dimBOuter: i32 = ${S};
  const dimInner: i32 = ${w};
  ${q.declareVariables(...K,D)}
  ${T}
  ${oe}
  ${I?fr(P,M,W,h):mr(P,M,W,h)}
                   ${h.impl()}`;return{name:"MatMul",shaderCache:{hint:t.activationCacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:R[0],y:R[1],z:R[2]}}),getShaderSource:we}}});var sd,as,os=L(()=>{"use strict";vt();he();ve();en();Yn();hr();sd=(e,t,r,o,n=!1,s,u=!1,l=4,a=4,p=4,h="f32")=>{let b=le=>{switch(le){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${h}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${le} is not supported.`)}},g=le=>{switch(le){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${le} is not supported.`)}},v=e?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,$=e?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,w=e?"xShape[1]":"xShape[2]",S=e?"xShape[2]":"xShape[3]",I=e?"row":"col",T=e?"col":"row",B=`
    let inChannels = wShape[2];
    let outWidth = ${e?"outShape[2]":"outShape[3]"};
    let outRow = ${I} / outWidth;
    let outCol = ${I} % outWidth;

    let WRow = ${T} / (filterDims[1] * inChannels);
    let WCol = ${T} / inChannels % filterDims[1];
    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];
    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];
    let xCh = ${T} % inChannels;
    var resData = ${ze(l,h)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${w} && xCol >= 0 && xCol < ${S}) {
      ${v}
      let xIndex = getIndexFromCoords4D(coord, xShape);
      ${b(l)}
    }
    return resData;`,P=e?t&&o?`
    let col = colIn * ${l};
    ${B}`:`
    let col = colIn * ${l};
    if (row < dimAOuter && col < dimInner) {
      ${B}
    }
    return ${ze(l,h)}(0.0);`:o&&r?`
    let col = colIn * ${l};
    ${B}`:`
    let col = colIn * ${l};
    if (row < dimInner && col < dimBOuter) {
      ${B}
    }
    return ${ze(l,h)}(0.0);`,M=`${g(a)}`,R=ze(p,h),W=e?ze(l,h):ze(a,h),V=e?ze(a,h):ze(l,h);return`
    ${Qr(s,u,p===4,4)}
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${W} {
      ${e?P:M}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${V} {
      ${e?M:P}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${R}) {
      let col = colIn * ${p};
      if (row < dimAOuter && col < dimBOuter)
      {
      var value = valueIn;
      let outWidth = ${e?"outShape[2]":"outShape[3]"};
      ${$}
      ${Zr(n,s)}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},as=(e,t,r,o,n,s,u,l)=>{let a=t.format==="NHWC",p=a?e[0].dims[3]:e[0].dims[1],h=r[0],b=a?r[2]:r[3],g=a?r[1]:r[2],v=a?r[3]:r[1],$=a&&(p%4===0||p%3===0)&&v%4===0,w=a?v:b*g,S=a?b*g:v,I=[8,8,1],T=o<=8?[4,1,1]:[4,4,1],B=[Math.ceil(w/I[0]/T[0]),Math.ceil(S/I[1]/T[1]),Math.ceil(h/I[2]/T[2])];Oe("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${B}`);let P=$?a&&p%4!==0?3:4:T[0],M=I[1]*T[1],R=I[0]*T[0],W=Math.max(I[0]*P,I[1]),V=o%M===0,Y=n%R===0,le=s%W===0,D=$?[P,4,4]:[1,1,1],K=ke(e[0].dataType),Se=[`@group(0) @binding(0) var<storage, read> x: array<${$&&P===4?`vec4<${K}>`:K}>;`,`@group(0) @binding(1) var<storage, read> w: array<${$?`vec4<${K}>`:K}>;`],oe=`
      fn setOutputAtIndex(flatIndex : i32, value : ${$?`vec4<${K}>`:K}) {
        result[flatIndex] = ${$?`vec4<${K}>`:K}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${$?`vec4<${K}>`:K}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${$?"/ 4":""}, value);
      }`;return u&&(Se.push(`@group(0) @binding(2) var<storage, read> bias: array<${$?`vec4<${K}>`:K}>;`),oe+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${$?`vec4<${K}>`:K} {
          return bias[coords.${a?"w":"y"}${$?"/ 4":""}];
        }`),{name:"Conv2DMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:B[0],y:B[1],z:B[2]}}),getShaderSource:()=>`
        ${tn}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${Se.join("")}
        @group(0) @binding(${Se.length}) var<storage, read_write> result: array<${$?`vec4<${K}>`:K}>;
        //@group(0) @binding(${Se.length+1}) var<uniform> uniforms: Uniforms;

        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${z.computeStrides(r).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[0]}, ${t.kernelShape[1]});
        const pad : vec2<i32> = vec2<i32>(${t.pads[0]}, ${t.pads[1]});
        const stride : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});
        const dimAOuter : i32 = ${o};
        const dimBOuter : i32 = ${n};
        const dimInner : i32 = ${s};
        ${oe}
        ${sd(a,V,Y,le,u,t.activation.toLowerCase(),!1,D[0],D[1],D[2],K)}
            ${$?fr(T,I,K,void 0,!a,W):mr(T,I,K,void 0,!a,W,!1,void 0,l)}`}}});var Xn,is=L(()=>{"use strict";he();ve();Qn();pr();Xn=(e,t,r)=>{let o=e.length>2,n=o?"value += b[output_channel];":"",s=e[0].dims,u=e[1].dims,l=u[0]/t.group,{activationFunction:a,applyActivation:p}=rn(t),h=t.format==="NHWC",b=Jn(s,u,t.dilations,t.pads,t.strides,h),g=z.size(b),v=Q("output",e[0].dataType,b),$=H("x",e[0].dataType,s),w=H("w",e[1].dataType,u),S=[$,w];o&&S.push(H("b",e[2].dataType,e[2].dims));let I=T=>`
  const strides: vec2<u32> = vec2(${t.strides[0]}u, ${t.strides[1]}u);
  const pads: vec2<u32> = vec2(${t.pads[0]}u, ${t.pads[1]}u);

  ${T.declareVariables(...S,v)}

  ${a}

  ${T.mainStart()}
    ${T.guardAgainstOutOfBoundsWorkgroupSizes(g)}

    let outputIndices = ${v.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${h?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${h?1:2}], outputIndices[${h?2:3}]) * strides - pads;
    let group_id: u32 = output_channel / ${l}u;

    var value: ${v.type.value} = ${v.type.value}(0);
    for (var wInChannel: u32 = 0u; wInChannel < ${u[1]}u; wInChannel++) {
      let input_channel = group_id * ${u[1]}u + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < ${u[2]}u; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * ${t.dilations[0]}u;

        if (xHeight < 0u || xHeight >= ${s[h?1:2]}u) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < ${u[3]}u; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * ${t.dilations[1]}u;
          if (xWidth < 0u || xWidth >= ${s[h?2:3]}u) {
            continue;
          }

          let xVal = ${h?$.get("batch","xHeight","xWidth","input_channel"):$.get("batch","input_channel","xHeight","xWidth")};
          let wVal = ${w.get("output_channel","wInChannel","wHeight","wWidth")};
          value += xVal*wVal;
        }
      }
    }
    ${n}
    ${p}
    ${v.setByOffset("global_idx","value")}
  }`;return{name:"GroupedConv",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r?r(b):b,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(g/64)}}),getShaderSource:I}}});var ud,ss,ld,dd,Vt,us,ls,on=L(()=>{"use strict";he();Pe();ve();ud=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},ss=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,ld=(e,t)=>z.sortBasedOnPerm(e,ss(e.length,t)),dd=(e,t,r,o)=>{let n=[];n.push(`fn perm(i: ${o.type.indices}) -> ${r.type.indices} {
    var a: ${r.type.indices};`);for(let s=0;s<t;++s)n.push(r.indicesSet("a",e[s],`i[${s}]`));return n.push("return a;}"),n.join(`
`)},Vt=(e,t)=>{let r=e.dataType,o=e.dims.length,n=ss(o,t),s=jo(o),u=ld(e.dims,n),l=s?u.length:u,a=s?o:e.dims,p=Q("output",r,l),h=H("a",r,a),b=g=>`
  ${g.registerUniform("output_size","u32").declareVariables(h,p)}

  ${dd(n,o,h,p)}

  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${p.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${p.setByOffset("global_idx",h.getByIndices("aIndices"))}
  }`;return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:s?["rank"]:["dims"]},getRunData:g=>{let v=z.size(u);return{outputs:[{dims:u,dataType:g[0].dataType}],dispatchGroup:{x:Math.ceil(v/64)},programUniforms:s?[{type:"uint32",data:v},...Ln(g[0].dims),...Ln(u)]:[{type:"uint32",data:v}]}},getShaderSource:b}},us=(e,t)=>{ud(e.inputs),e.compute(Vt(e.inputs[0],t.perm))},ls=e=>ie({perm:e.perm})});var Jn,ds,cd,cs,Zn,pd,fd,ea,Qn=L(()=>{"use strict";he();Pe();os();hr();is();pr();on();Jn=(e,t,r,o,n,s)=>{let u=e[0],l=e.slice(s?1:2,s?3:4),a=l.length,p=t[0],b=t.slice(2).map(($,w)=>$+($-1)*(r[w]-1)),v=l.map(($,w)=>$+o[w]+o[w+a]).map(($,w)=>Math.floor(($-b[w]+n[w])/n[w]));return v.splice(0,0,u),v.splice(s?3:1,0,p),v},ds=[2,3,1,0],cd=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[1]*t.group;if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==n*2)throw new Error(`pads should be ${n*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},cs=(e,t)=>{let r=e.kernelShape.slice();for(let s=2;s<t[1].dims.length;++s)r[s-2]===0&&(r[s-2]=t[1].dims[s]);let o=e.pads.slice();Ot.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,o,e.format==="NHWC",e.autoPad);let n=Object.assign({},e);return Object.assign(n,{kernelShape:r,pads:o,cacheKey:e.cacheKey}),n},Zn=e=>{let t=nn(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],n=e.dilations,s=e.group,u=e.kernel_shape,l=e.pads,a=e.strides,p=e.w_is_const();return ie({autoPad:o,format:r,dilations:n,group:s,kernelShape:u,pads:l,strides:a,wIsConst:p,...t})},pd=(e,t,r)=>{let o=cs(r,t);if(r.group!==1){e.compute(Xn(t,o));return}let n=r.format==="NHWC",s=t.length===3,u=t[0].dims[n?1:2],l=t[0].dims[n?2:3],a=t[0].dims[n?3:1],p=t[1].dims[2],h=t[1].dims[3],b=Jn(t[0].dims,t[1].dims,r.dilations,o.pads,r.strides,n),g=b[n?1:2],v=b[n?2:3],$=b[n?3:1],w=n&&p===u&&h===l&&r.pads[0]===0&&r.pads[1]===0;if(w||p===1&&h===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let R=b[0],W,V,Y,le=[];if(n){let D=e.kernelCustomData.wT??e.compute(Vt(t[1],ds),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=D),w){let K=u*l*a;W=t[0].reshape([1,R,K]),V=D.reshape([1,K,$]),Y=[1,R,$]}else W=t[0].reshape([R,u*l,a]),V=D.reshape([1,a,$]),Y=[R,g*v,$];le.push(W),le.push(V)}else W=t[0].reshape([R,a,u*l]),V=t[1].reshape([1,$,a]),Y=[R,$,g*v],le.push(V),le.push(W);s&&le.push(t[2]),e.compute(an(le,o,b,Y,n),{inputs:le});return}let S=!0,I=e.kernelCustomData.wT??e.compute(Vt(t[1],ds),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=I);let T=[t[0],I];s&&T.push(t[2]);let B=n?g*v:$,P=n?$:g*v,M=p*h*a;e.compute(as(T,o,b,B,P,M,s,S),{inputs:T})},fd=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&o.push(e.inputs[2]);let n=[0,t.pads[0],0,t.pads[1]],s=[1].concat(t.strides),u=[1].concat(t.dilations),l=[1].concat(t.kernelShape),a=cs({...t,pads:n,strides:s,dilations:u,kernelShape:l},o);e.compute(Xn(o,a,p=>r?[p[0],p[2],p[3]]:[]))},ea=(e,t)=>{cd(e.inputs,t),e.inputs[0].dims.length===3?fd(e,t):pd(e,e.inputs,t)}});var md,ps,fs=L(()=>{"use strict";vt();he();en();Yn();hr();md=(e,t=!1,r,o=!1,n=4)=>{let s=ze(n,"f32"),u=I=>{switch(I){case 1:return"return W[getIndexFromCoords4D(coord, wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${I} is not supported.`)}},l=e?`
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `,a=e?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,p=e?"outBackprop[1]":"outBackprop[2]",h=e?"outBackprop[2]":"outBackprop[3]",b=e?"row":"col",g=e?"col":"row",v=`
      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};
      let outWidth = ${e?"outShape[2]":"outShape[3]"};
      let outRow = ${b} / outWidth;
      let outCol = ${b} % outWidth;

      let WRow = ${g} / (filterDims[1] * inChannels);
      let WCol = ${g} / inChannels % filterDims[1];
      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);
      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);
      if (xR < 0.0 || xR >= f32(${p}) || fract(xR) > 0.0) {
        return ${s}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${h}) || fract(xC) > 0.0) {
        return ${s}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${g} % inChannels;
      ${l}
      return x[getIndexFromCoords4D(coord, xShape)/${n}];`,$=e?`
      let col = colIn * ${n};
      if (row < dimAOuter && col < dimInner) {
        ${v}
      }
      return ${s}(0.0);`:`
      let col = colIn * ${n};
      if (row < dimInner && col < dimBOuter) {
        ${v}
      }
      return ${s}(0.0);`,w=`
      let col = colIn * ${n};
      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};
      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);
      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];
      if (${e?"row < dimInner && col < dimBOuter":"row < dimInner && col < dimAOuter"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${u(n)}
      }
      return ${s}(0.0);
      `;return`
  ${Qr(r,o,n===4,4)}
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${s} {
    ${e?$:w}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${s} {
    ${e?w:$}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${s}) {
    let col = colIn * ${n};
    if (row < dimAOuter && col < dimBOuter) {
      var value = valueInput;
      let outWidth = ${e?"outShape[2]":"outShape[3]"};
      ${a}
      ${Zr(t,r)}
      result[getIndexFromCoords4D(coords, outShape)/${n}] = value;
    }
  }`},ps=(e,t,r,o,n,s,u,l)=>{let a=t.format==="NHWC",p=a?e[0].dims[3]:e[0].dims[1],h=r[0],b=a?r[2]:r[3],g=a?r[1]:r[2],v=a?r[3]:r[1],$=a?p%4===0&&v%4===0:b%4===0&&v%4===0,w=a?v:b*g,S=a?b*g:v,I=$?[8,8,1]:[w<=4||S<=4?4:16,w>4&&S<=4?4:16,1],T=$?[4,4,1]:[w<=4?1:4,w>4&&S<=4?1:4,1],B=[Math.ceil(w/I[0]/T[0]),Math.ceil(S/I[1]/T[1]),Math.ceil(h/I[2]/T[2])];Oe("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${B}`);let P=$?4:1,M=Math.max(I[0]*P,I[1]),R=[`@group(0) @binding(0) var<storage, read> x: array<${$?"vec4<f32>":"f32"}>;`,"@group(0) @binding(1) var<storage, read> W: array<f32>;"],W="";return u&&(R.push(`@group(0) @binding(2) var<storage, read> bias: array<${$?"vec4<f32>":"f32"}>;`),W+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${$?"vec4<f32>":"f32"} {
          return bias[coords.${a?"w":"y"}${$?"/ 4":""}];
        }`),{name:"Conv2DTransposeMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:B[0],y:B[1],z:B[2]}}),getShaderSource:()=>`
        ${tn}
        ${R.join(`
`)}
        @group(0) @binding(${R.length}) var<storage, read_write> result: array<${$?"vec4<f32>":"f32"}>;
        const outBackprop : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});
        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${z.computeStrides(r).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[a?1:2]}, ${t.kernelShape[a?2:3]});
        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(
              ${t.dilations[0]<=1?0:(t.kernelShape[a?1:2]-1)*(t.dilations[0]-1)},
              ${t.dilations[1]<=1?0:(t.kernelShape[a?2:3]-1)*(t.dilations[1]-1)});
        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${t.pads[0]+t.pads[2]})/2,
                                         i32(effectiveFilterDims[1]) - 1 - (${t.pads[1]+t.pads[3]})/2);
        const strides : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});
        const dimAOuter : i32 = ${o};
        const dimBOuter : i32 = ${n};
        const dimInner : i32 = ${s};
        ${W}
        ${md(a,u,t.activation.toLowerCase(),!1,P)}
        ${$?fr(T,I,"f32",void 0,!a,M):mr(T,I,"f32",void 0,!a,M,!1,void 0,l)}`}}});var hd,ta,ms=L(()=>{"use strict";vt();he();ve();hd=(e,t,r,o,n,s,u=!1,l)=>{let a=r.format==="NHWC",p=a?1:2,h=a?2:3,b=a?3:1,g=z.size(o),v=u?2:1,$=r.group,w=t[1].dims,S=w[0]/$,I=w[1],T=`
  fn setOutputAtIndex(flatIndex : u32, value : ${u?`vec4<${l}>`:l}) {
    result[flatIndex] = ${u?`vec4<${l}>`:l}(value);
  }`;n&&(T+=`
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${u?`vec4<${l}>`:l} {
      return bias[coords.${a?"w":"y"}${u?"/ 4":""}];
    }`);let B=u?4:1,P=H("W",t[1].dataType,t[1].dims,B),M=H("Dy",t[0].dataType,t[0].dims,B),R=[M,P];n&&R.push(H("bias",t[2].dataType,[o[b]],B));let W=Q("result",t[0].dataType,o,B),V=`{
        let batch: u32 = ${s?"global_id.z":"workgroup_id.z"} / outShape[1];
        let r = ${s?"global_id.z":"workgroup_id.z"} % outShape[1];
        let c = ${s?"global_id.y":"workgroup_id.y"} * ${v};
        let d1: u32 = ${s?"global_id.x":"workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${l}>, ${v}>;
        for (var i = 0; i < ${v}; i++) {
          dotProd[i] = vec4<${l}>(0.0);
        }
        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {
          var dyR = (${l}(dyCorner.x) + ${l}(wR)) / ${l}(strides.x);
          let wRPerm = filterDims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${l}(outBackprop[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {
            let dyC = (${l}(dyCorner.y) + ${l}(wC)) / ${l}(strides.y);
            let dyC2 = (${l}(dyCorner.y) + 1.0 + ${l}(wC)) / ${l}(strides.y);
            let wCPerm = filterDims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${l}(outBackprop[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${l}(outBackprop[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${P.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${P.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${P.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${P.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${M.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${l}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${M.get("batch","idyR","idyC2","d2")};

                dotProd[1] = dotProd[1] + vec4<${l}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = outBackprop[${b}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${P.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${P.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${P.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${P.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${M.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${l}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${P.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${P.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${P.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${P.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${M.get("batch","idyR","idyC2","d2")};
                let tmpval = vec4<${l}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${v}; i = i + 1) {
          let value = dotProd[i] + ${n?"bias[c+i]":"0.0"};
          ${W.set("batch","r","c + i","d1","value")};
        }
      }`,Y=`
          let outputIndices = ${W.offsetToIndices("global_idx")};
          let batch = ${W.indicesGet("outputIndices",0)};
          let d1 = ${W.indicesGet("outputIndices",b)};
          let r = ${W.indicesGet("outputIndices",p)};
          let c = ${W.indicesGet("outputIndices",h)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / ${I};
          let wOutChannel = d1 - groupId * ${I};
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = 0.0;
          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {
            if (wR % dilations.x != 0) {
              continue;
            }
            let dyR = (${l}(dyRCorner) + ${l}(wR)) / ${l}(strides[0]);
            let wRPerm = filterDims.x - 1 - wR / dilations.x;
            if (dyR < 0.0 || dyR >= ${l}(outBackprop[${p}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {
              if (wC % dilations.y != 0) {
                continue;
              }
              let dyC = (${l}(dyCCorner) + ${l}(wC)) / ${l}(strides.y);
              let wCPerm = filterDims.y - 1 - wC / dilations.y;
              if (dyC < 0.0 || dyC >= ${l}(outBackprop[${h}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * ${S};
              for (var d2: u32 = 0; d2 < ${S}; d2 = d2 + 1) {
                let xValue = ${a?M.get("batch","idyR","idyC","inputChannel"):M.get("batch","inputChannel","idyR","idyC")};
                let wValue = ${P.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${n?"bias[d1]":"0.0"};
          ${W.setByOffset("global_idx","value")};
        `;return`
  ${e.declareVariables(...R,W)}
  ${T}
  const outShape : vec4<u32> = vec4<u32>(${o.join(",")});
  const outBackprop : vec4<u32> = vec4<u32>(${t[0].dims.join(",")});
  const strides : vec2<u32> = vec2<u32>(${r.strides[0]}, ${r.strides[1]});
  const filterDims : vec2<u32> = vec2<u32>(${r.kernelShape[a?1:2]}, ${r.kernelShape[a?2:3]});
  const dilations : vec2<u32> = vec2<u32>(${r.dilations[0]}, ${r.dilations[1]});
  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(
          ${r.dilations[0]<=1?0:(r.kernelShape[a?1:2]-1)*(r.dilations[0]-1)},
          ${r.dilations[1]<=1?0:(r.kernelShape[a?2:3]-1)*(r.dilations[1]-1)});
  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,
                                     i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);
    ${e.mainStart()}
    ${e.guardAgainstOutOfBoundsWorkgroupSizes(g)};
  ${u?V:Y}}`},ta=(e,t,r)=>{let o=e.length>2,n=t.outputShape,s=z.size(n),u=[Math.ceil(s/64),1,1];Oe("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${u}`);let l=ke(e[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:t.cacheKey},getRunData:()=>({dispatchGroup:{x:u[0],y:u[1],z:u[2]},outputs:[{dims:r?r(n):n,dataType:e[0].dataType}]}),getShaderSource:a=>hd(a,e,t,n,o,u[1]===1&&u[2]===1,!1,l)}}});var gd,yd,bd,hs,gs,wd,vd,$d,xd,ys,bs=L(()=>{"use strict";Pe();fs();ms();pr();on();gd=(e,t,r,o,n,s)=>(e-1)*t+r+(o-1)*n+1-s,yd=(e,t,r,o,n)=>{let s=Math.floor(e/2);t==="SAME_UPPER"?(r[o]=s,r[n]=e-s):t==="SAME_LOWER"&&(r[o]=e-s,r[n]=s)},bd=(e,t,r,o,n,s,u,l,a,p)=>{let h=e.length-2,b=p.length===0;if(a.length===0)for(let $=0;$<h;++$)a.push(0);let g=e[0],v=t[l?3:1]*n;for(let $=0,w=e.length-h-(l?1:0);$<h;++$,++w){let S=e[w],I=b?S*u[$]:p[$],T=gd(S,u[$],s[$],t[w],r[$],I);yd(T,o,s,$,$+h),b&&p.push(u[$]*(S-1)+a[$]+(t[w]-1)*r[$]+1-s[$]-s[$+h])}p.splice(0,0,g),p.splice(l?3:1,0,v)},hs=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((g,v)=>g*v,1)===0){r.length=0;for(let g=2;g<t[1].dims.length;++g)r.push(t[1].dims[g])}let o=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(o?3:1,0,t[1].dims[1]);let n=e.pads.slice(),s=e.outputShape.slice(),u=e.outputPadding.slice(),l=t[0].dims,a=e.dilations.slice();if(a.reduce((g,v)=>g+v,0)===0){let g=t[0].dims.length-2;a=new Array(g).fill(1)}let p=e.strides.slice();if(p.reduce((g,v)=>g+v,0)===0){let g=t[0].dims.length-2;p=new Array(g).fill(1)}bd(l,r,a,e.autoPad,e.group,n,p,o,u,s);let h=Object.assign({},e),b=e.cacheKey+[r.join("n,"),n.join(","),p.join(","),u.join(","),s.join(","),a.join(",")].join("_");return Object.assign(h,{kernelShape:r,pads:n,outputPadding:u,outputShape:s,dilations:a,strides:p,cacheKey:b}),h},gs=e=>{let t=nn(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],n=e.dilations,s=e.group,u=e.kernelShape,l=e.pads,a=e.strides,p=e.wIsConst(),h=e.outputPadding,b=e.outputShape;return ie({autoPad:o,format:r,dilations:n,group:s,kernelShape:u,outputPadding:h,outputShape:b,pads:l,strides:a,wIsConst:p,...t})},wd=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[0];if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==n))throw new Error("invalid bias");let s=e[0].dims.length-2;if(t.dilations.reduce((h,b)=>h+b,0)>0&&t.dilations.length!==s)throw new Error(`dilations should be ${s}D`);if(t.strides.reduce((h,b)=>h+b,0)>0&&t.strides.length!==s)throw new Error(`strides should be ${s}D`);if(t.pads.reduce((h,b)=>h+b,0)>0&&t.pads.length!==s*2)throw new Error(`pads should be ${s*2}D`);if(t.outputPadding.length!==s&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${s}D`);if(t.kernelShape.reduce((h,b)=>h+b,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},vd=[2,3,1,0],$d=(e,t,r)=>{let o=hs(r,t),n=r.format==="NHWC",s=t.length===3;if(o.group!==1){e.compute(ta(t,o));return}let u=o.outputShape,l=u[n?1:2],a=u[n?2:3],p=u[n?3:1],h=t[1].dims[2],b=t[1].dims[3],g=t[0].dims[n?3:1],v=n?l*a:p,$=n?p:l*a,w=h*b*g,S=!0,I=e.kernelCustomData.wT??e.compute(Vt(t[1],vd),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=I);let T=[t[0],I];s&&(!n&&t[2].dims.length===1?T.push(t[2].reshape([t[2].dims[0],1,1])):T.push(t[2])),e.compute(ps(T,o,u,v,$,w,s,S),{inputs:T})},xd=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];o.length===3&&o.push(e.inputs[2]);let n=t.kernelShape;(n.length===0||n[0]===0)&&(n=[e.inputs[1].dims[2]]);let s=t.dilations;(s.length===0||s[0]===0)&&(s=[1]);let u=t.strides;(u.length===0||u[0]===0)&&(u=[1]);let l=t.pads;l.length===0&&(l=[0,0]),l=[0,l[0],0,l[1]],u=[1].concat(u),s=[1].concat(s),n=[1].concat(n);let a=hs({...t,pads:l,strides:u,dilations:s,kernelShape:n},o);e.compute(ta(o,a,p=>r?[p[0],p[2],p[3]]:[p[0],p[1],p[3]]))},ys=(e,t)=>{wd(e.inputs,t),e.inputs[0].dims.length===3?xd(e,t):$d(e,e.inputs,t)}});var ra,sn,ws,Sd,Cd,na,aa,Id,vs,$s,xs=L(()=>{"use strict";he();Pe();ve();ra="[a-zA-Z]|\\.\\.\\.",sn="("+ra+")+",ws="^"+sn+"$",Sd="("+sn+",)*"+sn,Cd="^"+Sd+"$",na=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let o=this.symbolToIndices.get(t);o===void 0?o=[r]:o.push(r),this.symbolToIndices.set(t,o)}},aa=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[o,n]=r.includes("->")?r.split("->",2):[r,""];if(!o.match(RegExp(Cd)))throw new Error("Invalid LHS term");if(o.split(",").forEach((l,a)=>{let p=t[a].dims.slice();if(!l.match(RegExp(ws)))throw new Error("Invalid LHS term");let h=this.processTerm(l,!0,p,a);this.lhs.push(h)}),n==="")n+=[...this.symbolToInfo.entries()].filter(([l,a])=>a.count===1||l==="...").map(([l])=>l).join("");else if(!n.match(RegExp(sn)))throw new Error("Invalid RHS");n.match(RegExp(ra,"g"))?.forEach(l=>{if(l==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let a=this.symbolToInfo.get(l);if(a===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(a.dimValue)}}),this.rhs=this.processTerm(n,!0,this.outputDims)}addSymbol(t,r,o){let n=this.symbolToInfo.get(t);if(n!==void 0){if(n.dimValue!==r&&n.count!==1)throw new Error("Dimension mismatch");n.count++,n.inputIndices.push(o)}else n={count:1,dimValue:r,inputIndices:[o]};this.symbolToInfo.set(t,n)}processTerm(t,r,o,n=-1){let s=o.length,u=!1,l=[],a=0;if(!t.match(RegExp(ws))&&!r&&t!=="")throw new Error("Invalid LHS term");let p=t.match(RegExp(ra,"g")),h=new na(n);return p?.forEach((b,g)=>{if(b==="..."){if(u)throw new Error("Only one ellipsis is allowed per input term");u=!0;let v=s-p.length+1;if(v<0)throw new Error("Ellipsis out of bounds");if(l=o.slice(a,a+v),this.hasEllipsis){if(this.ellipsisDims.length!==l.length||this.ellipsisDims.toString()!==l.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=l;else throw new Error("Ellipsis must be specified in the LHS");for(let $=0;$<l.length;$++){let w=String.fromCharCode("0".charCodeAt(0)+g);h.addSymbol(w,g+$),this.addSymbol(w,o[a++],n)}}else h.addSymbol(b,g),this.addSymbol(b,o[a++],n)}),h}},Id=(e,t)=>{let r=e[0].dataType,o=new Array(e.length);for(let B=0;B<e.length;++B)o[B]=H(`input${B}`,r,e[B].dims);let n=t.outputDims,s=z.size(n),u=Q("output",r,n),l=[],a=Array.from(t.rhs.symbolToIndices.keys()),p="var prod = 1.0;",h="var sum = 0.0;",b="sum += prod;",g=[],v=[],$=[],w=[],S=t.symbolToInfo.size===a.length;t.symbolToInfo.forEach((B,P)=>{if(a.includes(P)){let M=a.indexOf(P);t.lhs.forEach((R,W)=>{if(B.inputIndices.includes(W)){let V=R.symbolToIndices.get(P);if(V===void 0)throw new Error("Invalid symbol error");V.forEach(Y=>{l.push(`${o[W].indicesSet(`input${W}Indices`,Y,u.indicesGet("outputIndices",M))}`)})}})}else t.lhs.forEach((M,R)=>{let W=t.symbolToInfo.get(P);if(W===void 0)throw new Error("Invalid symbol error");if(W.inputIndices.includes(R)){let V=M.symbolToIndices.get(P);if(V===void 0)throw new Error("Invalid symbol error");V.forEach(Y=>{g.push(`${o[R].indicesSet(`input${R}Indices`,Y,`${P}`)}`)}),w.push(`prod *= ${o[R].getByIndices(`input${R}Indices`)};`)}}),v.push(`for(var ${P}: u32 = 0; ${P} < ${t.symbolToInfo.get(P)?.dimValue}; ${P}++) {`),$.push("}")});let I=S?[...l,`let sum = ${o.map((B,P)=>B.getByIndices(`input${P}Indices`)).join(" * ")};`]:[...l,h,...v,...g,p,...w,b,...$],T=B=>`
      ${B.declareVariables(...o,u)}

      ${B.mainStart()}
        ${B.guardAgainstOutOfBoundsWorkgroupSizes(s)}
        var outputIndices = ${u.offsetToIndices("global_idx")};
        ${o.map((P,M)=>`var input${M}Indices: ${o[M].type.indices};`).join(`
`)}
        ${I.join(`
`)};
        ${u.setByOffset("global_idx","sum")};
      }`;return{name:"Einsum",shaderCache:{hint:t.equation},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:T}},vs=(e,t)=>{let r=new aa(e.inputs,t.equation);e.compute(Id(e.inputs,r))},$s=e=>{let t=e.equation.replace(/\s+/g,"");return ie({equation:t})}});var Ad,Ss,_d,Ed,Cs,Is=L(()=>{"use strict";he();ve();Ad=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=r.length<t.length?0:r.length-t.length,n=t.length<r.length?0:t.length-r.length;for(;o<r.length&&n<t.length;++o,++n)if(r[o]!==t[n]&&r[o]!==1&&t[n]!==1)throw new Error("Expand requires shape to be broadcastable to input")},Ss=(e,t)=>{let r=e.length-t.length,o=[];for(let n=0;n<r;++n)o.push(e[n]);for(let n=0;n<t.length;++n)o.push(t[n]===1?e[n+r]:t[n]);return o},_d=(e,t)=>e.length>t.length?Ss(e,t):Ss(t,e),Ed=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=_d(t,r),n=z.size(o),s=e[0].dataType,u=H("input",s,t),l=Q("output",s,o),a=p=>`
  const inputShape = ${u.indices(...t)};
  ${p.declareVariables(u,l)}
  ${p.mainStart()}
  ${p.guardAgainstOutOfBoundsWorkgroupSizes(n)}
    let outputIndices = ${l.offsetToIndices("global_idx")};
    var inputIndices: ${u.type.indices};
    for (var i = 0; i < ${t.length}; i++) {
      if (${u.indicesGet("inputShape","i")} == 1) {
        ${u.indicesSet("inputIndices","i",0)}
      } else {
        ${u.indicesSet("inputIndices","i",l.indicesGet("outputIndices",`i + ${o.length-t.length}`))}
      }
    }
    ${l.setByOffset("global_idx",u.getByIndices("inputIndices"))}
  }`;return{name:"Expand",shaderCache:{hint:`${o}`},getShaderSource:a,getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}})}},Cs=e=>{Ad(e.inputs),e.compute(Ed(e.inputs),{inputs:[0]})}});var Od,Td,As,_s,Es=L(()=>{"use strict";he();Pe();ve();Od=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},Td=(e,t)=>{let r=e[0].dims,o=e[1].dims,n=r.length,s=z.normalizeAxis(t.axis,n),u=r.slice(0);u.splice(s,1,...o);let l=r[s],a=z.size(u),p=H("data",e[0].dataType,e[0].dims),h=H("inputIndices",e[1].dataType,e[1].dims),b=Q("output",e[0].dataType,u),g=()=>{let $=o.length,w=`var indicesIndices  = ${h.type.indices}(0);`;for(let S=0;S<$;S++)w+=`${$>1?`indicesIndices[${S}]`:"indicesIndices"} = ${u.length>1?`outputIndices[${s+S}]`:"outputIndices"};`;w+=`
        var idx = ${h.getByIndices("indicesIndices")};
        if (idx < 0) {
          idx = idx + ${l};
        }
        var dataIndices = ${p.type.indices}(0);
      `;for(let S=0,I=0;S<n;S++)S===s?(w+=`${n>1?`dataIndices[${S}]`:"dataIndices"} = u32(idx);`,I+=$):(w+=`${n>1?`dataIndices[${S}]`:"dataIndices"} = ${u.length>1?`outputIndices[${I}]`:"outputIndices"};`,I++);return w},v=$=>`
      ${$.declareVariables(p,h,b)}
      ${$.mainStart()}
        ${$.guardAgainstOutOfBoundsWorkgroupSizes(a)}
        let outputIndices = ${b.offsetToIndices("global_idx")};
        ${g()};
        let value = ${p.getByIndices("dataIndices")};
        ${b.setByOffset("global_idx","value")};
      }`;return{name:"Gather",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:v}},As=e=>ie({axis:e.axis}),_s=(e,t)=>{let r=e.inputs;Od(r),e.compute(Td(e.inputs,t))}});var Rd,Pd,Os,Ts,Rs=L(()=>{"use strict";he();Pe();ve();Rd=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},Pd=(e,t)=>{let r=e[0].dims,o=e[0].dataType,n=r.length,s=z.computeStrides(r),u=z.size(r),l=e[1].dims,a=e[1].dataType,p=z.size(l),h=z.normalizeAxis(t.axis,n),b=r[h],g=l.slice(0),v=z.size(g),$=H("input",o,r),w=H("indices",a,[p]),S=Q("output",o,g),I=T=>`
      const inputStrides = array<u32, ${s.length}>(${s.map(B=>`${B}u`).join(",")});
      ${T.declareVariables($,w,S)}
      ${T.mainStart()}
      ${T.guardAgainstOutOfBoundsWorkgroupSizes(v)}

      let outputIndices = ${S.offsetToIndices("global_idx")};

      var idx = ${w.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + ${b};
      }

      var srcOffset = u32(0);

      for (var i = 0; i < ${r.length}; i++) {
        if (i == ${h}) {
          srcOffset +=  u32(idx) * inputStrides[i];
        } else {
          srcOffset += ${S.indicesGet("outputIndices","i")} * inputStrides[i];
        }
      }

      // Should never hit this with valid values in indices
      // This is a guard against malicious data in the indices input
      if (srcOffset < 0 || srcOffset >= ${u}) {
        return;
      }

      output[global_idx] = input[srcOffset];
  }`;return{name:"GatherElements",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:g,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(v/64)}}),getShaderSource:I}},Os=e=>ie({axis:e.axis}),Ts=(e,t)=>{let r=e.inputs;Rd(r),e.compute(Pd(e.inputs,t))}});var kd,Bd,Md,Ps,ks,Bs=L(()=>{"use strict";he();Pe();ve();kd=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},Bd=(e,t,r)=>{if(r.length===0)return"0u";let o=r.length===1&&e!==1||r.length===2&&r[0]!==e,n=r[r.length-1]!==t,s="0u";return o||(s+=`+ m * ${r[r.length-1]}u`),n||(s+="+n"),s},Md=(e,t)=>{let r=e[0].dims.slice(),o=e[1].dims.slice(),[n,s,u]=jr.getShapeOfGemmResult(r,t.transA,o,t.transB,e.length===3?e[2].dims:void 0),l=[n,s];if(!l)throw new Error("Can't use gemm on the given tensors");let a=z.size(l),p="";t.transA&&t.transB?p="value += a[k * M + m] * b[n * K + k];":t.transA&&!t.transB?p="value += a[k * M + m] * b[k * N + n];":!t.transA&&t.transB?p="value += a[m * K + k] * b[n * K + k];":!t.transA&&!t.transB&&(p="value += a[m * K + k] * b[k * N + n];");let h=ke(e[0].dataType),b=t.alpha===1?"":"value *= alpha;",g=e.length===3?`value += beta * c[${Bd(n,s,e[2].dims)}];`:"",v=[`@group(0) @binding(0) var<storage, read> a : array<${h}>;`,`@group(0) @binding(1) var<storage, read> b : array<${h}>;`];e.length===3&&v.push(`@group(0) @binding(2) var<storage, read> c : array<${h}>;`);let $=w=>`
  const M: u32 = ${n}u;
  const N: u32 = ${s}u;
  const K: u32 = ${u}u;
  const alpha = ${h}(${t.alpha});
  const beta = ${h}(${t.beta});

  ${v.join(`
`)}
  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${h}>;

  ${w.mainStart()}
    ${w.guardAgainstOutOfBoundsWorkgroupSizes(a)}

    let m = global_id.x / N;
    let n = global_id.x % N;

    var value = ${h}(0);
    for (var k: u32 = 0u; k<${u}u; k++) {
      ${p}
    }

    ${b}
    ${g}
    output[global_id.x] = value;

  }`;return{name:"Gemm",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:l,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:$}},Ps=(e,t)=>{kd(e.inputs),e.compute(Md(e.inputs,t))},ks=e=>ie(e)});var Dd,zd,Wd,Nd,Ms,Ds,zs=L(()=>{"use strict";De();he();Pe();ve();Dd={name:"InstanceNormalization"},zd=(e,t)=>{let r=e[0].dims,o=r,n=2,s=z.sizeToDimension(r,n),u=z.sizeFromDimension(r,n),l=r[1],a=H("x",e[0].dataType,[r[0],r[1],u]),p=H("scale",e[1].dataType,e[1].dims),h=H("bias",e[2].dataType,e[2].dims),b=Q("output",e[0].dataType,[r[0],r[1],u]),g=[a,p,h,b],v=a.type.value,$=64,w=S=>`

  const C: u32 = ${l};
  const normSize: u32 = ${u};
  const epsilon: f32 = ${t.epsilon};
  var<workgroup> meanShared : ${v};
  var<workgroup> squaredNormShared : ${v};
  var<workgroup> workgroupShared : array<${v}, ${$}>;
  const workgroupSize = ${$}u;
  ${S.declareVariables(...g)}
  ${S.mainStart($)}
    let norm = global_idx / workgroupSize;
    let batch = norm / C;
    let channel = norm % C;
    let localIndex = local_id.x;

    // initialize workgroup memory
    var initial: ${v} = 0;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      initial = initial + ${a.get("batch","channel","h")};
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the mean of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      meanShared = workgroupShared[0] / ${v}(normSize);
    }
    workgroupBarrier();

    // reinitialize workgroup memory.
    initial = 0;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      let deviation =  ${a.get("batch","channel","h")} - meanShared;
      initial = initial + deviation * deviation;
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the sum of square of deviation of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      squaredNormShared = workgroupShared[0];
    }
    workgroupBarrier();

    let invStdDev = 1 / sqrt(squaredNormShared / ${v}(normSize) + epsilon);
    let channelScale = invStdDev * ${p.getByOffset("channel")};
    let channelShift = ${h.getByOffset("channel")} - meanShared * channelScale;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      let value = ${a.get("batch","channel","h")} * channelScale + channelShift;
      ${b.set("batch","channel","h","value")};
    }
  }`;return{...Dd,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:s}}),getShaderSource:w}},Wd=(e,t,r,o,n,s,u,l)=>{let a=ft(u),p=H("input",t.dataType,t.dims,a),h=H("scale",r.dataType,r.dims,a),b=H("bias",o.dataType,o.dims,a),g=64,v=a===1?"vec2f":`mat2x${a}f`,$=a===1?"f32":`vec${a}f`,w=(M,R)=>`${v}(${M}, ${R})`,S=n*u/a,I=Math.ceil(s/g),T=M=>`
  const H: u32 = ${s};
  const C: u32 = ${u/a};
  const imageSize: u32 = ${s*u/a};

  ${M.declareVariables(p)}
  @group(0) @binding(1) var<storage, read_write> output : array<${v}>;

  ${M.mainStart(g)}
    let currentImageNumber = global_idx / ${g} / C;
    let currentChannelNumber = (global_idx / ${g}) % C;
    let wgId = global_idx % ${g};
    let wgOffset = wgId * ${I};
    if (wgOffset >= H) {
        return;
    }
    let wgMax = min(wgOffset + ${I}, H);

    let offset = currentImageNumber * imageSize + currentChannelNumber;
    var sum = ${et("f32",a)};
    var squaredSum = ${et("f32",a)};
    for (var i: u32 = wgOffset; i < wgMax; i++) {
        let value = ${$}(input[offset + i * C]);
        sum += value;
        squaredSum += value * value;
    }
    output[global_idx] = ${w("sum","squaredSum")};
  }`,B=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:a,n,h:s,c:u})},getRunData:()=>({outputs:[{dims:[n,u,g,2],dataType:1}],dispatchGroup:{x:n*u/a}}),getShaderSource:T},{inputs:[t],outputs:[-1]})[0],P=M=>`
  const H: u32 = ${s};
  const C: u32 = ${u/a};
  const imageSize: u32 = ${g*u/a};
  const epsilon: f32 = ${l};

  @group(0) @binding(0) var<storage, read> input : array<${v}>;
  @group(0) @binding(1) var<storage, read> scale : array<${h.type.storage}>;
  @group(0) @binding(2) var<storage, read> bias : array<${b.type.storage}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${v}>;

  ${M.mainStart()}
    ${M.guardAgainstOutOfBoundsWorkgroupSizes(S)}
    let currentImageNumber = global_idx / C;
    let currentChannelNumber = global_idx % C;

    let offset = currentImageNumber * imageSize;
    var sum = ${et("f32",a)};
    var squaredSum = ${et("f32",a)};
    for (var i: u32 = 0; i < ${g}; i++) {
        let value = input[offset + i + currentChannelNumber * ${g}];
        sum += value[0];
        squaredSum += value[1];
    }
    sum = sum / f32(H);
    squaredSum = squaredSum / f32(H);
    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);
    let channelScale = invStdDev * ${$}(scale[currentChannelNumber]);
    let channelShift = ${$}(bias[currentChannelNumber]) - sum * channelScale;

    output[global_idx] = ${w("channelScale","channelShift")};
  }`;return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:a,n,h:s,c:u,epsilon:l})},getRunData:()=>({outputs:[{dims:[n,u,2],dataType:1}],dispatchGroup:{x:Math.ceil(S/64)}}),getShaderSource:P},{inputs:[B,r,o],outputs:[-1]})[0]},Nd=(e,t,r)=>{let o=t[0].dims,n=o,s=o[0],u=o[o.length-1],l=z.sizeFromDimension(o,1)/u,a=ft(u),p=z.size(n)/a,h=H("input",t[0].dataType,t[0].dims,a),b=Q("output",t[0].dataType,n,a),g=ke(t[0].dataType),v=a===1?"vec2f":`mat2x${a}f`,$=a===1?g:`vec${a}<${g}>`,w=Wd(e,t[0],t[1],t[2],s,l,u,r.epsilon),S=I=>`
  const H: u32 = ${l};
  const C: u32 = ${u/a};

  @group(0) @binding(0) var<storage, read> input : array<${h.type.storage}>;
  @group(0) @binding(1) var<storage, read> scaleInput : array<${v}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${b.type.storage}>;

  ${I.mainStart()}
    let currentImageNumber = global_idx / (C * H);
    let currentChannelNumber = global_idx % C;

    let scaleOffset = currentImageNumber * C + currentChannelNumber;
    let scale = scaleInput[scaleOffset];
    output[global_idx] = fma(input[global_idx], ${$}(scale[0]), ${$}(scale[1]));
  }`;e.compute({name:"InstanceNormalization",shaderCache:{hint:`${r.cacheKey}`},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)}}),getShaderSource:S},{inputs:[t[0],w]})},Ms=e=>ie({epsilon:e.epsilon,format:e.format}),Ds=(e,t)=>{t.format==="NHWC"?Nd(e,e.inputs,t):e.compute(zd(e.inputs,t))}});var Gd,Ud,Ws,Ns,Gs=L(()=>{"use strict";De();he();Pe();ve();Gd=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},Ud=(e,t,r)=>{let o=e[0].dims,n=e[1],s=e[2],u=o,l=z.normalizeAxis(t.axis,o.length),a=z.sizeToDimension(o,l),p=z.sizeFromDimension(o,l),h=z.size(n.dims),b=s?z.size(s.dims):0;if(h!==p||s&&b!==p)throw new Error(`Size of X.shape()[axis:] == ${p}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${h} and bias size of ${b}`);let g=[];for(let P=0;P<o.length;++P)P<l?g.push(o[P]):g.push(1);let v=ft(p),$=ke(e[0].dataType),w=[H("x",e[0].dataType,e[0].dims,v),H("scale",n.dataType,n.dims,v)];s&&w.push(H("bias",s.dataType,s.dims,v)),w.push(Q("output",e[0].dataType,u,v));let S=r>1,I=r>2;S&&w.push(Q("meanDataOutput",1,g)),I&&w.push(Q("invStdOutput",1,g));let T=P=>`
  const normSize: f32 = ${p};
  const normSizeVectorized: u32 = ${p/v};
  const epsilon: f32 = ${t.epsilon};

  ${P.declareVariables(...w)}
  ${P.mainStart()}
    ${P.guardAgainstOutOfBoundsWorkgroupSizes(a)}
    let offset = global_idx * normSizeVectorized;
    var meanVector = ${et("f32",v)};
    var meanSquareVector = ${et("f32",v)};

    for (var h: u32 = 0u; h < normSizeVectorized; h++) {
      let value = ${Tt($,v,"x[h + offset]")};
      meanVector += value;
      meanSquareVector += value * value;
    }
    let mean = ${$t("meanVector",v)} / normSize;
    let meanSquare = sqrt(${$t("meanSquareVector",v)} 
      / normSize - mean * mean + epsilon);

    for (var j: u32 = 0; j < normSizeVectorized; j++) {
      let f32input = ${Tt($,v,"x[j + offset]")};
      let f32scale = ${Tt($,v,"scale[j]")};
      output[j + offset] = ${w[0].type.value}((f32input - mean) / meanSquare * f32scale
        ${s?`+ ${Tt($,v,"bias[j]")}`:""}
      );
    }

    ${S?"meanDataOutput[global_idx] = mean":""};
    ${I?"invStdOutput[global_idx] = 1 / meanSquare":""};
  }`,B=[{dims:u,dataType:e[0].dataType}];return S&&B.push({dims:g,dataType:1}),I&&B.push({dims:g,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${t.cacheKey}|${r}|${e.length}`},getRunData:()=>({outputs:B,dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:T}},Ws=e=>ie({axis:e.axis,epsilon:e.epsilon}),Ns=(e,t)=>{Gd(e.inputs),e.compute(Ud(e.inputs,t,e.outputCount))}});var Vd,Us,Vs=L(()=>{"use strict";he();hr();Vd=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},Us=e=>{Vd(e.inputs);let t=it.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can't use matmul on the given tensors");e.compute(an(e.inputs,{activation:"",activationCacheKey:""},t))}});var Ld,Hd,Fd,jd,qd,Kd,Yd,Xd,Jd,Ls,Hs,Fs=L(()=>{"use strict";De();he();Pe();ve();Ld=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1)throw new Error("Input type must be float.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},Hd=(e,t,r,o,n,s,u)=>{let l=r.length,a="";for(let p=l-1;p>=0;--p)a+=`
            k = i32(${e.indicesGet("indices",p)}) - ${n[p]};
            if (k < 0) {
              break;
            }
            if (k >= ${r[p]}) {
              break;
            }
            offset += k * ${o[p]};
        `;return`
          value = ${s}(${u});
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${a}
            value = x[offset];
          }
      `},Fd=(e,t,r,o,n)=>{let s=r.length,u="";for(let l=s-1;l>=0;--l)u+=`
                k = i32(${e.indicesGet("indices",l)}) - ${n[l]};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = ${2*(r[l]-1)};
                  k = k % _2n_1;
                  if(k >= ${r[l]}) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * ${o[l]};
            `;return`
              var offset = 0;
              var k = 0;
              ${u}
              value = x[offset];
          `},jd=(e,t,r,o,n)=>{let s=r.length,u="";for(let l=s-1;l>=0;--l)u+=`
                k = i32(${e.indicesGet("indices",l)}) - ${n[l]};
                if (k < 0) {
                  k = 0;
                }
                if (k >= ${r[l]}) {
                  k = ${r[l]-1};
                }
                offset += k * ${o[l]};
            `;return`
              var offset = 0;
              var k = 0;
              ${u}
              value = x[offset];
          `},qd=(e,t,r,o,n)=>{let s=r.length,u="";for(let l=s-1;l>=0;--l)u+=`
                k = i32(${e.indicesGet("indices",l)}) - ${n[l]};
                if (k < 0)  {
                  k += ${r[l]};
                }
                if (k >= ${r[l]}) {
                  k -= ${r[l]};
                }
                offset += k * ${o[l]};
            `;return`
              var offset = 0;
              var k = 0;
              ${u}
              value = x[offset];
          `},Kd=(e,t,r,o,n,s)=>{switch(n.mode){case 0:return Hd(e,t,r,o,n.pads,s,n.value);case 1:return Fd(e,t,r,o,n.pads);case 2:return jd(e,t,r,o,n.pads);case 3:return qd(e,t,r,o,n.pads);default:throw new Error("Invalid mode")}},Yd=(e,t,r,o)=>{let n=t[0].dims,s=z.padShape(n.slice(),r.pads),u=z.size(s),l=z.computeStrides(n),a=Q("output",t[0].dataType,s),p=H("x",t[0].dataType,n),h=Kd(a,s,n,l,r,o);return`
              ${e.declareVariables(p,a)}
              ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}

              let indices = ${a.offsetToIndices("global_idx")};

              var value = ${o}(0);
              ${h}
              output[global_idx] = value;
          }`},Xd=(e,t)=>{let r=z.padShape(e[0].dims.slice(),t.pads);return{name:"Pad",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(z.size(r)/64)}}),getShaderSource:o=>Yd(o,e,t,"f32")}},Jd=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),o=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,n=e[0].dims.length,s=new Int32Array(2*n).fill(0);if(e.length>=4){let l=e[3].getBigInt64Array();for(let a=0;a<l.length;a++)s[Number(l[a])]=Number(r[a]),s[Number(l[a])+n]=Number(r[a+l.length])}else r.forEach((l,a)=>s[Number(a)]=Number(l));let u=[];return s.forEach(l=>u.push(l)),ie({mode:t.mode,value:o,pads:u})}else return t},Ls=(e,t)=>{Ld(e.inputs);let r=Jd(e.inputs,t);e.compute(Xd(e.inputs,r),{inputs:[0]})},Hs=e=>{let t=e.mode,r=e.value,o=e.pads;return ie({mode:t,value:r,pads:o})}});var un,js,qs,Ks,Ys,Xs,Js,Qs,Zs,eu,tu,ru,nu,au,ou,iu=L(()=>{"use strict";he();Pe();ve();un=e=>{if(!e||e.length!==1)throw new Error("Pool ops requires 1 input.");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("Pool ops supports 1-D or 2-D inputs only for now.")},js=(e,t,r)=>{let o=t.format==="NHWC",n=e.dims.slice();o&&n.splice(1,0,n.pop());let s=Object.hasOwnProperty.call(t,"dilations"),u=t.kernelShape.slice(),l=t.strides.slice(),a=s?t.dilations.slice():[],p=t.pads.slice();Ot.adjustPoolAttributes(r,n,u,l,a,p);let h=Ot.computePoolOutputShape(r,n,l,a,u,p,t.autoPad),b=Object.assign({},t);s?Object.assign(b,{kernelShape:u,strides:l,pads:p,dilations:a,cacheKey:t.cacheKey}):Object.assign(b,{kernelShape:u,strides:l,pads:p,cacheKey:t.cacheKey});let g=h.slice();return g.push(g.splice(1,1)[0]),[b,o?g:h]},qs=(e,t,r,o,n,s,u,l)=>{let a=n.format==="NHWC",p=r,h=t.type.value,b=p.length,g=z.size(o),v=Q("output",t.type.tensor,o);if(n.kernelShape.length<=2){let $=n.kernelShape[n.kernelShape.length-1],w=n.strides[n.strides.length-1],S=n.pads[n.pads.length/2-1],I=n.pads[n.pads.length-1],T=b-(a?2:1),B="",P="",M="";if(S+I!==0?B=`
                for (var i: u32 = 0u; i < ${$}u; i++) {
                  xIndices[${T}] = indices[${T}] * ${w} - ${S} + i;
                  if (xIndices[${T}] < 0 || xIndices[${T}] >= ${p[T]}) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${t.indicesToOffset("xIndices")}];
                  ${s}
                }`:B=`
                for (var i: u32 = 0u; i < ${$}u; i++) {
                  xIndices[${T}] = indices[${T}] * ${w} - ${S} + i;
                  let x_val = x[${t.indicesToOffset("xIndices")}];
                  ${s}
                }`,n.kernelShape.length===2){let W=n.kernelShape[n.kernelShape.length-2],V=n.strides[n.strides.length-2],Y=n.pads[n.pads.length/2-2],le=n.pads[n.pads.length-2],D=b-(a?3:2),K=p[D];Y+le!==0?P=`
                for (var j: u32 = 0u; j < ${W}u; j++) {
                  xIndices[${D}] = indices[${D}] * ${V} - ${Y} + j;
                  if (xIndices[${D}] < 0 || xIndices[${D}] >= ${K}) {
                    pad+= ${$};
                    continue;
                  }
              `:P=`
                for (var j: u32 = 0u; j < ${W}u; j++) {
                  xIndices[${D}] = indices[${D}] * ${V} - ${Y} + j;
                `,M=`
              }
            `}return`
            ${e.declareVariables(t,v)}

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes(g)}

              let indices = ${v.offsetToIndices("global_idx")};
              var xIndices = ${v.offsetToIndices("global_idx")};

              var value: ${h} = ${h}(${l});
              var pad = 0;
              ${P}
              ${B}
              ${M}
              ${u}

              output[global_idx] = value;
            }`}else{if(a)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let $=z.size(n.kernelShape),w=z.computeStrides(n.kernelShape),S=w.length,I=n.pads.length,T=n.pads.reduce((M,R)=>M+R),B="";return T?B=`
                if (xIndices[j] >= inputDims[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${t.indicesToOffset("xIndices")}];
                ${s}
              }`:B=`
              }
              let x_val = x[${t.indicesToOffset("xIndices")}];
              ${s}
            `,`
            ${e.declareVariables(t,v)}

            const pads = array<u32, ${I}>(${n.pads.map(M=>`${M}u`).join(",")});
            const inputDims = array<u32, ${b}>(${p.map(M=>`${M}u`).join(",")});
            const kernelStrides = array<u32, ${S}>(${w.map(M=>`${M}u`).join(",")});
            const strides = array<u32, ${S}>(${n.strides.map(M=>`${M}u`).join(",")});

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes(g)}

              let indices = ${v.offsetToIndices("global_idx")};
              let xIndices = ${v.offsetToIndices("global_idx")};

              var offsets: array<u32, ${S}>;

              var value = ${v.type.value}(${l});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < ${$}u; i++) {
                var offset = i;
                for (var j = 0u; j < ${S-1}u; j++) {
                  offsets[j] = offset / kernelStrides[j];
                  offset -= offsets[j] * kernelStrides[j];
                }
                offsets[${S-1}] = offset;

                isPad = false;
                for (var j = ${b-S}u; j < ${b}u; j++) {
                  xIndices[j] = indices[j] * strides[j - ${b-S}u]
                    + offsets[j - ${b-S}u] - pads[j - 2u];
                  ${B}
              }
              ${u}

              output[global_idx] = value;
            }`}},Ks=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Ys=(e,t,r,o)=>{let[n,s]=js(t,o,r),u=z.size(n.kernelShape),l=H("x",t.dataType,t.dims),a=l.type.value,p="value += x_val;",h="";return n.countIncludePad?h+=`value /= ${a}(${u});`:h+=`value /= ${a}(${u} - pad);`,{name:e,shaderCache:{hint:o.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(z.size(s)/64)}}),getShaderSource:b=>qs(b,l,t.dims,s,n,p,h,"0.0")}},Xs=e=>{let t=e.count_include_pad!==0,r=Ks(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return ie({countIncludePad:t,...r})},Js=(e,t)=>{un(e.inputs),e.compute(Ys("AveragePool",e.inputs[0],!1,t))},Qs={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},Zs=e=>{let t=e.format;return{format:t,...Qs,cacheKey:t}},eu=(e,t)=>{un(e.inputs),e.compute(Ys("GlobalAveragePool",e.inputs[0],!0,t))},tu=(e,t,r,o)=>{let[n,s]=js(t,o,r),u=`
      value = max(x_val, value);
    `,l="",a=H("x",t.dataType,t.dims);return{name:e,shaderCache:{hint:o.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(z.size(s)/64)}}),getShaderSource:p=>qs(p,a,t.dims,s,n,u,l,"-1e5")}},ru=(e,t)=>{un(e.inputs),e.compute(tu("MaxPool",e.inputs[0],!1,t))},nu=e=>{let t=e.storage_order,r=e.dilations,o=Ks(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(o.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return ie({storageOrder:t,dilations:r,...o})},au=e=>{let t=e.format;return{format:t,...Qs,cacheKey:t}},ou=(e,t)=>{un(e.inputs),e.compute(tu("GlobalMaxPool",e.inputs[0],!0,t))}});var Zd,ec,su,uu=L(()=>{"use strict";wt();De();ve();Zd=(e,t,r)=>{let o=e===t,n=e<t&&r<0,s=e>t&&r>0;if(o||n||s)throw new Error("Range these inputs' contents are invalid.")},ec=(e,t,r,o)=>{let n=Math.abs(Math.ceil((t-e)/r)),s=[n],u=n,l=Q("output",o,s),a=l.type.storage,p=h=>`
        ${h.declareVariables(l)}
        ${h.mainStart()}
        ${h.guardAgainstOutOfBoundsWorkgroupSizes(u)}
        output[global_idx] = ${a}(${e}) + ${a}(global_idx) * ${a}(${r});
      }`;return{name:"Range",shaderCache:{hint:[e,t,r].map(h=>h.toString()).join("_")},getShaderSource:p,getRunData:()=>({outputs:[{dims:s,dataType:o}],dispatchGroup:{x:Math.ceil(u/64)}})}},su=e=>{let t=0,r=0,o=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],o=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],o=e.inputs[2].getFloat32Array()[0]),Ie.webgpu.validateInputContent&&Zd(t,r,o),e.compute(ec(t,r,o,e.inputs[0].dataType),{inputs:[]})}});var tc,rc,nc,ac,oc,ic,sc,uc,lc,dc,cc,pc,fc,mc,hc,lu,du,cu=L(()=>{"use strict";he();Pe();ve();tc=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},rc=(e,t,r)=>{t.every(n=>n>=0&&n<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let o=new Array(r).fill(1);return t.forEach((n,s)=>o[n]=e[s]),o},nc=(e,t,r,o,n,s)=>{let[u,l,a]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],p=e[0].dims.length;if(u>0&&e.length>u&&e[u].dims.length>0)e[u].getFloat32Array().forEach(h=>s.push(h));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(l>0&&e.length>l&&e[l].dims.length>0){if(e[l].getFloat32Array().forEach(h=>o.push(h)),o.length!==0&&o.length!==p&&r>=18&&o.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");tc(o,t),t.axes.length>0&&rc(o,t.axes,p).forEach((h,b)=>o[b]=h)}if(a>0&&e.length>a&&(e[a].getBigInt64Array().forEach(h=>n.push(Number(h))),n.length!==p||r>=18&&n.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(o.length!==t.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(n.length!==t.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof o<"u"&&typeof n<"u"&&o.length>0&&n.length>p)throw new Error("Resize requires only of scales or sizes to be specified")},ac=e=>"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(e){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`
`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",oc=(e,t)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",ic=(e,t,r)=>{let o=new Array(r).fill(0).concat(new Array(r).fill(1)),n=e.length===0?o:e.slice();return t.length>0?(t.forEach((s,u)=>{o[s]=n[u],o[u+r]=n[t.length+u]}),o):n},sc=(e,t,r,o)=>{let n=[];if(r.length>0)if(o.length>0){if(e.forEach(s=>n.push(s)),Math.max(...o)>e.length)throw new Error("axes is out of bound");o.forEach((s,u)=>n[s]=r[u])}else r.forEach(s=>n.push(s));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");n=e.map((s,u)=>Math.round(s*t[u]))}return n},uc=(e,t,r,o)=>{let n=(()=>{switch(o.keepAspectRatioPolicy){case"not_larger":return o.axes.length>0?Math.min(...o.axes.map(u=>r[u]),Number.MAX_VALUE):Math.min(...r,Number.MAX_VALUE);case"not_smaller":return o.axes.length>0?Math.max(...o.axes.map(u=>r[u]),Number.MIN_VALUE):Math.max(...r,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${o.keepAspectRatioPolicy} is not supported`)}})();r.fill(1,0,r.length);let s=e.slice();return o.axes.length>0?(o.axes.forEach(u=>r[u]=n),o.axes.forEach(u=>s[u]=Math.round(e[u]*r[u]))):(r.fill(n,0,r.length),s.forEach((u,l)=>s[l]=Math.round(u*r[l]))),s},lc=(e,t,r,o,n)=>`
    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> array<f32, ${r.length}> {
      const inputShape = array<u32, ${t.length}>(${t.map(s=>`${s}u`).join(",")});
      const outputShape = array<u32, ${r.length}>(${r.map(s=>`${s}u`).join(",")});
      const scales = array<f32, ${o.length}>(${o.map(s=>`${s}f`).join(",")});
      const roi = array<f32, ${n.length}>(${n.map(s=>`${s}f`).join(",")});
      var originalIndices: array<f32, ${r.length}>;
      for (var i:u32 = 0; i < ${r.length}; i++) {
        var outputIndex = ${r.length===1?"outputIndices":"outputIndices[i]"};
        if (scales[i] == 1.0) {
          originalIndices[i] = f32(outputIndex);
        } else {
          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],
                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${t.length}]);
        }
      }
      return originalIndices;
    }`,dc=(e,t,r,o,n,s,u)=>`
    fn calculateInputIndicesFromOutputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {
        const inputShape = array<u32, ${r.length}>(${r.map(l=>`${l}u`).join(",")});
        const outputShape = array<u32, ${o.length}>(${o.map(l=>`${l}u`).join(",")});
        const scales = array<f32, ${n.length}>(${n.map(l=>`${l}f`).join(",")});
        const roi = array<f32, ${s.length}>(${s.map(l=>`${l}f`).join(",")});
        var inputIndices: ${e.type.indices};
        for (var i:u32 = 0; i < ${o.length}; i++) {
          var outputIndex = ${o.length===1?"outputIndices":"outputIndices[i]"};
          var inputIndex: u32;
          if (scales[i] == 1.0) {
            inputIndex = outputIndex;
          } else {
            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],
                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${r.length}]);
            if (!${u} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {
              if (original_idx < 0) {
                inputIndex = 0;
              } else if (original_idx > (f32(inputShape[i]) - 1)) {
                inputIndex = inputShape[i] - 1;
              } else {
                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));
              }
            } else {
              inputIndex = u32(original_idx);
            }
          }
          ${e.indicesSet("inputIndices","i","inputIndex")}
        }
        return inputIndices;
    }`,cc=(e,t)=>`
    fn checkInputIndices(inputIndices: ${e.type.indices}) -> bool {
      const inputShape = array<u32, ${t.length}>(${t.map(r=>`${r}u`).join(",")});
      for (var i:u32 = 0; i < ${t.length}; i++) {
        var inputIndex = ${t.length===1?"inputIndices":"inputIndices[i]"};
        if (inputIndex < 0 || inputIndex >= inputShape[i]) {
          return false;
        }
      }
      return true;
    }`,pc=(e,t,r,o,n,s,u)=>{let[l,a,p,h]=r.length===2?[-1,0,1,-1]:n[1]===1?[0,2,3,1]:[0,1,2,3];return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {
      var inputIndices: ${e.type.indices};
      inputIndices[${a}] = max(0, min(row, ${r[a]} - 1));
      inputIndices[${p}] = max(0, min(col, ${r[p]} - 1));
      if (${r.length} > 2) {
        inputIndices[${h}] = channel;
        inputIndices[${l}] = batch;
      };
      return input[${e.indicesToOffset("inputIndices")}];
    }

    fn bilinearInterpolation(outputIndices: ${t.type.indices}) -> f32 {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);
      var row:f32 = originalIndices[${a}];
      var col:f32 = originalIndices[${p}];
      if (${s} && (row < 0 || row > (${r[a]} - 1) || col < 0 || col > ${r[p]} - 1)) {
        return ${u};
      }
      row = max(0, min(row, ${r[a]} - 1));
      col = max(0, min(col, ${r[p]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = 0;
      var batch: u32 = 0;
      if (${r.length>2}) {
        channel = u32(originalIndices[${h}]);
        batch = u32(originalIndices[${l}]);
      }
      var x11: f32 = getInputValue(batch, channel, row1, col1);
      var x12: f32 = getInputValue(batch, channel, row1, col2);
      var x21: f32 = getInputValue(batch, channel, row2, col1);
      var x22: f32 = getInputValue(batch, channel, row2, col2);
      var dx1: f32 = row - f32(row1);
      var dx2: f32 = f32(row2 ) - row;
      var dy1 = col - f32(col1);
      var dy2 = f32(col2) - col;
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},fc=(e,t,r,o,n,s,u,l,a,p)=>{let[h,b]=r.length===2?[0,1]:n[1]===1?[2,3]:[1,2],g=v=>{let $=v===h?"row":"col";return`
      fn ${$}CubicInterpolation(inputIndices: ${e.type.indices}, outputIndices: ${t.type.indices}) -> f32 {
        var outputIndex = ${o.length===1?"outputIndices":`outputIndices[${v}]`};
        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${n[v]},
        f32(${o[v]}), f32(${r[v]}), ${s[v]}, ${s[v]} + ${r.length});
        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${l} && (originalIdx < 0 || originalIdx > (${r[v]} - 1))) {
          return ${a};
        }
        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${$}: f32 = originalIdx + f32(i);
          if (${$} < 0 || ${$} >= ${r[v]}) {
            if (${p}) {
              coefs[i + 1] = 0.0;
              continue;
            } else if (${l}) {
              return ${a};
            } else {
              ${$} = max(0, min(${$}, ${r[v]} - 1));
            }
          }
          var inputIndicesCopy: ${e.type.indices} = inputIndices;
          inputIndicesCopy[${v}] = u32(${$});
          data[i + 1] = ${v===h?`input[${e.indicesToOffset("inputIndicesCopy")}];`:`
                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);`}
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${g(h)};
    ${g(b)};
  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {
    var absS = abs(s);
    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: f32 = 1.0 - absS;
    var twoMinusAbsS: f32 = 2.0 - absS;
    var onePlusAbsS: f32 = 1.0 + absS;
    coeffs[0] = ((${u} * onePlusAbsS - 5 * ${u}) * onePlusAbsS + 8 * ${u}) * onePlusAbsS - 4 * ${u};
    coeffs[1] = ((${u} + 2) * absS - (${u} + 3)) * absS * absS + 1;
    coeffs[2] = ((${u} + 2) * oneMinusAbsS - (${u} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${u} * twoMinusAbsS - 5 * ${u}) * twoMinusAbsS + 8 * ${u}) * twoMinusAbsS - 4 * ${u};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {
    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(outputIndices: ${t.type.indices}) -> f32 {
    var inputIndices: ${e.type.indices} = outputIndices;
    return colCubicInterpolation(inputIndices, outputIndices);
  }
    `},mc=(e,t,r,o,n,s)=>{let u=e.dims,l=ic(s,t.axes,u.length),a=sc(u,o,n,t.axes),p=o.slice();o.length===0&&(p=u.map((S,I)=>S===0?1:a[I]/S),t.keepAspectRatioPolicy!=="stretch"&&(a=uc(u,a,p,t)));let h=Q("output",e.dataType,a),b=H("input",e.dataType,u),g=z.size(a),v=u.length===a.length&&u.every((S,I)=>S===a[I]),$=t.coordinateTransformMode==="tf_crop_and_resize",w=S=>`
      ${ac(t.coordinateTransformMode)};
      ${(()=>{switch(t.mode){case"nearest":return`
              ${cc(b,u)};
              ${oc(t.nearestMode,r)};
              ${dc(b,h,u,a,p,l,$)};
              `;case"linear":return`
              ${lc(h,u,a,p,l)};
              ${pc(b,h,u,a,p,$,t.extrapolationValue)};
              `;case"cubic":return`
            ${fc(b,h,u,a,p,l,t.cubicCoeffA,$,t.extrapolationValue,t.excludeOutside)};
            `;default:throw Error("Invalid resize mode")}})()};
      ${S.declareVariables(b,h)}
      ${S.mainStart()}
        ${S.guardAgainstOutOfBoundsWorkgroupSizes(g)}
        if (${v}) {
          output[global_idx] = input[global_idx];
        } else {
          let outputIndices = ${h.offsetToIndices("global_idx")};
          var inputIndices: ${b.type.indices};
          ${(()=>{switch(t.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);
                  if (checkInputIndices(inputIndices)) {
                    output[global_idx] = input[${b.indicesToOffset("inputIndices")}];
                  } else {
                    output[global_idx] = ${t.extrapolationValue};
                  }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};
        }
      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${p.length>0?p:""}|${n.length>0?n:""}`},getShaderSource:w,getRunData:()=>({outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(g/64)}})}},hc=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},lu=(e,t)=>{let r=[],o=[],n=[],s=hc(e);nc(e.inputs,t,s,r,o,n),e.compute(mc(e.inputs[0],t,s,r,o,n),{inputs:[0]})},du=e=>{let t=e.antialias,r=e.axes,o=e.coordinateTransformMode,n=e.cubicCoeffA,s=e.excludeOutside!==0,u=e.extrapolationValue,l=e.keepAspectRatioPolicy,a=e.mode,p=e.nearestMode===""?"simple":e.nearestMode;return ie({antialias:t,axes:r,coordinateTransformMode:o,cubicCoeffA:n,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:l,mode:a,nearestMode:p})}});var gc,yc,pu,fu,mu=L(()=>{"use strict";De();he();Pe();ve();gc=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],r=e[1],o=e[2];if(t.dataType!==r.dataType||t.dataType!==o.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let n=t.dims[t.dims.length-1],s=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==n)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==s)throw new Error("Skip must have the same sequence length as input");if(o.dims.length!==1)throw new Error("Gamma must be 1D");if(o.dims[o.dims.length-1]!==n)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let u=e[3];if(u.dims.length!==1)throw new Error("Beta must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let u=e[4];if(u.dims.length!==1)throw new Error("Bias must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Bias must have the same hidden size as input")}},yc=(e,t,r,o)=>{let n=e[0].dims,s=z.size(n),u=n,l=s,a=n.slice(-1)[0],p=o?n.slice(0,-1).concat(1):[],h=e.length>3,b=e.length>4,g=o&&r>1,v=o&&r>2,$=r>3,w=ft(a),S=[H("x",e[0].dataType,e[0].dims,w),H("skip",e[1].dataType,e[1].dims,w),H("gamma",e[2].dataType,e[2].dims,w)];h&&S.push(H("beta",e[3].dataType,e[3].dims,w)),b&&S.push(H("bias",e[4].dataType,e[4].dims,w)),S.push(Q("output",e[0].dataType,u,w)),g&&S.push(Q("meanOutput",1,p)),v&&S.push(Q("invStdOutput",1,p)),$&&S.push(Q("inputSkipBiasSum",e[0].dataType,u,w));let I=ke(e[0].dataType),T=P=>`
      const hiddenSize: f32 = ${a};
      const hiddenSizeVectorized: u32 = ${a/w};
      const epsilon: f32 = ${t.epsilon};

      ${P.declareVariables(...S)}

      ${P.mainStart()}
        ${P.guardAgainstOutOfBoundsWorkgroupSizes(l/a)}
        let offset = global_idx * hiddenSizeVectorized;
        var sum = ${et("f32",w)};
        var squareSum = ${et("f32",w)};
        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {
          let skipValue = skip[offset + i];
          let biasValue = ${b?"bias[i]":"0.0"};
          let inputValue = x[offset + i];
          let value = inputValue + skipValue + biasValue;
          ${$?"inputSkipBiasSum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32Value = ${Tt(I,w,"value")};
          sum += f32Value;
          squareSum += f32Value * f32Value;
        }
        let mean = ${$t("sum",w)} / hiddenSize;
        let variance = sqrt(${$t("squareSum",w)} / hiddenSize - mean * mean + epsilon);
        ${g?"meanOutput[global_idx] = mean;":""}
        ${v?"invStdOutput[global_idx] = 1.0 / variance;":""}
        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {
          output[offset + i] = (output[offset + i] - ${I}(mean)) / ${I}(variance) * gamma[i]
           + ${h?"beta[i]":"0.0"};
        }
      }`,B=[{dims:u,dataType:e[0].dataType}];return r>1&&B.push({dims:p,dataType:1}),r>2&&B.push({dims:p,dataType:1}),r>3&&B.push({dims:n,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:t.cacheKey},getShaderSource:T,getRunData:()=>({outputs:B,dispatchGroup:{x:Math.ceil(l/a/64)}})}},pu=(e,t)=>{gc(e.inputs);let o=[0];e.outputCount>1&&o.push(-3),e.outputCount>2&&o.push(-3),e.outputCount>3&&o.push(3),e.compute(yc(e.inputs,t,e.outputCount,!1),{outputs:o})},fu=e=>{let t=e.epsilon;return ie({epsilon:t})}});var bc,ln,wc,hu,vc,$c,gu,yu,bu=L(()=>{"use strict";De();he();Pe();ve();bc=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,o)=>{if(e[o+1].dataType!==6&&e[o+1].dataType!==7)throw new Error(`Input ${o} must be an array of int32 or int64`)})},ln=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(o=>r.push(Number(o)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(o=>r.push(Number(o)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},wc=(e,t)=>{if(e.length>1){let r=ln(e,1),o=ln(e,2),n=ln(e,3);return n.length===0&&(n=[...Array(e[0].dims.length).keys()]),ie({starts:r,ends:o,axes:n})}else return t},hu=(e,t,r,o,n)=>{let s=e;return e<0&&(s+=r[o[t]]),n[t]<0?Math.max(0,Math.min(s,r[o[t]]-1)):Math.max(0,Math.min(s,r[o[t]]))},vc=(e,t,r,o)=>`fn calculateInputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {
          var inputIndices: ${e.type.indices};
          var carry = 0u;
          for (var i = ${r.length}; i >= 0; i--) {
            var outputIndex = ${o.length===1?"outputIndices":"outputIndices[i]"};
            var inputIndex = outputIndex * steps[i] + starts[i] + carry;
            carry = inputIndex / inputShape[i];
            inputIndex = inputIndex % inputShape[i];
            if (signs[i] < 0) {
              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];
            }
            ${r.length===1?"inputIndices":"inputIndices[i]"} = inputIndex;
          }
          return inputIndices;
      }`,$c=(e,t)=>{let r=e[0].dims,o=z.size(r),n=t.axes.length>0?z.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],s=ln(e,4);s.forEach(w=>w!==0||(()=>{throw new Error("step cannot be 0")})),s.length===0&&(s=Array(n.length).fill(1));let u=t.starts.map((w,S)=>hu(w,S,r,n,s)),l=t.ends.map((w,S)=>hu(w,S,r,n,s));if(n.length!==r.length)for(let w=0;w<r.length;++w)n.includes(w)||(u.splice(w,0,0),l.splice(w,0,r[w]),s.splice(w,0,1));let a=s.map(w=>Math.sign(w));s.forEach((w,S,I)=>{if(w<0){let T=(l[S]-u[S])/w,B=u[S],P=B+T*s[S];u[S]=P,l[S]=B,I[S]=-w}});let p=r.slice(0);n.forEach((w,S)=>{p[w]=Math.ceil((l[w]-u[w])/s[w])});let h={dims:p,dataType:e[0].dataType},b=Q("output",e[0].dataType,p),g=H("input",e[0].dataType,r),v=z.size(p),$=w=>`
      ${w.declareVariables(g,b)}
        const signs = array<i32, ${a.length}>(${a.map(S=>`${S}i`).join(",")});
        const starts = array<u32, ${u.length}>(${u.map(S=>`${S}u`).join(",")});
        const ends = array<u32, ${l.length}>(${l.map(S=>`${S}u`).join(",")});
        const steps = array<u32, ${s.length}>(${s.map(S=>`${S}u`).join(",")});
        const inputShape = array<u32, ${r.length}>(${r.map(S=>`${S}u`).join(",")});

        ${vc(g,b,r,p)}
        ${w.mainStart()}
          ${w.guardAgainstOutOfBoundsWorkgroupSizes(v)}
          let outputIndices = ${b.offsetToIndices("global_idx")};
          let inputIndices = calculateInputIndices(outputIndices);
          ${b.setByOffset("global_idx",g.getByIndices("inputIndices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${t.cacheKey}|${e[4]?.dims??""}`},getShaderSource:$,getRunData:()=>({outputs:[h],dispatchGroup:{x:Math.ceil(o/64)}})}},gu=(e,t)=>{bc(e.inputs,t);let r=wc(e.inputs,t);e.compute($c(e.inputs,r),{inputs:[0]})},yu=e=>{let t=e.starts,r=e.ends,o=e.axes;return ie({starts:t,ends:r,axes:o})}});var xc,Sc,wu,vu,$u=L(()=>{"use strict";he();Pe();ve();xc=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},Sc=(e,t)=>{let r=ke(e.dataType),o=e.dims,n=z.size(o),s=64,u=t.axis;if(u<0&&(u=o.length+u),u<o.length-1)throw new Error("softmax only supports last axis for now.");let l=o[u],a=n/l,p=ft(l),h=l/p,b=p===1?r:`vec${p}<${r}>`,g=(w,S)=>S===4?`max(max(${w}.x, ${w}.y), max(${w}.z, ${w}.w))`:S===2?`max(${w}.x, ${w}.y)`:S===3?`max(max(${w}.x, ${w}.y), ${w}.z)`:w,v=r==="f32"?`var threadMax = ${b}(-3.402823e+38f);`:`var threadMax = ${b}(-65504.0h);`;return{name:"Softmax",getRunData:()=>({outputs:[{dims:o,dataType:e.dataType}],dispatchGroup:{x:a}}),getShaderSource:w=>`
      var<workgroup> rowMaxShared : ${b};
      var<workgroup> rowSumShared : ${b};
      var<workgroup> threadShared : array<${b}, ${s}>;

      @group(0) @binding(0) var<storage, read> x : array<${b}>;
      @group(0) @binding(1) var<storage, read_write> result : array<${b}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${b} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${b}) {
        let index = row * row_stride + col;
        result[index] = value;
      }

      @compute @workgroup_size(${s}, 1, 1)
      fn main(@builtin(local_invocation_id) local_id : vec3<u32>, @builtin(global_invocation_id) global_id : vec3u) {
        let gindex = i32(global_id.x);
        let lindex = i32(local_id.x);
        const wg = ${s};
        let row = gindex / wg;
        let cols = ${h};
        let row_stride : i32 = ${h};

        // find the rows max
        ${v}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${b}(${g("threadShared[0]",p)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${b}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${b}(${$t("threadShared[0]",p)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`}},wu=(e,t)=>{xc(e.inputs),e.compute(Sc(e.inputs[0],t))},vu=e=>ie({axis:e.axis})});var Cc,Ic,Ac,_c,Ec,xu,Su,Cu=L(()=>{"use strict";he();Pe();ve();Cc=e=>{if(!e||e.length<1)throw new Error("too few inputs")},Ic=(e,t)=>{let r=[],o=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(n=>r.push(Number(n))),o=r.length),ie({numOutputs:o,axis:t.axis,splitSizes:r})},Ac=e=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {
    if (index < sizeInConcatAxis[i]) {
        return i;
    }
    }
    return ${e}u;
}`,_c=e=>{let t=e.length,r=[];for(let o=0;o<t;++o){let n=e[o].setByIndices("indices","input[global_idx]");t===1?r.push(n):o===0?r.push(`if (outputNumber == ${o}u) { ${n} }`):o===t-1?r.push(`else { ${n} }`):r.push(`else if (outputNumber == ${o}) { ${n} }`)}return`
      fn writeBufferData(outputNumber: u32, indices: ${e[0].type.indices}, global_idx: u32) {
        ${r.join(`
`)}
      }`},Ec=(e,t)=>{let r=e[0].dims,o=z.size(r),n=e[0].dataType,s=r.length,u=t.axis,l=u<0?r.length+u:u,a=new Array(t.numOutputs),p=H("input",n,r),h=new Array(t.numOutputs),b=[],g=[],v=0;for(let S=0;S<t.numOutputs;S++){v+=t.splitSizes[S],h[S]=v;let I=r.slice();I[t.axis]=t.splitSizes[S],g.push(I),a[S]=Q(`output${S}`,n,g[S]),b.push({dims:g[S],dataType:e[0].dataType})}let $=s<2?"indices":`indices[${l}]`,w=S=>`
  ${S.declareVariables(p,...a)}
  const sizeInConcatAxis = array<u32, ${h.length}>(${h.map(I=>`${I}u`).join(",")});
  ${Ac(h.length)}
  ${_c(a)}

  ${S.mainStart()}
    ${S.guardAgainstOutOfBoundsWorkgroupSizes(o)}

    var indices = ${p.offsetToIndices("global_idx")};
    let outputNumber = calculateOutputIndex(${$});
    if (outputNumber != 0) {
        ${$} -= sizeInConcatAxis[outputNumber - 1u];
    }
    writeBufferData(outputNumber, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:t.cacheKey},getShaderSource:w,getRunData:()=>({outputs:b,dispatchGroup:{x:Math.ceil(o/64)}})}},xu=(e,t)=>{Cc(e.inputs);let r=e.inputs.length===1?t:Ic(e.inputs,t);e.compute(Ec(e.inputs,r),{inputs:[0]})},Su=e=>{let t=e.axis,r=e.splitSizes,o=e.numOutputs<0?r.length:e.numOutputs;if(o!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ie({axis:t,numOutputs:o,splitSizes:r})}});var Iu,Oc,Tc,Rc,Au,_u=L(()=>{"use strict";De();he();ve();Iu=e=>Array.from(e.getBigInt64Array(),Number),Oc=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(Iu(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Tc=(e,t)=>{let r=[];for(let o=0;o<e.length;++o)r.push(e[o]*t[o]);return r},Rc=e=>{let t=e[0].dims,r=Iu(e[1]),o=Tc(t,r),n=z.size(o),s=e[0].dataType,u=H("input",s,t),l=Q("output",s,o),a=p=>`
      const inputShape = ${u.indices(...t)};
      ${p.declareVariables(u,l)}
      ${p.mainStart()}
      ${p.guardAgainstOutOfBoundsWorkgroupSizes(n)}
      let outputIndices = ${l.offsetToIndices("global_idx")};
      var inputIndices: ${u.type.indices};
      for (var i = 0; i < ${t.length}; i++) {
        let inputDimValue = ${l.indicesGet("outputIndices","i")}  % ${u.indicesGet("inputShape","i")};

        ${u.indicesSet("inputIndices","i","inputDimValue")}
      }
      ${l.setByOffset("global_idx",u.getByIndices("inputIndices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${r}`},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}}),getShaderSource:a}},Au=e=>{Oc(e.inputs),e.compute(Rc(e.inputs),{inputs:[0]})}});var Pc,kc,Eu,Ou=L(()=>{"use strict";De();he();ve();Pc=(e,t,r,o,n)=>{let s=z.size(r),u=Math.ceil(s/4),l=Q("outputData",n,r,4),a=H("aData",t[1].dataType,t[1].dims,4),p=H("bData",t[2].dataType,t[2].dims,4),h=H("cData",t[0].dataType,t[0].dims,4),b,g=(v,$,w)=>`select(${$}, ${v}, ${w})`;if(!o)b=l.setByOffset("global_idx",g(a.getByOffset("global_idx"),p.getByOffset("global_idx"),h.getByOffset("global_idx")));else{let v=($,w,S="")=>{let I=`aData[indexA${w}][componentA${w}]`,T=`bData[indexB${w}][componentB${w}]`,B=`bool(cData[indexC${w}] & ${4278190080>>>(3-w)*8}u)`;return`
            let outputIndices${w} = ${l.offsetToIndices(`global_idx * 4u + ${w}u`)};
            let offsetA${w} = ${a.broadcastedIndicesToOffset(`outputIndices${w}`,l)};
            let offsetB${w} = ${p.broadcastedIndicesToOffset(`outputIndices${w}`,l)};
            let offsetC${w} = ${h.broadcastedIndicesToOffset(`outputIndices${w}`,l)};
            let indexA${w} = offsetA${w} / 4u;
            let indexB${w} = offsetB${w} / 4u;
            let indexC${w} = offsetC${w} / 4u;
            let componentA${w} = offsetA${w} % 4u;
            let componentB${w} = offsetB${w} % 4u;
            ${$}[${w}] = ${S}(${g(I,T,B)});
          `};n===9?b=`
            var data = vec4<u32>(0);
            ${v("data",0,"u32")}
            ${v("data",1,"u32")}
            ${v("data",2,"u32")}
            ${v("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:b=`
            ${v("outputData[global_idx]",0)}
            ${v("outputData[global_idx]",1)}
            ${v("outputData[global_idx]",2)}
            ${v("outputData[global_idx]",3)}
          `}return`
        ${e.declareVariables(h,a,p,l)}
        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}
        ${b}
      }`},kc=e=>{let t=e[1].dims,r=e[2].dims,o=e[0].dims,n=e[1].dataType,s=!(z.areEqual(t,r)&&z.areEqual(r,o)),u=t,l=z.size(t);if(s){let a=it.calcShape(it.calcShape(t,r,!1),o,!1);if(!a)throw new Error("Can't perform where op on the given tensors");u=a,l=z.size(u)}return{name:"Where",getShaderSource:a=>Pc(a,e,u,s,n),getRunData:()=>({outputs:[{dims:u,dataType:n}],dispatchGroup:{x:Math.ceil(l/64/4)}})}},Eu=e=>{e.compute(kc(e.inputs))}});var Tu,Ru=L(()=>{"use strict";si();li();Vi();Zi();rs();Qn();bs();xs();Is();Es();Rs();Bs();zs();Gs();Vs();Fs();iu();uu();Fn();cu();mu();bu();$u();Cu();_u();on();Kn();Ou();Tu=new Map([["Abs",[di]],["Acos",[ci]],["Acosh",[pi]],["Add",[Li]],["ArgMax",[ii,jn]],["ArgMin",[oi,jn]],["Asin",[fi]],["Asinh",[mi]],["Atan",[hi]],["Atanh",[gi]],["AveragePool",[Js,Xs]],["BiasAdd",[ui]],["BiasSplitGelu",[Ui]],["Cast",[bi,yi]],["Ceil",[vi]],["ClipV10",[qn]],["Clip",[wi]],["Concat",[es,ts]],["Conv",[ea,Zn]],["ConvTranspose",[ys,gs]],["Cos",[$i]],["Cosh",[xi]],["Div",[Hi]],["Einsum",[vs,$s]],["Elu",[Si,Xr]],["Equal",[Fi]],["Erf",[Ci]],["Exp",[Ii]],["Expand",[Cs]],["Floor",[Ai]],["FusedConv",[ea,Zn]],["Gather",[_s,As]],["GatherElements",[Ts,Os]],["Gelu",[_i]],["Gemm",[Ps,ks]],["GlobalAveragePool",[eu,Zs]],["GlobalMaxPool",[ou,au]],["Greater",[Yi]],["GreaterOrEqual",[Ji]],["InstanceNormalization",[Ds,Ms]],["LayerNormalization",[Ns,Ws]],["LeakyRelu",[Ei,Xr]],["Less",[Xi]],["LessOrEqual",[Qi]],["Log",[Gi]],["MatMul",[Us]],["MaxPool",[ru,nu]],["Mul",[ji]],["Neg",[Ti]],["Not",[Oi]],["Pad",[Ls,Hs]],["Pow",[qi]],["Range",[su]],["Reciprocal",[Ri]],["ReduceMin",[Zo,tt]],["ReduceMean",[Qo,tt]],["ReduceMax",[Jo,tt]],["ReduceSum",[ti,tt]],["ReduceProd",[ei,tt]],["ReduceL1",[Ko,tt]],["ReduceL2",[Yo,tt]],["ReduceLogSum",[qo,tt]],["ReduceLogSumExp",[Xo,tt]],["ReduceSumSquare",[ri,tt]],["Relu",[Pi]],["Resize",[lu,du]],["Sigmoid",[ki]],["Sin",[Bi]],["Sinh",[Mi]],["Slice",[gu,yu]],["SkipLayerNormalization",[pu,fu]],["Split",[xu,Su]],["Sqrt",[Di]],["Softmax",[wu,vu]],["Sub",[Ki]],["Tan",[zi]],["Tanh",[Wi]],["ThresholdedRelu",[Ni,Xr]],["Tile",[Au]],["Transpose",[us,ls]],["Where",[Eu]]])});var dn,Pu=L(()=>{"use strict";De();vt();ve();dn=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,o,n,s,u,l){let a=this.backend.device,p=this.backend.getComputePassEncoder();p.setPipeline(t.computePipeline);let h=[];for(let g of n)h.push({binding:h.length,resource:{buffer:g.buffer}});for(let g of s)h.push({binding:h.length,resource:{buffer:g.buffer}});l&&h.push({binding:h.length,resource:l});let b=a.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:h,label:t.programInfo.name});if(p.setBindGroup(0,b),p.dispatchWorkgroups(...u),this.backend.pendingDispatchNumber++,this.backend.isQueryEnabled()){typeof this.backend.queryData>"u"&&(this.backend.queryData=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let g=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.querySet,0,2,this.backend.queryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.queryData.buffer,0,g.buffer,0,this.backend.querySetCount*8),this.backend.flush();let v=this.backend.currentKernelId,$=this.backend.kernels.get(v),w=`[${$[0]}] ${$[1]}`;g.buffer.mapAsync(GPUMapMode.READ).then(()=>{let S=new BigUint64Array(g.buffer.getMappedRange()),I=S[0],T=S[1];g.buffer.unmap(),typeof this.backend.queryTimeBase>"u"&&(this.backend.queryTimeBase=I);let B=Number(I-this.backend.queryTimeBase),P=Number(T-this.backend.queryTimeBase);if(!Number.isSafeInteger(B)||!Number.isSafeInteger(P))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(g.id);let M="";r.forEach((W,V)=>{M+=`input[${V}]: [${W.dims}] | ${lr(W.dataType)}, `});let R="";o.forEach((W,V)=>{R+=`output[${V}]: [${W.dims}] | ${lr(W.dataType)}, `}),console.log(`[profiling] kernel "${v}|${w}" ${M}${R}execution time: ${P-B} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(t,r){let o=this.backend.device,n=[];o.features.has("shader-f16")&&n.push("enable f16;");let s=Fo(r),u=t.getShaderSource(s),l=`${n.join(`
`)}
${s.additionalImplementations}
${u}`,a=o.createShaderModule({code:l,label:t.name});Oe("verbose",()=>`[WebGPU] shader code: ${l}`);let p=o.createComputePipeline({compute:{module:a,entryPoint:"main"},layout:"auto",label:t.name});return{programInfo:t,computePipeline:p}}normalizeDispatchGroupSize(t){let r=typeof t=="number"?t:t.x,o=typeof t=="number"?1:t.y||1,n=typeof t=="number"?1:t.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=s&&o<=s&&n<=s)return[r,o,n];let u=r*o*n,l=Math.ceil(Math.sqrt(u));if(l>s){if(l=Math.ceil(Math.cbrt(u)),l>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[l,l,l]}else return[l,l,1]}}});var Bc,Mc,cn,ku=L(()=>{"use strict";vt();Wo();Vo();Ru();Pu();Bc=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let o=0;o<e.length;++o){let n=e[o].dataType;switch(t[o]){case"none":{r.push("");break}case"type":{r.push(`${n}`);break}case"rank":{let s=e[o].dims.length;r.push(`${n};${s}`);break}case"dims":{let s=e[o].dims.join(",");r.push(`${n};${s}`);break}default:throw new Error(`unsupported input dependency: ${t[o]}`)}}return r.join("|")},Mc=(e,t)=>{let r=e.name;return e.shaderCache?.hint&&(r+="["+e.shaderCache.hint+"]"),r+=`:${Bc(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,r},cn=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.querySetCount=2;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let r=await navigator.gpu.requestAdapter();if(!r)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=t;let o=[],n={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:o};r.features.has("timestamp-query")&&o.push("timestamp-query"),r.features.has("shader-f16")&&o.push("shader-f16"),this.device=await r.requestDevice(n),this.gpuDataManager=Uo(this),this.programManager=new dn(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Do(t.logLevel,!!t.debug),this.device.onuncapturederror=s=>{s.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${s.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t={};this.isQueryEnabled()&&(typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}isQueryEnabled(){return!!(this.device.features.has("timestamp-query")&&this.env.webgpu.profilingMode==="default")}run(t,r,o,n,s){let u=[];for(let I=0;I<r.length;++I){let T=this.gpuDataManager.get(r[I].data);if(!T)throw new Error(`no GPU data for input: ${r[I].data}`);u[I]=T}let l=Mc(t,r),a=this.programManager.getArtifact(l),{outputs:p,dispatchGroup:h,programUniforms:b}=t.getRunData(r),g=o.length===0?p.map((I,T)=>T):o;if(g.length!==p.length)throw new Error(`Output size ${g.length} must be equal to ${p.length}.`);let v=[],$=[];for(let I=0;I<p.length;++I){if(!Number.isInteger(g[I])||g[I]<-3||g[I]>=p.length)throw new Error(`Invalid output index: ${g[I]}`);if(g[I]===-3)continue;let T=g[I]===-1,B=g[I]===-2,P=T||B?s(p[I].dataType,p[I].dims):n(g[I],p[I].dataType,p[I].dims),M=this.gpuDataManager.get(P.data);if(!M)throw new Error(`no GPU data for output: ${P.data}`);if(T&&this.temporaryData.push(M),B){let R=this.kernelPersistentData.get(this.currentKernelId);R||(R=[],this.kernelPersistentData.set(this.currentKernelId,R)),R.push(M)}v.push(P),$.push(M)}let w;if(b){let I=0,T=0,B=[],P=1;b.forEach(W=>{let V=typeof W.data=="number"?[W.data]:W.data,Y;switch(V.length){case 1:Y=4;break;case 2:Y=8;break;case 3:Y=16;break;case 4:Y=16;break;case 5:Y=16;break;case 6:Y=16;break;default:throw new Error(`unsupported data length: ${V.length}`)}(T===5||T===6)&&(Y=16),Y>P&&(P=Y),I=Math.ceil(I/Y)*Y,T=V.length,B.push(I),I+=V.length*4}),I=Math.ceil(I/P)*P;let M=new ArrayBuffer(I);b.forEach((W,V)=>{let Y=B[V],le=typeof W.data=="number"?[W.data]:W.data;W.type==="int32"?new Int32Array(M,Y,le.length).set(le):W.type==="uint32"?new Uint32Array(M,Y,le.length).set(le):new Float32Array(M,Y,le.length).set(le)});let R=this.gpuDataManager.create(I,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(R.buffer,0,M,0,I),this.gpuDataManager.release(R.id),w={offset:0,size:I,buffer:R.buffer}}let S=this.programManager.normalizeDispatchGroupSize(h);return a||(a=this.programManager.build(t,S),this.programManager.setArtifact(l,a)),Oe("info",()=>`[ProgramManager] run "${t.name}" (key=${l}) with ${S[0]}x${S[1]}x${S[2]}`),this.programManager.run(a,r,v,u,$,S,w),v}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,o,n){let s=Tu.get(t);if(!s)throw new Error(`kernel not implemented: ${t}`);this.kernels.set(r,[t,n,s[0],[s[1],o]])}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let o of r)this.gpuDataManager.release(o.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,o){let n=this.kernels.get(t);if(!n)throw new Error(`kernel not created: ${t}`);let[s,u,l,a]=n;if(this.currentKernelId!==null)throw new Error(`kernel "[${s}] ${u}" is not allowed to be called recursively`);this.currentKernelId=t,a[0]&&(a[1]=a[0](a[1]),a[0]=void 0),Oe("info",()=>`[WebGPU] Start to run kernel "[${s}] ${u}"...`);let p=this.env.debug;this.temporaryData=[];try{return p&&this.device.pushErrorScope("validation"),l(r,a[1]),0}catch(h){return o.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${u}" failed. ${h}`)),1}finally{p&&o.push(this.device.popErrorScope().then(h=>h?`GPU validation error for kernel "[${s}] ${u}": ${h.message}`:null));for(let h of this.temporaryData)this.gpuDataManager.release(h.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,o,n){let s=this.sessionExternalDataMapping.get(t);s||(s=new Map,this.sessionExternalDataMapping.set(t,s));let u=s.get(r),l=this.gpuDataManager.registerExternalBuffer(o,n,u?.[1]);return s.set(r,[l,o]),l}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(o=>this.gpuDataManager.unregisterExternalBuffer(o[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,o){return async()=>{let n=await Nn(this,t,r);return zo(n.buffer,o)}}}});var Bu={};_t(Bu,{init:()=>Dc});var gr,oa,Dc,Mu=L(()=>{"use strict";De();ku();vt();he();gr=class e{constructor(t,r,o,n){this.module=t;this.dataType=r;this.data=o;this.dims=n}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=z.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=z.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=z.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(z.size(t)!==z.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},oa=class{constructor(t,r,o){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;let n=t.HEAPU32,s=o>>2;this.opKernelContext=n[s++];let u=n[s++];this.outputCount=n[s++],this.customDataOffset=n[s++],this.customDataSize=n[s++];let l=[];for(let a=0;a<u;a++){let p=n[s++],h=n[s++],b=n[s++],g=[];for(let v=0;v<b;v++)g.push(n[s++]);l.push(new gr(t,p,h,g))}this.inputs=l}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,r){let o=r?.inputs?.map(l=>typeof l=="number"?this.inputs[l]:l)??this.inputs,n=r?.outputs??[],s=(l,a,p)=>new gr(this.module,a,this.output(l,p),p),u=(l,a)=>{let p=dr(l);if(!p)throw new Error(`Unsupported data type: ${l}`);let h=p*z.size(a);return new gr(this.module,l,this.backend.gpuDataManager.create(h).id,a)};return this.backend.run(t,o,n,s,u)}output(t,r){let o=this.module.stackSave();try{let n=this.module.stackAlloc((1+r.length)*4),s=n>>2;this.module.HEAPU32[s++]=r.length;for(let u=0;u<r.length;u++)this.module.HEAPU32[s++]=r[u];return this.module._JsepOutput(this.opKernelContext,t,n)}catch(n){throw new Error(`Failed to generate kernel's output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(o)}}},Dc=async(e,t)=>{let r=e.jsepInit;if(r&&navigator.gpu){if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let o=new cn;await o.initialize(t),r(o,n=>o.alloc(n),n=>o.free(n),(n,s,u,l=!1)=>{if(l)Oe("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${n}, dst=${s}, size=${u}`),o.memcpy(n,s);else{Oe("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${n}, gpuDataId=${s}, size=${u}`);let a=e.HEAPU8.subarray(n,n+u);o.upload(s,a)}},async(n,s,u)=>{Oe("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${n}, dataOffset=${s}, size=${u}`),await o.download(n,()=>e.HEAPU8.subarray(s,s+u))},(n,s,u)=>o.createKernel(n,s,u,t.debug||t.webgpu.profilingMode==="default"?e.UTF8ToString(e._JsepGetNodeName(s)):`${s}`),n=>o.releaseKernel(n),(n,s,u,l)=>{Oe("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${u}, kernel=${n}, contextDataOffset=${s}`);let a=new oa(e,o,s);return o.computeKernel(n,a,l)})}}});var zu,zc,Wc,Wu,yr,Nu,ia,sa,Gu,Uu,Du,Vu,Lu,Hu,Fu=L(()=>{"use strict";Ro();ko();De();Ut();Vr();zu=!1,zc=e=>{let t=Re(),r=t.stackSave();try{let o=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,o,o+4)!==0&&Ae("Can't get session input/output count."),[t.HEAP32[o/4],t.HEAP32[o/4+1]]}finally{t.stackRestore(r)}},Wc=(e,t)=>{Re()._OrtInit(e,t)!==0&&Ae("Can't initialize onnxruntime.")},Wu=async e=>{Wc(e.wasm.numThreads,cr(e.logLevel));{let t=(Mu(),bt(Bu)).init;await t(Re(),e)}zu=!0},yr=new Map,Nu=()=>zu,ia=e=>{let t=Re(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},sa=(e,t)=>{let r=Re(),o=0,n=0,s=0,u=[],l=[],a=[];try{[n,u]=Po(t),o=r._OrtCreateSession(e[0],e[1],n),o===0&&Ae("Can't create a session.");let[p,h]=zc(o),b=[],g=[],v=[];for(let w=0;w<p;w++){let S=r._OrtGetInputName(o,w);S===0&&Ae("Can't get an input name."),l.push(S),b.push(r.UTF8ToString(S))}for(let w=0;w<h;w++){let S=r._OrtGetOutputName(o,w);S===0&&Ae("Can't get an output name."),a.push(S);let I=r.UTF8ToString(S);g.push(I);{let T=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[I]??"cpu";if(T!=="cpu"&&T!=="cpu-pinned"&&T!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${T}.`);v.push(T)}}let $=null;return v.some(w=>w==="gpu-buffer")&&(s=r._OrtCreateBinding(o),s===0&&Ae("Can't create IO binding."),$={handle:s,outputPreferredLocations:v,outputPreferredLocationsEncoded:v.map(w=>zn(w))}),yr.set(o,[o,l,a,$]),[o,b,g]}catch(p){throw l.forEach(h=>r._OrtFree(h)),a.forEach(h=>r._OrtFree(h)),s!==0&&r._OrtReleaseBinding(s),o!==0&&r._OrtReleaseSession(o),p}finally{r._free(e[0]),n!==0&&r._OrtReleaseSessionOptions(n),u.forEach(p=>r._free(p))}},Gu=(e,t)=>{let r=ia(e);return sa(r,t)},Uu=e=>{let t=Re(),r=yr.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[o,n,s,u]=r;u&&t._OrtReleaseBinding(u.handle),t.jsepUnregisterBuffers?.(e),n.forEach(l=>t._OrtFree(l)),s.forEach(l=>t._OrtFree(l)),t._OrtReleaseSession(o),yr.delete(e)},Du=(e,t,r,o,n)=>{if(!e){t.push(0);return}let s=Re(),u=e[0],l=e[1],a=e[3],p,h;if(u==="string"&&a==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(a==="gpu-buffer"){let v=e[2].gpuBuffer,$=dr(Dn(u));h=l.reduce((w,S)=>w*S,1)*$,p=s.jsepRegisterBuffer(o,n,v,h)}else{let v=e[2];if(Array.isArray(v)){h=4*v.length,p=s._malloc(h),r.push(p);let $=p/4;for(let w=0;w<v.length;w++){if(typeof v[w]!="string")throw new TypeError(`tensor data at index ${w} is not a string`);s.HEAPU32[$++]=Me(v[w],r)}}else h=v.byteLength,p=s._malloc(h),r.push(p),s.HEAPU8.set(new Uint8Array(v.buffer,v.byteOffset,h),p)}let b=s.stackSave(),g=s.stackAlloc(4*l.length);try{let v=g/4;l.forEach(w=>s.HEAP32[v++]=w);let $=s._OrtCreateTensor(Dn(u),p,h,g,l.length,zn(a));$===0&&Ae(`Can't create tensor for input/output. session=${o}, index=${n}.`),t.push($)}finally{s.stackRestore(b)}},Vu=async(e,t,r,o,n,s)=>{let u=Re(),l=yr.get(e);if(!l)throw new Error(`cannot run inference. invalid session id: ${e}`);let[a,p,h,b]=l,g=t.length,v=o.length,$=0,w=[],S=[],I=[],T=[],B=u.stackSave(),P=u.stackAlloc(g*4),M=u.stackAlloc(g*4),R=u.stackAlloc(v*4),W=u.stackAlloc(v*4);try{[$,w]=To(s);for(let oe=0;oe<g;oe++)Du(r[oe],S,T,e,t[oe]);for(let oe=0;oe<v;oe++)Du(n[oe],I,T,e,g+o[oe]);let V=P/4,Y=M/4,le=R/4,D=W/4;for(let oe=0;oe<g;oe++)u.HEAPU32[V++]=S[oe],u.HEAPU32[Y++]=p[t[oe]];for(let oe=0;oe<v;oe++)u.HEAPU32[le++]=I[oe],u.HEAPU32[D++]=h[o[oe]];if(b){let{handle:oe,outputPreferredLocations:we,outputPreferredLocationsEncoded:q}=b;if(p.length!==g)throw new Error(`input count from feeds (${g}) is expected to be always equal to model's input count (${p.length}).`);for(let Ce=0;Ce<g;Ce++){let Be=t[Ce];await u._OrtBindInput(oe,p[Be],S[Ce])!==0&&Ae(`Can't bind input[${Ce}] for session=${e}.`)}for(let Ce=0;Ce<v;Ce++){let Be=o[Ce];n[Ce]?.[3]?u._OrtBindOutput(oe,h[Be],I[Ce],0)!==0&&Ae(`Can't bind pre-allocated output[${Ce}] for session=${e}.`):u._OrtBindOutput(oe,h[Be],0,q[Be])!==0&&Ae(`Can't bind output[${Ce}] to ${we[Ce]} for session=${e}.`)}}let K;b?K=await u._OrtRunWithBinding(a,b.handle,v,R,$):K=await u._OrtRun(a,M,P,g,W,v,R,$),K!==0&&Ae("failed to call OrtRun().");let Se=[];for(let oe=0;oe<v;oe++){let we=u.HEAPU32[R/4+oe];if(we===I[oe]){Se.push(n[oe]);continue}let q=u.stackSave(),Ce=u.stackAlloc(4*4),Be=!1,xe,_e=0;try{u._OrtGetTensorData(we,Ce,Ce+4,Ce+8,Ce+12)!==0&&Ae(`Can't access output tensor data on index ${oe}.`);let Ge=Ce/4,dt=u.HEAPU32[Ge++];_e=u.HEAPU32[Ge++];let G=u.HEAPU32[Ge++],de=u.HEAPU32[Ge++],pe=[];for(let Te=0;Te<de;Te++)pe.push(u.HEAPU32[G/4+Te]);u._OrtFree(G);let Ne=pe.reduce((Te,Ee)=>Te*Ee,1);xe=lr(dt);let Ue=b?.outputPreferredLocations[o[oe]];if(xe==="string"){if(Ue==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Te=[],Ee=_e/4;for(let qe=0;qe<Ne;qe++){let Ke=u.HEAPU32[Ee++],He=qe===Ne-1?void 0:u.HEAPU32[Ee]-Ke;Te.push(u.UTF8ToString(Ke,He))}Se.push([xe,pe,Te,"cpu"])}else if(Ue==="gpu-buffer"&&Ne>0){let Te=u.jsepGetBuffer(_e),Ee=dr(dt);if(Ee===void 0||!Hr(xe))throw new Error(`Unsupported data type: ${xe}`);Be=!0,Se.push([xe,pe,{gpuBuffer:Te,download:u.jsepCreateDownloader(Te,Ne*Ee,xe),dispose:()=>{u._OrtReleaseTensor(we)}},"gpu-buffer"])}else{let Te=Lr(xe),Ee=new Te(Ne);new Uint8Array(Ee.buffer,Ee.byteOffset,Ee.byteLength).set(u.HEAPU8.subarray(_e,_e+Ee.byteLength)),Se.push([xe,pe,Ee,"cpu"])}}finally{u.stackRestore(q),xe==="string"&&_e&&u._free(_e),Be||u._OrtReleaseTensor(we)}}return b&&u._OrtClearBoundOutputs(b.handle),Se}finally{u.stackRestore(B),S.forEach(V=>u._OrtReleaseTensor(V)),I.forEach(V=>u._OrtReleaseTensor(V)),T.forEach(V=>u._free(V)),$!==0&&u._OrtReleaseRunOptions($),w.forEach(V=>u._free(V))}},Lu=e=>{let t=Re(),r=yr.get(e);if(!r)throw new Error("invalid session id");let o=r[0],n=t._OrtEndProfiling(o);n===0&&Ae("Can't get an profile file name."),t._OrtFree(n)},Hu=e=>{let t=[];for(let r of e){let o=r[2];!Array.isArray(o)&&"buffer"in o&&t.push(o.buffer)}return t}});var ju=Gt((Z0,Gc)=>{Gc.exports='/*!\n * ONNX Runtime Web v1.17.0\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var Qr=Object.defineProperty;var lu=Object.getOwnPropertyDescriptor;var cu=Object.getOwnPropertyNames;var du=Object.prototype.hasOwnProperty;var j=(e,t)=>()=>(e&&(t=e(e=0)),t);var Yt=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),xr=(e,t)=>{for(var r in t)Qr(e,r,{get:t[r],enumerable:!0})},pu=(e,t,r,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of cu(t))!du.call(e,n)&&n!==r&&Qr(e,n,{get:()=>t[n],enumerable:!(i=lu(t,n))||i.enumerable});return e};var Et=e=>pu(Qr({},"__esModule",{value:!0}),e);var en={};xr(en,{readFile:()=>fu});var fu,tn=j(()=>{fu=void 0});var rn={};xr(rn,{join:()=>mu});var mu,nn=j(()=>{mu=void 0});var ao=Yt((oo,on)=>{"use strict";var no=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){var r=t,i,n;r.ready=new Promise((l,p)=>{i=l,n=p}),r.jsepInit=(l,p,h,S,T,U,H,L)=>{r.Za=l,r.Oa=p,r.Qa=h,r.Ja=S,r.Pa=T,r.ra=U,r.Ra=H,r.Sa=L,p=(X,J,Q)=>(...de)=>{let me=Ne,O=J?.();de=X(...de);let se=J?.();return O!==se&&(X=se,Q(O),J=Q=null),Ne!=me?dr():de},h=X=>async(...J)=>{try{if(r.Da)throw Error("Session already started");let Q=r.Da={Ta:J[0],errors:[]},de=await X(...J);if(r.Da!==Q)throw Error("Session mismatch");l.flush();let me=Q.errors;if(0<me.length){let O=await Promise.all(me);if(O=O.filter(se=>se),0<O.length)throw Error(O.join(`\n`))}return de}finally{r.Da=null}},r._OrtRun=h(p(r._OrtRun,()=>r._OrtRun,X=>r._OrtRun=X)),r._OrtRunWithBinding=h(p(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,X=>r._OrtRunWithBinding=X)),r._OrtBindInput=p(r._OrtBindInput,()=>r._OrtBindInput,X=>r._OrtBindInput=X),r.jsepRegisterBuffer=(X,J,Q,de)=>l.registerBuffer(X,J,Q,de),r.jsepUnregisterBuffers=X=>{l.unregisterBuffers(X)},r.jsepGetBuffer=X=>l.getBuffer(X),r.jsepCreateDownloader=(X,J,Q)=>l.createDownloader(X,J,Q)};var s=Object.assign({},r),u="./this.program",c=(l,p)=>{throw p},o=typeof window=="object",m=typeof importScripts=="function",g=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",x="",b,w,$;if(g){var y=(tn(),Et(en)),C=(nn(),Et(rn));x=m?C.dirname(x)+"/":__dirname+"/",b=(l,p)=>(l=l.startsWith("file://")?new URL(l):C.normalize(l),y.readFileSync(l,p?void 0:"utf8")),$=l=>(l=b(l,!0),l.buffer||(l=new Uint8Array(l)),l),w=(l,p,h,S=!0)=>{l=l.startsWith("file://")?new URL(l):C.normalize(l),y.readFile(l,S?void 0:"utf8",(T,U)=>{T?h(T):p(S?U.buffer:U)})},!r.thisProgram&&1<process.argv.length&&(u=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),c=(l,p)=>{throw process.exitCode=l,p},r.inspect=()=>"[Emscripten Module object]"}else(o||m)&&(m?x=self.location.href:typeof document<"u"&&document.currentScript&&(x=document.currentScript.src),e&&(x=e),x.indexOf("blob:")!==0?x=x.substr(0,x.replace(/[?#].*/,"").lastIndexOf("/")+1):x="",b=l=>{var p=new XMLHttpRequest;return p.open("GET",l,!1),p.send(null),p.responseText},m&&($=l=>{var p=new XMLHttpRequest;return p.open("GET",l,!1),p.responseType="arraybuffer",p.send(null),new Uint8Array(p.response)}),w=(l,p,h)=>{var S=new XMLHttpRequest;S.open("GET",l,!0),S.responseType="arraybuffer",S.onload=()=>{S.status==200||S.status==0&&S.response?p(S.response):h()},S.onerror=h,S.send(null)});var A=r.print||console.log.bind(console),P=r.printErr||console.error.bind(console);Object.assign(r,s),s=null,r.thisProgram&&(u=r.thisProgram),r.quit&&(c=r.quit);var W;r.wasmBinary&&(W=r.wasmBinary);var B=r.noExitRuntime||!0;typeof WebAssembly!="object"&&Ge("no native wasm support detected");var D,_,z=!1,N,Y,le,M,q,Ce;function ae(){var l=D.buffer;r.HEAP8=Y=new Int8Array(l),r.HEAP16=new Int16Array(l),r.HEAP32=M=new Int32Array(l),r.HEAPU8=le=new Uint8Array(l),r.HEAPU16=new Uint16Array(l),r.HEAPU32=q=new Uint32Array(l),r.HEAPF32=new Float32Array(l),r.HEAPF64=Ce=new Float64Array(l)}var we=[],K=[],Se=[];function Be(){var l=r.preRun.shift();we.unshift(l)}var xe=0,Ie=null,Ze=null;function Ge(l){throw r.onAbort&&r.onAbort(l),l="Aborted("+l+")",P(l),z=!0,N=1,l=new WebAssembly.RuntimeError(l+". Build with -sASSERTIONS for more info."),n(l),l}function it(l){return l.startsWith("data:application/octet-stream;base64,")}var V;if(V="ort-wasm-simd.wasm",!it(V)){var ce=V;V=r.locateFile?r.locateFile(ce,x):x+ce}function pe(l){if(l==V&&W)return new Uint8Array(W);if($)return $(l);throw"both async and sync fetching of the wasm failed"}function ze(l){if(!W&&(o||m)){if(typeof fetch=="function"&&!l.startsWith("file://"))return fetch(l,{credentials:"same-origin"}).then(p=>{if(!p.ok)throw"failed to load wasm binary file at \'"+l+"\'";return p.arrayBuffer()}).catch(()=>pe(l));if(w)return new Promise((p,h)=>{w(l,S=>p(new Uint8Array(S)),h)})}return Promise.resolve().then(()=>pe(l))}function Ve(l,p,h){return ze(l).then(S=>WebAssembly.instantiate(S,p)).then(S=>S).then(h,S=>{P("failed to asynchronously prepare wasm: "+S),Ge(S)})}function Ee(l,p){var h=V;return W||typeof WebAssembly.instantiateStreaming!="function"||it(h)||h.startsWith("file://")||g||typeof fetch!="function"?Ve(h,l,p):fetch(h,{credentials:"same-origin"}).then(S=>WebAssembly.instantiateStreaming(S,l).then(p,function(T){return P("wasm streaming compile failed: "+T),P("falling back to ArrayBuffer instantiation"),Ve(h,l,p)}))}var Te,He={915152:l=>{r.ra("Abs",l,void 0)},915203:l=>{r.ra("Neg",l,void 0)},915254:l=>{r.ra("Floor",l,void 0)},915307:l=>{r.ra("Ceil",l,void 0)},915359:l=>{r.ra("Reciprocal",l,void 0)},915417:l=>{r.ra("Sqrt",l,void 0)},915469:l=>{r.ra("Exp",l,void 0)},915520:l=>{r.ra("Erf",l,void 0)},915571:l=>{r.ra("Sigmoid",l,void 0)},915626:l=>{r.ra("Log",l,void 0)},915677:l=>{r.ra("Sin",l,void 0)},915728:l=>{r.ra("Cos",l,void 0)},915779:l=>{r.ra("Tan",l,void 0)},915830:l=>{r.ra("Asin",l,void 0)},915882:l=>{r.ra("Acos",l,void 0)},915934:l=>{r.ra("Atan",l,void 0)},915986:l=>{r.ra("Sinh",l,void 0)},916038:l=>{r.ra("Cosh",l,void 0)},916090:l=>{r.ra("Asinh",l,void 0)},916143:l=>{r.ra("Acosh",l,void 0)},916196:l=>{r.ra("Atanh",l,void 0)},916249:l=>{r.ra("Tanh",l,void 0)},916301:l=>{r.ra("Not",l,void 0)},916352:(l,p,h)=>{r.ra("ClipV10",l,{min:p,max:h})},916424:l=>{r.ra("Clip",l,void 0)},916476:(l,p)=>{r.ra("Elu",l,{alpha:p})},916534:l=>{r.ra("Relu",l,void 0)},916586:(l,p)=>{r.ra("LeakyRelu",l,{alpha:p})},916650:(l,p)=>{r.ra("ThresholdedRelu",l,{alpha:p})},916720:(l,p)=>{r.ra("Cast",l,{to:p})},916778:l=>{r.ra("Add",l,void 0)},916829:l=>{r.ra("Sub",l,void 0)},916880:l=>{r.ra("Mul",l,void 0)},916931:l=>{r.ra("Div",l,void 0)},916982:l=>{r.ra("Pow",l,void 0)},917033:l=>{r.ra("Equal",l,void 0)},917086:l=>{r.ra("Greater",l,void 0)},917141:l=>{r.ra("GreaterOrEqual",l,void 0)},917203:l=>{r.ra("Less",l,void 0)},917255:l=>{r.ra("LessOrEqual",l,void 0)},917314:(l,p,h,S,T)=>{r.ra("ReduceMean",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(M.subarray(T>>>0,T+S>>>0)):[]})},917478:(l,p,h,S,T)=>{r.ra("ReduceMax",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(M.subarray(T>>>0,T+S>>>0)):[]})},917641:(l,p,h,S,T)=>{r.ra("ReduceMin",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(M.subarray(T>>>0,T+S>>>0)):[]})},917804:(l,p,h,S,T)=>{r.ra("ReduceProd",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(M.subarray(T>>>0,T+S>>>0)):[]})},917968:(l,p,h,S,T)=>{r.ra("ReduceSum",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(M.subarray(T>>>0,T+S>>>0)):[]})},918131:(l,p,h,S,T)=>{r.ra("ReduceL1",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(M.subarray(T>>>0,T+S>>>0)):[]})},918293:(l,p,h,S,T)=>{r.ra("ReduceL2",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(M.subarray(T>>>0,T+S>>>0)):[]})},918455:(l,p,h,S,T)=>{r.ra("ReduceLogSum",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(M.subarray(T>>>0,T+S>>>0)):[]})},918621:(l,p,h,S,T)=>{r.ra("ReduceSumSquare",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(M.subarray(T>>>0,T+S>>>0)):[]})},918790:(l,p,h,S,T)=>{r.ra("ReduceLogSumExp",l,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(M.subarray(T>>>0,T+S>>>0)):[]})},918959:l=>{r.ra("Where",l,void 0)},919012:(l,p,h)=>{r.ra("Transpose",l,{perm:p?Array.from(M.subarray(h>>>0,h+p>>>0)):[]})},919125:(l,p,h,S,T,U,H,L,X,J)=>{r.ra("Conv",l,{format:X?"NHWC":"NCHW",auto_pad:p,dilations:[h],group:S,kernel_shape:[T],pads:[U,H],strides:[L],w_is_const:()=>!!Y[J>>>0]})},919353:(l,p,h,S,T,U,H,L,X,J,Q,de,me,O,se)=>{r.ra("Conv",l,{format:O?"NHWC":"NCHW",auto_pad:p,dilations:[h,S],group:T,kernel_shape:[U,H],pads:[L,X,J,Q],strides:[de,me],w_is_const:()=>!!Y[se>>>0]})},919612:(l,p,h,S,T,U,H,L,X,J)=>{r.ra("Conv",l,{format:X?"NHWC":"NCHW",auto_pad:p,dilations:[h],group:S,kernel_shape:[T],pads:[U,H],strides:[L],w_is_const:()=>!!Y[J>>>0]})},919840:(l,p,h,S,T,U,H,L,X,J,Q,de,me,O,se)=>{r.ra("Conv",l,{format:O?"NHWC":"NCHW",auto_pad:p,dilations:[h,S],group:T,kernel_shape:[U,H],pads:[L,X,J,Q],strides:[de,me],w_is_const:()=>!!Y[se>>>0]})},920099:(l,p,h,S,T,U,H,L,X,J,Q,de,me,O)=>{r.ra("ConvTranspose",l,{format:X?"NHWC":"NCHW",autoPad:p,dilations:[h],group:S,kernel_shape:[T],pads:[U,H],strides:[L],wIsConst:()=>!!Y[J>>>0],outputPadding:Q?Array.from(M.subarray(de>>>0,de+Q>>>0)):[],outputShape:me?Array.from(M.subarray(O>>>0,O+me>>>0)):[]})},920479:(l,p,h,S,T,U,H,L,X,J,Q,de,me)=>{r.ra("ConvTranspose",l,{format:L?"NHWC":"NCHW",autoPad:p,dilations:Array.from(M.subarray(h>>>0,h+2>>>0)),group:S,kernelShape:Array.from(M.subarray(T>>>0,T+2>>>0)),pads:Array.from(M.subarray(U>>>0,U+4>>>0)),strides:Array.from(M.subarray(H>>>0,H+2>>>0)),wIsConst:()=>!!Y[X>>>0],outputPadding:0<J?Array.from(M.subarray(Q>>>0,Q+J>>>0)):[],outputShape:0<de?Array.from(M.subarray(me>>>0,me+de>>>0)):[]})},921002:(l,p,h,S,T,U,H,L,X,J,Q,de,me,O)=>{r.ra("ConvTranspose",l,{format:X?"NHWC":"NCHW",autoPad:p,dilations:[h],group:S,kernel_shape:[T],pads:[U,H],strides:[L],wIsConst:()=>!!Y[J>>>0],outputPadding:Q?Array.from(M.subarray(de>>>0,de+Q>>>0)):[],outputShape:me?Array.from(M.subarray(O>>>0,O+me>>>0)):[]})},921382:(l,p,h,S,T,U,H,L,X,J,Q,de,me)=>{r.ra("ConvTranspose",l,{format:L?"NHWC":"NCHW",autoPad:p,dilations:Array.from(M.subarray(h>>>0,h+2>>>0)),group:S,kernelShape:Array.from(M.subarray(T>>>0,T+2>>>0)),pads:Array.from(M.subarray(U>>>0,U+4>>>0)),strides:Array.from(M.subarray(H>>>0,H+2>>>0)),wIsConst:()=>!!Y[X>>>0],outputPadding:0<J?Array.from(M.subarray(Q>>>0,Q+J>>>0)):[],outputShape:0<de?Array.from(M.subarray(me>>>0,me+de>>>0)):[]})},921905:(l,p)=>{r.ra("GlobalAveragePool",l,{format:p?"NHWC":"NCHW"})},921996:(l,p,h,S,T,U,H,L,X,J,Q,de,me,O,se,ge)=>{r.ra("AveragePool",l,{format:ge?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:S,storage_order:T,dilations:[U,H],kernel_shape:[L,X],pads:[J,Q,de,me],strides:[O,se]})},922280:(l,p)=>{r.ra("GlobalAveragePool",l,{format:p?"NHWC":"NCHW"})},922371:(l,p,h,S,T,U,H,L,X,J,Q,de,me,O,se,ge)=>{r.ra("AveragePool",l,{format:ge?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:S,storage_order:T,dilations:[U,H],kernel_shape:[L,X],pads:[J,Q,de,me],strides:[O,se]})},922655:(l,p)=>{r.ra("GlobalMaxPool",l,{format:p?"NHWC":"NCHW"})},922742:(l,p,h,S,T,U,H,L,X,J,Q,de,me,O,se,ge)=>{r.ra("MaxPool",l,{format:ge?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:S,storage_order:T,dilations:[U,H],kernel_shape:[L,X],pads:[J,Q,de,me],strides:[O,se]})},923022:(l,p)=>{r.ra("GlobalMaxPool",l,{format:p?"NHWC":"NCHW"})},923109:(l,p,h,S,T,U,H,L,X,J,Q,de,me,O,se,ge)=>{r.ra("MaxPool",l,{format:ge?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:S,storage_order:T,dilations:[U,H],kernel_shape:[L,X],pads:[J,Q,de,me],strides:[O,se]})},923389:(l,p,h,S,T)=>{r.ra("Gemm",l,{alpha:p,beta:h,transA:S,transB:T})},923493:l=>{r.ra("MatMul",l,void 0)},923547:(l,p,h,S)=>{r.ra("ArgMax",l,{keepDims:!!p,selectLastIndex:!!h,axis:S})},923655:(l,p,h,S)=>{r.ra("ArgMin",l,{keepDims:!!p,selectLastIndex:!!h,axis:S})},923763:(l,p)=>{r.ra("Softmax",l,{axis:p})},923826:(l,p)=>{r.ra("Concat",l,{axis:p})},923886:(l,p,h,S,T)=>{r.ra("Split",l,{axis:p,numOutputs:h,splitSizes:S?Array.from(M.subarray(T>>>0,T+S>>>0)):[]})},924031:l=>{r.ra("Expand",l,void 0)},924085:(l,p)=>{r.ra("Gather",l,{axis:Number(p)})},924156:(l,p)=>{r.ra("GatherElements",l,{axis:Number(p)})},924235:(l,p,h,S,T,U,H,L,X,J,Q)=>{r.ra("Resize",l,{antialias:p,axes:h?Array.from(M.subarray(S>>>0,S+h>>>0)):[],coordinateTransformMode:Ke(T),cubicCoeffA:U,excludeOutside:H,extrapolationValue:L,keepAspectRatioPolicy:Ke(X),mode:Ke(J),nearestMode:Ke(Q)})},924586:(l,p,h,S,T,U,H)=>{r.ra("Slice",l,{starts:p?Array.from(M.subarray(h>>>0,h+p>>>0)):[],ends:S?Array.from(M.subarray(T>>>0,T+S>>>0)):[],axes:U?Array.from(M.subarray(H>>>0,H+U>>>0)):[]})},924817:l=>{r.ra("Tile",l,void 0)},924869:(l,p,h)=>{r.ra("LayerNormalization",l,{axis:Number(p),epsilon:Number(h)})},924976:(l,p,h)=>{r.ra("InstanceNormalization",l,{epsilon:p,format:h?"NHWC":"NCHW"})},925090:(l,p,h)=>{r.ra("InstanceNormalization",l,{epsilon:p,format:h?"NHWC":"NCHW"})},925204:l=>{r.ra("Range",l,void 0)},925257:(l,p)=>{r.ra("Einsum",l,{equation:Ke(p)})},925338:(l,p,h,S,T)=>{r.ra("Pad",l,{mode:p,value:h,pads:S?Array.from(M.subarray(T>>>0,T+S>>>0)):[]})},925470:l=>{r.ra("Gelu",l,void 0)},925522:l=>{r.ra("BiasAdd",l,void 0)},925577:l=>{r.ra("BiasSplitGelu",l,void 0)},925638:(l,p)=>{r.ra("SkipLayerNormalization",l,{epsilon:p})},925719:l=>{r.Ra(l)},925753:(l,p)=>r.Sa(l,p,r.Da.Ta,r.Da.errors),925865:l=>r.Oa(l),925898:l=>r.Qa(l),925930:(l,p,h)=>{r.Ja(l,p,h,!0)},925969:(l,p,h)=>{r.Ja(l,p,h)}};function Le(l){this.name="ExitStatus",this.message=`Program terminated with exit(${l})`,this.status=l}var Ue=l=>{for(;0<l.length;)l.shift()(r)};function Pt(l){this.Ha=l-24,this.Ma=function(p){q[this.Ha+4>>2>>>0]=p},this.La=function(p){q[this.Ha+8>>2>>>0]=p},this.Ya=function(p,h){this.Ka(),this.Ma(p),this.La(h)},this.Ka=function(){q[this.Ha+16>>2>>>0]=0}}var lt=0,ir=0,Rt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,je=(l,p,h)=>{p>>>=0;var S=p+h;for(h=p;l[h]&&!(h>=S);)++h;if(16<h-p&&l.buffer&&Rt)return Rt.decode(l.subarray(p,h));for(S="";p<h;){var T=l[p++];if(T&128){var U=l[p++]&63;if((T&224)==192)S+=String.fromCharCode((T&31)<<6|U);else{var H=l[p++]&63;T=(T&240)==224?(T&15)<<12|U<<6|H:(T&7)<<18|U<<12|H<<6|l[p++]&63,65536>T?S+=String.fromCharCode(T):(T-=65536,S+=String.fromCharCode(55296|T>>10,56320|T&1023))}}else S+=String.fromCharCode(T)}return S},Ke=(l,p)=>(l>>>=0)?je(le,l,p):"",Qe=l=>{for(var p=0,h=0;h<l.length;++h){var S=l.charCodeAt(h);127>=S?p++:2047>=S?p+=2:55296<=S&&57343>=S?(p+=4,++h):p+=3}return p},vt=(l,p,h,S)=>{if(h>>>=0,!(0<S))return 0;var T=h;S=h+S-1;for(var U=0;U<l.length;++U){var H=l.charCodeAt(U);if(55296<=H&&57343>=H){var L=l.charCodeAt(++U);H=65536+((H&1023)<<10)|L&1023}if(127>=H){if(h>=S)break;p[h++>>>0]=H}else{if(2047>=H){if(h+1>=S)break;p[h++>>>0]=192|H>>6}else{if(65535>=H){if(h+2>=S)break;p[h++>>>0]=224|H>>12}else{if(h+3>=S)break;p[h++>>>0]=240|H>>18,p[h++>>>0]=128|H>>12&63}p[h++>>>0]=128|H>>6&63}p[h++>>>0]=128|H&63}}return p[h>>>0]=0,h-T},ct=l=>l%4===0&&(l%100!==0||l%400===0),Bt=[0,31,60,91,121,152,182,213,244,274,305,335],sr=[0,31,59,90,120,151,181,212,243,273,304,334],st=l=>{var p=Qe(l)+1,h=It(p);return h&&vt(l,le,h,p),h},mt=[],ht=(l,p)=>{mt.length=0;var h;for(p>>=2;h=le[l++>>>0];)p+=h!=105&p,mt.push(h==105?M[p>>>0]:Ce[p++>>>1]),++p;return mt},gt={},Mt=()=>{if(!$t){var l={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:u||"./this.program"},p;for(p in gt)gt[p]===void 0?delete l[p]:l[p]=gt[p];var h=[];for(p in l)h.push(`${p}=${l[p]}`);$t=h}return $t},$t,ur=[null,[],[]],kt=[31,29,31,30,31,30,31,31,30,31,30,31],We=[31,28,31,30,31,30,31,31,30,31,30,31];function lr(l){var p=Array(Qe(l)+1);return vt(l,p,0,p.length),p}function xt(l,p,h,S){function T(O,se,ge){for(O=typeof O=="number"?O.toString():O||"";O.length<se;)O=ge[0]+O;return O}function U(O,se){return T(O,se,"0")}function H(O,se){function ge(gr){return 0>gr?-1:0<gr?1:0}var et;return(et=ge(O.getFullYear()-se.getFullYear()))===0&&(et=ge(O.getMonth()-se.getMonth()))===0&&(et=ge(O.getDate()-se.getDate())),et}function L(O){switch(O.getDay()){case 0:return new Date(O.getFullYear()-1,11,29);case 1:return O;case 2:return new Date(O.getFullYear(),0,3);case 3:return new Date(O.getFullYear(),0,2);case 4:return new Date(O.getFullYear(),0,1);case 5:return new Date(O.getFullYear()-1,11,31);case 6:return new Date(O.getFullYear()-1,11,30)}}function X(O){var se=O.Ba;for(O=new Date(new Date(O.Ca+1900,0,1).getTime());0<se;){var ge=O.getMonth(),et=(ct(O.getFullYear())?kt:We)[ge];if(se>et-O.getDate())se-=et-O.getDate()+1,O.setDate(1),11>ge?O.setMonth(ge+1):(O.setMonth(0),O.setFullYear(O.getFullYear()+1));else{O.setDate(O.getDate()+se);break}}return ge=new Date(O.getFullYear()+1,0,4),se=L(new Date(O.getFullYear(),0,4)),ge=L(ge),0>=H(se,O)?0>=H(ge,O)?O.getFullYear()+1:O.getFullYear():O.getFullYear()-1}l>>>=0,p>>>=0,h>>>=0,S>>>=0;var J=M[S+40>>2>>>0];S={Wa:M[S>>2>>>0],Va:M[S+4>>2>>>0],Ea:M[S+8>>2>>>0],Ia:M[S+12>>2>>>0],Fa:M[S+16>>2>>>0],Ca:M[S+20>>2>>>0],wa:M[S+24>>2>>>0],Ba:M[S+28>>2>>>0],$a:M[S+32>>2>>>0],Ua:M[S+36>>2>>>0],Xa:J?Ke(J):""},h=Ke(h),J={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var Q in J)h=h.replace(new RegExp(Q,"g"),J[Q]);var de="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),me="January February March April May June July August September October November December".split(" ");J={"%a":O=>de[O.wa].substring(0,3),"%A":O=>de[O.wa],"%b":O=>me[O.Fa].substring(0,3),"%B":O=>me[O.Fa],"%C":O=>U((O.Ca+1900)/100|0,2),"%d":O=>U(O.Ia,2),"%e":O=>T(O.Ia,2," "),"%g":O=>X(O).toString().substring(2),"%G":O=>X(O),"%H":O=>U(O.Ea,2),"%I":O=>(O=O.Ea,O==0?O=12:12<O&&(O-=12),U(O,2)),"%j":O=>{for(var se=0,ge=0;ge<=O.Fa-1;se+=(ct(O.Ca+1900)?kt:We)[ge++]);return U(O.Ia+se,3)},"%m":O=>U(O.Fa+1,2),"%M":O=>U(O.Va,2),"%n":()=>`\n`,"%p":O=>0<=O.Ea&&12>O.Ea?"AM":"PM","%S":O=>U(O.Wa,2),"%t":()=>"	","%u":O=>O.wa||7,"%U":O=>U(Math.floor((O.Ba+7-O.wa)/7),2),"%V":O=>{var se=Math.floor((O.Ba+7-(O.wa+6)%7)/7);if(2>=(O.wa+371-O.Ba-2)%7&&se++,se)se==53&&(ge=(O.wa+371-O.Ba)%7,ge==4||ge==3&&ct(O.Ca)||(se=1));else{se=52;var ge=(O.wa+7-O.Ba-1)%7;(ge==4||ge==5&&ct(O.Ca%400-1))&&se++}return U(se,2)},"%w":O=>O.wa,"%W":O=>U(Math.floor((O.Ba+7-(O.wa+6)%7)/7),2),"%y":O=>(O.Ca+1900).toString().substring(2),"%Y":O=>O.Ca+1900,"%z":O=>{O=O.Ua;var se=0<=O;return O=Math.abs(O)/60,(se?"+":"-")+("0000"+(O/60*100+O%60)).slice(-4)},"%Z":O=>O.Xa,"%%":()=>"%"},h=h.replace(/%%/g,"\\0\\0");for(Q in J)h.includes(Q)&&(h=h.replace(new RegExp(Q,"g"),J[Q](S)));return h=h.replace(/\\0\\0/g,"%"),Q=lr(h),Q.length>p?0:(Y.set(Q,l>>>0),Q.length-1)}function re(l){try{l()}catch(p){Ge(p)}}function Ct(l){var p={},h;for(h in l)(function(S){var T=l[S];p[S]=typeof T=="function"?function(){St.push(S);try{return T.apply(null,arguments)}finally{z||(St.pop()===S||Ge(),Ne&&qe===1&&St.length===0&&(qe=0,re(jt),typeof Fibers<"u"&&Fibers.ab()))}}:T})(h);return p}var qe=0,Ne=null,Dt=0,St=[],Wt={},zt={},cr=0,At=null,Gt=[];function dr(){return new Promise((l,p)=>{At={resolve:l,reject:p}})}function pr(){var l=It(65548),p=l+12;q[l>>2>>>0]=p,q[l+4>>2>>>0]=p+65536,p=St[0];var h=Wt[p];return h===void 0&&(h=cr++,Wt[p]=h,zt[h]=p),M[l+8>>2>>>0]=h,l}function fr(l){if(!z){if(qe===0){var p=!1,h=!1;l((S=0)=>{if(!z&&(Dt=S,p=!0,h)){qe=2,re(()=>Kt(Ne)),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.resume(),S=!1;try{var T=(0,_[zt[M[Ne+8>>2>>>0]]])()}catch(L){T=L,S=!0}var U=!1;if(!Ne){var H=At;H&&(At=null,(S?H.reject:H.resolve)(T),U=!0)}if(S&&!U)throw T}}),h=!0,p||(qe=1,Ne=pr(),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.pause(),re(()=>Lt(Ne)))}else qe===2?(qe=0,re(Tt),Vt(Ne),Ne=null,Gt.forEach(S=>{if(!z)try{if(S(),!B)try{N=N=S=N,B||(r.onExit&&r.onExit(S),z=!0),c(S,new Le(S))}catch(T){T instanceof Le||T=="unwind"||c(1,T)}}catch(T){T instanceof Le||T=="unwind"||c(1,T)}})):Ge(`invalid state: ${qe}`);return Dt}}function mr(l){return fr(p=>{l().then(p)})}var hr={n:function(l,p,h){return mr(async()=>{await r.Pa(l,p,h)})},a:function(l,p,h){throw l>>>=0,new Pt(l).Ya(p>>>0,h>>>0),lt=l,ir++,lt},g:function(){return 0},J:function(){},z:function(){},B:function(){},L:function(){return 0},H:function(){},C:function(){},G:function(){},l:function(){},A:function(){},x:function(){},I:function(){},y:function(){},m:()=>!0,q:function(l,p,h){l=p+2097152>>>0<4194305-!!l?(l>>>0)+4294967296*p:NaN,h>>>=0,l=new Date(1e3*l),M[h>>2>>>0]=l.getUTCSeconds(),M[h+4>>2>>>0]=l.getUTCMinutes(),M[h+8>>2>>>0]=l.getUTCHours(),M[h+12>>2>>>0]=l.getUTCDate(),M[h+16>>2>>>0]=l.getUTCMonth(),M[h+20>>2>>>0]=l.getUTCFullYear()-1900,M[h+24>>2>>>0]=l.getUTCDay(),M[h+28>>2>>>0]=(l.getTime()-Date.UTC(l.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(l,p,h){l=p+2097152>>>0<4194305-!!l?(l>>>0)+4294967296*p:NaN,h>>>=0,l=new Date(1e3*l),M[h>>2>>>0]=l.getSeconds(),M[h+4>>2>>>0]=l.getMinutes(),M[h+8>>2>>>0]=l.getHours(),M[h+12>>2>>>0]=l.getDate(),M[h+16>>2>>>0]=l.getMonth(),M[h+20>>2>>>0]=l.getFullYear()-1900,M[h+24>>2>>>0]=l.getDay(),M[h+28>>2>>>0]=(ct(l.getFullYear())?Bt:sr)[l.getMonth()]+l.getDate()-1|0,M[h+36>>2>>>0]=-(60*l.getTimezoneOffset()),p=new Date(l.getFullYear(),6,1).getTimezoneOffset();var S=new Date(l.getFullYear(),0,1).getTimezoneOffset();M[h+32>>2>>>0]=(p!=S&&l.getTimezoneOffset()==Math.min(S,p))|0},s:function(l){l>>>=0;var p=new Date(M[l+20>>2>>>0]+1900,M[l+16>>2>>>0],M[l+12>>2>>>0],M[l+8>>2>>>0],M[l+4>>2>>>0],M[l>>2>>>0],0),h=M[l+32>>2>>>0],S=p.getTimezoneOffset(),T=new Date(p.getFullYear(),6,1).getTimezoneOffset(),U=new Date(p.getFullYear(),0,1).getTimezoneOffset(),H=Math.min(U,T);return 0>h?M[l+32>>2>>>0]=+(T!=U&&H==S):0<h!=(H==S)&&(T=Math.max(U,T),p.setTime(p.getTime()+6e4*((0<h?H:T)-S))),M[l+24>>2>>>0]=p.getDay(),M[l+28>>2>>>0]=(ct(p.getFullYear())?Bt:sr)[p.getMonth()]+p.getDate()-1|0,M[l>>2>>>0]=p.getSeconds(),M[l+4>>2>>>0]=p.getMinutes(),M[l+8>>2>>>0]=p.getHours(),M[l+12>>2>>>0]=p.getDate(),M[l+16>>2>>>0]=p.getMonth(),M[l+20>>2>>>0]=p.getYear(),l=p.getTime()/1e3,Ut((Te=l,1<=+Math.abs(Te)?0<Te?+Math.floor(Te/4294967296)>>>0:~~+Math.ceil((Te-+(~~Te>>>0))/4294967296)>>>0:0)),l>>>0},o:function(){return-52},p:function(){},v:function(l,p,h){function S(X){return(X=X.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?X[1]:"GMT"}h>>>=0;var T=new Date().getFullYear(),U=new Date(T,0,1),H=new Date(T,6,1);T=U.getTimezoneOffset();var L=H.getTimezoneOffset();q[l>>>0>>2>>>0]=60*Math.max(T,L),M[p>>>0>>2>>>0]=+(T!=L),l=S(U),p=S(H),l=st(l),p=st(p),L<T?(q[h>>2>>>0]=l,q[h+4>>2>>>0]=p):(q[h>>2>>>0]=p,q[h+4>>2>>>0]=l)},e:()=>{Ge("")},b:function(l,p,h){return l>>>=0,p=ht(p>>>0,h>>>0),He[l].apply(null,p)},i:function(l,p,h){return l>>>=0,p=ht(p>>>0,h>>>0),He[l].apply(null,p)},h:function(){return Date.now()},w:function(){return 4294901760},c:()=>performance.now(),K:function(l,p,h){return p>>>=0,le.copyWithin(l>>>0>>>0,p>>>0,p+(h>>>0)>>>0)},u:function(l){l>>>=0;var p=le.length;if(4294901760<l)return!1;for(var h=1;4>=h;h*=2){var S=p*(1+.2/h);S=Math.min(S,l+100663296);var T=Math;S=Math.max(l,S);e:{T=T.min.call(T,4294901760,S+(65536-S%65536)%65536)-D.buffer.byteLength+65535>>>16;try{D.grow(T),ae();var U=1;break e}catch{}U=void 0}if(U)return!0}return!1},D:function(l,p){l>>>=0,p>>>=0;var h=0;return Mt().forEach(function(S,T){var U=p+h;for(T=q[l+4*T>>2>>>0]=U,U=0;U<S.length;++U)Y[T++>>0>>>0]=S.charCodeAt(U);Y[T>>0>>>0]=0,h+=S.length+1}),0},E:function(l,p){l>>>=0,p>>>=0;var h=Mt();q[l>>2>>>0]=h.length;var S=0;return h.forEach(function(T){S+=T.length+1}),q[p>>2>>>0]=S,0},f:()=>52,k:function(){return 52},t:function(){return 70},j:function(l,p,h,S){p>>>=0,h>>>=0,S>>>=0;for(var T=0,U=0;U<h;U++){var H=q[p>>2>>>0],L=q[p+4>>2>>>0];p+=8;for(var X=0;X<L;X++){var J=le[H+X>>>0],Q=ur[l];J===0||J===10?((l===1?A:P)(je(Q,0)),Q.length=0):Q.push(J)}T+=L}return q[S>>2>>>0]=T,0},F:xt,d:function(l,p,h,S){return xt(l>>>0,p>>>0,h>>>0,S>>>0)}};(function(){function l(h){if(h=h.exports,h=Ct(h),_=h=Ot(h),D=_.M,ae(),K.unshift(_.N),xe--,r.monitorRunDependencies&&r.monitorRunDependencies(xe),xe==0&&(Ie!==null&&(clearInterval(Ie),Ie=null),Ze)){var S=Ze;Ze=null,S()}return h}var p={a:hr};if(xe++,r.monitorRunDependencies&&r.monitorRunDependencies(xe),r.instantiateWasm)try{return r.instantiateWasm(p,l)}catch(h){P("Module.instantiateWasm callback failed with error: "+h),n(h)}return Ee(p,function(h){l(h.instance)}).catch(n),{}})(),r._OrtInit=(l,p)=>(r._OrtInit=_.O)(l,p),r._OrtGetLastError=(l,p)=>(r._OrtGetLastError=_.P)(l,p),r._OrtCreateSessionOptions=(l,p,h,S,T,U,H,L,X,J)=>(r._OrtCreateSessionOptions=_.Q)(l,p,h,S,T,U,H,L,X,J),r._OrtAppendExecutionProvider=(l,p)=>(r._OrtAppendExecutionProvider=_.R)(l,p),r._OrtAddFreeDimensionOverride=(l,p,h)=>(r._OrtAddFreeDimensionOverride=_.S)(l,p,h),r._OrtAddSessionConfigEntry=(l,p,h)=>(r._OrtAddSessionConfigEntry=_.T)(l,p,h),r._OrtReleaseSessionOptions=l=>(r._OrtReleaseSessionOptions=_.U)(l),r._OrtCreateSession=(l,p,h)=>(r._OrtCreateSession=_.V)(l,p,h),r._OrtReleaseSession=l=>(r._OrtReleaseSession=_.W)(l),r._OrtGetInputOutputCount=(l,p,h)=>(r._OrtGetInputOutputCount=_.X)(l,p,h),r._OrtGetInputName=(l,p)=>(r._OrtGetInputName=_.Y)(l,p),r._OrtGetOutputName=(l,p)=>(r._OrtGetOutputName=_.Z)(l,p),r._OrtFree=l=>(r._OrtFree=_._)(l),r._OrtCreateTensor=(l,p,h,S,T,U)=>(r._OrtCreateTensor=_.$)(l,p,h,S,T,U),r._OrtGetTensorData=(l,p,h,S,T)=>(r._OrtGetTensorData=_.aa)(l,p,h,S,T),r._OrtReleaseTensor=l=>(r._OrtReleaseTensor=_.ba)(l),r._OrtCreateRunOptions=(l,p,h,S)=>(r._OrtCreateRunOptions=_.ca)(l,p,h,S),r._OrtAddRunConfigEntry=(l,p,h)=>(r._OrtAddRunConfigEntry=_.da)(l,p,h),r._OrtReleaseRunOptions=l=>(r._OrtReleaseRunOptions=_.ea)(l),r._OrtCreateBinding=l=>(r._OrtCreateBinding=_.fa)(l),r._OrtBindInput=(l,p,h)=>(r._OrtBindInput=_.ga)(l,p,h),r._OrtBindOutput=(l,p,h,S)=>(r._OrtBindOutput=_.ha)(l,p,h,S),r._OrtClearBoundOutputs=l=>(r._OrtClearBoundOutputs=_.ia)(l),r._OrtReleaseBinding=l=>(r._OrtReleaseBinding=_.ja)(l),r._OrtRunWithBinding=(l,p,h,S,T)=>(r._OrtRunWithBinding=_.ka)(l,p,h,S,T),r._OrtRun=(l,p,h,S,T,U,H,L)=>(r._OrtRun=_.la)(l,p,h,S,T,U,H,L),r._OrtEndProfiling=l=>(r._OrtEndProfiling=_.ma)(l),r._JsepOutput=(l,p,h)=>(r._JsepOutput=_.na)(l,p,h),r._JsepGetNodeName=l=>(r._JsepGetNodeName=_.oa)(l);var It=r._malloc=l=>(It=r._malloc=_.pa)(l),Vt=r._free=l=>(Vt=r._free=_.qa)(l),Ut=l=>(Ut=_.sa)(l),Nt=()=>(Nt=_.ta)(),Ft=l=>(Ft=_.ua)(l),Ht=l=>(Ht=_.va)(l),Lt=l=>(Lt=_.xa)(l),jt=()=>(jt=_.ya)(),Kt=l=>(Kt=_.za)(l),Tt=()=>(Tt=_.Aa)();r.___start_em_js=926002,r.___stop_em_js=926163;function Ot(l){l=Object.assign({},l);var p=S=>()=>S()>>>0,h=S=>T=>S(T)>>>0;return l.__errno_location=p(l.__errno_location),l.malloc=h(l.malloc),l.stackSave=p(l.stackSave),l.stackAlloc=h(l.stackAlloc),l}r.stackAlloc=Ht,r.stackSave=Nt,r.stackRestore=Ft,r.UTF8ToString=Ke,r.stringToUTF8=(l,p,h)=>vt(l,le,p,h),r.lengthBytesUTF8=Qe;var Ye;Ze=function l(){Ye||qt(),Ye||(Ze=l)};function qt(){function l(){if(!Ye&&(Ye=!0,r.calledRun=!0,!z)){if(Ue(K),i(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),r.postRun)for(typeof r.postRun=="function"&&(r.postRun=[r.postRun]);r.postRun.length;){var p=r.postRun.shift();Se.unshift(p)}Ue(Se)}}if(!(0<xe)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;)Be();Ue(we),0<xe||(r.setStatus?(r.setStatus("Running..."),setTimeout(function(){setTimeout(function(){r.setStatus("")},1),l()},1)):l())}}if(r.preInit)for(typeof r.preInit=="function"&&(r.preInit=[r.preInit]);0<r.preInit.length;)r.preInit.pop()();return qt(),t.ready}})();typeof oo=="object"&&typeof on=="object"?on.exports=no:typeof define=="function"&&define.amd&&define([],()=>no)});var io=Yt(()=>{});var so=Yt(()=>{});var uo={};xr(uo,{cpus:()=>hu});var hu,lo=j(()=>{hu=void 0});var fo=Yt((po,an)=>{"use strict";var co=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){function r(){return we.buffer!=Ie.buffer&&pe(),Ie}function i(){return we.buffer!=Ie.buffer&&pe(),Ze}function n(){return we.buffer!=Ie.buffer&&pe(),Ge}function s(){return we.buffer!=Ie.buffer&&pe(),it}function u(){return we.buffer!=Ie.buffer&&pe(),V}function c(){return we.buffer!=Ie.buffer&&pe(),ce}var o=t,m,g;o.ready=new Promise((a,d)=>{m=a,g=d}),o.jsepInit=(a,d,f,v,I,R,G,oe)=>{o.Qb=a,o.wb=d,o.yb=f,o.jb=v,o.xb=I,o.Ea=R,o.zb=G,o.Ab=oe,d=(te,ee,ne)=>(...fe)=>{let be=tt,E=ee?.();fe=te(...fe);let ue=ee?.();return E!==ue&&(te=ue,ne(E),ee=ne=null),tt!=be?tu():fe},f=te=>async(...ee)=>{try{if(o.bb)throw Error("Session already started");let ne=o.bb={Fb:ee[0],errors:[]},fe=await te(...ee);if(o.bb!==ne)throw Error("Session mismatch");a.flush();let be=ne.errors;if(0<be.length){let E=await Promise.all(be);if(E=E.filter(ue=>ue),0<E.length)throw Error(E.join(`\n`))}return fe}finally{o.bb=null}},o._OrtRun=f(d(o._OrtRun,()=>o._OrtRun,te=>o._OrtRun=te)),o._OrtRunWithBinding=f(d(o._OrtRunWithBinding,()=>o._OrtRunWithBinding,te=>o._OrtRunWithBinding=te)),o._OrtBindInput=d(o._OrtBindInput,()=>o._OrtBindInput,te=>o._OrtBindInput=te),o.jsepRegisterBuffer=(te,ee,ne,fe)=>a.registerBuffer(te,ee,ne,fe),o.jsepUnregisterBuffers=te=>{a.unregisterBuffers(te)},o.jsepGetBuffer=te=>a.getBuffer(te),o.jsepCreateDownloader=(te,ee,ne)=>a.createDownloader(te,ee,ne)};var x=Object.assign({},o),b="./this.program",w=(a,d)=>{throw d},$=typeof window=="object",y=typeof importScripts=="function",C=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",A=o.ENVIRONMENT_IS_PTHREAD||!1,P="";function W(a){return o.locateFile?o.locateFile(a,P):P+a}var B,D,_;if(C){var z=(tn(),Et(en)),N=(nn(),Et(rn));P=y?N.dirname(P)+"/":__dirname+"/",B=(d,f)=>(d=d.startsWith("file://")?new URL(d):N.normalize(d),z.readFileSync(d,f?void 0:"utf8")),_=d=>(d=B(d,!0),d.buffer||(d=new Uint8Array(d)),d),D=(d,f,v,I=!0)=>{d=d.startsWith("file://")?new URL(d):N.normalize(d),z.readFile(d,I?void 0:"utf8",(R,G)=>{R?v(R):f(I?G.buffer:G)})},!o.thisProgram&&1<process.argv.length&&(b=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),w=(d,f)=>{throw process.exitCode=d,f},o.inspect=()=>"[Emscripten Module object]";let a;try{a=io()}catch(d){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),d}global.Worker=a.Worker}else($||y)&&(y?P=self.location.href:typeof document<"u"&&document.currentScript&&(P=document.currentScript.src),typeof e<"u"&&e&&(P=e),P.indexOf("blob:")!==0?P=P.substr(0,P.replace(/[?#].*/,"").lastIndexOf("/")+1):P="",C||(B=a=>{var d=new XMLHttpRequest;return d.open("GET",a,!1),d.send(null),d.responseText},y&&(_=a=>{var d=new XMLHttpRequest;return d.open("GET",a,!1),d.responseType="arraybuffer",d.send(null),new Uint8Array(d.response)}),D=(a,d,f)=>{var v=new XMLHttpRequest;v.open("GET",a,!0),v.responseType="arraybuffer",v.onload=()=>{v.status==200||v.status==0&&v.response?d(v.response):f()},v.onerror=f,v.send(null)}));C&&typeof performance>"u"&&(global.performance=so().performance);var Y=console.log.bind(console),le=console.error.bind(console);C&&(Y=(...a)=>z.writeSync(1,a.join(" ")+`\n`),le=(...a)=>z.writeSync(2,a.join(" ")+`\n`));var M=o.print||Y,q=o.printErr||le;Object.assign(o,x),x=null,o.thisProgram&&(b=o.thisProgram),o.quit&&(w=o.quit);var Ce;o.wasmBinary&&(Ce=o.wasmBinary);var ae=o.noExitRuntime||!0;typeof WebAssembly!="object"&&je("no native wasm support detected");var we,K,Se,Be=!1,xe,Ie,Ze,Ge,it,V,ce;function pe(){var a=we.buffer;o.HEAP8=Ie=new Int8Array(a),o.HEAP16=new Int16Array(a),o.HEAP32=Ge=new Int32Array(a),o.HEAPU8=Ze=new Uint8Array(a),o.HEAPU16=new Uint16Array(a),o.HEAPU32=it=new Uint32Array(a),o.HEAPF32=V=new Float32Array(a),o.HEAPF64=ce=new Float64Array(a)}var ze=o.INITIAL_MEMORY||16777216;if(5242880<=ze||je("INITIAL_MEMORY should be larger than STACK_SIZE, was "+ze+"! (STACK_SIZE=5242880)"),A)we=o.wasmMemory;else if(o.wasmMemory)we=o.wasmMemory;else if(we=new WebAssembly.Memory({initial:ze/65536,maximum:65536,shared:!0}),!(we.buffer instanceof SharedArrayBuffer))throw q("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),C&&q("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");pe(),ze=we.buffer.byteLength;var Ve=[],Ee=[],Te=[],He=0;function Le(){return ae||0<He}var Ue=0,Pt=null,lt=null;function ir(){Ue++,o.monitorRunDependencies&&o.monitorRunDependencies(Ue)}function Rt(){if(Ue--,o.monitorRunDependencies&&o.monitorRunDependencies(Ue),Ue==0&&(Pt!==null&&(clearInterval(Pt),Pt=null),lt)){var a=lt;lt=null,a()}}function je(a){throw o.onAbort&&o.onAbort(a),a="Aborted("+a+")",q(a),Be=!0,xe=1,a=new WebAssembly.RuntimeError(a+". Build with -sASSERTIONS for more info."),g(a),a}function Ke(a){return a.startsWith("data:application/octet-stream;base64,")}var Qe;Qe="ort-wasm-simd-threaded.wasm",Ke(Qe)||(Qe=W(Qe));function vt(a){if(a==Qe&&Ce)return new Uint8Array(Ce);if(_)return _(a);throw"both async and sync fetching of the wasm failed"}function ct(a){if(!Ce&&($||y)){if(typeof fetch=="function"&&!a.startsWith("file://"))return fetch(a,{credentials:"same-origin"}).then(d=>{if(!d.ok)throw"failed to load wasm binary file at \'"+a+"\'";return d.arrayBuffer()}).catch(()=>vt(a));if(D)return new Promise((d,f)=>{D(a,v=>d(new Uint8Array(v)),f)})}return Promise.resolve().then(()=>vt(a))}function Bt(a,d,f){return ct(a).then(v=>WebAssembly.instantiate(v,d)).then(v=>v).then(f,v=>{q("failed to asynchronously prepare wasm: "+v),je(v)})}function sr(a,d){var f=Qe;return Ce||typeof WebAssembly.instantiateStreaming!="function"||Ke(f)||f.startsWith("file://")||C||typeof fetch!="function"?Bt(f,a,d):fetch(f,{credentials:"same-origin"}).then(v=>WebAssembly.instantiateStreaming(v,a).then(d,function(I){return q("wasm streaming compile failed: "+I),q("falling back to ArrayBuffer instantiation"),Bt(f,a,d)}))}var st,mt={1420080:a=>{o.Ea("Abs",a,void 0)},1420131:a=>{o.Ea("Neg",a,void 0)},1420182:a=>{o.Ea("Floor",a,void 0)},1420235:a=>{o.Ea("Ceil",a,void 0)},1420287:a=>{o.Ea("Reciprocal",a,void 0)},1420345:a=>{o.Ea("Sqrt",a,void 0)},1420397:a=>{o.Ea("Exp",a,void 0)},1420448:a=>{o.Ea("Erf",a,void 0)},1420499:a=>{o.Ea("Sigmoid",a,void 0)},1420554:a=>{o.Ea("Log",a,void 0)},1420605:a=>{o.Ea("Sin",a,void 0)},1420656:a=>{o.Ea("Cos",a,void 0)},1420707:a=>{o.Ea("Tan",a,void 0)},1420758:a=>{o.Ea("Asin",a,void 0)},1420810:a=>{o.Ea("Acos",a,void 0)},1420862:a=>{o.Ea("Atan",a,void 0)},1420914:a=>{o.Ea("Sinh",a,void 0)},1420966:a=>{o.Ea("Cosh",a,void 0)},1421018:a=>{o.Ea("Asinh",a,void 0)},1421071:a=>{o.Ea("Acosh",a,void 0)},1421124:a=>{o.Ea("Atanh",a,void 0)},1421177:a=>{o.Ea("Tanh",a,void 0)},1421229:a=>{o.Ea("Not",a,void 0)},1421280:(a,d,f)=>{o.Ea("ClipV10",a,{min:d,max:f})},1421352:a=>{o.Ea("Clip",a,void 0)},1421404:(a,d)=>{o.Ea("Elu",a,{alpha:d})},1421462:a=>{o.Ea("Relu",a,void 0)},1421514:(a,d)=>{o.Ea("LeakyRelu",a,{alpha:d})},1421578:(a,d)=>{o.Ea("ThresholdedRelu",a,{alpha:d})},1421648:a=>{o.zb(a)},1421682:(a,d)=>o.Ab(a,d,o.bb.Fb,o.bb.errors),1421794:(a,d)=>{o.Ea("Cast",a,{to:d})},1421852:a=>{o.Ea("Add",a,void 0)},1421903:a=>{o.Ea("Sub",a,void 0)},1421954:a=>{o.Ea("Mul",a,void 0)},1422005:a=>{o.Ea("Div",a,void 0)},1422056:a=>{o.Ea("Pow",a,void 0)},1422107:a=>{o.Ea("Equal",a,void 0)},1422160:a=>{o.Ea("Greater",a,void 0)},1422215:a=>{o.Ea("GreaterOrEqual",a,void 0)},1422277:a=>{o.Ea("Less",a,void 0)},1422329:a=>{o.Ea("LessOrEqual",a,void 0)},1422388:(a,d,f,v,I)=>{o.Ea("ReduceMean",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:v?Array.from(n().subarray(I>>>0,I+v>>>0)):[]})},1422552:(a,d,f,v,I)=>{o.Ea("ReduceMax",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:v?Array.from(n().subarray(I>>>0,I+v>>>0)):[]})},1422715:(a,d,f,v,I)=>{o.Ea("ReduceMin",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:v?Array.from(n().subarray(I>>>0,I+v>>>0)):[]})},1422878:(a,d,f,v,I)=>{o.Ea("ReduceProd",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:v?Array.from(n().subarray(I>>>0,I+v>>>0)):[]})},1423042:(a,d,f,v,I)=>{o.Ea("ReduceSum",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:v?Array.from(n().subarray(I>>>0,I+v>>>0)):[]})},1423205:(a,d,f,v,I)=>{o.Ea("ReduceL1",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:v?Array.from(n().subarray(I>>>0,I+v>>>0)):[]})},1423367:(a,d,f,v,I)=>{o.Ea("ReduceL2",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:v?Array.from(n().subarray(I>>>0,I+v>>>0)):[]})},1423529:(a,d,f,v,I)=>{o.Ea("ReduceLogSum",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:v?Array.from(n().subarray(I>>>0,I+v>>>0)):[]})},1423695:(a,d,f,v,I)=>{o.Ea("ReduceSumSquare",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:v?Array.from(n().subarray(I>>>0,I+v>>>0)):[]})},1423864:(a,d,f,v,I)=>{o.Ea("ReduceLogSumExp",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:v?Array.from(n().subarray(I>>>0,I+v>>>0)):[]})},1424033:a=>{o.Ea("Where",a,void 0)},1424086:(a,d,f)=>{o.Ea("Transpose",a,{perm:d?Array.from(n().subarray(f>>>0,f+d>>>0)):[]})},1424199:(a,d,f,v,I,R,G,oe,te,ee,ne,fe,be)=>{o.Ea("Conv",a,{format:te?"NHWC":"NCHW",auto_pad:d,dilations:[f],group:v,kernel_shape:[I],pads:R?Array.from(n().subarray(G>>>0,G+R>>>0)):[],strides:[oe],w_is_const:()=>!!r()[ee>>>0],activation:We(ne),activation_params:fe?Array.from(u().subarray(be>>>0,be+fe>>>0)):[]})},1424580:(a,d,f,v,I,R,G,oe,te,ee,ne,fe,be,E,ue,ye)=>{o.Ea("Conv",a,{format:fe?"NHWC":"NCHW",auto_pad:d,dilations:[f,v],group:I,kernel_shape:[R,G],pads:oe?Array.from(n().subarray(te>>>0,te+oe>>>0)):[],strides:[ee,ne],w_is_const:()=>!!r()[be>>>0],activation:We(E),activation_params:ue?Array.from(u().subarray(ye>>>0,ye+ue>>>0)):[]})},1424982:(a,d,f,v,I,R,G,oe,te,ee,ne,fe,be,E,ue)=>{o.Ea("ConvTranspose",a,{format:te?"NHWC":"NCHW",autoPad:d,dilations:[f],group:v,kernel_shape:[I],pads:[R,G],strides:[oe],wIsConst:()=>!!r()[ee>>>0],outputPadding:ne?Array.from(n().subarray(fe>>>0,fe+ne>>>0)):[],outputShape:be?Array.from(n().subarray(E>>>0,E+be>>>0)):[],activation:We(ue)})},1425396:(a,d,f,v,I,R,G,oe,te,ee,ne,fe,be,E)=>{o.Ea("ConvTranspose",a,{format:oe?"NHWC":"NCHW",autoPad:d,dilations:Array.from(n().subarray(f>>>0,f+2>>>0)),group:v,kernelShape:Array.from(n().subarray(I>>>0,I+2>>>0)),pads:Array.from(n().subarray(R>>>0,R+4>>>0)),strides:Array.from(n().subarray(G>>>0,G+2>>>0)),wIsConst:()=>!!r()[te>>>0],outputPadding:0<ee?Array.from(n().subarray(ne>>>0,ne+ee>>>0)):[],outputShape:0<fe?Array.from(n().subarray(be>>>0,be+fe>>>0)):[],activation:We(E)})},1425953:(a,d,f,v,I,R,G,oe,te,ee,ne,fe,be,E,ue)=>{o.Ea("ConvTranspose",a,{format:te?"NHWC":"NCHW",autoPad:d,dilations:[f],group:v,kernel_shape:[I],pads:[R,G],strides:[oe],wIsConst:()=>!!r()[ee>>>0],outputPadding:ne?Array.from(n().subarray(fe>>>0,fe+ne>>>0)):[],outputShape:be?Array.from(n().subarray(E>>>0,E+be>>>0)):[],activation:We(ue)})},1426367:(a,d,f,v,I,R,G,oe,te,ee,ne,fe,be,E)=>{o.Ea("ConvTranspose",a,{format:oe?"NHWC":"NCHW",autoPad:d,dilations:Array.from(n().subarray(f>>>0,f+2>>>0)),group:v,kernelShape:Array.from(n().subarray(I>>>0,I+2>>>0)),pads:Array.from(n().subarray(R>>>0,R+4>>>0)),strides:Array.from(n().subarray(G>>>0,G+2>>>0)),wIsConst:()=>!!r()[te>>>0],outputPadding:0<ee?Array.from(n().subarray(ne>>>0,ne+ee>>>0)):[],outputShape:0<fe?Array.from(n().subarray(be>>>0,be+fe>>>0)):[],activation:We(E)})},1426924:(a,d)=>{o.Ea("GlobalAveragePool",a,{format:d?"NHWC":"NCHW"})},1427015:(a,d,f,v,I,R,G,oe,te,ee,ne,fe,be,E,ue,ye)=>{o.Ea("AveragePool",a,{format:ye?"NHWC":"NCHW",auto_pad:d,ceil_mode:f,count_include_pad:v,storage_order:I,dilations:[R,G],kernel_shape:[oe,te],pads:[ee,ne,fe,be],strides:[E,ue]})},1427299:(a,d)=>{o.Ea("GlobalAveragePool",a,{format:d?"NHWC":"NCHW"})},1427390:(a,d,f,v,I,R,G,oe,te,ee,ne,fe,be,E,ue,ye)=>{o.Ea("AveragePool",a,{format:ye?"NHWC":"NCHW",auto_pad:d,ceil_mode:f,count_include_pad:v,storage_order:I,dilations:[R,G],kernel_shape:[oe,te],pads:[ee,ne,fe,be],strides:[E,ue]})},1427674:(a,d)=>{o.Ea("GlobalMaxPool",a,{format:d?"NHWC":"NCHW"})},1427761:(a,d,f,v,I,R,G,oe,te,ee,ne,fe,be,E,ue,ye)=>{o.Ea("MaxPool",a,{format:ye?"NHWC":"NCHW",auto_pad:d,ceil_mode:f,count_include_pad:v,storage_order:I,dilations:[R,G],kernel_shape:[oe,te],pads:[ee,ne,fe,be],strides:[E,ue]})},1428041:(a,d)=>{o.Ea("GlobalMaxPool",a,{format:d?"NHWC":"NCHW"})},1428128:(a,d,f,v,I,R,G,oe,te,ee,ne,fe,be,E,ue,ye)=>{o.Ea("MaxPool",a,{format:ye?"NHWC":"NCHW",auto_pad:d,ceil_mode:f,count_include_pad:v,storage_order:I,dilations:[R,G],kernel_shape:[oe,te],pads:[ee,ne,fe,be],strides:[E,ue]})},1428408:(a,d,f,v,I)=>{o.Ea("Gemm",a,{alpha:d,beta:f,transA:v,transB:I})},1428512:a=>{o.Ea("MatMul",a,void 0)},1428566:(a,d,f,v)=>{o.Ea("ArgMax",a,{keepDims:!!d,selectLastIndex:!!f,axis:v})},1428674:(a,d,f,v)=>{o.Ea("ArgMin",a,{keepDims:!!d,selectLastIndex:!!f,axis:v})},1428782:(a,d)=>{o.Ea("Softmax",a,{axis:d})},1428845:(a,d)=>{o.Ea("Concat",a,{axis:d})},1428905:(a,d,f,v,I)=>{o.Ea("Split",a,{axis:d,numOutputs:f,splitSizes:v?Array.from(n().subarray(I>>>0,I+v>>>0)):[]})},1429050:a=>{o.Ea("Expand",a,void 0)},1429104:(a,d)=>{o.Ea("Gather",a,{axis:Number(d)})},1429175:(a,d)=>{o.Ea("GatherElements",a,{axis:Number(d)})},1429254:(a,d,f,v,I,R,G,oe,te,ee,ne)=>{o.Ea("Resize",a,{antialias:d,axes:f?Array.from(n().subarray(v>>>0,v+f>>>0)):[],coordinateTransformMode:We(I),cubicCoeffA:R,excludeOutside:G,extrapolationValue:oe,keepAspectRatioPolicy:We(te),mode:We(ee),nearestMode:We(ne)})},1429605:(a,d,f,v,I,R,G)=>{o.Ea("Slice",a,{starts:d?Array.from(n().subarray(f>>>0,f+d>>>0)):[],ends:v?Array.from(n().subarray(I>>>0,I+v>>>0)):[],axes:R?Array.from(n().subarray(G>>>0,G+R>>>0)):[]})},1429836:a=>{o.Ea("Tile",a,void 0)},1429888:(a,d,f)=>{o.Ea("LayerNormalization",a,{axis:Number(d),epsilon:Number(f)})},1429995:(a,d,f)=>{o.Ea("InstanceNormalization",a,{epsilon:d,format:f?"NHWC":"NCHW"})},1430109:(a,d,f)=>{o.Ea("InstanceNormalization",a,{epsilon:d,format:f?"NHWC":"NCHW"})},1430223:a=>{o.Ea("Range",a,void 0)},1430276:(a,d)=>{o.Ea("Einsum",a,{equation:We(d)})},1430357:(a,d,f,v,I)=>{o.Ea("Pad",a,{mode:d,value:f,pads:v?Array.from(n().subarray(I>>>0,I+v>>>0)):[]})},1430489:a=>{o.Ea("Gelu",a,void 0)},1430541:a=>{o.Ea("BiasAdd",a,void 0)},1430596:a=>{o.Ea("BiasSplitGelu",a,void 0)},1430657:(a,d)=>{o.Ea("SkipLayerNormalization",a,{epsilon:d})},1430738:a=>o.wb(a),1430771:a=>o.yb(a),1430803:(a,d,f)=>{o.jb(a,d,f,!0)},1430842:(a,d,f)=>{o.jb(a,d,f)}};function ht(a){this.name="ExitStatus",this.message=`Program terminated with exit(${a})`,this.status=a}function gt(a){a.terminate(),a.onmessage=()=>{}}function Mt(a){(a=re.Qa[a])||je(),re.Eb(a)}function $t(a){var d=re.tb();if(!d)return 6;re.Ya.push(d),re.Qa[a.Xa]=d,d.Xa=a.Xa;var f={cmd:"run",start_routine:a.Gb,arg:a.rb,pthread_ptr:a.Xa};return C&&d.unref(),d.postMessage(f,a.Mb),0}var ur=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,kt=(a,d,f)=>{d>>>=0;var v=d+f;for(f=d;a[f]&&!(f>=v);)++f;if(16<f-d&&a.buffer&&ur)return ur.decode(a.buffer instanceof SharedArrayBuffer?a.slice(d,f):a.subarray(d,f));for(v="";d<f;){var I=a[d++];if(I&128){var R=a[d++]&63;if((I&224)==192)v+=String.fromCharCode((I&31)<<6|R);else{var G=a[d++]&63;I=(I&240)==224?(I&15)<<12|R<<6|G:(I&7)<<18|R<<12|G<<6|a[d++]&63,65536>I?v+=String.fromCharCode(I):(I-=65536,v+=String.fromCharCode(55296|I>>10,56320|I&1023))}}else v+=String.fromCharCode(I)}return v},We=(a,d)=>(a>>>=0)?kt(i(),a,d):"";function lr(a){if(A)return L(1,1,a);xe=a,Le()||(re.Hb(),o.onExit&&o.onExit(a),Be=!0),w(a,new ht(a))}var xt=a=>{if(xe=a,A)throw qe(a),"unwind";lr(a)},re={ab:[],Ya:[],mb:[],Qa:{},gb:function(){A?re.vb():re.ub()},ub:function(){Ve.unshift(()=>{ir(),re.Bb(()=>Rt())})},vb:function(){re.receiveObjectTransfer=re.Db,re.threadInitTLS=re.lb,re.setExitStatus=re.kb,ae=!1},kb:function(a){xe=a},Sb:["$terminateWorker"],Hb:function(){for(var a of re.Ya)gt(a);for(a of re.ab)gt(a);re.ab=[],re.Ya=[],re.Qa=[]},Eb:function(a){var d=a.Xa;delete re.Qa[d],re.ab.push(a),re.Ya.splice(re.Ya.indexOf(a),1),a.Xa=0,Yr(d)},Db:function(){},lb:function(){re.mb.forEach(a=>a())},Cb:a=>new Promise(d=>{a.onmessage=R=>{R=R.data;var G=R.cmd;if(R.targetThread&&R.targetThread!=wr()){var oe=re.Qa[R.Rb];oe?oe.postMessage(R,R.transferList):q(\'Internal error! Worker sent a message "\'+G+\'" to target pthread \'+R.targetThread+", but that thread no longer exists!")}else G==="checkMailbox"?Ot():G==="spawnThread"?$t(R):G==="cleanupThread"?Mt(R.thread):G==="killThread"?(R=R.thread,G=re.Qa[R],delete re.Qa[R],gt(G),Yr(R),re.Ya.splice(re.Ya.indexOf(G),1),G.Xa=0):G==="cancelThread"?re.Qa[R.thread].postMessage({cmd:"cancel"}):G==="loaded"?(a.loaded=!0,d(a)):G==="alert"?alert("Thread "+R.threadId+": "+R.text):R.target==="setimmediate"?a.postMessage(R):G==="callHandler"?o[R.handler](...R.args):G&&q("worker sent an unknown command "+G)},a.onerror=R=>{throw q("worker sent an error! "+R.filename+":"+R.lineno+": "+R.message),R},C&&(a.on("message",function(R){a.onmessage({data:R})}),a.on("error",function(R){a.onerror(R)}));var f=[],v=["onExit","onAbort","print","printErr"],I;for(I of v)o.hasOwnProperty(I)&&f.push(I);a.postMessage({cmd:"load",handlers:f,urlOrBlob:o.mainScriptUrlOrBlob||e,wasmMemory:we,wasmModule:Se})}),Bb:function(a){a()},qb:function(){var a=W("ort-wasm-simd-threaded.worker.js");a=new Worker(a),re.ab.push(a)},tb:function(){return re.ab.length==0&&(re.qb(),re.Cb(re.ab[0])),re.ab.pop()}};o.PThread=re;var Ct=a=>{for(;0<a.length;)a.shift()(o)};o.establishStackSpace=function(){var a=wr(),d=n()[a+52>>2>>>0];a=n()[a+56>>2>>>0],Yn(d,d-a),vr(d)};function qe(a){if(A)return L(2,0,a);xt(a)}o.invokeEntryPoint=function(a,d){a=Xn.apply(null,[a,d]),Le()?re.kb(a):Xr(a)};function Ne(a){this.fb=a-24,this.pb=function(d){s()[this.fb+4>>2>>>0]=d},this.ob=function(d){s()[this.fb+8>>2>>>0]=d},this.gb=function(d,f){this.nb(),this.pb(d),this.ob(f)},this.nb=function(){s()[this.fb+16>>2>>>0]=0}}var Dt=0,St=0;function Wt(a,d,f,v){return A?L(3,1,a,d,f,v):zt(a,d,f,v)}function zt(a,d,f,v){if(a>>>=0,d>>>=0,f>>>=0,v>>>=0,typeof SharedArrayBuffer>"u")return q("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var I=[];return A&&I.length===0?Wt(a,d,f,v):(a={Gb:f,Xa:a,rb:v,Mb:I},A?(a.Ob="spawnThread",postMessage(a,I),0):$t(a))}function cr(a,d,f){return A?L(4,1,a,d,f):0}function At(a,d){if(A)return L(5,1,a,d)}var Gt=a=>{for(var d=0,f=0;f<a.length;++f){var v=a.charCodeAt(f);127>=v?d++:2047>=v?d+=2:55296<=v&&57343>=v?(d+=4,++f):d+=3}return d},dr=(a,d,f,v)=>{if(f>>>=0,!(0<v))return 0;var I=f;v=f+v-1;for(var R=0;R<a.length;++R){var G=a.charCodeAt(R);if(55296<=G&&57343>=G){var oe=a.charCodeAt(++R);G=65536+((G&1023)<<10)|oe&1023}if(127>=G){if(f>=v)break;d[f++>>>0]=G}else{if(2047>=G){if(f+1>=v)break;d[f++>>>0]=192|G>>6}else{if(65535>=G){if(f+2>=v)break;d[f++>>>0]=224|G>>12}else{if(f+3>=v)break;d[f++>>>0]=240|G>>18,d[f++>>>0]=128|G>>12&63}d[f++>>>0]=128|G>>6&63}d[f++>>>0]=128|G&63}}return d[f>>>0]=0,f-I},pr=(a,d,f)=>dr(a,i(),d,f);function fr(a,d){if(A)return L(6,1,a,d)}function mr(a,d,f){if(A)return L(7,1,a,d,f)}function hr(a,d,f){return A?L(8,1,a,d,f):0}function It(a,d){if(A)return L(9,1,a,d)}function Vt(a,d,f){if(A)return L(10,1,a,d,f)}function Ut(a,d,f,v){if(A)return L(11,1,a,d,f,v)}function Nt(a,d,f,v){if(A)return L(12,1,a,d,f,v)}function Ft(a,d,f,v){if(A)return L(13,1,a,d,f,v)}function Ht(a){if(A)return L(14,1,a)}function Lt(a,d){if(A)return L(15,1,a,d)}function jt(a,d,f){if(A)return L(16,1,a,d,f)}var Kt=a=>{if(!Be)try{if(a(),!Le())try{A?Xr(xe):xt(xe)}catch(d){d instanceof ht||d=="unwind"||w(1,d)}}catch(d){d instanceof ht||d=="unwind"||w(1,d)}};function Tt(a){a>>>=0,typeof Atomics.Nb=="function"&&(Atomics.Nb(n(),a>>2,a).value.then(Ot),a+=128,Atomics.store(n(),a>>2,1))}o.__emscripten_thread_mailbox_await=Tt;function Ot(){var a=wr();a&&(Tt(a),Kt(()=>Kn()))}o.checkMailbox=Ot;var Ye=a=>a%4===0&&(a%100!==0||a%400===0),qt=[0,31,60,91,121,152,182,213,244,274,305,335],l=[0,31,59,90,120,151,181,212,243,273,304,334];function p(a,d,f,v,I,R,G,oe){return A?L(17,1,a,d,f,v,I,R,G,oe):-52}function h(a,d,f,v,I,R,G){if(A)return L(18,1,a,d,f,v,I,R,G)}var S=a=>{var d=Gt(a)+1,f=qr(d);return f&&pr(a,f,d),f},T=[],U=(a,d)=>{T.length=0;var f;for(d>>=2;f=i()[a++>>>0];)d+=f!=105&d,T.push(f==105?n()[d>>>0]:c()[d++>>>1]),++d;return T},H=a=>{var d=Jr();return a=a(),vr(d),a};function L(a,d){var f=arguments.length-2,v=arguments;return H(()=>{for(var I=Zr(8*f),R=I>>3,G=0;G<f;G++){var oe=v[2+G];c()[R+G>>>0]=oe}return jn(a,f,I,d)})}var X=[],J={},Q=()=>{if(!de){var a={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:b||"./this.program"},d;for(d in J)J[d]===void 0?delete a[d]:a[d]=J[d];var f=[];for(d in a)f.push(`${d}=${a[d]}`);de=f}return de},de;function me(a,d){if(A)return L(19,1,a,d);a>>>=0,d>>>=0;var f=0;return Q().forEach(function(v,I){var R=d+f;for(I=s()[a+4*I>>2>>>0]=R,R=0;R<v.length;++R)r()[I++>>0>>>0]=v.charCodeAt(R);r()[I>>0>>>0]=0,f+=v.length+1}),0}function O(a,d){if(A)return L(20,1,a,d);a>>>=0,d>>>=0;var f=Q();s()[a>>2>>>0]=f.length;var v=0;return f.forEach(function(I){v+=I.length+1}),s()[d>>2>>>0]=v,0}function se(a){return A?L(21,1,a):52}function ge(a,d,f,v){return A?L(22,1,a,d,f,v):52}function et(a,d,f,v,I){return A?L(23,1,a,d,f,v,I):70}var gr=[null,[],[]];function Wn(a,d,f,v){if(A)return L(24,1,a,d,f,v);d>>>=0,f>>>=0,v>>>=0;for(var I=0,R=0;R<f;R++){var G=s()[d>>2>>>0],oe=s()[d+4>>2>>>0];d+=8;for(var te=0;te<oe;te++){var ee=i()[G+te>>>0],ne=gr[a];ee===0||ee===10?((a===1?M:q)(kt(ne,0)),ne.length=0):ne.push(ee)}I+=oe}return s()[v>>2>>>0]=I,0}var zn=[31,29,31,30,31,30,31,31,30,31,30,31],Gn=[31,28,31,30,31,30,31,31,30,31,30,31];function Xs(a){var d=Array(Gt(a)+1);return dr(a,d,0,d.length),d}var Js=(a,d)=>{r().set(a,d>>>0)};function Vn(a,d,f,v){function I(E,ue,ye){for(E=typeof E=="number"?E.toString():E||"";E.length<ue;)E=ye[0]+E;return E}function R(E,ue){return I(E,ue,"0")}function G(E,ue){function ye(ro){return 0>ro?-1:0<ro?1:0}var yt;return(yt=ye(E.getFullYear()-ue.getFullYear()))===0&&(yt=ye(E.getMonth()-ue.getMonth()))===0&&(yt=ye(E.getDate()-ue.getDate())),yt}function oe(E){switch(E.getDay()){case 0:return new Date(E.getFullYear()-1,11,29);case 1:return E;case 2:return new Date(E.getFullYear(),0,3);case 3:return new Date(E.getFullYear(),0,2);case 4:return new Date(E.getFullYear(),0,1);case 5:return new Date(E.getFullYear()-1,11,31);case 6:return new Date(E.getFullYear()-1,11,30)}}function te(E){var ue=E.Za;for(E=new Date(new Date(E.$a+1900,0,1).getTime());0<ue;){var ye=E.getMonth(),yt=(Ye(E.getFullYear())?zn:Gn)[ye];if(ue>yt-E.getDate())ue-=yt-E.getDate()+1,E.setDate(1),11>ye?E.setMonth(ye+1):(E.setMonth(0),E.setFullYear(E.getFullYear()+1));else{E.setDate(E.getDate()+ue);break}}return ye=new Date(E.getFullYear()+1,0,4),ue=oe(new Date(E.getFullYear(),0,4)),ye=oe(ye),0>=G(ue,E)?0>=G(ye,E)?E.getFullYear()+1:E.getFullYear():E.getFullYear()-1}a>>>=0,d>>>=0,f>>>=0,v>>>=0;var ee=n()[v+40>>2>>>0];v={Kb:n()[v>>2>>>0],Jb:n()[v+4>>2>>>0],cb:n()[v+8>>2>>>0],ib:n()[v+12>>2>>>0],eb:n()[v+16>>2>>>0],$a:n()[v+20>>2>>>0],Wa:n()[v+24>>2>>>0],Za:n()[v+28>>2>>>0],Tb:n()[v+32>>2>>>0],Ib:n()[v+36>>2>>>0],Lb:ee?We(ee):""},f=We(f),ee={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ne in ee)f=f.replace(new RegExp(ne,"g"),ee[ne]);var fe="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),be="January February March April May June July August September October November December".split(" ");ee={"%a":E=>fe[E.Wa].substring(0,3),"%A":E=>fe[E.Wa],"%b":E=>be[E.eb].substring(0,3),"%B":E=>be[E.eb],"%C":E=>R((E.$a+1900)/100|0,2),"%d":E=>R(E.ib,2),"%e":E=>I(E.ib,2," "),"%g":E=>te(E).toString().substring(2),"%G":E=>te(E),"%H":E=>R(E.cb,2),"%I":E=>(E=E.cb,E==0?E=12:12<E&&(E-=12),R(E,2)),"%j":E=>{for(var ue=0,ye=0;ye<=E.eb-1;ue+=(Ye(E.$a+1900)?zn:Gn)[ye++]);return R(E.ib+ue,3)},"%m":E=>R(E.eb+1,2),"%M":E=>R(E.Jb,2),"%n":()=>`\n`,"%p":E=>0<=E.cb&&12>E.cb?"AM":"PM","%S":E=>R(E.Kb,2),"%t":()=>"	","%u":E=>E.Wa||7,"%U":E=>R(Math.floor((E.Za+7-E.Wa)/7),2),"%V":E=>{var ue=Math.floor((E.Za+7-(E.Wa+6)%7)/7);if(2>=(E.Wa+371-E.Za-2)%7&&ue++,ue)ue==53&&(ye=(E.Wa+371-E.Za)%7,ye==4||ye==3&&Ye(E.$a)||(ue=1));else{ue=52;var ye=(E.Wa+7-E.Za-1)%7;(ye==4||ye==5&&Ye(E.$a%400-1))&&ue++}return R(ue,2)},"%w":E=>E.Wa,"%W":E=>R(Math.floor((E.Za+7-(E.Wa+6)%7)/7),2),"%y":E=>(E.$a+1900).toString().substring(2),"%Y":E=>E.$a+1900,"%z":E=>{E=E.Ib;var ue=0<=E;return E=Math.abs(E)/60,(ue?"+":"-")+("0000"+(E/60*100+E%60)).slice(-4)},"%Z":E=>E.Lb,"%%":()=>"%"},f=f.replace(/%%/g,"\\0\\0");for(ne in ee)f.includes(ne)&&(f=f.replace(new RegExp(ne,"g"),ee[ne](v)));return f=f.replace(/\\0\\0/g,"%"),ne=Xs(f),ne.length>d?0:(Js(ne,a),ne.length-1)}function yr(a){try{a()}catch(d){je(d)}}function Zs(a){var d={},f;for(f in a)(function(v){var I=a[v];d[v]=typeof I=="function"?function(){br.push(v);try{return I.apply(null,arguments)}finally{Be||(br.pop()===v||je(),tt&&dt===1&&br.length===0&&(dt=0,He+=1,yr(Zn),typeof Fibers<"u"&&Fibers.Ub()))}}:I})(f);return d}var dt=0,tt=null,Un=0,br=[],Nn={},Fn={},Qs=0,Kr=null,eu=[];function tu(){return new Promise((a,d)=>{Kr={resolve:a,reject:d}})}function ru(){var a=qr(65548),d=a+12;s()[a>>2>>>0]=d,s()[a+4>>2>>>0]=d+65536,d=br[0];var f=Nn[d];return f===void 0&&(f=Qs++,Nn[d]=f,Fn[f]=d),d=f,n()[a+8>>2>>>0]=d,a}function nu(){var a=n()[tt+8>>2>>>0];return a=K[Fn[a]],--He,a()}function ou(a){if(!Be){if(dt===0){var d=!1,f=!1;a((v=0)=>{if(!Be&&(Un=v,d=!0,f)){dt=2,yr(()=>Qn(tt)),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),v=!1;try{var I=nu()}catch(oe){I=oe,v=!0}var R=!1;if(!tt){var G=Kr;G&&(Kr=null,(v?G.reject:G.resolve)(I),R=!0)}if(v&&!R)throw I}}),f=!0,d||(dt=1,tt=ru(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),yr(()=>Jn(tt)))}else dt===2?(dt=0,yr(eo),Hn(tt),tt=null,eu.forEach(v=>Kt(v))):je(`invalid state: ${dt}`);return Un}}function au(a){return ou(d=>{a().then(d)})}re.gb();var iu=[null,lr,qe,Wt,cr,At,fr,mr,hr,It,Vt,Ut,Nt,Ft,Ht,Lt,jt,p,h,me,O,se,ge,et,Wn],su={r:function(a,d,f){return au(async()=>{await o.xb(a,d,f)})},b:function(a,d,f){throw a>>>=0,new Ne(a).gb(d>>>0,f>>>0),Dt=a,St++,Dt},P:function(a){Ln(a>>>0,!y,1,!$,131072,!1),re.lb()},n:function(a){a>>>=0,A?postMessage({cmd:"cleanupThread",thread:a}):Mt(a)},K:zt,g:cr,V:At,F:fr,H:mr,y:hr,T:It,L:Vt,S:Ut,p:Nt,G:Ft,D:Ht,U:Lt,E:jt,q:()=>!0,B:function(a,d){a>>>=0,a==d>>>0?setTimeout(()=>Ot()):A?postMessage({targetThread:a,cmd:"checkMailbox"}):(a=re.Qa[a])&&a.postMessage({cmd:"checkMailbox"})},N:function(){return-1},O:Tt,X:function(a){C&&re.Qa[a>>>0].ref()},u:function(a,d,f){a=d+2097152>>>0<4194305-!!a?(a>>>0)+4294967296*d:NaN,f>>>=0,a=new Date(1e3*a),n()[f>>2>>>0]=a.getUTCSeconds(),n()[f+4>>2>>>0]=a.getUTCMinutes(),n()[f+8>>2>>>0]=a.getUTCHours(),n()[f+12>>2>>>0]=a.getUTCDate(),n()[f+16>>2>>>0]=a.getUTCMonth(),n()[f+20>>2>>>0]=a.getUTCFullYear()-1900,n()[f+24>>2>>>0]=a.getUTCDay(),a=(a.getTime()-Date.UTC(a.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,n()[f+28>>2>>>0]=a},v:function(a,d,f){a=d+2097152>>>0<4194305-!!a?(a>>>0)+4294967296*d:NaN,f>>>=0,a=new Date(1e3*a),n()[f>>2>>>0]=a.getSeconds(),n()[f+4>>2>>>0]=a.getMinutes(),n()[f+8>>2>>>0]=a.getHours(),n()[f+12>>2>>>0]=a.getDate(),n()[f+16>>2>>>0]=a.getMonth(),n()[f+20>>2>>>0]=a.getFullYear()-1900,n()[f+24>>2>>>0]=a.getDay(),d=(Ye(a.getFullYear())?qt:l)[a.getMonth()]+a.getDate()-1|0,n()[f+28>>2>>>0]=d,n()[f+36>>2>>>0]=-(60*a.getTimezoneOffset()),d=new Date(a.getFullYear(),6,1).getTimezoneOffset();var v=new Date(a.getFullYear(),0,1).getTimezoneOffset();a=(d!=v&&a.getTimezoneOffset()==Math.min(v,d))|0,n()[f+32>>2>>>0]=a},w:function(a){a>>>=0;var d=new Date(n()[a+20>>2>>>0]+1900,n()[a+16>>2>>>0],n()[a+12>>2>>>0],n()[a+8>>2>>>0],n()[a+4>>2>>>0],n()[a>>2>>>0],0),f=n()[a+32>>2>>>0],v=d.getTimezoneOffset(),I=new Date(d.getFullYear(),6,1).getTimezoneOffset(),R=new Date(d.getFullYear(),0,1).getTimezoneOffset(),G=Math.min(R,I);return 0>f?n()[a+32>>2>>>0]=+(I!=R&&G==v):0<f!=(G==v)&&(I=Math.max(R,I),d.setTime(d.getTime()+6e4*((0<f?G:I)-v))),n()[a+24>>2>>>0]=d.getDay(),f=(Ye(d.getFullYear())?qt:l)[d.getMonth()]+d.getDate()-1|0,n()[a+28>>2>>>0]=f,n()[a>>2>>>0]=d.getSeconds(),n()[a+4>>2>>>0]=d.getMinutes(),n()[a+8>>2>>>0]=d.getHours(),n()[a+12>>2>>>0]=d.getDate(),n()[a+16>>2>>>0]=d.getMonth(),n()[a+20>>2>>>0]=d.getYear(),a=d.getTime()/1e3,qn((st=a,1<=+Math.abs(st)?0<st?+Math.floor(st/4294967296)>>>0:~~+Math.ceil((st-+(~~st>>>0))/4294967296)>>>0:0)),a>>>0},s:p,t:h,A:function(a,d,f){function v(ee){return(ee=ee.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?ee[1]:"GMT"}a>>>=0,d>>>=0,f>>>=0;var I=new Date().getFullYear(),R=new Date(I,0,1),G=new Date(I,6,1);I=R.getTimezoneOffset();var oe=G.getTimezoneOffset(),te=Math.max(I,oe);s()[a>>2>>>0]=60*te,n()[d>>2>>>0]=+(I!=oe),a=v(R),d=v(G),a=S(a),d=S(d),oe<I?(s()[f>>2>>>0]=a,s()[f+4>>2>>>0]=d):(s()[f>>2>>>0]=d,s()[f+4>>2>>>0]=a)},e:()=>{je("")},c:function(a,d,f){return a>>>=0,d=U(d>>>0,f>>>0),mt[a].apply(null,d)},l:function(a,d,f){return a>>>=0,d=U(d>>>0,f>>>0),mt[a].apply(null,d)},o:function(){},k:function(){return Date.now()},W:()=>{throw He+=1,"unwind"},C:function(){return 4294901760},d:()=>performance.timeOrigin+performance.now(),i:function(){return C?(lo(),Et(uo)).cpus().length:navigator.hardwareConcurrency},M:function(a,d,f,v){for(re.Pb=d>>>0,X.length=f,d=v>>>0>>3,v=0;v<f;v++)X[v]=c()[d+v>>>0];return(0>a?mt[-a-1]:iu[a]).apply(null,X)},z:function(a){a>>>=0;var d=i().length;if(a<=d||4294901760<a)return!1;for(var f=1;4>=f;f*=2){var v=d*(1+.2/f);v=Math.min(v,a+100663296);var I=Math;v=Math.max(a,v);e:{I=I.min.call(I,4294901760,v+(65536-v%65536)%65536)-we.buffer.byteLength+65535>>>16;try{we.grow(I),pe();var R=1;break e}catch{}R=void 0}if(R)return!0}return!1},Q:me,R:O,J:xt,h:se,m:ge,x:et,j:Wn,a:we||o.wasmMemory,I:Vn,f:function(a,d,f,v){return Vn(a>>>0,d>>>0,f>>>0,v>>>0)}};(function(){function a(f,v){return f=f.exports,f=Zs(f),K=f=uu(f),re.mb.push(K.Da),Ee.unshift(K.Y),Se=v,Rt(),f}var d={a:su};if(ir(),o.instantiateWasm)try{return o.instantiateWasm(d,a)}catch(f){q("Module.instantiateWasm callback failed with error: "+f),g(f)}return sr(d,function(f){a(f.instance,f.module)}).catch(g),{}})(),o._OrtInit=(a,d)=>(o._OrtInit=K.Z)(a,d),o._OrtGetLastError=(a,d)=>(o._OrtGetLastError=K._)(a,d),o._OrtCreateSessionOptions=(a,d,f,v,I,R,G,oe,te,ee)=>(o._OrtCreateSessionOptions=K.$)(a,d,f,v,I,R,G,oe,te,ee),o._OrtAppendExecutionProvider=(a,d)=>(o._OrtAppendExecutionProvider=K.aa)(a,d),o._OrtAddFreeDimensionOverride=(a,d,f)=>(o._OrtAddFreeDimensionOverride=K.ba)(a,d,f),o._OrtAddSessionConfigEntry=(a,d,f)=>(o._OrtAddSessionConfigEntry=K.ca)(a,d,f),o._OrtReleaseSessionOptions=a=>(o._OrtReleaseSessionOptions=K.da)(a),o._OrtCreateSession=(a,d,f)=>(o._OrtCreateSession=K.ea)(a,d,f),o._OrtReleaseSession=a=>(o._OrtReleaseSession=K.fa)(a),o._OrtGetInputOutputCount=(a,d,f)=>(o._OrtGetInputOutputCount=K.ga)(a,d,f),o._OrtGetInputName=(a,d)=>(o._OrtGetInputName=K.ha)(a,d),o._OrtGetOutputName=(a,d)=>(o._OrtGetOutputName=K.ia)(a,d),o._OrtFree=a=>(o._OrtFree=K.ja)(a),o._OrtCreateTensor=(a,d,f,v,I,R)=>(o._OrtCreateTensor=K.ka)(a,d,f,v,I,R),o._OrtGetTensorData=(a,d,f,v,I)=>(o._OrtGetTensorData=K.la)(a,d,f,v,I),o._OrtReleaseTensor=a=>(o._OrtReleaseTensor=K.ma)(a),o._OrtCreateRunOptions=(a,d,f,v)=>(o._OrtCreateRunOptions=K.na)(a,d,f,v),o._OrtAddRunConfigEntry=(a,d,f)=>(o._OrtAddRunConfigEntry=K.oa)(a,d,f),o._OrtReleaseRunOptions=a=>(o._OrtReleaseRunOptions=K.pa)(a),o._OrtCreateBinding=a=>(o._OrtCreateBinding=K.qa)(a),o._OrtBindInput=(a,d,f)=>(o._OrtBindInput=K.ra)(a,d,f),o._OrtBindOutput=(a,d,f,v)=>(o._OrtBindOutput=K.sa)(a,d,f,v),o._OrtClearBoundOutputs=a=>(o._OrtClearBoundOutputs=K.ta)(a),o._OrtReleaseBinding=a=>(o._OrtReleaseBinding=K.ua)(a),o._OrtRunWithBinding=(a,d,f,v,I)=>(o._OrtRunWithBinding=K.va)(a,d,f,v,I),o._OrtRun=(a,d,f,v,I,R,G,oe)=>(o._OrtRun=K.wa)(a,d,f,v,I,R,G,oe),o._OrtEndProfiling=a=>(o._OrtEndProfiling=K.xa)(a),o._JsepOutput=(a,d,f)=>(o._JsepOutput=K.ya)(a,d,f),o._JsepGetNodeName=a=>(o._JsepGetNodeName=K.za)(a);var wr=o._pthread_self=()=>(wr=o._pthread_self=K.Aa)(),qr=o._malloc=a=>(qr=o._malloc=K.Ba)(a),Hn=o._free=a=>(Hn=o._free=K.Ca)(a);o.__emscripten_tls_init=()=>(o.__emscripten_tls_init=K.Da)();var Ln=o.__emscripten_thread_init=(a,d,f,v,I,R)=>(Ln=o.__emscripten_thread_init=K.Fa)(a,d,f,v,I,R);o.__emscripten_thread_crashed=()=>(o.__emscripten_thread_crashed=K.Ga)();var jn=(a,d,f,v)=>(jn=K.Ha)(a,d,f,v),Yr=a=>(Yr=K.Ia)(a),Xr=o.__emscripten_thread_exit=a=>(Xr=o.__emscripten_thread_exit=K.Ja)(a),Kn=o.__emscripten_check_mailbox=()=>(Kn=o.__emscripten_check_mailbox=K.Ka)(),qn=a=>(qn=K.La)(a),Yn=(a,d)=>(Yn=K.Ma)(a,d),Jr=()=>(Jr=K.Na)(),vr=a=>(vr=K.Oa)(a),Zr=a=>(Zr=K.Pa)(a),Xn=o.dynCall_ii=(a,d)=>(Xn=o.dynCall_ii=K.Ra)(a,d),Jn=a=>(Jn=K.Sa)(a),Zn=()=>(Zn=K.Ta)(),Qn=a=>(Qn=K.Ua)(a),eo=()=>(eo=K.Va)();o.___start_em_js=1430875,o.___stop_em_js=1431036;function uu(a){a=Object.assign({},a);var d=v=>()=>v()>>>0,f=v=>I=>v(I)>>>0;return a.__errno_location=d(a.__errno_location),a.pthread_self=d(a.pthread_self),a.malloc=f(a.malloc),a.stackSave=d(a.stackSave),a.stackAlloc=f(a.stackAlloc),a}o.keepRuntimeAlive=Le,o.wasmMemory=we,o.stackAlloc=Zr,o.stackSave=Jr,o.stackRestore=vr,o.UTF8ToString=We,o.stringToUTF8=pr,o.lengthBytesUTF8=Gt,o.ExitStatus=ht,o.PThread=re;var $r;lt=function a(){$r||to(),$r||(lt=a)};function to(){function a(){if(!$r&&($r=!0,o.calledRun=!0,!Be)&&(A||Ct(Ee),m(o),o.onRuntimeInitialized&&o.onRuntimeInitialized(),!A)){if(o.postRun)for(typeof o.postRun=="function"&&(o.postRun=[o.postRun]);o.postRun.length;){var d=o.postRun.shift();Te.unshift(d)}Ct(Te)}}if(!(0<Ue))if(A)m(o),A||Ct(Ee),startWorker(o);else{if(o.preRun)for(typeof o.preRun=="function"&&(o.preRun=[o.preRun]);o.preRun.length;)Ve.unshift(o.preRun.shift());Ct(Ve),0<Ue||(o.setStatus?(o.setStatus("Running..."),setTimeout(function(){setTimeout(function(){o.setStatus("")},1),a()},1)):a())}}if(o.preInit)for(typeof o.preInit=="function"&&(o.preInit=[o.preInit]);0<o.preInit.length;)o.preInit.pop()();return to(),t.ready}})();typeof po=="object"&&typeof an=="object"?an.exports=co:typeof define=="function"&&define.amd&&define([],()=>co)});var mo=Yt((Mc,gu)=>{gu.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\\n\'});var ln,Jt,Zt,Sr,Qt,vo,cn,ke=j(()=>{"use strict";ln=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},Jt=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},Zt=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],Sr=e=>{switch(e){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Qt=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},vo=e=>e==="float32"||e==="int32"||e==="int64"||e==="bool"||e==="float16"||e==="uint32",cn=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var Au,Iu,$o,xo,Co,Tu,Oe,pt=j(()=>{"use strict";ke();Au=["V","I","W","E","F"],Iu=(e,t)=>{console.log(`[${Au[e]},${new Date().toISOString()}]${t}`)},Co=(e,t)=>{$o=e,xo=t},Tu=(e,t)=>{let r=Qt(e),i=Qt($o);r>=i&&Iu(r,typeof t=="function"?t():t)},Oe=(...e)=>{xo&&Tu(...e)}});var So,Ao=j(()=>{"use strict";ke();So=(e,t)=>new(Sr(t))(e)});var Io=j(()=>{"use strict"});var Ar,Ou,To,pn,dn,Oo,Eo=j(()=>{"use strict";pt();Io();Ar=e=>Math.ceil(e/16)*16,Ou=1,To=()=>Ou++,pn=async(e,t,r,i)=>{let n=Ar(r),s=e.device.createBuffer({size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let u=e.getCommandEncoder();e.endComputePass(),u.copyBufferToBuffer(t,0,s,0,n),e.flush(),await s.mapAsync(GPUMapMode.READ);let c=s.getMappedRange();if(i){let o=i();return o.set(new Uint8Array(c,0,r)),o}else return new Uint8Array(c.slice(0,r))}finally{s.destroy()}},dn=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(t,r){let i=r.buffer,n=r.byteOffset,s=r.byteLength,u=Ar(s),c=this.storageCache.get(t);if(!c)throw new Error("gpu data for uploading does not exist");if(c.originalSize!==s)throw new Error(`inconsistent data size. gpu data size=${c.originalSize}, data size=${s}`);let o=this.backend.device.createBuffer({mappedAtCreation:!0,size:u,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),m=o.getMappedRange();new Uint8Array(m).set(new Uint8Array(i,n,s)),o.unmap();let g=this.backend.getCommandEncoder();this.backend.endComputePass(),g.copyBufferToBuffer(o,0,c.gpuData.buffer,0,u),Oe("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(o)}memcpy(t,r){let i=this.storageCache.get(t);if(!i)throw new Error("source gpu data for memcpy does not exist");let n=this.storageCache.get(r);if(!n)throw new Error("destination gpu data for memcpy does not exist");if(i.originalSize!==n.originalSize)throw new Error("inconsistent source and destination gpu data size");let s=Ar(i.originalSize),u=this.backend.getCommandEncoder();this.backend.endComputePass(),u.copyBufferToBuffer(i.gpuData.buffer,0,n.gpuData.buffer,0,s)}registerExternalBuffer(t,r,i){let n;if(i){if(n=this.externalBuffers.get(i),n===void 0)throw new Error("previous buffer is not registered");if(t===i)return Oe("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, buffer is the same, skip.`),n;this.externalBuffers.delete(i)}else n=To();return this.storageCache.set(n,{gpuData:{id:n,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,n),Oe("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, registered.`),n}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),Oe("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let i=Ar(t),n,s=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,u=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||u){let o=s?this.freeBuffers:this.freeUniformBuffers,m=o.get(i);m||(m=[],o.set(i,m)),m.length>0?n=m.pop():n=this.backend.device.createBuffer({size:i,usage:r})}else n=this.backend.device.createBuffer({size:i,usage:r});let c={id:To(),type:0,buffer:n};return this.storageCache.set(c.id,{gpuData:c,originalSize:t}),Oe("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${c.id}`),c}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error("releasing data does not exist");return Oe("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let i=this.storageCache.get(t);if(!i)throw new Error("data does not exist");await pn(this.backend,i.gpuData.buffer,i.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();this.buffersForUploadingPending=[];for(let t of this.buffersPending)(t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(t.size).push(t):(t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(t.size).push(t):t.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},Oo=(...e)=>new dn(...e)});var fn,ie,Pe=j(()=>{"use strict";fn=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this._cacheKey}},ie=e=>new fn(e)});var mn,rt,k,bt,Ir,Tr,Or,he=j(()=>{"use strict";mn=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},rt=class{static calcShape(t,r,i=!1){let n=t.length,s=r.length;if(n===0)return r;if(s===0)return t;let u=Math.max(t.length,r.length),c=new Array(u);if(i){if(n<2||s<2)return;let o=mn.calcMatMulShape([t[n-2],t[n-1]],[r[s-2],r[s-1]]);if(o===void 0)return;[c[u-2],c[u-1]]=o}for(let o=i?3:1;o<=u;o++){let m=n-o<0?1:t[n-o],g=s-o<0?1:r[s-o];if(m!==g&&m>1&&g>1)return;c[u-o]=Math.max(m,g)}return c}static isValidBroadcast(t,r){let i=t.length,n=r.length;if(i>n)return!1;for(let s=1;s<=i;s++)if(t[i-s]!==1&&t[i-s]!==r[n-s])return!1;return!0}},k=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,i){let n=1;for(let s=r;s<i;s++){if(t[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");n*=t[s]}return n}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let i=new Array(r);i[r-1]=1,i[r-2]=t[r-1];for(let n=r-3;n>=0;--n)i[n]=i[n+1]*t[n+1];return i}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(i=>this.normalizeAxis(i,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(i=>t[i]):t.slice().reverse()}static padShape(t,r){let i=t.length;return t.map((n,s)=>n+r[s]+r[s+i])}static areEqual(t,r){return t.length!==r.length?!1:t.every((i,n)=>i===r[n])}},bt=class e{static adjustPoolAttributes(t,r,i,n,s,u){if(!t&&i.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let c=0;c<r.length-2;c++)c>=i.length?i.push(r[c+2]):i[c]=r[c+2];for(let c=0;c<i.length;c++)if(c<n.length){if(n[c]<0)throw new Error("strides should be greater than or equal to 1")}else n.push(1);for(let c=0;c<i.length;c++)if(c<s.length){if(s[c]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let c=0;c<i.length*2;c++)if(c<u.length){if(u[c]<0)throw new Error("pad should be greater than or equal to 1")}else u.push(0);for(let c=0;c<i.length;c++){if(i[c]<=0)throw new Error("kernel shapes need to be greater than 0");if(u[c]>=i[c]||u[c+i.length]>=i[c])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,i,n,s,u,c){if(c){if(s.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let o=0;o<t.length-2;o++)e.adjustPadAndReturnShape(t[o+(u?1:2)],r[o],i[o],n[o],s,o,o+t.length-2,c)}}static computePoolOutputShape(t,r,i,n,s,u,c){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let o=[r[0],r[1]];return e.computeShapeHelper(t,r,o,i,n,s,u,c),o}static computeConvOutputShape(t,r,i,n,s,u,c){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let o=[t[0],r[0]];return e.computeShapeHelper(!1,t,o,i,n,s,u,c),o}static computeShapeHelper(t,r,i,n,s,u,c,o){if(t)for(let m=0;m<r.length-2;m++)i.push(1);else for(let m=0;m<r.length-2;m++)i.push(e.adjustPadAndReturnShape(r[m+2],n[m],s[m],u[m],c,m,m+r.length-2,o))}static adjustPadAndReturnShape(t,r,i,n,s,u,c,o){let m=i*(n-1)+1;if(o&&o!=="NOTSET")switch(o){case"VALID":return s[u]=0,s[c]=0,Math.floor((t-m)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(i!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let x=((t+r-1)/r-1)*r+n-t;return s[u]=Math.floor(o==="SAME_LOWER"?(x+1)/2:x/2),s[c]=x-s[u],Math.floor((t+x-n)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+s[u]+s[c]-m)/r+1)}},Ir=class{static getShapeOfGemmResult(t,r,i,n,s){if(t.length!==2||i.length!==2)throw new Error("shape need to be of size 2");let u,c,o;r?(u=t[1],c=t[0]):(u=t[0],c=t[1]);let m=-1;if(n?(o=i[0],m=1):(o=i[1],m=0),i[m]!==c)throw new Error("dimension mismatch");if(u<=0||o<=0||c<=0)throw new Error("invalid shape specified");if(s&&!rt.isValidBroadcast(s,[u,o]))throw new Error("gemm: invalid bias shape for broadcast");return[u,o,c]}},Tr=-34028234663852886e22,Or=34028234663852886e22});var Eu,_o,Re,gn,ut,Xe,wt,ft,Po,F,Z,hn,Ro,yn,Bo,ve=j(()=>{"use strict";ke();he();Eu=64,_o=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},Re=(e,t=1)=>{let r=_o(e,t);return typeof r=="string"?r:r[0]},gn=e=>[{type:"uint32",data:e},{type:"uint32",data:k.computeStrides(e)}],ut=e=>e%4===0?4:e%2===0?2:1,Xe=(e="f32",t,r="0")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,wt=(e,t,r)=>e==="f32"?r:t===1?`f32(${r})`:`vec${t}f(${r})`,ft=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,Po=(e,t,r,i,n)=>{let s=typeof r=="number",u=s?r:r.length,c=[...new Array(u).keys()],o=u<2?"u32":u<=4?`vec${u}<u32>`:`array<u32, ${u}>`,m=_o(t,n),g=typeof m=="string"?m:m[1],x=typeof m=="string"?m:m[0],b={indices:o,value:g,storage:x,tensor:t},w=V=>typeof V=="string"?V:`${V}u`,$={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},y=s?"uniforms.":"",C=`${y}${e}_shape`,A=`${y}${e}_strides`,P="";for(let V=0;V<u-1;V++)P+=`\n    let dim${V} = current / ${A}[${V}];\n    let rest${V} = current % ${A}[${V}];\n    indices[${V}] = dim${V};\n    current = rest${V};\n    `;P+=`indices[${u-1}] = current;`;let W=u<2?"":`\n  fn o2i_${e}(offset: u32) -> ${b.indices} {\n    var indices: ${b.indices};\n    var current = offset;\n    ${P}\n    return indices;\n  }`,B=V=>($.offsetToIndices=!0,u<2?V:`o2i_${e}(${V})`),D=[];if(u>=2)for(let V=u-1;V>=0;V--)D.push(`${A}[${V}] * (indices[${V}])`);let _=u<2?"":`\n  fn i2o_${e}(indices: ${b.indices}) -> u32 {\n    return ${D.join("+")};\n  }`,z=V=>($.indicesToOffset=!0,u<2?V:`i2o_${e}(${V})`),N=(...V)=>u===0?"0u":`${b.indices}(${V.map(w).join(",")})`,Y=(V,ce)=>u<2?`${V}`:`${V}[${ce}]`,le=(V,ce,pe)=>u<2?`${V}=${pe};`:`${V}[${ce}]=${pe};`,M={},q=(V,ce)=>{$.broadcastedIndicesToOffset=!0;let pe=`${ce.name}broadcastedIndicesTo${e}Offset`;if(pe in M)return`${pe}(${V})`;let ze=[];for(let Ve=u-1;Ve>=0;Ve--){let Ee=ce.indicesGet("outputIndices",Ve+ce.rank-u);ze.push(`${Y(A,Ve)} * (${Ee} % ${Y(C,Ve)})`)}return M[pe]=`fn ${pe}(outputIndices: ${ce.type.indices}) -> u32 {\n             return ${ze.length>0?ze.join("+"):"0u"};\n           }`,`${pe}(${V})`},Ce=(V,ce)=>(()=>{if(b.storage===b.value)return`${e}[${V}]=${ce};`;if(b.storage==="vec2<u32>"&&b.value==="i32")return`${e}[${V}]=vec2<u32>(u32(${ce}), select(0u, 0xFFFFFFFFu, ${ce} < 0));`;if(b.storage==="vec2<u32>"&&b.value==="u32")return`${e}[${V}]=vec2<u32>(u32(${ce}), 0u);`;if(b.storage==="u32"&&b.value==="vec4<bool>")return`${e}[${V}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${ce}));`;throw new Error(`not supported combination of storage type ${b.storage} and value type ${b.value} yet`)})(),ae=V=>(()=>{if(b.storage===b.value)return`${e}[${V}]`;if(b.storage==="vec2<u32>"&&b.value==="i32")return`i32(${e}[${V}].x)`;if(b.storage==="vec2<u32>"&&b.value==="u32")return`u32(${e}[${V}].x)`;if(b.storage==="u32"&&b.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${V}] & 0xFFu), bool(${e}[${V}] & 0xFF00u), bool(${e}[${V}] & 0xFF0000u), bool(${e}[${V}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${b.storage} and value type ${b.value} yet`)})(),we=u<2?"":`\n  fn get_${e}ByIndices(indices: ${b.indices}) -> ${g} {\n    return ${ae(`i2o_${e}(indices)`)};\n  }`,K=u<2?"":(()=>{let V=c.map(pe=>`d${pe}: u32`).join(", "),ce=c.map(pe=>`d${pe}`).join(", ");return`\n  fn get_${e}(${V}) -> ${g} {\n    return get_${e}ByIndices(${N(ce)});\n  }`})(),Se=(...V)=>{if(V.length!==u)throw new Error(`indices length must be ${u}`);let ce=V.map(w).join(",");return u===0?ae("0u"):u===1?ae(ce[0]):($.get=!0,$.getByIndices=!0,$.indicesToOffset=!0,`get_${e}(${ce})`)},Be=V=>u<2?ae(V):($.getByIndices=!0,$.indicesToOffset=!0,`get_${e}ByIndices(${V})`),xe=u<2?"":`\n  fn set_${e}ByIndices(indices: ${b.indices}, value: ${g}) {\n    ${Ce(`i2o_${e}(indices)`,"value")}\n  }`,Ie=u<2?"":(()=>{let V=c.map(pe=>`d${pe}: u32`).join(", "),ce=c.map(pe=>`d${pe}`).join(", ");return`\n  fn set_${e}(${V}, value: ${g}) {\n    set_${e}ByIndices(${N(ce)}, value);\n  }`})();return{impl:()=>{let V=[];return s||(V.push(`const ${C} = ${b.indices}(${r.join(",")});`),V.push(`const ${A} = ${b.indices}(${k.computeStrides(r).join(",")});`)),$.offsetToIndices&&V.push(W),$.indicesToOffset&&V.push(_),$.broadcastedIndicesToOffset&&Object.values(M).forEach(ce=>V.push(ce)),$.set&&V.push(Ie),$.setByIndices&&V.push(xe),$.get&&V.push(K),$.getByIndices&&V.push(we),V.join(`\n`)},type:b,offsetToIndices:B,indicesToOffset:z,broadcastedIndicesToOffset:q,indices:N,indicesGet:Y,indicesSet:le,set:(...V)=>{if(V.length!==u+1)throw new Error(`indices length must be ${u}`);let ce=V[u];if(typeof ce!="string")throw new Error("value must be string");let pe=V.slice(0,u).map(w).join(",");return u===0?Ce("0u",ce):u===1?Ce(pe[0],ce):($.set=!0,$.setByIndices=!0,$.indicesToOffset=!0,`set_${e}(${pe}, ${ce})`)},setByOffset:Ce,setByIndices:(V,ce)=>u<2?Ce(V,ce):($.setByIndices=!0,$.indicesToOffset=!0,`set_${e}ByIndices(${V}, ${ce});`),get:Se,getByOffset:ae,getByIndices:Be,usage:i?"input":"output",name:e,strides:A,shape:C,rank:u}},F=(e,t,r,i=1)=>Po(e,t,r,!0,i),Z=(e,t,r,i=1)=>Po(e,t,r,!1,i),hn=class{constructor(t){this.normalizedDispatchGroup=t;this.indicesHelpers=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=Eu){let r=typeof t=="number"?t:t[0],i=typeof t=="number"?1:t[1],n=typeof t=="number"?1:t[2],s=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,u=s?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>`,c=s?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +\n          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${r*i*n}u + local_index;`;return`@compute @workgroup_size(${r}, ${i}, ${n})\n  fn main(${u}) {\n    ${c}\n  `}declareVariable(t,r){this.indicesHelpers.push(t),t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:t.type.indices}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:t.type.indices});let i=t.usage==="input"?"read":"read_write",n=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${i}> ${t.name}: array<${n}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`\n`)}registerUniform(t,r){return this.uniforms.push({name:t,type:r}),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:r,type:i}of this.uniforms)t.push(`${r}:${i}`);return`\n      struct Uniforms { ${t.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.indicesHelpers.map(t=>t.impl()).join(`\n`)}},Ro=e=>new hn(e),yn=(e,t)=>{let r=e.length,i=[];for(let n=0;n<r;n++){let s=r-1-n,u=e[s]||1;(t[t.length-1-n]||1)>1&&u===1&&i.unshift(s)}return i},Bo=e=>e<=4});var nt,_u,Er,Pu,ot,Mo,ko,Do,Wo,zo,Go,Vo,Uo,No,Fo,Je,bn=j(()=>{"use strict";he();Pe();ve();nt=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},_u=e=>["","",`var value = ${e.getByOffset("inputOffset")};`,""],Er=(e,t,r,i,n,s,u=!1,c=!1)=>{let o=[],m=r[0].dims,g=k.normalizeAxes(n,r[0].dims.length),x=!c&&g.length===0;m.forEach((z,N)=>{x||g.indexOf(N)>=0?u&&o.push(1):o.push(z)});let b=[],w=F("_A",r[0].dataType,m),$=Z("output",s,o),y=i(w,$,g),C=`inputOffset = ${w.indicesToOffset("inputIndices")};`,A=`let ${C};`,P=`var ${C};`,W=y[1]===""?"":P,B=(y[1]===""?A:C)+`\n`+y[2];for(let z=0,N=0;z<r[0].dims.length;z++)x||g.indexOf(z)>=0?(u&&N++,B=`for(var j${z}: u32 = 0; j${z} < ${r[0].dims[z]}; j${z}++) {\n                ${y[2].includes("lastIndex")?`let lastIndex = j${z};`:""}\n                ${w.indicesSet("inputIndices",z,`j${z}`)}\n                ${B}\n              }`):(b.push(`${w.indicesSet("inputIndices",z,$.indicesGet("outputIndices",N))};`),N++);let D=k.size(o);return{name:e,shaderCache:t,getShaderSource:z=>`\n        ${z.declareVariables(w,$)}\n\n        ${z.mainStart()}\n          ${z.guardAgainstOutOfBoundsWorkgroupSizes(D)}\n          var inputIndices: ${w.type.indices};\n          let outputIndices = ${$.offsetToIndices("global_idx")};\n\n          ${b.join(`\n`)}\n          ${y[0]}       // init ops for reduce max/min\n          ${W}\n          ${y[1]}\n          ${B}\n          ${y[3]}\n          ${y.length===4?$.setByOffset("global_idx","value"):y.slice(4).join(`\n`)}\n        }`,getRunData:()=>({outputs:[{dims:o,dataType:s}],dispatchGroup:{x:Math.ceil(D/64)}})}},Pu=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(i=>r.push(Number(i))),ie({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},ot=(e,t,r,i)=>{let n=e.inputs,s=n.length===1?r:Pu(n,r);e.compute(Er(t,{hint:s.cacheKey},[n[0]],s.noopWithEmptyAxes&&s.axes.length===0?_u:i,s.axes,n[0].dataType,s.keepDims,s.noopWithEmptyAxes),{inputs:[0]})},Mo=(e,t)=>{nt(e.inputs),ot(e,"ReduceLogSum",t,(i,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${i.getByOffset("inputOffset")};`,"value = log(value);"])},ko=(e,t)=>{nt(e.inputs),ot(e,"ReduceL1",t,(i,n)=>[`var value = ${n.type.storage}(0);`,"",`value += abs(${i.getByOffset("inputOffset")});`,""])},Do=(e,t)=>{nt(e.inputs),ot(e,"ReduceL2",t,(i,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${i.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])},Wo=(e,t)=>{nt(e.inputs),ot(e,"ReduceLogSumExp",t,(i,n)=>[`var value = ${n.type.storage}(0);`,"",`value += exp(${i.getByOffset("inputOffset")});`,"value = log(value);"])},zo=(e,t)=>{nt(e.inputs),ot(e,"ReduceMax",t,(i,n,s)=>{let u=[];for(let c=0;c<i.rank;c++)(s.indexOf(c)>=0||s.length===0)&&u.push(i.indicesSet("inputIndices",c,0));return[`${u.join(`\n`)}`,`var value = ${i.getByOffset("inputOffset")};`,`value = max(value, ${i.getByOffset("inputOffset")});`,""]})},Go=(e,t)=>{nt(e.inputs),ot(e,"ReduceMean",t,(i,n,s)=>{let u=1;for(let c=0;c<i.rank;c++)(s.indexOf(c)>=0||s.length===0)&&(u*=e.inputs[0].dims[c]);return["var sum = f32(0);","",`sum += f32(${i.getByOffset("inputOffset")});`,`let value = ${n.type.value}(sum / ${u});`]})},Vo=(e,t)=>{nt(e.inputs),ot(e,"ReduceMin",t,(i,n,s)=>{let u=[];for(let c=0;c<i.rank;c++)(s.indexOf(c)>=0||s.length===0)&&u.push(`inputIndices[${c}] = 0;`);return[`${u.join(`\n`)}`,`var value = ${i.getByOffset("inputOffset")};`,`value = min(value, ${i.getByOffset("inputOffset")});`,""]})},Uo=(e,t)=>{nt(e.inputs),ot(e,"ReduceProd",t,(i,n)=>[`var value = ${n.type.storage}(1);`,"",`value *= ${i.getByOffset("inputOffset")};`,""])},No=(e,t)=>{nt(e.inputs),ot(e,"ReduceSum",t,(i,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${i.getByOffset("inputOffset")};`,""])},Fo=(e,t)=>{nt(e.inputs),ot(e,"ReduceSumSquare",t,(i,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${i.getByOffset("inputOffset")}; value += t * t;`,""])},Je=e=>ie(e)});var Ho,Lo,jo,Ko,wn,qo=j(()=>{"use strict";ke();Pe();bn();Ho=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},Lo=(e,t)=>ie({axis:t.axis,keepDims:t.keepDims,selectLastIndex:t.selectLastIndex}),jo=(e,t)=>{Ho(e.inputs);let r=(n,s,u)=>{let c=[];for(let o=0;o<n.rank;o++)(u.indexOf(o)>=0||u.length===0)&&c.push(`inputIndices[${o}] = 0;`);return[`${c.join(`\n`)}`,`var value = ${n.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${n.getByOffset("inputOffset")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${n.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",s.setByOffset("global_idx","bestIndex")]},i=e.inputs.length===1?t:Lo(e.inputs,t);e.compute(Er("ArgMin",{hint:i.cacheKey},[e.inputs[0]],r,[i.axis],7,i.keepDims),{inputs:[0]})},Ko=(e,t)=>{Ho(e.inputs);let r=(n,s,u)=>{let c=[];for(let o=0;o<n.rank;o++)(u.indexOf(o)>=0||u.length===0)&&c.push(`inputIndices[${o}] = 0;`);return[`${c.join(`\n`)}`,`var value = ${n.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${n.getByOffset("inputOffset")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${n.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",s.setByOffset("global_idx","bestIndex")]},i=e.inputs.length===1?t:Lo(e.inputs,t);e.compute(Er("argMax",{hint:i.cacheKey},[e.inputs[0]],r,[i.axis],7,i.keepDims),{inputs:[0]})},wn=e=>ie(e)});var Ru,Bu,Yo,Xo=j(()=>{"use strict";he();ve();Ru=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Bu=e=>{let t=e[0].dims,r=e[0].dims[2],i=k.size(t)/4,n=e[0].dataType,s=F("input",n,t,4),u=F("bias",n,[r],4),c=F("residual",n,t,4),o=Z("output",n,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:g=>`\n  const channels = ${r}u / 4;\n  ${g.declareVariables(s,u,c,o)}\n\n  ${g.mainStart()}\n    ${g.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n    let value = ${s.getByOffset("global_idx")}\n      + ${u.getByOffset("global_idx % channels")} + ${c.getByOffset("global_idx")};\n    ${o.setByOffset("global_idx","value")}\n  }`}},Yo=e=>{Ru(e.inputs),e.compute(Bu(e.inputs))}});var Mu,$e,Jo,Zo,Qo,ea,ta,ra,na,oa,aa,vn,ku,ia,sa,ua,la,_r,ca,Pr,da,pa,fa,ma,ha,ga,ya,ba,wa,va,$a,xa,Ca,Sa,Aa,Ia,Ta,$n=j(()=>{"use strict";ke();he();Pe();ve();Mu=(e,t,r,i,n,s)=>{let u=Math.ceil(t/4),c="";typeof n=="string"?c=`${n}(a)`:c=n("a");let o=F("inputData",r,[u],4),m=Z("outputData",i,[u],4);return`\n  ${e.declareVariables(o,m)}\n\n  ${s??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n\n    let a = ${o.getByOffset("global_idx")};\n    ${m.setByOffset("global_idx",c)}\n  }`},$e=(e,t,r,i,n,s=e.dataType)=>({name:t,shaderCache:{hint:n},getShaderSource:u=>Mu(u,k.size(e.dims),e.dataType,s,r,i),getRunData:u=>({outputs:[{dims:e.dims,dataType:s}],dispatchGroup:{x:Math.ceil(k.size(u[0].dims)/64/4)}})}),Jo=e=>{e.compute($e(e.inputs[0],"Abs","abs"))},Zo=e=>{e.compute($e(e.inputs[0],"Acos","acos"))},Qo=e=>{e.compute($e(e.inputs[0],"Acosh","acosh"))},ea=e=>{e.compute($e(e.inputs[0],"Asin","asin"))},ta=e=>{e.compute($e(e.inputs[0],"Asinh","asinh"))},ra=e=>{e.compute($e(e.inputs[0],"Atan","atan"))},na=e=>{e.compute($e(e.inputs[0],"Atanh","atanh"))},oa=e=>ie(e),aa=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${t.to}`)}e.compute($e(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},vn=(e,t)=>{let r=Re(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Clip",i=>`clamp(${i}, clip_min_, clip_max_)`,`\n    const clip_min_: vec4<${r}> = vec4(${r}(${t.min}));\n    const clip_max_: vec4<${r}> = vec4(${r}(${t.max}));\n`,t.cacheKey),{inputs:[0]})},ku=e=>{let t=e.length>=2?e[1].getFloat32Array()[0]:Tr,r=e.length>=3?e[2].getFloat32Array()[0]:Or;return ie({min:t,max:r})},ia=e=>{let t=ku(e.inputs);vn(e,t)},sa=e=>{e.compute($e(e.inputs[0],"Ceil","ceil"))},ua=e=>{e.compute($e(e.inputs[0],"Cos","cos"))},la=e=>{e.compute($e(e.inputs[0],"Cosh","cosh"))},_r=e=>ie(e),ca=(e,t)=>{e.compute($e(e.inputs[0],"Elu",r=>`elu_vf32(${r})`,`\n  const elu_alpha_: f32 = f32(${t.alpha});\n\n  fn elu_f32(a: f32) -> f32 {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},Pr=(e,t="f32")=>`\nconst r0: ${t} = 0.3275911;\nconst r1: ${t} = 0.254829592;\nconst r2: ${t} = -0.284496736;\nconst r3: ${t} = 1.421413741;\nconst r4: ${t} = -1.453152027;\nconst r5: ${t} = 1.061405429;\n\nfn erf_vf32(v: ${e}) -> ${e} {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,da=e=>{let t=Re(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,Pr(`vec4<${t}>`,t)))},pa=e=>{e.compute($e(e.inputs[0],"Exp","exp"))},fa=e=>{e.compute($e(e.inputs[0],"Floor","floor"))},ma=e=>{let t=Re(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,Pr(`vec4<${t}>`,t)))},ha=(e,t)=>{e.compute($e(e.inputs[0],"LeakyRelu",r=>`select(leaky_relu_alpha_ * ${r}, ${r}, ${r} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${t.alpha});`,t.cacheKey))},ga=e=>{e.compute($e(e.inputs[0],"Not",t=>`!${t}`))},ya=e=>{e.compute($e(e.inputs[0],"Neg",t=>`-${t}`))},ba=e=>{e.compute($e(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},wa=e=>{e.compute($e(e.inputs[0],"Relu",t=>`select(vec4<f32>(0.0), ${t}, ${t} > vec4<f32>(0.0))`))},va=e=>{e.compute($e(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},$a=e=>{e.compute($e(e.inputs[0],"Sin","sin"))},xa=e=>{e.compute($e(e.inputs[0],"Sinh","sinh"))},Ca=e=>{e.compute($e(e.inputs[0],"Sqrt","sqrt"))},Sa=e=>{e.compute($e(e.inputs[0],"Tan","tan"))},Aa=e=>{e.compute($e(e.inputs[0],"Tanh","tanh"))},Ia=(e,t)=>(e.compute($e(e.inputs[0],"ThresholdedRelu",r=>`select(vec4<f32>(0.0), ${r}, ${r} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${t.alpha});`,t.cacheKey)),0),Ta=e=>{e.compute($e(e.inputs[0],"Log","log"))}});var Wu,zu,Oa,Ea=j(()=>{"use strict";he();ve();$n();Wu=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},zu=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=F("input",e[0].dataType,e[0].dims,4),i=F("bias",e[0].dataType,[e[0].dims[2]],4),n=Z("output",e[0].dataType,t,4),s=k.size(t)/4;return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:c=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${c.declareVariables(r,i,n)}\n\n  ${Pr("vec4f")}\n\n  ${c.mainStart()}\n    ${c.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${n.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},Oa=e=>{Wu(e.inputs),e.compute(zu(e.inputs))}});var Gu,Vu,at,_a,Pa,Ra,Ba,Ma,ka,Da,Wa,za,Ga,Va=j(()=>{"use strict";ke();he();ve();Gu=(e,t,r,i,n,s,u,c,o,m,g)=>{let x=k.size(i),b=Math.ceil(x/4),w,$;typeof u=="string"?w=$=(B,D)=>`${u}((${B}),(${D}))`:typeof u=="function"?w=$=u:(w=u.scalar,$=u.vector);let y="",C=Z("outputData",m,i,4),A=F("aData",c,t,4),P=F("bData",o,r,4);if(s){let B=D=>{let _=k.computeStrides(D),z=[];for(let N=D.length-1;N>=0;N--){let Y=C.indicesGet("outputIndices",N+i.length-D.length);z.push(`${_[N]}u * (${Y} % ${D[N]}u)`)}return z.length>0?z.join("+"):"0u"};y=`\n          fn calcOffsetA(outputIndices: ${C.type.indices}) -> u32 {\n            return ${B(t)};\n          }\n\n          fn calcOffsetB(outputIndices: ${C.type.indices}) -> u32 {\n            return ${B(r)};\n          }\n        `}let W;if(n)if(s){let B=k.size(t)===1,D=k.size(r)===1;B||D?W=C.setByOffset("global_idx",$(B?`${A.type.value}(${A.getByOffset("0")}.x)`:A.getByOffset("global_idx"),D?`${P.type.value}(${P.getByOffset("0")}.x)`:P.getByOffset("global_idx"))):W=`\n            let outputIndices = ${C.offsetToIndices("global_idx * 4u")};\n            let offsetA = calcOffsetA(outputIndices);\n            let offsetB = calcOffsetB(outputIndices);\n            ${C.setByOffset("global_idx",$(A.getByOffset("offsetA / 4u"),P.getByOffset("offsetB / 4u")))}\n          `}else W=C.setByOffset("global_idx",$(A.getByOffset("global_idx"),P.getByOffset("global_idx")));else{if(!s)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let B=(D,_,z="")=>{let N=`aData[indexA${_}][componentA${_}]`,Y=`bData[indexB${_}][componentB${_}]`;return`\n            let outputIndices${_} = ${C.offsetToIndices(`global_idx * 4u + ${_}u`)};\n            let offsetA${_} = calcOffsetA(outputIndices${_});\n            let offsetB${_} = calcOffsetB(outputIndices${_});\n            let indexA${_} = offsetA${_} / 4u;\n            let indexB${_} = offsetB${_} / 4u;\n            let componentA${_} = offsetA${_} % 4u;\n            let componentB${_} = offsetB${_} % 4u;\n            ${D}[${_}] = ${z}(${w(N,Y)});\n          `};m===9?W=`\n            var data = vec4<u32>(0);\n            ${B("data",0,"u32")}\n            ${B("data",1,"u32")}\n            ${B("data",2,"u32")}\n            ${B("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:W=`\n            ${B("outputData[global_idx]",0)}\n            ${B("outputData[global_idx]",1)}\n            ${B("outputData[global_idx]",2)}\n            ${B("outputData[global_idx]",3)}\n          `}return`\n        ${e.declareVariables(A,P,C)}\n\n        ${g??""}\n        ${y}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n        ${W}\n      }`},Vu=(e,t,r,i,n,s,u=r.dataType)=>{let c=!k.areEqual(r.dims,i.dims),o=r.dims,m=k.size(r.dims),g=!1;if(c){let x=rt.calcShape(r.dims,i.dims,!1);if(!x)throw new Error("Can\'t perform binary op on the given tensors");o=x,m=k.size(o);let b=k.size(r.dims)===1,w=k.size(i.dims)===1,$=1;for(let y=1;y<o.length;y++){let C=r.dims[r.dims.length-y]??1,A=i.dims[i.dims.length-y]??1;if(C===A)$*=C;else break}($%4===0||b||w)&&(g=!0)}else g=!0;return{name:e,shaderCache:{hint:t},getShaderSource:x=>Gu(x,r.dims,i.dims,o,g,c,n,r.dataType,i.dataType,u,s),getRunData:()=>({outputs:[{dims:o,dataType:u}],dispatchGroup:{x:Math.ceil(m/64/4)}})}},at=(e,t,r,i,n,s)=>{e.compute(Vu(t,n??"",e.inputs[0],e.inputs[1],r,i,s))},_a=e=>{at(e,"Add",(t,r)=>`${t}+${r}`)},Pa=e=>{at(e,"Div",(t,r)=>`${t}/${r}`)},Ra=e=>{at(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Ba=e=>{at(e,"Mul",(t,r)=>`${t}*${r}`)},Ma=e=>{let t=F("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;at(e,"Pow",{scalar:(i,n)=>`pow_custom(${i},${n})`,vector:(i,n)=>`pow_vector_custom(${i},${n})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},ka=e=>{at(e,"Sub",(t,r)=>`${t}-${r}`)},Da=e=>{at(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},Wa=e=>{at(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},za=e=>{at(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},Ga=e=>{at(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var Nu,Fu,Hu,Lu,Ua,Na,Fa=j(()=>{"use strict";he();Pe();ve();Nu=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].dataType,r=e[0].dims.length;for(let i of e){if(i.dataType!==t)throw new Error("input tensors should be one type");if(i.dims.length!==r)throw new Error("input tensors should have the same shape")}},Fu=e=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,Hu=(e,t)=>{let r=e.length,i=[];for(let n=0;n<r;++n){let s=t.setByOffset("global_idx",e[n].getByIndices("indices"));r===1?i.push(s):n===0?i.push(`if (inputIndex == ${n}u) { ${s} }`):n===r-1?i.push(`else { ${s} }`):i.push(`else if (inputIndex == ${n}) { ${s} }`)}return i.join(`\n`)},Lu=(e,t)=>{let r=e[0].dims.slice();if(t>=r.length||t<-1*r.length)throw new Error("axis specified for concat doesn\'t match input dimensionality");let i=t<0?r.length+t:t,n=r.slice(0);for(let w=1;w<e.length;w++){let $=e[w].dims.slice();for(let y=0;y<r.length;y++)if(y===i)n[i]+=$[y];else if(r[y]!==$[y])throw new Error("non concat dimensions must match")}let s=k.size(n),u=new Array(e.length),c=new Array(e.length),o=e[0].dataType,m=0;for(let w=0;w<e.length;++w)m+=e[w].dims[i],u[w]=m,c[w]=F(`input${w}`,o,e[w].dims);let g=Z("output",o,n),x=g.indicesGet("indices",i),b=w=>`\n  ${w.declareVariables(...c,g)}\n\n  const sizeInConcatAxis = array<u32, ${u.length}>(${u.map($=>`${$}u`).join(",")});\n  ${Fu(u.length)}\n\n  ${w.mainStart()}\n    ${w.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n\n    var indices = ${g.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${x});\n    if (inputIndex != 0u) {\n      ${x} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${Hu(c,g)}\n  }`;return{name:"Concat",shaderCache:{hint:`${t}`},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:b}},Ua=(e,t)=>{Nu(e.inputs),e.compute(Lu(e.inputs,t.axis))},Na=e=>ie({axis:e.axis})});var De,Rr,Br,Mr=j(()=>{"use strict";De=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Rr=(e,t=!1,r=!1,i=3)=>"",Br=(e,t)=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      // TODO uncomment the following line when activation is supported above.\n      // ${t?"value = activation(value, coords);":""}\n      `});var kr,xn=j(()=>{"use strict";kr=`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));\n}\n`});var Dr,Wr,er=j(()=>{"use strict";he();Dr=(e,t=!1)=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${e.clipMin});const clip_max_=f32(${e.clipMax});`,applyActivation:t?"value = clamp(value, vec4(clip_min_), vec4(clip_max_));":"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},Wr=e=>{let t=e?.activation||"";if(t==="Clip"){let[r,i]=e?.activation_params||[Tr,Or];return{activation:t,clipMax:i,clipMin:r,activationCacheKey:`${t}:${r},${i}`}}return{activation:t,activationCacheKey:t}}});var ju,Ku,tr,Ha,qu,rr,Yu,zr,nr=j(()=>{"use strict";he();ve();er();Mr();ju=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,Ku=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,tr=(e,t,r="f32",i,n=!1,s=32,u=!1,c=32)=>{let o=t[1]*e[1],m=t[0]*e[0],g=n?o:s,x=n?s:o,b=g/t[0],w=s/t[1];if(!((n&&b===4&&e[1]===4||!n&&(b===3||b===4))&&g%t[0]===0&&s%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${n} is true, innerElementSize ${b} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${b} must be 3 or 4.\n  tileAWidth ${g} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${b}<${r}>, ${g/b}>, ${x}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${r}>, ${m/e[0]}>, ${s}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${b};\nconst tileInner = ${s};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${u?"0":"i32(globalId.z)"};\n  ${i?`let batchIndices = ${i.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${o};\n\n  let numTiles = ${u?`${Math.ceil(c/s)}`:"(dimInner - 1) / tileInner + 1"};\n  var kStart = ${u?`i32(globalId.z) * ${c}`:"0"};\n\n  var acc: array<vec4<${r}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${w};\n  for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${ju(n,i)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${i?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${b===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${Ku(n,b)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},Ha=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,qu=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",rr=(e,t,r="f32",i,n=!1,s=32,u=!1,c=32,o=!1)=>{let m=e[1]*t[1],g=e[0]*t[0],x=n?m:s,b=n?s:m;if(!(b%t[1]===0&&x%t[0]===0&&s%t[1]===0))throw new Error(`tileAHight ${b} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${x} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`);let w=b/t[1],$=x/t[0],y=s/t[1],C=o?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${m};\n    let globalColStart = i32(workgroupId.x) * ${g};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${b}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${x}; inputCol = inputCol + ${t[0]}) {\n          ${Ha(n,i)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${g}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${i?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${r}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${m};\n\nlet tileRowA = i32(localId.y) * ${w};\nlet tileColA = i32(localId.x) * ${$};\nlet tileRowB = i32(localId.y) * ${y};\n// Loop over shared dimension.\nfor (var t = 0; t < numTiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${$}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Ha(n,i)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${y}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${i?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${r}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${qu(n)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${r}, ${x}>, ${b}>;\n  var<workgroup> mm_Bsub : array<array<${r}, ${g}>, ${s}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${s};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${u?"0":"i32(globalId.z)"};\n    ${i?`let batchIndices = ${i.offsetToIndices("u32(batch)")};`:""}\n    let numTiles = ${u?`${Math.ceil(c/s)}`:"(dimInner - 1) / tileInner + 1"};\n    var kStart = ${u?`i32(globalId.z) * ${c}`:"0"};\n\n    var acc : array<array<${r}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${C}\n  }\n`},Yu=(e,t,r,i,n,s=!1)=>{let u=n[0],c=n[1],o=n[2],m=i[0],g=i[1],x=i[2],b=i[3],w=yn(u,o),$=yn(c,o),y=Re(i[0].type.tensor),C=()=>{let W=g.rank,B=m.rank,D=`var aIndices: ${g.type.indices};`;for(let _=W-2-1,z=B-1;_>=0;_--,z--)D+=`\naIndices[${_}] = ${B>1?`batchIndices[${z}]`:"batchIndices"};`;return w.forEach(_=>{D+=`\naIndices[${_}] = 0;`}),D+=`\naIndices[${W-2}] = u32(row);\n                   aIndices[${W-1}] = u32(colIn);`,D},A=()=>{let W=x.rank,B=m.rank,D=`var bIndices: ${x.type.indices};`;for(let _=W-2-1,z=B-1;_>=0;_--,z--)D+=`\nbIndices[${_}] = ${B>1?`batchIndices[${z}]`:"batchIndices"};`;return $.forEach(_=>{D+=`\nbIndices[${_}] = 0;`}),D+=`\nbIndices[${W-2}] = u32(row);\n                   bIndices[${W-1}] = u32(colIn);`,D};return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${m.type.indices}) -> ${De(e,y)} {\n      var value = ${De(e,y)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimAOuter && col < dimInner)\n      {\n        ${C()}\n        value = ${g.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${m.type.indices}) -> ${De(e,y)} {\n      var value = ${De(e,y)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimInner && col < dimBOuter)\n      {\n        ${A()}\n        value = ${x.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${De(e,y)}) {\n      let col = colIn * ${e};\n      if (row < dimAOuter && col < dimBOuter) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${s?"bias[colIn]":`${De(e,y)}(bias[row])`};`:""}\n        ${r}\n        ${b.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},zr=(e,t,r,i,n=!1)=>{let s=e[0].dims,u=e[1].dims,c=s.slice(0,-2),o=u.slice(0,-2),m=i?i.slice(0,-2):r.slice(0,-2),g=F("batchDims",e[0].dataType,m),x=[g],b=[c,o,m],w=k.size(m),$=s[s.length-2],y=s[s.length-1],C=u[u.length-1],A=y%4===0&&C%4===0,{activationFunction:P,applyActivation:W}=Dr(t,A),B=$<=8?[4,1,1]:[4,4,1],D=[8,8,1],_=[Math.ceil(C/D[0]/B[0]),Math.ceil($/D[1]/B[1]),Math.ceil(w/D[2]/B[2])],z=Re(e[0].dataType),N=A?4:1,Y=F("a",e[0].dataType,[...c,$,y/N],N),le=F("b",e[1].dataType,[...o,y,C/N],N),M=Z("result",e[0].dataType,[w,$,C/N],N);x.push(Y),x.push(le),x.push(M);let q=[Y,le],Ce=e.length>2,ae=Yu(N,Ce,W,x,b,n);if(Ce){let K=n?N:1;q.push(F("bias",e[2].dataType,e[2].dims,K))}let we=K=>`\n  const dimAOuter: i32 = ${$};\n  const dimBOuter: i32 = ${C};\n  const dimInner: i32 = ${y};\n  ${K.declareVariables(...q,M)}\n  ${P}\n  ${ae}\n  ${A?tr(B,D,z,g):rr(B,D,z,g)}\n                   ${g.impl()}`;return{name:"MatMul",shaderCache:{hint:t.activationCacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:_[0],y:_[1],z:_[2]}}),getShaderSource:we}}});var Xu,La,ja=j(()=>{"use strict";pt();he();ve();Mr();xn();nr();Xu=(e,t,r,i,n=!1,s,u=!1,c=4,o=4,m=4,g="f32")=>{let x=le=>{switch(le){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${g}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${le} is not supported.`)}},b=le=>{switch(le){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${le} is not supported.`)}},w=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,$=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,y=e?"xShape[1]":"xShape[2]",C=e?"xShape[2]":"xShape[3]",A=e?"row":"col",P=e?"col":"row",W=`\n    let inChannels = wShape[2];\n    let outWidth = ${e?"outShape[2]":"outShape[3]"};\n    let outRow = ${A} / outWidth;\n    let outCol = ${A} % outWidth;\n\n    let WRow = ${P} / (filterDims[1] * inChannels);\n    let WCol = ${P} / inChannels % filterDims[1];\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\n    let xCh = ${P} % inChannels;\n    var resData = ${De(c,g)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the \'same\' padding type.\n    if (xRow >= 0 && xRow < ${y} && xCol >= 0 && xCol < ${C}) {\n      ${w}\n      let xIndex = getIndexFromCoords4D(coord, xShape);\n      ${x(c)}\n    }\n    return resData;`,B=e?t&&i?`\n    let col = colIn * ${c};\n    ${W}`:`\n    let col = colIn * ${c};\n    if (row < dimAOuter && col < dimInner) {\n      ${W}\n    }\n    return ${De(c,g)}(0.0);`:i&&r?`\n    let col = colIn * ${c};\n    ${W}`:`\n    let col = colIn * ${c};\n    if (row < dimInner && col < dimBOuter) {\n      ${W}\n    }\n    return ${De(c,g)}(0.0);`,D=`${b(o)}`,_=De(m,g),z=e?De(c,g):De(o,g),N=e?De(o,g):De(c,g);return`\n    ${Rr(s,u,m===4,4)}\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${z} {\n      ${e?B:D}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${N} {\n      ${e?D:B}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${_}) {\n      let col = colIn * ${m};\n      if (row < dimAOuter && col < dimBOuter)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${$}\n      ${Br(n,s)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},La=(e,t,r,i,n,s,u,c)=>{let o=t.format==="NHWC",m=o?e[0].dims[3]:e[0].dims[1],g=r[0],x=o?r[2]:r[3],b=o?r[1]:r[2],w=o?r[3]:r[1],$=o&&(m%4===0||m%3===0)&&w%4===0,y=o?w:x*b,C=o?x*b:w,A=[8,8,1],P=i<=8?[4,1,1]:[4,4,1],W=[Math.ceil(y/A[0]/P[0]),Math.ceil(C/A[1]/P[1]),Math.ceil(g/A[2]/P[2])];Oe("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${W}`);let B=$?o&&m%4!==0?3:4:P[0],D=A[1]*P[1],_=A[0]*P[0],z=Math.max(A[0]*B,A[1]),N=i%D===0,Y=n%_===0,le=s%z===0,M=$?[B,4,4]:[1,1,1],q=Re(e[0].dataType),Ce=[`@group(0) @binding(0) var<storage, read> x: array<${$&&B===4?`vec4<${q}>`:q}>;`,`@group(0) @binding(1) var<storage, read> w: array<${$?`vec4<${q}>`:q}>;`],ae=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${$?`vec4<${q}>`:q}) {\n        result[flatIndex] = ${$?`vec4<${q}>`:q}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${$?`vec4<${q}>`:q}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${$?"/ 4":""}, value);\n      }`;return u&&(Ce.push(`@group(0) @binding(2) var<storage, read> bias: array<${$?`vec4<${q}>`:q}>;`),ae+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${$?`vec4<${q}>`:q} {\n          return bias[coords.${o?"w":"y"}${$?"/ 4":""}];\n        }`),{name:"Conv2DMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:W[0],y:W[1],z:W[2]}}),getShaderSource:()=>`\n        ${kr}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${Ce.join("")}\n        @group(0) @binding(${Ce.length}) var<storage, read_write> result: array<${$?`vec4<${q}>`:q}>;\n        //@group(0) @binding(${Ce.length+1}) var<uniform> uniforms: Uniforms;\n\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${k.computeStrides(r).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[0]}, ${t.kernelShape[1]});\n        const pad : vec2<i32> = vec2<i32>(${t.pads[0]}, ${t.pads[1]});\n        const stride : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${i};\n        const dimBOuter : i32 = ${n};\n        const dimInner : i32 = ${s};\n        ${ae}\n        ${Xu(o,N,Y,le,u,t.activation.toLowerCase(),!1,M[0],M[1],M[2],q)}\n            ${$?tr(P,A,q,void 0,!o,z):rr(P,A,q,void 0,!o,z,!1,void 0,c)}`}}});var Cn,Ka=j(()=>{"use strict";he();ve();An();er();Cn=(e,t,r)=>{let i=e.length>2,n=i?"value += b[output_channel];":"",s=e[0].dims,u=e[1].dims,c=u[0]/t.group,{activationFunction:o,applyActivation:m}=Dr(t),g=t.format==="NHWC",x=Sn(s,u,t.dilations,t.pads,t.strides,g),b=k.size(x),w=Z("output",e[0].dataType,x),$=F("x",e[0].dataType,s),y=F("w",e[1].dataType,u),C=[$,y];i&&C.push(F("b",e[2].dataType,e[2].dims));let A=P=>`\n  const strides: vec2<u32> = vec2(${t.strides[0]}u, ${t.strides[1]}u);\n  const pads: vec2<u32> = vec2(${t.pads[0]}u, ${t.pads[1]}u);\n\n  ${P.declareVariables(...C,w)}\n\n  ${o}\n\n  ${P.mainStart()}\n    ${P.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n\n    let outputIndices = ${w.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${g?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${g?1:2}], outputIndices[${g?2:3}]) * strides - pads;\n    let group_id: u32 = output_channel / ${c}u;\n\n    var value: ${w.type.value} = ${w.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < ${u[1]}u; wInChannel++) {\n      let input_channel = group_id * ${u[1]}u + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < ${u[2]}u; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * ${t.dilations[0]}u;\n\n        if (xHeight < 0u || xHeight >= ${s[g?1:2]}u) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < ${u[3]}u; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * ${t.dilations[1]}u;\n          if (xWidth < 0u || xWidth >= ${s[g?2:3]}u) {\n            continue;\n          }\n\n          let xVal = ${g?$.get("batch","xHeight","xWidth","input_channel"):$.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${y.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${n}\n    ${m}\n    ${w.setByOffset("global_idx","value")}\n  }`;return{name:"GroupedConv",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r?r(x):x,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)}}),getShaderSource:A}}});var Ju,qa,Zu,Qu,_t,Ya,Xa,Gr=j(()=>{"use strict";he();Pe();ve();Ju=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},qa=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,Zu=(e,t)=>k.sortBasedOnPerm(e,qa(e.length,t)),Qu=(e,t,r,i)=>{let n=[];n.push(`fn perm(i: ${i.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let s=0;s<t;++s)n.push(r.indicesSet("a",e[s],`i[${s}]`));return n.push("return a;}"),n.join(`\n`)},_t=(e,t)=>{let r=e.dataType,i=e.dims.length,n=qa(i,t),s=Bo(i),u=Zu(e.dims,n),c=s?u.length:u,o=s?i:e.dims,m=Z("output",r,c),g=F("a",r,o),x=b=>`\n  ${b.registerUniform("output_size","u32").declareVariables(g,m)}\n\n  ${Qu(n,i,g,m)}\n\n  ${b.mainStart()}\n    ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${m.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${m.setByOffset("global_idx",g.getByIndices("aIndices"))}\n  }`;return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:s?["rank"]:["dims"]},getRunData:b=>{let w=k.size(u);return{outputs:[{dims:u,dataType:b[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:s?[{type:"uint32",data:w},...gn(b[0].dims),...gn(u)]:[{type:"uint32",data:w}]}},getShaderSource:x}},Ya=(e,t)=>{Ju(e.inputs),e.compute(_t(e.inputs[0],t.perm))},Xa=e=>ie({perm:e.perm})});var Sn,Ja,el,Za,In,tl,rl,Tn,An=j(()=>{"use strict";he();Pe();ja();nr();Ka();er();Gr();Sn=(e,t,r,i,n,s)=>{let u=e[0],c=e.slice(s?1:2,s?3:4),o=c.length,m=t[0],x=t.slice(2).map(($,y)=>$+($-1)*(r[y]-1)),w=c.map(($,y)=>$+i[y]+i[y+o]).map(($,y)=>Math.floor(($-x[y]+n[y])/n[y]));return w.splice(0,0,u),w.splice(s?3:1,0,m),w},Ja=[2,3,1,0],el=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],i=e[1].dims[1]*t.group;if(r!==i)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==n*2)throw new Error(`pads should be ${n*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},Za=(e,t)=>{let r=e.kernelShape.slice();for(let s=2;s<t[1].dims.length;++s)r[s-2]===0&&(r[s-2]=t[1].dims[s]);let i=e.pads.slice();bt.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,i,e.format==="NHWC",e.autoPad);let n=Object.assign({},e);return Object.assign(n,{kernelShape:r,pads:i,cacheKey:e.cacheKey}),n},In=e=>{let t=Wr(e),r=e.format,i=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],n=e.dilations,s=e.group,u=e.kernel_shape,c=e.pads,o=e.strides,m=e.w_is_const();return ie({autoPad:i,format:r,dilations:n,group:s,kernelShape:u,pads:c,strides:o,wIsConst:m,...t})},tl=(e,t,r)=>{let i=Za(r,t);if(r.group!==1){e.compute(Cn(t,i));return}let n=r.format==="NHWC",s=t.length===3,u=t[0].dims[n?1:2],c=t[0].dims[n?2:3],o=t[0].dims[n?3:1],m=t[1].dims[2],g=t[1].dims[3],x=Sn(t[0].dims,t[1].dims,r.dilations,i.pads,r.strides,n),b=x[n?1:2],w=x[n?2:3],$=x[n?3:1],y=n&&m===u&&g===c&&r.pads[0]===0&&r.pads[1]===0;if(y||m===1&&g===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let _=x[0],z,N,Y,le=[];if(n){let M=e.kernelCustomData.wT??e.compute(_t(t[1],Ja),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=M),y){let q=u*c*o;z=t[0].reshape([1,_,q]),N=M.reshape([1,q,$]),Y=[1,_,$]}else z=t[0].reshape([_,u*c,o]),N=M.reshape([1,o,$]),Y=[_,b*w,$];le.push(z),le.push(N)}else z=t[0].reshape([_,o,u*c]),N=t[1].reshape([1,$,o]),Y=[_,$,b*w],le.push(N),le.push(z);s&&le.push(t[2]),e.compute(zr(le,i,x,Y,n),{inputs:le});return}let C=!0,A=e.kernelCustomData.wT??e.compute(_t(t[1],Ja),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=A);let P=[t[0],A];s&&P.push(t[2]);let W=n?b*w:$,B=n?$:b*w,D=m*g*o;e.compute(La(P,i,x,W,B,D,s,C),{inputs:P})},rl=(e,t)=>{let r=t.format==="NHWC",i=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&i.push(e.inputs[2]);let n=[0,t.pads[0],0,t.pads[1]],s=[1].concat(t.strides),u=[1].concat(t.dilations),c=[1].concat(t.kernelShape),o=Za({...t,pads:n,strides:s,dilations:u,kernelShape:c},i);e.compute(Cn(i,o,m=>r?[m[0],m[2],m[3]]:[]))},Tn=(e,t)=>{el(e.inputs,t),e.inputs[0].dims.length===3?rl(e,t):tl(e,e.inputs,t)}});var nl,Qa,ei=j(()=>{"use strict";pt();he();Mr();xn();nr();nl=(e,t=!1,r,i=!1,n=4)=>{let s=De(n,"f32"),u=A=>{switch(A){case 1:return"return W[getIndexFromCoords4D(coord, wShape)];";case 4:return`\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            `;default:throw new Error(`innerElementSize ${A} is not supported.`)}},c=e?`\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      `:`\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      `,o=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,m=e?"outBackprop[1]":"outBackprop[2]",g=e?"outBackprop[2]":"outBackprop[3]",x=e?"row":"col",b=e?"col":"row",w=`\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      let outRow = ${x} / outWidth;\n      let outCol = ${x} % outWidth;\n\n      let WRow = ${b} / (filterDims[1] * inChannels);\n      let WCol = ${b} / inChannels % filterDims[1];\n      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);\n      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);\n      if (xR < 0.0 || xR >= f32(${m}) || fract(xR) > 0.0) {\n        return ${s}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${g}) || fract(xC) > 0.0) {\n        return ${s}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${b} % inChannels;\n      ${c}\n      return x[getIndexFromCoords4D(coord, xShape)/${n}];`,$=e?`\n      let col = colIn * ${n};\n      if (row < dimAOuter && col < dimInner) {\n        ${w}\n      }\n      return ${s}(0.0);`:`\n      let col = colIn * ${n};\n      if (row < dimInner && col < dimBOuter) {\n        ${w}\n      }\n      return ${s}(0.0);`,y=`\n      let col = colIn * ${n};\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);\n      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];\n      if (${e?"row < dimInner && col < dimBOuter":"row < dimInner && col < dimAOuter"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${u(n)}\n      }\n      return ${s}(0.0);\n      `;return`\n  ${Rr(r,i,n===4,4)}\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${s} {\n    ${e?$:y}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${s} {\n    ${e?y:$}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${s}) {\n    let col = colIn * ${n};\n    if (row < dimAOuter && col < dimBOuter) {\n      var value = valueInput;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${o}\n      ${Br(t,r)}\n      result[getIndexFromCoords4D(coords, outShape)/${n}] = value;\n    }\n  }`},Qa=(e,t,r,i,n,s,u,c)=>{let o=t.format==="NHWC",m=o?e[0].dims[3]:e[0].dims[1],g=r[0],x=o?r[2]:r[3],b=o?r[1]:r[2],w=o?r[3]:r[1],$=o?m%4===0&&w%4===0:x%4===0&&w%4===0,y=o?w:x*b,C=o?x*b:w,A=$?[8,8,1]:[y<=4||C<=4?4:16,y>4&&C<=4?4:16,1],P=$?[4,4,1]:[y<=4?1:4,y>4&&C<=4?1:4,1],W=[Math.ceil(y/A[0]/P[0]),Math.ceil(C/A[1]/P[1]),Math.ceil(g/A[2]/P[2])];Oe("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${W}`);let B=$?4:1,D=Math.max(A[0]*B,A[1]),_=[`@group(0) @binding(0) var<storage, read> x: array<${$?"vec4<f32>":"f32"}>;`,"@group(0) @binding(1) var<storage, read> W: array<f32>;"],z="";return u&&(_.push(`@group(0) @binding(2) var<storage, read> bias: array<${$?"vec4<f32>":"f32"}>;`),z+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${$?"vec4<f32>":"f32"} {\n          return bias[coords.${o?"w":"y"}${$?"/ 4":""}];\n        }`),{name:"Conv2DTransposeMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:W[0],y:W[1],z:W[2]}}),getShaderSource:()=>`\n        ${kr}\n        ${_.join(`\n`)}\n        @group(0) @binding(${_.length}) var<storage, read_write> result: array<${$?"vec4<f32>":"f32"}>;\n        const outBackprop : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${k.computeStrides(r).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[o?1:2]}, ${t.kernelShape[o?2:3]});\n        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(\n              ${t.dilations[0]<=1?0:(t.kernelShape[o?1:2]-1)*(t.dilations[0]-1)},\n              ${t.dilations[1]<=1?0:(t.kernelShape[o?2:3]-1)*(t.dilations[1]-1)});\n        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${t.pads[0]+t.pads[2]})/2,\n                                         i32(effectiveFilterDims[1]) - 1 - (${t.pads[1]+t.pads[3]})/2);\n        const strides : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${i};\n        const dimBOuter : i32 = ${n};\n        const dimInner : i32 = ${s};\n        ${z}\n        ${nl(o,u,t.activation.toLowerCase(),!1,B)}\n        ${$?tr(P,A,"f32",void 0,!o,D):rr(P,A,"f32",void 0,!o,D,!1,void 0,c)}`}}});var ol,On,ti=j(()=>{"use strict";pt();he();ve();ol=(e,t,r,i,n,s,u=!1,c)=>{let o=r.format==="NHWC",m=o?1:2,g=o?2:3,x=o?3:1,b=k.size(i),w=u?2:1,$=r.group,y=t[1].dims,C=y[0]/$,A=y[1],P=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${u?`vec4<${c}>`:c}) {\n    result[flatIndex] = ${u?`vec4<${c}>`:c}(value);\n  }`;n&&(P+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${u?`vec4<${c}>`:c} {\n      return bias[coords.${o?"w":"y"}${u?"/ 4":""}];\n    }`);let W=u?4:1,B=F("W",t[1].dataType,t[1].dims,W),D=F("Dy",t[0].dataType,t[0].dims,W),_=[D,B];n&&_.push(F("bias",t[2].dataType,[i[x]],W));let z=Z("result",t[0].dataType,i,W),N=`{\n        let batch: u32 = ${s?"global_id.z":"workgroup_id.z"} / outShape[1];\n        let r = ${s?"global_id.z":"workgroup_id.z"} % outShape[1];\n        let c = ${s?"global_id.y":"workgroup_id.y"} * ${w};\n        let d1: u32 = ${s?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${c}>, ${w}>;\n        for (var i = 0; i < ${w}; i++) {\n          dotProd[i] = vec4<${c}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {\n          var dyR = (${c}(dyCorner.x) + ${c}(wR)) / ${c}(strides.x);\n          let wRPerm = filterDims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${c}(outBackprop[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {\n            let dyC = (${c}(dyCorner.y) + ${c}(wC)) / ${c}(strides.y);\n            let dyC2 = (${c}(dyCorner.y) + 1.0 + ${c}(wC)) / ${c}(strides.y);\n            let wCPerm = filterDims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${c}(outBackprop[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${c}(outBackprop[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${D.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${c}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${D.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${c}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = outBackprop[${x}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${D.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${c}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${D.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${c}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${w}; i = i + 1) {\n          let value = dotProd[i] + ${n?"bias[c+i]":"0.0"};\n          ${z.set("batch","r","c + i","d1","value")};\n        }\n      }`,Y=`\n          let outputIndices = ${z.offsetToIndices("global_idx")};\n          let batch = ${z.indicesGet("outputIndices",0)};\n          let d1 = ${z.indicesGet("outputIndices",x)};\n          let r = ${z.indicesGet("outputIndices",m)};\n          let c = ${z.indicesGet("outputIndices",g)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / ${A};\n          let wOutChannel = d1 - groupId * ${A};\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = 0.0;\n          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {\n            if (wR % dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${c}(dyRCorner) + ${c}(wR)) / ${c}(strides[0]);\n            let wRPerm = filterDims.x - 1 - wR / dilations.x;\n            if (dyR < 0.0 || dyR >= ${c}(outBackprop[${m}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {\n              if (wC % dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${c}(dyCCorner) + ${c}(wC)) / ${c}(strides.y);\n              let wCPerm = filterDims.y - 1 - wC / dilations.y;\n              if (dyC < 0.0 || dyC >= ${c}(outBackprop[${g}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * ${C};\n              for (var d2: u32 = 0; d2 < ${C}; d2 = d2 + 1) {\n                let xValue = ${o?D.get("batch","idyR","idyC","inputChannel"):D.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${B.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${n?"bias[d1]":"0.0"};\n          ${z.setByOffset("global_idx","value")};\n        `;return`\n  ${e.declareVariables(..._,z)}\n  ${P}\n  const outShape : vec4<u32> = vec4<u32>(${i.join(",")});\n  const outBackprop : vec4<u32> = vec4<u32>(${t[0].dims.join(",")});\n  const strides : vec2<u32> = vec2<u32>(${r.strides[0]}, ${r.strides[1]});\n  const filterDims : vec2<u32> = vec2<u32>(${r.kernelShape[o?1:2]}, ${r.kernelShape[o?2:3]});\n  const dilations : vec2<u32> = vec2<u32>(${r.dilations[0]}, ${r.dilations[1]});\n  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(\n          ${r.dilations[0]<=1?0:(r.kernelShape[o?1:2]-1)*(r.dilations[0]-1)},\n          ${r.dilations[1]<=1?0:(r.kernelShape[o?2:3]-1)*(r.dilations[1]-1)});\n  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,\n                                     i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)};\n  ${u?N:Y}}`},On=(e,t,r)=>{let i=e.length>2,n=t.outputShape,s=k.size(n),u=[Math.ceil(s/64),1,1];Oe("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${u}`);let c=Re(e[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:t.cacheKey},getRunData:()=>({dispatchGroup:{x:u[0],y:u[1],z:u[2]},outputs:[{dims:r?r(n):n,dataType:e[0].dataType}]}),getShaderSource:o=>ol(o,e,t,n,i,u[1]===1&&u[2]===1,!1,c)}}});var al,il,sl,ri,ni,ul,ll,cl,dl,oi,ai=j(()=>{"use strict";Pe();ei();ti();er();Gr();al=(e,t,r,i,n,s)=>(e-1)*t+r+(i-1)*n+1-s,il=(e,t,r,i,n)=>{let s=Math.floor(e/2);t==="SAME_UPPER"?(r[i]=s,r[n]=e-s):t==="SAME_LOWER"&&(r[i]=e-s,r[n]=s)},sl=(e,t,r,i,n,s,u,c,o,m)=>{let g=e.length-2,x=m.length===0;if(o.length===0)for(let $=0;$<g;++$)o.push(0);let b=e[0],w=t[c?3:1]*n;for(let $=0,y=e.length-g-(c?1:0);$<g;++$,++y){let C=e[y],A=x?C*u[$]:m[$],P=al(C,u[$],s[$],t[y],r[$],A);il(P,i,s,$,$+g),x&&m.push(u[$]*(C-1)+o[$]+(t[y]-1)*r[$]+1-s[$]-s[$+g])}m.splice(0,0,b),m.splice(c?3:1,0,w)},ri=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((b,w)=>b*w,1)===0){r.length=0;for(let b=2;b<t[1].dims.length;++b)r.push(t[1].dims[b])}let i=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(i?3:1,0,t[1].dims[1]);let n=e.pads.slice(),s=e.outputShape.slice(),u=e.outputPadding.slice(),c=t[0].dims,o=e.dilations.slice();if(o.reduce((b,w)=>b+w,0)===0){let b=t[0].dims.length-2;o=new Array(b).fill(1)}let m=e.strides.slice();if(m.reduce((b,w)=>b+w,0)===0){let b=t[0].dims.length-2;m=new Array(b).fill(1)}sl(c,r,o,e.autoPad,e.group,n,m,i,u,s);let g=Object.assign({},e),x=e.cacheKey+[r.join("n,"),n.join(","),m.join(","),u.join(","),s.join(","),o.join(",")].join("_");return Object.assign(g,{kernelShape:r,pads:n,outputPadding:u,outputShape:s,dilations:o,strides:m,cacheKey:x}),g},ni=e=>{let t=Wr(e),r=e.format,i=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],n=e.dilations,s=e.group,u=e.kernelShape,c=e.pads,o=e.strides,m=e.wIsConst(),g=e.outputPadding,x=e.outputShape;return ie({autoPad:i,format:r,dilations:n,group:s,kernelShape:u,outputPadding:g,outputShape:x,pads:c,strides:o,wIsConst:m,...t})},ul=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],i=e[1].dims[0];if(r!==i)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==n))throw new Error("invalid bias");let s=e[0].dims.length-2;if(t.dilations.reduce((g,x)=>g+x,0)>0&&t.dilations.length!==s)throw new Error(`dilations should be ${s}D`);if(t.strides.reduce((g,x)=>g+x,0)>0&&t.strides.length!==s)throw new Error(`strides should be ${s}D`);if(t.pads.reduce((g,x)=>g+x,0)>0&&t.pads.length!==s*2)throw new Error(`pads should be ${s*2}D`);if(t.outputPadding.length!==s&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${s}D`);if(t.kernelShape.reduce((g,x)=>g+x,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},ll=[2,3,1,0],cl=(e,t,r)=>{let i=ri(r,t),n=r.format==="NHWC",s=t.length===3;if(i.group!==1){e.compute(On(t,i));return}let u=i.outputShape,c=u[n?1:2],o=u[n?2:3],m=u[n?3:1],g=t[1].dims[2],x=t[1].dims[3],b=t[0].dims[n?3:1],w=n?c*o:m,$=n?m:c*o,y=g*x*b,C=!0,A=e.kernelCustomData.wT??e.compute(_t(t[1],ll),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=A);let P=[t[0],A];s&&(!n&&t[2].dims.length===1?P.push(t[2].reshape([t[2].dims[0],1,1])):P.push(t[2])),e.compute(Qa(P,i,u,w,$,y,s,C),{inputs:P})},dl=(e,t)=>{let r=t.format==="NHWC",i=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];i.length===3&&i.push(e.inputs[2]);let n=t.kernelShape;(n.length===0||n[0]===0)&&(n=[e.inputs[1].dims[2]]);let s=t.dilations;(s.length===0||s[0]===0)&&(s=[1]);let u=t.strides;(u.length===0||u[0]===0)&&(u=[1]);let c=t.pads;c.length===0&&(c=[0,0]),c=[0,c[0],0,c[1]],u=[1].concat(u),s=[1].concat(s),n=[1].concat(n);let o=ri({...t,pads:c,strides:u,dilations:s,kernelShape:n},i);e.compute(On(i,o,m=>r?[m[0],m[2],m[3]]:[m[0],m[1],m[3]]))},oi=(e,t)=>{ul(e.inputs,t),e.inputs[0].dims.length===3?dl(e,t):cl(e,e.inputs,t)}});var En,Vr,ii,pl,fl,_n,Pn,ml,si,ui,li=j(()=>{"use strict";he();Pe();ve();En="[a-zA-Z]|\\\\.\\\\.\\\\.",Vr="("+En+")+",ii="^"+Vr+"$",pl="("+Vr+",)*"+Vr,fl="^"+pl+"$",_n=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let i=this.symbolToIndices.get(t);i===void 0?i=[r]:i.push(r),this.symbolToIndices.set(t,i)}},Pn=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[i,n]=r.includes("->")?r.split("->",2):[r,""];if(!i.match(RegExp(fl)))throw new Error("Invalid LHS term");if(i.split(",").forEach((c,o)=>{let m=t[o].dims.slice();if(!c.match(RegExp(ii)))throw new Error("Invalid LHS term");let g=this.processTerm(c,!0,m,o);this.lhs.push(g)}),n==="")n+=[...this.symbolToInfo.entries()].filter(([c,o])=>o.count===1||c==="...").map(([c])=>c).join("");else if(!n.match(RegExp(Vr)))throw new Error("Invalid RHS");n.match(RegExp(En,"g"))?.forEach(c=>{if(c==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let o=this.symbolToInfo.get(c);if(o===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(o.dimValue)}}),this.rhs=this.processTerm(n,!0,this.outputDims)}addSymbol(t,r,i){let n=this.symbolToInfo.get(t);if(n!==void 0){if(n.dimValue!==r&&n.count!==1)throw new Error("Dimension mismatch");n.count++,n.inputIndices.push(i)}else n={count:1,dimValue:r,inputIndices:[i]};this.symbolToInfo.set(t,n)}processTerm(t,r,i,n=-1){let s=i.length,u=!1,c=[],o=0;if(!t.match(RegExp(ii))&&!r&&t!=="")throw new Error("Invalid LHS term");let m=t.match(RegExp(En,"g")),g=new _n(n);return m?.forEach((x,b)=>{if(x==="..."){if(u)throw new Error("Only one ellipsis is allowed per input term");u=!0;let w=s-m.length+1;if(w<0)throw new Error("Ellipsis out of bounds");if(c=i.slice(o,o+w),this.hasEllipsis){if(this.ellipsisDims.length!==c.length||this.ellipsisDims.toString()!==c.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=c;else throw new Error("Ellipsis must be specified in the LHS");for(let $=0;$<c.length;$++){let y=String.fromCharCode("0".charCodeAt(0)+b);g.addSymbol(y,b+$),this.addSymbol(y,i[o++],n)}}else g.addSymbol(x,b),this.addSymbol(x,i[o++],n)}),g}},ml=(e,t)=>{let r=e[0].dataType,i=new Array(e.length);for(let W=0;W<e.length;++W)i[W]=F(`input${W}`,r,e[W].dims);let n=t.outputDims,s=k.size(n),u=Z("output",r,n),c=[],o=Array.from(t.rhs.symbolToIndices.keys()),m="var prod = 1.0;",g="var sum = 0.0;",x="sum += prod;",b=[],w=[],$=[],y=[],C=t.symbolToInfo.size===o.length;t.symbolToInfo.forEach((W,B)=>{if(o.includes(B)){let D=o.indexOf(B);t.lhs.forEach((_,z)=>{if(W.inputIndices.includes(z)){let N=_.symbolToIndices.get(B);if(N===void 0)throw new Error("Invalid symbol error");N.forEach(Y=>{c.push(`${i[z].indicesSet(`input${z}Indices`,Y,u.indicesGet("outputIndices",D))}`)})}})}else t.lhs.forEach((D,_)=>{let z=t.symbolToInfo.get(B);if(z===void 0)throw new Error("Invalid symbol error");if(z.inputIndices.includes(_)){let N=D.symbolToIndices.get(B);if(N===void 0)throw new Error("Invalid symbol error");N.forEach(Y=>{b.push(`${i[_].indicesSet(`input${_}Indices`,Y,`${B}`)}`)}),y.push(`prod *= ${i[_].getByIndices(`input${_}Indices`)};`)}}),w.push(`for(var ${B}: u32 = 0; ${B} < ${t.symbolToInfo.get(B)?.dimValue}; ${B}++) {`),$.push("}")});let A=C?[...c,`let sum = ${i.map((W,B)=>W.getByIndices(`input${B}Indices`)).join(" * ")};`]:[...c,g,...w,...b,m,...y,x,...$],P=W=>`\n      ${W.declareVariables(...i,u)}\n\n      ${W.mainStart()}\n        ${W.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n        var outputIndices = ${u.offsetToIndices("global_idx")};\n        ${i.map((B,D)=>`var input${D}Indices: ${i[D].type.indices};`).join(`\n`)}\n        ${A.join(`\n`)};\n        ${u.setByOffset("global_idx","sum")};\n      }`;return{name:"Einsum",shaderCache:{hint:t.equation},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:P}},si=(e,t)=>{let r=new Pn(e.inputs,t.equation);e.compute(ml(e.inputs,r))},ui=e=>{let t=e.equation.replace(/\\s+/g,"");return ie({equation:t})}});var hl,ci,gl,yl,di,pi=j(()=>{"use strict";he();ve();hl=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),i=r.length<t.length?0:r.length-t.length,n=t.length<r.length?0:t.length-r.length;for(;i<r.length&&n<t.length;++i,++n)if(r[i]!==t[n]&&r[i]!==1&&t[n]!==1)throw new Error("Expand requires shape to be broadcastable to input")},ci=(e,t)=>{let r=e.length-t.length,i=[];for(let n=0;n<r;++n)i.push(e[n]);for(let n=0;n<t.length;++n)i.push(t[n]===1?e[n+r]:t[n]);return i},gl=(e,t)=>e.length>t.length?ci(e,t):ci(t,e),yl=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),i=gl(t,r),n=k.size(i),s=e[0].dataType,u=F("input",s,t),c=Z("output",s,i),o=m=>`\n  const inputShape = ${u.indices(...t)};\n  ${m.declareVariables(u,c)}\n  ${m.mainStart()}\n  ${m.guardAgainstOutOfBoundsWorkgroupSizes(n)}\n    let outputIndices = ${c.offsetToIndices("global_idx")};\n    var inputIndices: ${u.type.indices};\n    for (var i = 0; i < ${t.length}; i++) {\n      if (${u.indicesGet("inputShape","i")} == 1) {\n        ${u.indicesSet("inputIndices","i",0)}\n      } else {\n        ${u.indicesSet("inputIndices","i",c.indicesGet("outputIndices",`i + ${i.length-t.length}`))}\n      }\n    }\n    ${c.setByOffset("global_idx",u.getByIndices("inputIndices"))}\n  }`;return{name:"Expand",shaderCache:{hint:`${i}`},getShaderSource:o,getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}})}},di=e=>{hl(e.inputs),e.compute(yl(e.inputs),{inputs:[0]})}});var bl,wl,fi,mi,hi=j(()=>{"use strict";he();Pe();ve();bl=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},wl=(e,t)=>{let r=e[0].dims,i=e[1].dims,n=r.length,s=k.normalizeAxis(t.axis,n),u=r.slice(0);u.splice(s,1,...i);let c=r[s],o=k.size(u),m=F("data",e[0].dataType,e[0].dims),g=F("inputIndices",e[1].dataType,e[1].dims),x=Z("output",e[0].dataType,u),b=()=>{let $=i.length,y=`var indicesIndices  = ${g.type.indices}(0);`;for(let C=0;C<$;C++)y+=`${$>1?`indicesIndices[${C}]`:"indicesIndices"} = ${u.length>1?`outputIndices[${s+C}]`:"outputIndices"};`;y+=`\n        var idx = ${g.getByIndices("indicesIndices")};\n        if (idx < 0) {\n          idx = idx + ${c};\n        }\n        var dataIndices = ${m.type.indices}(0);\n      `;for(let C=0,A=0;C<n;C++)C===s?(y+=`${n>1?`dataIndices[${C}]`:"dataIndices"} = u32(idx);`,A+=$):(y+=`${n>1?`dataIndices[${C}]`:"dataIndices"} = ${u.length>1?`outputIndices[${A}]`:"outputIndices"};`,A++);return y},w=$=>`\n      ${$.declareVariables(m,g,x)}\n      ${$.mainStart()}\n        ${$.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n        let outputIndices = ${x.offsetToIndices("global_idx")};\n        ${b()};\n        let value = ${m.getByIndices("dataIndices")};\n        ${x.setByOffset("global_idx","value")};\n      }`;return{name:"Gather",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:w}},fi=e=>ie({axis:e.axis}),mi=(e,t)=>{let r=e.inputs;bl(r),e.compute(wl(e.inputs,t))}});var vl,$l,gi,yi,bi=j(()=>{"use strict";he();Pe();ve();vl=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},$l=(e,t)=>{let r=e[0].dims,i=e[0].dataType,n=r.length,s=k.computeStrides(r),u=k.size(r),c=e[1].dims,o=e[1].dataType,m=k.size(c),g=k.normalizeAxis(t.axis,n),x=r[g],b=c.slice(0),w=k.size(b),$=F("input",i,r),y=F("indices",o,[m]),C=Z("output",i,b),A=P=>`\n      const inputStrides = array<u32, ${s.length}>(${s.map(W=>`${W}u`).join(",")});\n      ${P.declareVariables($,y,C)}\n      ${P.mainStart()}\n      ${P.guardAgainstOutOfBoundsWorkgroupSizes(w)}\n\n      let outputIndices = ${C.offsetToIndices("global_idx")};\n\n      var idx = ${y.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + ${x};\n      }\n\n      var srcOffset = u32(0);\n\n      for (var i = 0; i < ${r.length}; i++) {\n        if (i == ${g}) {\n          srcOffset +=  u32(idx) * inputStrides[i];\n        } else {\n          srcOffset += ${C.indicesGet("outputIndices","i")} * inputStrides[i];\n        }\n      }\n\n      // Should never hit this with valid values in indices\n      // This is a guard against malicious data in the indices input\n      if (srcOffset < 0 || srcOffset >= ${u}) {\n        return;\n      }\n\n      output[global_idx] = input[srcOffset];\n  }`;return{name:"GatherElements",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:b,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)}}),getShaderSource:A}},gi=e=>ie({axis:e.axis}),yi=(e,t)=>{let r=e.inputs;vl(r),e.compute($l(e.inputs,t))}});var xl,Cl,Sl,wi,vi,$i=j(()=>{"use strict";he();Pe();ve();xl=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},Cl=(e,t,r)=>{if(r.length===0)return"0u";let i=r.length===1&&e!==1||r.length===2&&r[0]!==e,n=r[r.length-1]!==t,s="0u";return i||(s+=`+ m * ${r[r.length-1]}u`),n||(s+="+n"),s},Sl=(e,t)=>{let r=e[0].dims.slice(),i=e[1].dims.slice(),[n,s,u]=Ir.getShapeOfGemmResult(r,t.transA,i,t.transB,e.length===3?e[2].dims:void 0),c=[n,s];if(!c)throw new Error("Can\'t use gemm on the given tensors");let o=k.size(c),m="";t.transA&&t.transB?m="value += a[k * M + m] * b[n * K + k];":t.transA&&!t.transB?m="value += a[k * M + m] * b[k * N + n];":!t.transA&&t.transB?m="value += a[m * K + k] * b[n * K + k];":!t.transA&&!t.transB&&(m="value += a[m * K + k] * b[k * N + n];");let g=Re(e[0].dataType),x=t.alpha===1?"":"value *= alpha;",b=e.length===3?`value += beta * c[${Cl(n,s,e[2].dims)}];`:"",w=[`@group(0) @binding(0) var<storage, read> a : array<${g}>;`,`@group(0) @binding(1) var<storage, read> b : array<${g}>;`];e.length===3&&w.push(`@group(0) @binding(2) var<storage, read> c : array<${g}>;`);let $=y=>`\n  const M: u32 = ${n}u;\n  const N: u32 = ${s}u;\n  const K: u32 = ${u}u;\n  const alpha = ${g}(${t.alpha});\n  const beta = ${g}(${t.beta});\n\n  ${w.join(`\n`)}\n  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${g}>;\n\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n\n    let m = global_id.x / N;\n    let n = global_id.x % N;\n\n    var value = ${g}(0);\n    for (var k: u32 = 0u; k<${u}u; k++) {\n      ${m}\n    }\n\n    ${x}\n    ${b}\n    output[global_id.x] = value;\n\n  }`;return{name:"Gemm",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:c,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:$}},wi=(e,t)=>{xl(e.inputs),e.compute(Sl(e.inputs,t))},vi=e=>ie(e)});var Al,Il,Tl,Ol,xi,Ci,Si=j(()=>{"use strict";ke();he();Pe();ve();Al={name:"InstanceNormalization"},Il=(e,t)=>{let r=e[0].dims,i=r,n=2,s=k.sizeToDimension(r,n),u=k.sizeFromDimension(r,n),c=r[1],o=F("x",e[0].dataType,[r[0],r[1],u]),m=F("scale",e[1].dataType,e[1].dims),g=F("bias",e[2].dataType,e[2].dims),x=Z("output",e[0].dataType,[r[0],r[1],u]),b=[o,m,g,x],w=o.type.value,$=64,y=C=>`\n\n  const C: u32 = ${c};\n  const normSize: u32 = ${u};\n  const epsilon: f32 = ${t.epsilon};\n  var<workgroup> meanShared : ${w};\n  var<workgroup> squaredNormShared : ${w};\n  var<workgroup> workgroupShared : array<${w}, ${$}>;\n  const workgroupSize = ${$}u;\n  ${C.declareVariables(...b)}\n  ${C.mainStart($)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / C;\n    let channel = norm % C;\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial: ${w} = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      initial = initial + ${o.get("batch","channel","h")};\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = workgroupShared[0] / ${w}(normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let deviation =  ${o.get("batch","channel","h")} - meanShared;\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = workgroupShared[0];\n    }\n    workgroupBarrier();\n\n    let invStdDev = 1 / sqrt(squaredNormShared / ${w}(normSize) + epsilon);\n    let channelScale = invStdDev * ${m.getByOffset("channel")};\n    let channelShift = ${g.getByOffset("channel")} - meanShared * channelScale;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let value = ${o.get("batch","channel","h")} * channelScale + channelShift;\n      ${x.set("batch","channel","h","value")};\n    }\n  }`;return{...Al,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:s}}),getShaderSource:y}},Tl=(e,t,r,i,n,s,u,c)=>{let o=ut(u),m=F("input",t.dataType,t.dims,o),g=F("scale",r.dataType,r.dims,o),x=F("bias",i.dataType,i.dims,o),b=64,w=o===1?"vec2f":`mat2x${o}f`,$=o===1?"f32":`vec${o}f`,y=(D,_)=>`${w}(${D}, ${_})`,C=n*u/o,A=Math.ceil(s/b),P=D=>`\n  const H: u32 = ${s};\n  const C: u32 = ${u/o};\n  const imageSize: u32 = ${s*u/o};\n\n  ${D.declareVariables(m)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${w}>;\n\n  ${D.mainStart(b)}\n    let currentImageNumber = global_idx / ${b} / C;\n    let currentChannelNumber = (global_idx / ${b}) % C;\n    let wgId = global_idx % ${b};\n    let wgOffset = wgId * ${A};\n    if (wgOffset >= H) {\n        return;\n    }\n    let wgMax = min(wgOffset + ${A}, H);\n\n    let offset = currentImageNumber * imageSize + currentChannelNumber;\n    var sum = ${Xe("f32",o)};\n    var squaredSum = ${Xe("f32",o)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${$}(input[offset + i * C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${y("sum","squaredSum")};\n  }`,W=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:o,n,h:s,c:u})},getRunData:()=>({outputs:[{dims:[n,u,b,2],dataType:1}],dispatchGroup:{x:n*u/o}}),getShaderSource:P},{inputs:[t],outputs:[-1]})[0],B=D=>`\n  const H: u32 = ${s};\n  const C: u32 = ${u/o};\n  const imageSize: u32 = ${b*u/o};\n  const epsilon: f32 = ${c};\n\n  @group(0) @binding(0) var<storage, read> input : array<${w}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${g.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${x.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${w}>;\n\n  ${D.mainStart()}\n    ${D.guardAgainstOutOfBoundsWorkgroupSizes(C)}\n    let currentImageNumber = global_idx / C;\n    let currentChannelNumber = global_idx % C;\n\n    let offset = currentImageNumber * imageSize;\n    var sum = ${Xe("f32",o)};\n    var squaredSum = ${Xe("f32",o)};\n    for (var i: u32 = 0; i < ${b}; i++) {\n        let value = input[offset + i + currentChannelNumber * ${b}];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(H);\n    squaredSum = squaredSum / f32(H);\n    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);\n    let channelScale = invStdDev * ${$}(scale[currentChannelNumber]);\n    let channelShift = ${$}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${y("channelScale","channelShift")};\n  }`;return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:o,n,h:s,c:u,epsilon:c})},getRunData:()=>({outputs:[{dims:[n,u,2],dataType:1}],dispatchGroup:{x:Math.ceil(C/64)}}),getShaderSource:B},{inputs:[W,r,i],outputs:[-1]})[0]},Ol=(e,t,r)=>{let i=t[0].dims,n=i,s=i[0],u=i[i.length-1],c=k.sizeFromDimension(i,1)/u,o=ut(u),m=k.size(n)/o,g=F("input",t[0].dataType,t[0].dims,o),x=Z("output",t[0].dataType,n,o),b=Re(t[0].dataType),w=o===1?"vec2f":`mat2x${o}f`,$=o===1?b:`vec${o}<${b}>`,y=Tl(e,t[0],t[1],t[2],s,c,u,r.epsilon),C=A=>`\n  const H: u32 = ${c};\n  const C: u32 = ${u/o};\n\n  @group(0) @binding(0) var<storage, read> input : array<${g.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${w}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${x.type.storage}>;\n\n  ${A.mainStart()}\n    let currentImageNumber = global_idx / (C * H);\n    let currentChannelNumber = global_idx % C;\n\n    let scaleOffset = currentImageNumber * C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${$}(scale[0]), ${$}(scale[1]));\n  }`;e.compute({name:"InstanceNormalization",shaderCache:{hint:`${r.cacheKey}`},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)}}),getShaderSource:C},{inputs:[t[0],y]})},xi=e=>ie({epsilon:e.epsilon,format:e.format}),Ci=(e,t)=>{t.format==="NHWC"?Ol(e,e.inputs,t):e.compute(Il(e.inputs,t))}});var El,_l,Ai,Ii,Ti=j(()=>{"use strict";ke();he();Pe();ve();El=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},_l=(e,t,r)=>{let i=e[0].dims,n=e[1],s=e[2],u=i,c=k.normalizeAxis(t.axis,i.length),o=k.sizeToDimension(i,c),m=k.sizeFromDimension(i,c),g=k.size(n.dims),x=s?k.size(s.dims):0;if(g!==m||s&&x!==m)throw new Error(`Size of X.shape()[axis:] == ${m}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${g} and bias size of ${x}`);let b=[];for(let B=0;B<i.length;++B)B<c?b.push(i[B]):b.push(1);let w=ut(m),$=Re(e[0].dataType),y=[F("x",e[0].dataType,e[0].dims,w),F("scale",n.dataType,n.dims,w)];s&&y.push(F("bias",s.dataType,s.dims,w)),y.push(Z("output",e[0].dataType,u,w));let C=r>1,A=r>2;C&&y.push(Z("meanDataOutput",1,b)),A&&y.push(Z("invStdOutput",1,b));let P=B=>`\n  const normSize: f32 = ${m};\n  const normSizeVectorized: u32 = ${m/w};\n  const epsilon: f32 = ${t.epsilon};\n\n  ${B.declareVariables(...y)}\n  ${B.mainStart()}\n    ${B.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n    let offset = global_idx * normSizeVectorized;\n    var meanVector = ${Xe("f32",w)};\n    var meanSquareVector = ${Xe("f32",w)};\n\n    for (var h: u32 = 0u; h < normSizeVectorized; h++) {\n      let value = ${wt($,w,"x[h + offset]")};\n      meanVector += value;\n      meanSquareVector += value * value;\n    }\n    let mean = ${ft("meanVector",w)} / normSize;\n    let meanSquare = sqrt(${ft("meanSquareVector",w)} \n      / normSize - mean * mean + epsilon);\n\n    for (var j: u32 = 0; j < normSizeVectorized; j++) {\n      let f32input = ${wt($,w,"x[j + offset]")};\n      let f32scale = ${wt($,w,"scale[j]")};\n      output[j + offset] = ${y[0].type.value}((f32input - mean) / meanSquare * f32scale\n        ${s?`+ ${wt($,w,"bias[j]")}`:""}\n      );\n    }\n\n    ${C?"meanDataOutput[global_idx] = mean":""};\n    ${A?"invStdOutput[global_idx] = 1 / meanSquare":""};\n  }`,W=[{dims:u,dataType:e[0].dataType}];return C&&W.push({dims:b,dataType:1}),A&&W.push({dims:b,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${t.cacheKey}|${r}|${e.length}`},getRunData:()=>({outputs:W,dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:P}},Ai=e=>ie({axis:e.axis,epsilon:e.epsilon}),Ii=(e,t)=>{El(e.inputs),e.compute(_l(e.inputs,t,e.outputCount))}});var Pl,Oi,Ei=j(()=>{"use strict";he();nr();Pl=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},Oi=e=>{Pl(e.inputs);let t=rt.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can\'t use matmul on the given tensors");e.compute(zr(e.inputs,{activation:"",activationCacheKey:""},t))}});var Rl,Bl,Ml,kl,Dl,Wl,zl,Gl,Vl,_i,Pi,Ri=j(()=>{"use strict";ke();he();Pe();ve();Rl=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1)throw new Error("Input type must be float.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},Bl=(e,t,r,i,n,s,u)=>{let c=r.length,o="";for(let m=c-1;m>=0;--m)o+=`\n            k = i32(${e.indicesGet("indices",m)}) - ${n[m]};\n            if (k < 0) {\n              break;\n            }\n            if (k >= ${r[m]}) {\n              break;\n            }\n            offset += k * ${i[m]};\n        `;return`\n          value = ${s}(${u});\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${o}\n            value = x[offset];\n          }\n      `},Ml=(e,t,r,i,n)=>{let s=r.length,u="";for(let c=s-1;c>=0;--c)u+=`\n                k = i32(${e.indicesGet("indices",c)}) - ${n[c]};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = ${2*(r[c]-1)};\n                  k = k % _2n_1;\n                  if(k >= ${r[c]}) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * ${i[c]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${u}\n              value = x[offset];\n          `},kl=(e,t,r,i,n)=>{let s=r.length,u="";for(let c=s-1;c>=0;--c)u+=`\n                k = i32(${e.indicesGet("indices",c)}) - ${n[c]};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= ${r[c]}) {\n                  k = ${r[c]-1};\n                }\n                offset += k * ${i[c]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${u}\n              value = x[offset];\n          `},Dl=(e,t,r,i,n)=>{let s=r.length,u="";for(let c=s-1;c>=0;--c)u+=`\n                k = i32(${e.indicesGet("indices",c)}) - ${n[c]};\n                if (k < 0)  {\n                  k += ${r[c]};\n                }\n                if (k >= ${r[c]}) {\n                  k -= ${r[c]};\n                }\n                offset += k * ${i[c]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${u}\n              value = x[offset];\n          `},Wl=(e,t,r,i,n,s)=>{switch(n.mode){case 0:return Bl(e,t,r,i,n.pads,s,n.value);case 1:return Ml(e,t,r,i,n.pads);case 2:return kl(e,t,r,i,n.pads);case 3:return Dl(e,t,r,i,n.pads);default:throw new Error("Invalid mode")}},zl=(e,t,r,i)=>{let n=t[0].dims,s=k.padShape(n.slice(),r.pads),u=k.size(s),c=k.computeStrides(n),o=Z("output",t[0].dataType,s),m=F("x",t[0].dataType,n),g=Wl(o,s,n,c,r,i);return`\n              ${e.declareVariables(m,o)}\n              ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n\n              let indices = ${o.offsetToIndices("global_idx")};\n\n              var value = ${i}(0);\n              ${g}\n              output[global_idx] = value;\n          }`},Gl=(e,t)=>{let r=k.padShape(e[0].dims.slice(),t.pads);return{name:"Pad",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(k.size(r)/64)}}),getShaderSource:i=>zl(i,e,t,"f32")}},Vl=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),i=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,n=e[0].dims.length,s=new Int32Array(2*n).fill(0);if(e.length>=4){let c=e[3].getBigInt64Array();for(let o=0;o<c.length;o++)s[Number(c[o])]=Number(r[o]),s[Number(c[o])+n]=Number(r[o+c.length])}else r.forEach((c,o)=>s[Number(o)]=Number(c));let u=[];return s.forEach(c=>u.push(c)),ie({mode:t.mode,value:i,pads:u})}else return t},_i=(e,t)=>{Rl(e.inputs);let r=Vl(e.inputs,t);e.compute(Gl(e.inputs,r),{inputs:[0]})},Pi=e=>{let t=e.mode,r=e.value,i=e.pads;return ie({mode:t,value:r,pads:i})}});var Ur,Bi,Mi,ki,Di,Wi,zi,Gi,Vi,Ui,Ni,Fi,Hi,Li,ji,Ki=j(()=>{"use strict";he();Pe();ve();Ur=e=>{if(!e||e.length!==1)throw new Error("Pool ops requires 1 input.");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("Pool ops supports 1-D or 2-D inputs only for now.")},Bi=(e,t,r)=>{let i=t.format==="NHWC",n=e.dims.slice();i&&n.splice(1,0,n.pop());let s=Object.hasOwnProperty.call(t,"dilations"),u=t.kernelShape.slice(),c=t.strides.slice(),o=s?t.dilations.slice():[],m=t.pads.slice();bt.adjustPoolAttributes(r,n,u,c,o,m);let g=bt.computePoolOutputShape(r,n,c,o,u,m,t.autoPad),x=Object.assign({},t);s?Object.assign(x,{kernelShape:u,strides:c,pads:m,dilations:o,cacheKey:t.cacheKey}):Object.assign(x,{kernelShape:u,strides:c,pads:m,cacheKey:t.cacheKey});let b=g.slice();return b.push(b.splice(1,1)[0]),[x,i?b:g]},Mi=(e,t,r,i,n,s,u,c)=>{let o=n.format==="NHWC",m=r,g=t.type.value,x=m.length,b=k.size(i),w=Z("output",t.type.tensor,i);if(n.kernelShape.length<=2){let $=n.kernelShape[n.kernelShape.length-1],y=n.strides[n.strides.length-1],C=n.pads[n.pads.length/2-1],A=n.pads[n.pads.length-1],P=x-(o?2:1),W="",B="",D="";if(C+A!==0?W=`\n                for (var i: u32 = 0u; i < ${$}u; i++) {\n                  xIndices[${P}] = indices[${P}] * ${y} - ${C} + i;\n                  if (xIndices[${P}] < 0 || xIndices[${P}] >= ${m[P]}) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${s}\n                }`:W=`\n                for (var i: u32 = 0u; i < ${$}u; i++) {\n                  xIndices[${P}] = indices[${P}] * ${y} - ${C} + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${s}\n                }`,n.kernelShape.length===2){let z=n.kernelShape[n.kernelShape.length-2],N=n.strides[n.strides.length-2],Y=n.pads[n.pads.length/2-2],le=n.pads[n.pads.length-2],M=x-(o?3:2),q=m[M];Y+le!==0?B=`\n                for (var j: u32 = 0u; j < ${z}u; j++) {\n                  xIndices[${M}] = indices[${M}] * ${N} - ${Y} + j;\n                  if (xIndices[${M}] < 0 || xIndices[${M}] >= ${q}) {\n                    pad+= ${$};\n                    continue;\n                  }\n              `:B=`\n                for (var j: u32 = 0u; j < ${z}u; j++) {\n                  xIndices[${M}] = indices[${M}] * ${N} - ${Y} + j;\n                `,D=`\n              }\n            `}return`\n            ${e.declareVariables(t,w)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n\n              let indices = ${w.offsetToIndices("global_idx")};\n              var xIndices = ${w.offsetToIndices("global_idx")};\n\n              var value: ${g} = ${g}(${c});\n              var pad = 0;\n              ${B}\n              ${W}\n              ${D}\n              ${u}\n\n              output[global_idx] = value;\n            }`}else{if(o)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let $=k.size(n.kernelShape),y=k.computeStrides(n.kernelShape),C=y.length,A=n.pads.length,P=n.pads.reduce((D,_)=>D+_),W="";return P?W=`\n                if (xIndices[j] >= inputDims[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${s}\n              }`:W=`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${s}\n            `,`\n            ${e.declareVariables(t,w)}\n\n            const pads = array<u32, ${A}>(${n.pads.map(D=>`${D}u`).join(",")});\n            const inputDims = array<u32, ${x}>(${m.map(D=>`${D}u`).join(",")});\n            const kernelStrides = array<u32, ${C}>(${y.map(D=>`${D}u`).join(",")});\n            const strides = array<u32, ${C}>(${n.strides.map(D=>`${D}u`).join(",")});\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n\n              let indices = ${w.offsetToIndices("global_idx")};\n              let xIndices = ${w.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${C}>;\n\n              var value = ${w.type.value}(${c});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < ${$}u; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${C-1}u; j++) {\n                  offsets[j] = offset / kernelStrides[j];\n                  offset -= offsets[j] * kernelStrides[j];\n                }\n                offsets[${C-1}] = offset;\n\n                isPad = false;\n                for (var j = ${x-C}u; j < ${x}u; j++) {\n                  xIndices[j] = indices[j] * strides[j - ${x-C}u]\n                    + offsets[j - ${x-C}u] - pads[j - 2u];\n                  ${W}\n              }\n              ${u}\n\n              output[global_idx] = value;\n            }`}},ki=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Di=(e,t,r,i)=>{let[n,s]=Bi(t,i,r),u=k.size(n.kernelShape),c=F("x",t.dataType,t.dims),o=c.type.value,m="value += x_val;",g="";return n.countIncludePad?g+=`value /= ${o}(${u});`:g+=`value /= ${o}(${u} - pad);`,{name:e,shaderCache:{hint:i.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(k.size(s)/64)}}),getShaderSource:x=>Mi(x,c,t.dims,s,n,m,g,"0.0")}},Wi=e=>{let t=e.count_include_pad!==0,r=ki(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return ie({countIncludePad:t,...r})},zi=(e,t)=>{Ur(e.inputs),e.compute(Di("AveragePool",e.inputs[0],!1,t))},Gi={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},Vi=e=>{let t=e.format;return{format:t,...Gi,cacheKey:t}},Ui=(e,t)=>{Ur(e.inputs),e.compute(Di("GlobalAveragePool",e.inputs[0],!0,t))},Ni=(e,t,r,i)=>{let[n,s]=Bi(t,i,r),u=`\n      value = max(x_val, value);\n    `,c="",o=F("x",t.dataType,t.dims);return{name:e,shaderCache:{hint:i.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(k.size(s)/64)}}),getShaderSource:m=>Mi(m,o,t.dims,s,n,u,c,"-1e5")}},Fi=(e,t)=>{Ur(e.inputs),e.compute(Ni("MaxPool",e.inputs[0],!1,t))},Hi=e=>{let t=e.storage_order,r=e.dilations,i=ki(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(i.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return ie({storageOrder:t,dilations:r,...i})},Li=e=>{let t=e.format;return{format:t,...Gi,cacheKey:t}},ji=(e,t)=>{Ur(e.inputs),e.compute(Ni("GlobalMaxPool",e.inputs[0],!0,t))}});var Nr=j(()=>{});var qi=j(()=>{Nr()});var Yi,Xi=j(()=>{Yi="1.17.0"});var Ji,Rn,Zi=j(()=>{Xi();Ji="warning",Rn={wasm:{},webgl:{},webgpu:{},versions:{common:Yi},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);Ji=e}},get logLevel(){return Ji}};Object.defineProperty(Rn,"logLevel",{enumerable:!0})});var Qi,es=j(()=>{Zi();Qi=Rn});var ts=j(()=>{});var rs=j(()=>{Fr()});var os=j(()=>{});var as=j(()=>{Fr()});var Fr=j(()=>{ts();rs();os();as()});var Bn=j(()=>{Fr()});var is=j(()=>{Nr();Bn()});var ss=j(()=>{is()});var us=j(()=>{});var ls=j(()=>{Nr()});var cs=j(()=>{ls()});var ds=j(()=>{qi();es();ss();Bn();us();cs()});var Fl,Hl,ps,fs=j(()=>{"use strict";ds();ke();ve();Fl=(e,t,r)=>{let i=e===t,n=e<t&&r<0,s=e>t&&r>0;if(i||n||s)throw new Error("Range these inputs\' contents are invalid.")},Hl=(e,t,r,i)=>{let n=Math.abs(Math.ceil((t-e)/r)),s=[n],u=n,c=Z("output",i,s),o=c.type.storage,m=g=>`\n        ${g.declareVariables(c)}\n        ${g.mainStart()}\n        ${g.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n        output[global_idx] = ${o}(${e}) + ${o}(global_idx) * ${o}(${r});\n      }`;return{name:"Range",shaderCache:{hint:[e,t,r].map(g=>g.toString()).join("_")},getShaderSource:m,getRunData:()=>({outputs:[{dims:s,dataType:i}],dispatchGroup:{x:Math.ceil(u/64)}})}},ps=e=>{let t=0,r=0,i=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],i=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],i=e.inputs[2].getFloat32Array()[0]),Qi.webgpu.validateInputContent&&Fl(t,r,i),e.compute(Hl(t,r,i,e.inputs[0].dataType),{inputs:[]})}});var Ll,jl,Kl,ql,Yl,Xl,Jl,Zl,Ql,ec,tc,rc,nc,oc,ac,ms,hs,gs=j(()=>{"use strict";he();Pe();ve();Ll=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},jl=(e,t,r)=>{t.every(n=>n>=0&&n<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let i=new Array(r).fill(1);return t.forEach((n,s)=>i[n]=e[s]),i},Kl=(e,t,r,i,n,s)=>{let[u,c,o]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],m=e[0].dims.length;if(u>0&&e.length>u&&e[u].dims.length>0)e[u].getFloat32Array().forEach(g=>s.push(g));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(c>0&&e.length>c&&e[c].dims.length>0){if(e[c].getFloat32Array().forEach(g=>i.push(g)),i.length!==0&&i.length!==m&&r>=18&&i.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");Ll(i,t),t.axes.length>0&&jl(i,t.axes,m).forEach((g,x)=>i[x]=g)}if(o>0&&e.length>o&&(e[o].getBigInt64Array().forEach(g=>n.push(Number(g))),n.length!==m||r>=18&&n.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(i.length!==t.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(n.length!==t.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(typeof i<"u"&&typeof n<"u"&&i.length>0&&n.length>m)throw new Error("Resize requires only of scales or sizes to be specified")},ql=e=>"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(e){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`\n`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",Yl=(e,t)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",Xl=(e,t,r)=>{let i=new Array(r).fill(0).concat(new Array(r).fill(1)),n=e.length===0?i:e.slice();return t.length>0?(t.forEach((s,u)=>{i[s]=n[u],i[u+r]=n[t.length+u]}),i):n},Jl=(e,t,r,i)=>{let n=[];if(r.length>0)if(i.length>0){if(e.forEach(s=>n.push(s)),Math.max(...i)>e.length)throw new Error("axes is out of bound");i.forEach((s,u)=>n[s]=r[u])}else r.forEach(s=>n.push(s));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");n=e.map((s,u)=>Math.round(s*t[u]))}return n},Zl=(e,t,r,i)=>{let n=(()=>{switch(i.keepAspectRatioPolicy){case"not_larger":return i.axes.length>0?Math.min(...i.axes.map(u=>r[u]),Number.MAX_VALUE):Math.min(...r,Number.MAX_VALUE);case"not_smaller":return i.axes.length>0?Math.max(...i.axes.map(u=>r[u]),Number.MIN_VALUE):Math.max(...r,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${i.keepAspectRatioPolicy} is not supported`)}})();r.fill(1,0,r.length);let s=e.slice();return i.axes.length>0?(i.axes.forEach(u=>r[u]=n),i.axes.forEach(u=>s[u]=Math.round(e[u]*r[u]))):(r.fill(n,0,r.length),s.forEach((u,c)=>s[c]=Math.round(u*r[c]))),s},Ql=(e,t,r,i,n)=>`\n    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> array<f32, ${r.length}> {\n      const inputShape = array<u32, ${t.length}>(${t.map(s=>`${s}u`).join(",")});\n      const outputShape = array<u32, ${r.length}>(${r.map(s=>`${s}u`).join(",")});\n      const scales = array<f32, ${i.length}>(${i.map(s=>`${s}f`).join(",")});\n      const roi = array<f32, ${n.length}>(${n.map(s=>`${s}f`).join(",")});\n      var originalIndices: array<f32, ${r.length}>;\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var outputIndex = ${r.length===1?"outputIndices":"outputIndices[i]"};\n        if (scales[i] == 1.0) {\n          originalIndices[i] = f32(outputIndex);\n        } else {\n          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${t.length}]);\n        }\n      }\n      return originalIndices;\n    }`,ec=(e,t,r,i,n,s,u)=>`\n    fn calculateInputIndicesFromOutputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n        const inputShape = array<u32, ${r.length}>(${r.map(c=>`${c}u`).join(",")});\n        const outputShape = array<u32, ${i.length}>(${i.map(c=>`${c}u`).join(",")});\n        const scales = array<f32, ${n.length}>(${n.map(c=>`${c}f`).join(",")});\n        const roi = array<f32, ${s.length}>(${s.map(c=>`${c}f`).join(",")});\n        var inputIndices: ${e.type.indices};\n        for (var i:u32 = 0; i < ${i.length}; i++) {\n          var outputIndex = ${i.length===1?"outputIndices":"outputIndices[i]"};\n          var inputIndex: u32;\n          if (scales[i] == 1.0) {\n            inputIndex = outputIndex;\n          } else {\n            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${r.length}]);\n            if (!${u} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {\n              if (original_idx < 0) {\n                inputIndex = 0;\n              } else if (original_idx > (f32(inputShape[i]) - 1)) {\n                inputIndex = inputShape[i] - 1;\n              } else {\n                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));\n              }\n            } else {\n              inputIndex = u32(original_idx);\n            }\n          }\n          ${e.indicesSet("inputIndices","i","inputIndex")}\n        }\n        return inputIndices;\n    }`,tc=(e,t)=>`\n    fn checkInputIndices(inputIndices: ${e.type.indices}) -> bool {\n      const inputShape = array<u32, ${t.length}>(${t.map(r=>`${r}u`).join(",")});\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var inputIndex = ${t.length===1?"inputIndices":"inputIndices[i]"};\n        if (inputIndex < 0 || inputIndex >= inputShape[i]) {\n          return false;\n        }\n      }\n      return true;\n    }`,rc=(e,t,r,i,n,s,u)=>{let[c,o,m,g]=r.length===2?[-1,0,1,-1]:n[1]===1?[0,2,3,1]:[0,1,2,3];return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {\n      var inputIndices: ${e.type.indices};\n      inputIndices[${o}] = max(0, min(row, ${r[o]} - 1));\n      inputIndices[${m}] = max(0, min(col, ${r[m]} - 1));\n      if (${r.length} > 2) {\n        inputIndices[${g}] = channel;\n        inputIndices[${c}] = batch;\n      };\n      return input[${e.indicesToOffset("inputIndices")}];\n    }\n\n    fn bilinearInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);\n      var row:f32 = originalIndices[${o}];\n      var col:f32 = originalIndices[${m}];\n      if (${s} && (row < 0 || row > (${r[o]} - 1) || col < 0 || col > ${r[m]} - 1)) {\n        return ${u};\n      }\n      row = max(0, min(row, ${r[o]} - 1));\n      col = max(0, min(col, ${r[m]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = 0;\n      var batch: u32 = 0;\n      if (${r.length>2}) {\n        channel = u32(originalIndices[${g}]);\n        batch = u32(originalIndices[${c}]);\n      }\n      var x11: f32 = getInputValue(batch, channel, row1, col1);\n      var x12: f32 = getInputValue(batch, channel, row1, col2);\n      var x21: f32 = getInputValue(batch, channel, row2, col1);\n      var x22: f32 = getInputValue(batch, channel, row2, col2);\n      var dx1: f32 = row - f32(row1);\n      var dx2: f32 = f32(row2 ) - row;\n      var dy1 = col - f32(col1);\n      var dy2 = f32(col2) - col;\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},nc=(e,t,r,i,n,s,u,c,o,m)=>{let[g,x]=r.length===2?[0,1]:n[1]===1?[2,3]:[1,2],b=w=>{let $=w===g?"row":"col";return`\n      fn ${$}CubicInterpolation(inputIndices: ${e.type.indices}, outputIndices: ${t.type.indices}) -> f32 {\n        var outputIndex = ${i.length===1?"outputIndices":`outputIndices[${w}]`};\n        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${n[w]},\n        f32(${i[w]}), f32(${r[w]}), ${s[w]}, ${s[w]} + ${r.length});\n        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${c} && (originalIdx < 0 || originalIdx > (${r[w]} - 1))) {\n          return ${o};\n        }\n        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${$}: f32 = originalIdx + f32(i);\n          if (${$} < 0 || ${$} >= ${r[w]}) {\n            if (${m}) {\n              coefs[i + 1] = 0.0;\n              continue;\n            } else if (${c}) {\n              return ${o};\n            } else {\n              ${$} = max(0, min(${$}, ${r[w]} - 1));\n            }\n          }\n          var inputIndicesCopy: ${e.type.indices} = inputIndices;\n          inputIndicesCopy[${w}] = u32(${$});\n          data[i + 1] = ${w===g?`input[${e.indicesToOffset("inputIndicesCopy")}];`:`\n                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);`}\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${b(g)};\n    ${b(x)};\n  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {\n    var absS = abs(s);\n    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: f32 = 1.0 - absS;\n    var twoMinusAbsS: f32 = 2.0 - absS;\n    var onePlusAbsS: f32 = 1.0 + absS;\n    coeffs[0] = ((${u} * onePlusAbsS - 5 * ${u}) * onePlusAbsS + 8 * ${u}) * onePlusAbsS - 4 * ${u};\n    coeffs[1] = ((${u} + 2) * absS - (${u} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${u} + 2) * oneMinusAbsS - (${u} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${u} * twoMinusAbsS - 5 * ${u}) * twoMinusAbsS + 8 * ${u}) * twoMinusAbsS - 4 * ${u};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {\n    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n    var inputIndices: ${e.type.indices} = outputIndices;\n    return colCubicInterpolation(inputIndices, outputIndices);\n  }\n    `},oc=(e,t,r,i,n,s)=>{let u=e.dims,c=Xl(s,t.axes,u.length),o=Jl(u,i,n,t.axes),m=i.slice();i.length===0&&(m=u.map((C,A)=>C===0?1:o[A]/C),t.keepAspectRatioPolicy!=="stretch"&&(o=Zl(u,o,m,t)));let g=Z("output",e.dataType,o),x=F("input",e.dataType,u),b=k.size(o),w=u.length===o.length&&u.every((C,A)=>C===o[A]),$=t.coordinateTransformMode==="tf_crop_and_resize",y=C=>`\n      ${ql(t.coordinateTransformMode)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${tc(x,u)};\n              ${Yl(t.nearestMode,r)};\n              ${ec(x,g,u,o,m,c,$)};\n              `;case"linear":return`\n              ${Ql(g,u,o,m,c)};\n              ${rc(x,g,u,o,m,$,t.extrapolationValue)};\n              `;case"cubic":return`\n            ${nc(x,g,u,o,m,c,t.cubicCoeffA,$,t.extrapolationValue,t.excludeOutside)};\n            `;default:throw Error("Invalid resize mode")}})()};\n      ${C.declareVariables(x,g)}\n      ${C.mainStart()}\n        ${C.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n        if (${w}) {\n          output[global_idx] = input[global_idx];\n        } else {\n          let outputIndices = ${g.offsetToIndices("global_idx")};\n          var inputIndices: ${x.type.indices};\n          ${(()=>{switch(t.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);\n                  if (checkInputIndices(inputIndices)) {\n                    output[global_idx] = input[${x.indicesToOffset("inputIndices")}];\n                  } else {\n                    output[global_idx] = ${t.extrapolationValue};\n                  }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n        }\n      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${m.length>0?m:""}|${n.length>0?n:""}`},getShaderSource:y,getRunData:()=>({outputs:[{dims:o,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(b/64)}})}},ac=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},ms=(e,t)=>{let r=[],i=[],n=[],s=ac(e);Kl(e.inputs,t,s,r,i,n),e.compute(oc(e.inputs[0],t,s,r,i,n),{inputs:[0]})},hs=e=>{let t=e.antialias,r=e.axes,i=e.coordinateTransformMode,n=e.cubicCoeffA,s=e.excludeOutside!==0,u=e.extrapolationValue,c=e.keepAspectRatioPolicy,o=e.mode,m=e.nearestMode===""?"simple":e.nearestMode;return ie({antialias:t,axes:r,coordinateTransformMode:i,cubicCoeffA:n,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:c,mode:o,nearestMode:m})}});var ic,sc,ys,bs,ws=j(()=>{"use strict";ke();he();Pe();ve();ic=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],r=e[1],i=e[2];if(t.dataType!==r.dataType||t.dataType!==i.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let n=t.dims[t.dims.length-1],s=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==n)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==s)throw new Error("Skip must have the same sequence length as input");if(i.dims.length!==1)throw new Error("Gamma must be 1D");if(i.dims[i.dims.length-1]!==n)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let u=e[3];if(u.dims.length!==1)throw new Error("Beta must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let u=e[4];if(u.dims.length!==1)throw new Error("Bias must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Bias must have the same hidden size as input")}},sc=(e,t,r,i)=>{let n=e[0].dims,s=k.size(n),u=n,c=s,o=n.slice(-1)[0],m=i?n.slice(0,-1).concat(1):[],g=e.length>3,x=e.length>4,b=i&&r>1,w=i&&r>2,$=r>3,y=ut(o),C=[F("x",e[0].dataType,e[0].dims,y),F("skip",e[1].dataType,e[1].dims,y),F("gamma",e[2].dataType,e[2].dims,y)];g&&C.push(F("beta",e[3].dataType,e[3].dims,y)),x&&C.push(F("bias",e[4].dataType,e[4].dims,y)),C.push(Z("output",e[0].dataType,u,y)),b&&C.push(Z("meanOutput",1,m)),w&&C.push(Z("invStdOutput",1,m)),$&&C.push(Z("inputSkipBiasSum",e[0].dataType,u,y));let A=Re(e[0].dataType),P=B=>`\n      const hiddenSize: f32 = ${o};\n      const hiddenSizeVectorized: u32 = ${o/y};\n      const epsilon: f32 = ${t.epsilon};\n\n      ${B.declareVariables(...C)}\n\n      ${B.mainStart()}\n        ${B.guardAgainstOutOfBoundsWorkgroupSizes(c/o)}\n        let offset = global_idx * hiddenSizeVectorized;\n        var sum = ${Xe("f32",y)};\n        var squareSum = ${Xe("f32",y)};\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          let skipValue = skip[offset + i];\n          let biasValue = ${x?"bias[i]":"0.0"};\n          let inputValue = x[offset + i];\n          let value = inputValue + skipValue + biasValue;\n          ${$?"inputSkipBiasSum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32Value = ${wt(A,y,"value")};\n          sum += f32Value;\n          squareSum += f32Value * f32Value;\n        }\n        let mean = ${ft("sum",y)} / hiddenSize;\n        let variance = sqrt(${ft("squareSum",y)} / hiddenSize - mean * mean + epsilon);\n        ${b?"meanOutput[global_idx] = mean;":""}\n        ${w?"invStdOutput[global_idx] = 1.0 / variance;":""}\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          output[offset + i] = (output[offset + i] - ${A}(mean)) / ${A}(variance) * gamma[i]\n           + ${g?"beta[i]":"0.0"};\n        }\n      }`,W=[{dims:u,dataType:e[0].dataType}];return r>1&&W.push({dims:m,dataType:1}),r>2&&W.push({dims:m,dataType:1}),r>3&&W.push({dims:n,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:t.cacheKey},getShaderSource:P,getRunData:()=>({outputs:W,dispatchGroup:{x:Math.ceil(c/o/64)}})}},ys=(e,t)=>{ic(e.inputs);let i=[0];e.outputCount>1&&i.push(-3),e.outputCount>2&&i.push(-3),e.outputCount>3&&i.push(3),e.compute(sc(e.inputs,t,e.outputCount,!1),{outputs:i})},bs=e=>{let t=e.epsilon;return ie({epsilon:t})}});var uc,Hr,lc,vs,cc,dc,$s,xs,Cs=j(()=>{"use strict";ke();he();Pe();ve();uc=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,i)=>{if(e[i+1].dataType!==6&&e[i+1].dataType!==7)throw new Error(`Input ${i} must be an array of int32 or int64`)})},Hr=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(i=>r.push(Number(i)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(i=>r.push(Number(i)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},lc=(e,t)=>{if(e.length>1){let r=Hr(e,1),i=Hr(e,2),n=Hr(e,3);return n.length===0&&(n=[...Array(e[0].dims.length).keys()]),ie({starts:r,ends:i,axes:n})}else return t},vs=(e,t,r,i,n)=>{let s=e;return e<0&&(s+=r[i[t]]),n[t]<0?Math.max(0,Math.min(s,r[i[t]]-1)):Math.max(0,Math.min(s,r[i[t]]))},cc=(e,t,r,i)=>`fn calculateInputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n          var inputIndices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${r.length}; i >= 0; i--) {\n            var outputIndex = ${i.length===1?"outputIndices":"outputIndices[i]"};\n            var inputIndex = outputIndex * steps[i] + starts[i] + carry;\n            carry = inputIndex / inputShape[i];\n            inputIndex = inputIndex % inputShape[i];\n            if (signs[i] < 0) {\n              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];\n            }\n            ${r.length===1?"inputIndices":"inputIndices[i]"} = inputIndex;\n          }\n          return inputIndices;\n      }`,dc=(e,t)=>{let r=e[0].dims,i=k.size(r),n=t.axes.length>0?k.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],s=Hr(e,4);s.forEach(y=>y!==0||(()=>{throw new Error("step cannot be 0")})),s.length===0&&(s=Array(n.length).fill(1));let u=t.starts.map((y,C)=>vs(y,C,r,n,s)),c=t.ends.map((y,C)=>vs(y,C,r,n,s));if(n.length!==r.length)for(let y=0;y<r.length;++y)n.includes(y)||(u.splice(y,0,0),c.splice(y,0,r[y]),s.splice(y,0,1));let o=s.map(y=>Math.sign(y));s.forEach((y,C,A)=>{if(y<0){let P=(c[C]-u[C])/y,W=u[C],B=W+P*s[C];u[C]=B,c[C]=W,A[C]=-y}});let m=r.slice(0);n.forEach((y,C)=>{m[y]=Math.ceil((c[y]-u[y])/s[y])});let g={dims:m,dataType:e[0].dataType},x=Z("output",e[0].dataType,m),b=F("input",e[0].dataType,r),w=k.size(m),$=y=>`\n      ${y.declareVariables(b,x)}\n        const signs = array<i32, ${o.length}>(${o.map(C=>`${C}i`).join(",")});\n        const starts = array<u32, ${u.length}>(${u.map(C=>`${C}u`).join(",")});\n        const ends = array<u32, ${c.length}>(${c.map(C=>`${C}u`).join(",")});\n        const steps = array<u32, ${s.length}>(${s.map(C=>`${C}u`).join(",")});\n        const inputShape = array<u32, ${r.length}>(${r.map(C=>`${C}u`).join(",")});\n\n        ${cc(b,x,r,m)}\n        ${y.mainStart()}\n          ${y.guardAgainstOutOfBoundsWorkgroupSizes(w)}\n          let outputIndices = ${x.offsetToIndices("global_idx")};\n          let inputIndices = calculateInputIndices(outputIndices);\n          ${x.setByOffset("global_idx",b.getByIndices("inputIndices"))}\n      }`;return{name:"Slice",shaderCache:{hint:`${t.cacheKey}|${e[4]?.dims??""}`},getShaderSource:$,getRunData:()=>({outputs:[g],dispatchGroup:{x:Math.ceil(i/64)}})}},$s=(e,t)=>{uc(e.inputs,t);let r=lc(e.inputs,t);e.compute(dc(e.inputs,r),{inputs:[0]})},xs=e=>{let t=e.starts,r=e.ends,i=e.axes;return ie({starts:t,ends:r,axes:i})}});var pc,fc,Ss,As,Is=j(()=>{"use strict";he();Pe();ve();pc=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},fc=(e,t)=>{let r=Re(e.dataType),i=e.dims,n=k.size(i),s=64,u=t.axis;if(u<0&&(u=i.length+u),u<i.length-1)throw new Error("softmax only supports last axis for now.");let c=i[u],o=n/c,m=ut(c),g=c/m,x=m===1?r:`vec${m}<${r}>`,b=(y,C)=>C===4?`max(max(${y}.x, ${y}.y), max(${y}.z, ${y}.w))`:C===2?`max(${y}.x, ${y}.y)`:C===3?`max(max(${y}.x, ${y}.y), ${y}.z)`:y,w=r==="f32"?`var threadMax = ${x}(-3.402823e+38f);`:`var threadMax = ${x}(-65504.0h);`;return{name:"Softmax",getRunData:()=>({outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:o}}),getShaderSource:y=>`\n      var<workgroup> rowMaxShared : ${x};\n      var<workgroup> rowSumShared : ${x};\n      var<workgroup> threadShared : array<${x}, ${s}>;\n\n      @group(0) @binding(0) var<storage, read> x : array<${x}>;\n      @group(0) @binding(1) var<storage, read_write> result : array<${x}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${x} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${x}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n\n      @compute @workgroup_size(${s}, 1, 1)\n      fn main(@builtin(local_invocation_id) local_id : vec3<u32>, @builtin(global_invocation_id) global_id : vec3u) {\n        let gindex = i32(global_id.x);\n        let lindex = i32(local_id.x);\n        const wg = ${s};\n        let row = gindex / wg;\n        let cols = ${g};\n        let row_stride : i32 = ${g};\n\n        // find the rows max\n        ${w}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${x}(${b("threadShared[0]",m)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${x}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${x}(${ft("threadShared[0]",m)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`}},Ss=(e,t)=>{pc(e.inputs),e.compute(fc(e.inputs[0],t))},As=e=>ie({axis:e.axis})});var mc,hc,gc,yc,bc,Ts,Os,Es=j(()=>{"use strict";he();Pe();ve();mc=e=>{if(!e||e.length<1)throw new Error("too few inputs")},hc=(e,t)=>{let r=[],i=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(n=>r.push(Number(n))),i=r.length),ie({numOutputs:i,axis:t.axis,splitSizes:r})},gc=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < sizeInConcatAxis[i]) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,yc=e=>{let t=e.length,r=[];for(let i=0;i<t;++i){let n=e[i].setByIndices("indices","input[global_idx]");t===1?r.push(n):i===0?r.push(`if (outputNumber == ${i}u) { ${n} }`):i===t-1?r.push(`else { ${n} }`):r.push(`else if (outputNumber == ${i}) { ${n} }`)}return`\n      fn writeBufferData(outputNumber: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${r.join(`\n`)}\n      }`},bc=(e,t)=>{let r=e[0].dims,i=k.size(r),n=e[0].dataType,s=r.length,u=t.axis,c=u<0?r.length+u:u,o=new Array(t.numOutputs),m=F("input",n,r),g=new Array(t.numOutputs),x=[],b=[],w=0;for(let C=0;C<t.numOutputs;C++){w+=t.splitSizes[C],g[C]=w;let A=r.slice();A[t.axis]=t.splitSizes[C],b.push(A),o[C]=Z(`output${C}`,n,b[C]),x.push({dims:b[C],dataType:e[0].dataType})}let $=s<2?"indices":`indices[${c}]`,y=C=>`\n  ${C.declareVariables(m,...o)}\n  const sizeInConcatAxis = array<u32, ${g.length}>(${g.map(A=>`${A}u`).join(",")});\n  ${gc(g.length)}\n  ${yc(o)}\n\n  ${C.mainStart()}\n    ${C.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n\n    var indices = ${m.offsetToIndices("global_idx")};\n    let outputNumber = calculateOutputIndex(${$});\n    if (outputNumber != 0) {\n        ${$} -= sizeInConcatAxis[outputNumber - 1u];\n    }\n    writeBufferData(outputNumber, indices, global_idx);\n  }`;return{name:"Split",shaderCache:{hint:t.cacheKey},getShaderSource:y,getRunData:()=>({outputs:x,dispatchGroup:{x:Math.ceil(i/64)}})}},Ts=(e,t)=>{mc(e.inputs);let r=e.inputs.length===1?t:hc(e.inputs,t);e.compute(bc(e.inputs,r),{inputs:[0]})},Os=e=>{let t=e.axis,r=e.splitSizes,i=e.numOutputs<0?r.length:e.numOutputs;if(i!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ie({axis:t,numOutputs:i,splitSizes:r})}});var _s,wc,vc,$c,Ps,Rs=j(()=>{"use strict";ke();he();ve();_s=e=>Array.from(e.getBigInt64Array(),Number),wc=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(_s(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},vc=(e,t)=>{let r=[];for(let i=0;i<e.length;++i)r.push(e[i]*t[i]);return r},$c=e=>{let t=e[0].dims,r=_s(e[1]),i=vc(t,r),n=k.size(i),s=e[0].dataType,u=F("input",s,t),c=Z("output",s,i),o=m=>`\n      const inputShape = ${u.indices(...t)};\n      ${m.declareVariables(u,c)}\n      ${m.mainStart()}\n      ${m.guardAgainstOutOfBoundsWorkgroupSizes(n)}\n      let outputIndices = ${c.offsetToIndices("global_idx")};\n      var inputIndices: ${u.type.indices};\n      for (var i = 0; i < ${t.length}; i++) {\n        let inputDimValue = ${c.indicesGet("outputIndices","i")}  % ${u.indicesGet("inputShape","i")};\n\n        ${u.indicesSet("inputIndices","i","inputDimValue")}\n      }\n      ${c.setByOffset("global_idx",u.getByIndices("inputIndices"))}\n    }`;return{name:"Tile",shaderCache:{hint:`${r}`},getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}}),getShaderSource:o}},Ps=e=>{wc(e.inputs),e.compute($c(e.inputs),{inputs:[0]})}});var xc,Cc,Bs,Ms=j(()=>{"use strict";ke();he();ve();xc=(e,t,r,i,n)=>{let s=k.size(r),u=Math.ceil(s/4),c=Z("outputData",n,r,4),o=F("aData",t[1].dataType,t[1].dims,4),m=F("bData",t[2].dataType,t[2].dims,4),g=F("cData",t[0].dataType,t[0].dims,4),x,b=(w,$,y)=>`select(${$}, ${w}, ${y})`;if(!i)x=c.setByOffset("global_idx",b(o.getByOffset("global_idx"),m.getByOffset("global_idx"),g.getByOffset("global_idx")));else{let w=($,y,C="")=>{let A=`aData[indexA${y}][componentA${y}]`,P=`bData[indexB${y}][componentB${y}]`,W=`bool(cData[indexC${y}] & ${4278190080>>>(3-y)*8}u)`;return`\n            let outputIndices${y} = ${c.offsetToIndices(`global_idx * 4u + ${y}u`)};\n            let offsetA${y} = ${o.broadcastedIndicesToOffset(`outputIndices${y}`,c)};\n            let offsetB${y} = ${m.broadcastedIndicesToOffset(`outputIndices${y}`,c)};\n            let offsetC${y} = ${g.broadcastedIndicesToOffset(`outputIndices${y}`,c)};\n            let indexA${y} = offsetA${y} / 4u;\n            let indexB${y} = offsetB${y} / 4u;\n            let indexC${y} = offsetC${y} / 4u;\n            let componentA${y} = offsetA${y} % 4u;\n            let componentB${y} = offsetB${y} % 4u;\n            ${$}[${y}] = ${C}(${b(A,P,W)});\n          `};n===9?x=`\n            var data = vec4<u32>(0);\n            ${w("data",0,"u32")}\n            ${w("data",1,"u32")}\n            ${w("data",2,"u32")}\n            ${w("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:x=`\n            ${w("outputData[global_idx]",0)}\n            ${w("outputData[global_idx]",1)}\n            ${w("outputData[global_idx]",2)}\n            ${w("outputData[global_idx]",3)}\n          `}return`\n        ${e.declareVariables(g,o,m,c)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n        ${x}\n      }`},Cc=e=>{let t=e[1].dims,r=e[2].dims,i=e[0].dims,n=e[1].dataType,s=!(k.areEqual(t,r)&&k.areEqual(r,i)),u=t,c=k.size(t);if(s){let o=rt.calcShape(rt.calcShape(t,r,!1),i,!1);if(!o)throw new Error("Can\'t perform where op on the given tensors");u=o,c=k.size(u)}return{name:"Where",getShaderSource:o=>xc(o,e,u,s,n),getRunData:()=>({outputs:[{dims:u,dataType:n}],dispatchGroup:{x:Math.ceil(c/64/4)}})}},Bs=e=>{e.compute(Cc(e.inputs))}});var ks,Ds=j(()=>{"use strict";qo();Xo();Ea();Va();Fa();An();ai();li();pi();hi();bi();$i();Si();Ti();Ei();Ri();Ki();fs();bn();gs();ws();Cs();Is();Es();Rs();Gr();$n();Ms();ks=new Map([["Abs",[Jo]],["Acos",[Zo]],["Acosh",[Qo]],["Add",[_a]],["ArgMax",[Ko,wn]],["ArgMin",[jo,wn]],["Asin",[ea]],["Asinh",[ta]],["Atan",[ra]],["Atanh",[na]],["AveragePool",[zi,Wi]],["BiasAdd",[Yo]],["BiasSplitGelu",[Oa]],["Cast",[aa,oa]],["Ceil",[sa]],["ClipV10",[vn]],["Clip",[ia]],["Concat",[Ua,Na]],["Conv",[Tn,In]],["ConvTranspose",[oi,ni]],["Cos",[ua]],["Cosh",[la]],["Div",[Pa]],["Einsum",[si,ui]],["Elu",[ca,_r]],["Equal",[Ra]],["Erf",[da]],["Exp",[pa]],["Expand",[di]],["Floor",[fa]],["FusedConv",[Tn,In]],["Gather",[mi,fi]],["GatherElements",[yi,gi]],["Gelu",[ma]],["Gemm",[wi,vi]],["GlobalAveragePool",[Ui,Vi]],["GlobalMaxPool",[ji,Li]],["Greater",[Da]],["GreaterOrEqual",[za]],["InstanceNormalization",[Ci,xi]],["LayerNormalization",[Ii,Ai]],["LeakyRelu",[ha,_r]],["Less",[Wa]],["LessOrEqual",[Ga]],["Log",[Ta]],["MatMul",[Oi]],["MaxPool",[Fi,Hi]],["Mul",[Ba]],["Neg",[ya]],["Not",[ga]],["Pad",[_i,Pi]],["Pow",[Ma]],["Range",[ps]],["Reciprocal",[ba]],["ReduceMin",[Vo,Je]],["ReduceMean",[Go,Je]],["ReduceMax",[zo,Je]],["ReduceSum",[No,Je]],["ReduceProd",[Uo,Je]],["ReduceL1",[ko,Je]],["ReduceL2",[Do,Je]],["ReduceLogSum",[Mo,Je]],["ReduceLogSumExp",[Wo,Je]],["ReduceSumSquare",[Fo,Je]],["Relu",[wa]],["Resize",[ms,hs]],["Sigmoid",[va]],["Sin",[$a]],["Sinh",[xa]],["Slice",[$s,xs]],["SkipLayerNormalization",[ys,bs]],["Split",[Ts,Os]],["Sqrt",[Ca]],["Softmax",[Ss,As]],["Sub",[ka]],["Tan",[Sa]],["Tanh",[Aa]],["ThresholdedRelu",[Ia,_r]],["Tile",[Ps]],["Transpose",[Ya,Xa]],["Where",[Bs]]])});var Lr,Ws=j(()=>{"use strict";ke();pt();ve();Lr=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,i,n,s,u,c){let o=this.backend.device,m=this.backend.getComputePassEncoder();m.setPipeline(t.computePipeline);let g=[];for(let b of n)g.push({binding:g.length,resource:{buffer:b.buffer}});for(let b of s)g.push({binding:g.length,resource:{buffer:b.buffer}});c&&g.push({binding:g.length,resource:c});let x=o.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:g,label:t.programInfo.name});if(m.setBindGroup(0,x),m.dispatchWorkgroups(...u),this.backend.pendingDispatchNumber++,this.backend.isQueryEnabled()){typeof this.backend.queryData>"u"&&(this.backend.queryData=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let b=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.querySet,0,2,this.backend.queryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.queryData.buffer,0,b.buffer,0,this.backend.querySetCount*8),this.backend.flush();let w=this.backend.currentKernelId,$=this.backend.kernels.get(w),y=`[${$[0]}] ${$[1]}`;b.buffer.mapAsync(GPUMapMode.READ).then(()=>{let C=new BigUint64Array(b.buffer.getMappedRange()),A=C[0],P=C[1];b.buffer.unmap(),typeof this.backend.queryTimeBase>"u"&&(this.backend.queryTimeBase=A);let W=Number(A-this.backend.queryTimeBase),B=Number(P-this.backend.queryTimeBase);if(!Number.isSafeInteger(W)||!Number.isSafeInteger(B))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(b.id);let D="";r.forEach((z,N)=>{D+=`input[${N}]: [${z.dims}] | ${Jt(z.dataType)}, `});let _="";i.forEach((z,N)=>{_+=`output[${N}]: [${z.dims}] | ${Jt(z.dataType)}, `}),console.log(`[profiling] kernel "${w}|${y}" ${D}${_}execution time: ${B-W} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(t,r){let i=this.backend.device,n=[];i.features.has("shader-f16")&&n.push("enable f16;");let s=Ro(r),u=t.getShaderSource(s),c=`${n.join(`\n`)}\n${s.additionalImplementations}\n${u}`,o=i.createShaderModule({code:c,label:t.name});Oe("verbose",()=>`[WebGPU] shader code: ${c}`);let m=i.createComputePipeline({compute:{module:o,entryPoint:"main"},layout:"auto",label:t.name});return{programInfo:t,computePipeline:m}}normalizeDispatchGroupSize(t){let r=typeof t=="number"?t:t.x,i=typeof t=="number"?1:t.y||1,n=typeof t=="number"?1:t.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=s&&i<=s&&n<=s)return[r,i,n];let u=r*i*n,c=Math.ceil(Math.sqrt(u));if(c>s){if(c=Math.ceil(Math.cbrt(u)),c>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[c,c,c]}else return[c,c,1]}}});var Sc,Ac,jr,zs=j(()=>{"use strict";pt();Ao();Eo();Ds();Ws();Sc=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let i=0;i<e.length;++i){let n=e[i].dataType;switch(t[i]){case"none":{r.push("");break}case"type":{r.push(`${n}`);break}case"rank":{let s=e[i].dims.length;r.push(`${n};${s}`);break}case"dims":{let s=e[i].dims.join(",");r.push(`${n};${s}`);break}default:throw new Error(`unsupported input dependency: ${t[i]}`)}}return r.join("|")},Ac=(e,t)=>{let r=e.name;return e.shaderCache?.hint&&(r+="["+e.shaderCache.hint+"]"),r+=`:${Sc(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,r},jr=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.querySetCount=2;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let r=await navigator.gpu.requestAdapter();if(!r)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=t;let i=[],n={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:i};r.features.has("timestamp-query")&&i.push("timestamp-query"),r.features.has("shader-f16")&&i.push("shader-f16"),this.device=await r.requestDevice(n),this.gpuDataManager=Oo(this),this.programManager=new Lr(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Co(t.logLevel,!!t.debug),this.device.onuncapturederror=s=>{s.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${s.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t={};this.isQueryEnabled()&&(typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}isQueryEnabled(){return!!(this.device.features.has("timestamp-query")&&this.env.webgpu.profilingMode==="default")}run(t,r,i,n,s){let u=[];for(let A=0;A<r.length;++A){let P=this.gpuDataManager.get(r[A].data);if(!P)throw new Error(`no GPU data for input: ${r[A].data}`);u[A]=P}let c=Ac(t,r),o=this.programManager.getArtifact(c),{outputs:m,dispatchGroup:g,programUniforms:x}=t.getRunData(r),b=i.length===0?m.map((A,P)=>P):i;if(b.length!==m.length)throw new Error(`Output size ${b.length} must be equal to ${m.length}.`);let w=[],$=[];for(let A=0;A<m.length;++A){if(!Number.isInteger(b[A])||b[A]<-3||b[A]>=m.length)throw new Error(`Invalid output index: ${b[A]}`);if(b[A]===-3)continue;let P=b[A]===-1,W=b[A]===-2,B=P||W?s(m[A].dataType,m[A].dims):n(b[A],m[A].dataType,m[A].dims),D=this.gpuDataManager.get(B.data);if(!D)throw new Error(`no GPU data for output: ${B.data}`);if(P&&this.temporaryData.push(D),W){let _=this.kernelPersistentData.get(this.currentKernelId);_||(_=[],this.kernelPersistentData.set(this.currentKernelId,_)),_.push(D)}w.push(B),$.push(D)}let y;if(x){let A=0,P=0,W=[],B=1;x.forEach(z=>{let N=typeof z.data=="number"?[z.data]:z.data,Y;switch(N.length){case 1:Y=4;break;case 2:Y=8;break;case 3:Y=16;break;case 4:Y=16;break;case 5:Y=16;break;case 6:Y=16;break;default:throw new Error(`unsupported data length: ${N.length}`)}(P===5||P===6)&&(Y=16),Y>B&&(B=Y),A=Math.ceil(A/Y)*Y,P=N.length,W.push(A),A+=N.length*4}),A=Math.ceil(A/B)*B;let D=new ArrayBuffer(A);x.forEach((z,N)=>{let Y=W[N],le=typeof z.data=="number"?[z.data]:z.data;z.type==="int32"?new Int32Array(D,Y,le.length).set(le):z.type==="uint32"?new Uint32Array(D,Y,le.length).set(le):new Float32Array(D,Y,le.length).set(le)});let _=this.gpuDataManager.create(A,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(_.buffer,0,D,0,A),this.gpuDataManager.release(_.id),y={offset:0,size:A,buffer:_.buffer}}let C=this.programManager.normalizeDispatchGroupSize(g);return o||(o=this.programManager.build(t,C),this.programManager.setArtifact(c,o)),Oe("info",()=>`[ProgramManager] run "${t.name}" (key=${c}) with ${C[0]}x${C[1]}x${C[2]}`),this.programManager.run(o,r,w,u,$,C,y),w}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,i,n){let s=ks.get(t);if(!s)throw new Error(`kernel not implemented: ${t}`);this.kernels.set(r,[t,n,s[0],[s[1],i]])}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let i of r)this.gpuDataManager.release(i.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,i){let n=this.kernels.get(t);if(!n)throw new Error(`kernel not created: ${t}`);let[s,u,c,o]=n;if(this.currentKernelId!==null)throw new Error(`kernel "[${s}] ${u}" is not allowed to be called recursively`);this.currentKernelId=t,o[0]&&(o[1]=o[0](o[1]),o[0]=void 0),Oe("info",()=>`[WebGPU] Start to run kernel "[${s}] ${u}"...`);let m=this.env.debug;this.temporaryData=[];try{return m&&this.device.pushErrorScope("validation"),c(r,o[1]),0}catch(g){return i.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${u}" failed. ${g}`)),1}finally{m&&i.push(this.device.popErrorScope().then(g=>g?`GPU validation error for kernel "[${s}] ${u}": ${g.message}`:null));for(let g of this.temporaryData)this.gpuDataManager.release(g.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,i,n){let s=this.sessionExternalDataMapping.get(t);s||(s=new Map,this.sessionExternalDataMapping.set(t,s));let u=s.get(r),c=this.gpuDataManager.registerExternalBuffer(i,n,u?.[1]);return s.set(r,[c,i]),c}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(i=>this.gpuDataManager.unregisterExternalBuffer(i[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,i){return async()=>{let n=await pn(this,t,r);return So(n.buffer,i)}}}});var Gs={};xr(Gs,{init:()=>Ic});var or,Mn,Ic,Vs=j(()=>{"use strict";ke();zs();pt();he();or=class e{constructor(t,r,i,n){this.module=t;this.dataType=r;this.data=i;this.dims=n}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=k.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=k.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=k.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(k.size(t)!==k.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},Mn=class{constructor(t,r,i){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;let n=t.HEAPU32,s=i>>2;this.opKernelContext=n[s++];let u=n[s++];this.outputCount=n[s++],this.customDataOffset=n[s++],this.customDataSize=n[s++];let c=[];for(let o=0;o<u;o++){let m=n[s++],g=n[s++],x=n[s++],b=[];for(let w=0;w<x;w++)b.push(n[s++]);c.push(new or(t,m,g,b))}this.inputs=c}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,r){let i=r?.inputs?.map(c=>typeof c=="number"?this.inputs[c]:c)??this.inputs,n=r?.outputs??[],s=(c,o,m)=>new or(this.module,o,this.output(c,m),m),u=(c,o)=>{let m=Zt(c);if(!m)throw new Error(`Unsupported data type: ${c}`);let g=m*k.size(o);return new or(this.module,c,this.backend.gpuDataManager.create(g).id,o)};return this.backend.run(t,i,n,s,u)}output(t,r){let i=this.module.stackSave();try{let n=this.module.stackAlloc((1+r.length)*4),s=n>>2;this.module.HEAPU32[s++]=r.length;for(let u=0;u<r.length;u++)this.module.HEAPU32[s++]=r[u];return this.module._JsepOutput(this.opKernelContext,t,n)}catch(n){throw new Error(`Failed to generate kernel\'s output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(i)}}},Ic=async(e,t)=>{let r=e.jsepInit;if(r&&navigator.gpu){if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let i=new jr;await i.initialize(t),r(i,n=>i.alloc(n),n=>i.free(n),(n,s,u,c=!1)=>{if(c)Oe("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${n}, dst=${s}, size=${u}`),i.memcpy(n,s);else{Oe("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${n}, gpuDataId=${s}, size=${u}`);let o=e.HEAPU8.subarray(n,n+u);i.upload(s,o)}},async(n,s,u)=>{Oe("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${n}, dataOffset=${s}, size=${u}`),await i.download(n,()=>e.HEAPU8.subarray(s,s+u))},(n,s,u)=>i.createKernel(n,s,u,t.debug||t.webgpu.profilingMode==="default"?e.UTF8ToString(e._JsepGetNodeName(s)):`${s}`),n=>i.releaseKernel(n),(n,s,u,c)=>{Oe("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${u}, kernel=${n}, contextDataOffset=${s}`);let o=new Mn(e,i,s);return i.computeKernel(n,o,c)})}}});var go;go=ao();var yu=fo(),sn,un=!1,Cr=!1,ho=!1,bu=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},wu=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},vu=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",yo=async e=>{if(un)return Promise.resolve();if(Cr)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(ho)throw new Error("previous call to \'initializeWebAssembly()\' failed.");Cr=!0;let t=e.initTimeout,r=e.numThreads,i=e.simd,n=r>1&&bu(),s=i&&wu(),u=e.wasmPaths,c=typeof u=="string"?u:void 0,o=vu(s,n),m=typeof u=="object"?u[o]:void 0,g=!1,x=[];if(t>0&&x.push(new Promise(b=>{setTimeout(()=>{g=!0,b()},t)})),x.push(new Promise((b,w)=>{let $=n?yu:go,y={locateFile:(C,A)=>{if(n&&C.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([mo()],{type:"text/javascript"}));if(C.endsWith(".wasm")){if(m)return m;let P=c??A;return o==="ort-wasm-simd.wasm"?P+"ort-wasm-simd.jsep.wasm":o==="ort-wasm-simd-threaded.wasm"?P+"ort-wasm-simd-threaded.jsep.wasm":P+o}return A+C}};if(n)if(typeof Blob>"u")y.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let C=`var ortWasmThreaded=${$.toString()};`;y.mainScriptUrlOrBlob=new Blob([C],{type:"text/javascript"})}$(y).then(C=>{Cr=!1,un=!0,sn=C,b()},C=>{Cr=!1,ho=!0,w(C)})})),await Promise.race(x),g)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},_e=()=>{if(un&&sn)return sn;throw new Error("WebAssembly is not initialized yet.")};var Me=(e,t)=>{let r=_e(),i=r.lengthBytesUTF8(e)+1,n=r._malloc(i);return r.stringToUTF8(e,n,i),t.push(n),n},Xt=(e,t,r,i)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([n,s])=>{let u=t?t+n:n;if(typeof s=="object")Xt(s,u+".",r,i);else if(typeof s=="string"||typeof s=="number")i(u,s.toString());else if(typeof s=="boolean")i(u,s?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof s}`)})},Ae=e=>{let t=_e(),r=t.stackSave();try{let i=t.stackAlloc(8);t._OrtGetLastError(i,i+4);let n=t.HEAP32[i/4],s=t.HEAPU32[i/4+1],u=s?t.UTF8ToString(s):"";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${u}`)}finally{t.stackRestore(r)}};var bo=e=>{let t=_e(),r=0,i=[],n=e||{};try{if(e?.logSeverityLevel===void 0)n.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)n.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(n.terminate=!1);let s=0;return e?.tag!==void 0&&(s=Me(e.tag,i)),r=t._OrtCreateRunOptions(n.logSeverityLevel,n.logVerbosityLevel,!!n.terminate,s),r===0&&Ae("Can\'t create run options."),e?.extra!==void 0&&Xt(e.extra,"",new WeakSet,(u,c)=>{let o=Me(u,i),m=Me(c,i);t._OrtAddRunConfigEntry(r,o,m)!==0&&Ae(`Can\'t set a run config entry: ${u} - ${c}.`)}),[r,i]}catch(s){throw r!==0&&t._OrtReleaseRunOptions(r),i.forEach(u=>t._free(u)),s}};var $u=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},xu=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Cu=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},Su=(e,t,r)=>{for(let i of t){let n=typeof i=="string"?i:i.name;switch(n){case"xnnpack":n="XNNPACK";break;case"webnn":if(n="WEBNN",typeof i!="string"){let u=i;if(u?.deviceType){let c=Me("deviceType",r),o=Me(u.deviceType,r);_e()._OrtAddSessionConfigEntry(e,c,o)!==0&&Ae(`Can\'t set a session config entry: \'deviceType\' - ${u.deviceType}.`)}if(u?.powerPreference){let c=Me("powerPreference",r),o=Me(u.powerPreference,r);_e()._OrtAddSessionConfigEntry(e,c,o)!==0&&Ae(`Can\'t set a session config entry: \'powerPreference\' - ${u.powerPreference}.`)}}break;case"webgpu":if(n="JS",typeof i!="string"){let u=i;if(u?.preferredLayout){if(u.preferredLayout!=="NCHW"&&u.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${u.preferredLayout}`);let c=Me("preferredLayout",r),o=Me(u.preferredLayout,r);_e()._OrtAddSessionConfigEntry(e,c,o)!==0&&Ae(`Can\'t set a session config entry: \'preferredLayout\' - ${u.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${n}`)}let s=Me(n,r);_e()._OrtAppendExecutionProvider(e,s)!==0&&Ae(`Can\'t append execution provider: ${n}.`)}},wo=e=>{let t=_e(),r=0,i=[],n=e||{};Cu(n);try{let s=$u(n.graphOptimizationLevel??"all"),u=xu(n.executionMode??"sequential"),c=typeof n.logId=="string"?Me(n.logId,i):0,o=n.logSeverityLevel??2;if(!Number.isInteger(o)||o<0||o>4)throw new Error(`log serverity level is not valid: ${o}`);let m=n.logVerbosityLevel??0;if(!Number.isInteger(m)||m<0||m>4)throw new Error(`log verbosity level is not valid: ${m}`);let g=typeof n.optimizedModelFilePath=="string"?Me(n.optimizedModelFilePath,i):0;if(r=t._OrtCreateSessionOptions(s,!!n.enableCpuMemArena,!!n.enableMemPattern,u,!!n.enableProfiling,0,c,o,m,g),r===0&&Ae("Can\'t create session options."),n.executionProviders&&Su(r,n.executionProviders,i),n.freeDimensionOverrides)for(let[x,b]of Object.entries(n.freeDimensionOverrides)){if(typeof x!="string")throw new Error(`free dimension override name must be a string: ${x}`);if(typeof b!="number"||!Number.isInteger(b)||b<0)throw new Error(`free dimension override value must be a non-negative integer: ${b}`);let w=Me(x,i);t._OrtAddFreeDimensionOverride(r,w,b)!==0&&Ae(`Can\'t set a free dimension override: ${x} - ${b}.`)}return n.extra!==void 0&&Xt(n.extra,"",new WeakSet,(x,b)=>{let w=Me(x,i),$=Me(b,i);t._OrtAddSessionConfigEntry(r,w,$)!==0&&Ae(`Can\'t set a session config entry: ${x} - ${b}.`)}),[r,i]}catch(s){throw r!==0&&t._OrtReleaseSessionOptions(r),i.forEach(u=>t._free(u)),s}};ke();var Ns=!1,Tc=e=>{let t=_e(),r=t.stackSave();try{let i=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,i,i+4)!==0&&Ae("Can\'t get session input/output count."),[t.HEAP32[i/4],t.HEAP32[i/4+1]]}finally{t.stackRestore(r)}},Oc=(e,t)=>{_e()._OrtInit(e,t)!==0&&Ae("Can\'t initialize onnxruntime.")},Fs=async e=>{Oc(e.wasm.numThreads,Qt(e.logLevel));{let t=(Vs(),Et(Gs)).init;await t(_e(),e)}Ns=!0},ar=new Map,Hs=()=>Ns,kn=e=>{let t=_e(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},Dn=(e,t)=>{let r=_e(),i=0,n=0,s=0,u=[],c=[],o=[];try{[n,u]=wo(t),i=r._OrtCreateSession(e[0],e[1],n),i===0&&Ae("Can\'t create a session.");let[m,g]=Tc(i),x=[],b=[],w=[];for(let y=0;y<m;y++){let C=r._OrtGetInputName(i,y);C===0&&Ae("Can\'t get an input name."),c.push(C),x.push(r.UTF8ToString(C))}for(let y=0;y<g;y++){let C=r._OrtGetOutputName(i,y);C===0&&Ae("Can\'t get an output name."),o.push(C);let A=r.UTF8ToString(C);b.push(A);{let P=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[A]??"cpu";if(P!=="cpu"&&P!=="cpu-pinned"&&P!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${P}.`);w.push(P)}}let $=null;return w.some(y=>y==="gpu-buffer")&&(s=r._OrtCreateBinding(i),s===0&&Ae("Can\'t create IO binding."),$={handle:s,outputPreferredLocations:w,outputPreferredLocationsEncoded:w.map(y=>cn(y))}),ar.set(i,[i,c,o,$]),[i,x,b]}catch(m){throw c.forEach(g=>r._OrtFree(g)),o.forEach(g=>r._OrtFree(g)),s!==0&&r._OrtReleaseBinding(s),i!==0&&r._OrtReleaseSession(i),m}finally{r._free(e[0]),n!==0&&r._OrtReleaseSessionOptions(n),u.forEach(m=>r._free(m))}},Ls=(e,t)=>{let r=kn(e);return Dn(r,t)},js=e=>{let t=_e(),r=ar.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[i,n,s,u]=r;u&&t._OrtReleaseBinding(u.handle),t.jsepUnregisterBuffers?.(e),n.forEach(c=>t._OrtFree(c)),s.forEach(c=>t._OrtFree(c)),t._OrtReleaseSession(i),ar.delete(e)},Us=(e,t,r,i,n)=>{if(!e){t.push(0);return}let s=_e(),u=e[0],c=e[1],o=e[3],m,g;if(u==="string"&&o==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(o==="gpu-buffer"){let w=e[2].gpuBuffer,$=Zt(ln(u));g=c.reduce((y,C)=>y*C,1)*$,m=s.jsepRegisterBuffer(i,n,w,g)}else{let w=e[2];if(Array.isArray(w)){g=4*w.length,m=s._malloc(g),r.push(m);let $=m/4;for(let y=0;y<w.length;y++){if(typeof w[y]!="string")throw new TypeError(`tensor data at index ${y} is not a string`);s.HEAPU32[$++]=Me(w[y],r)}}else g=w.byteLength,m=s._malloc(g),r.push(m),s.HEAPU8.set(new Uint8Array(w.buffer,w.byteOffset,g),m)}let x=s.stackSave(),b=s.stackAlloc(4*c.length);try{let w=b/4;c.forEach(y=>s.HEAP32[w++]=y);let $=s._OrtCreateTensor(ln(u),m,g,b,c.length,cn(o));$===0&&Ae(`Can\'t create tensor for input/output. session=${i}, index=${n}.`),t.push($)}finally{s.stackRestore(x)}},Ks=async(e,t,r,i,n,s)=>{let u=_e(),c=ar.get(e);if(!c)throw new Error(`cannot run inference. invalid session id: ${e}`);let[o,m,g,x]=c,b=t.length,w=i.length,$=0,y=[],C=[],A=[],P=[],W=u.stackSave(),B=u.stackAlloc(b*4),D=u.stackAlloc(b*4),_=u.stackAlloc(w*4),z=u.stackAlloc(w*4);try{[$,y]=bo(s);for(let ae=0;ae<b;ae++)Us(r[ae],C,P,e,t[ae]);for(let ae=0;ae<w;ae++)Us(n[ae],A,P,e,b+i[ae]);let N=B/4,Y=D/4,le=_/4,M=z/4;for(let ae=0;ae<b;ae++)u.HEAPU32[N++]=C[ae],u.HEAPU32[Y++]=m[t[ae]];for(let ae=0;ae<w;ae++)u.HEAPU32[le++]=A[ae],u.HEAPU32[M++]=g[i[ae]];if(x){let{handle:ae,outputPreferredLocations:we,outputPreferredLocationsEncoded:K}=x;if(m.length!==b)throw new Error(`input count from feeds (${b}) is expected to be always equal to model\'s input count (${m.length}).`);for(let Se=0;Se<b;Se++){let Be=t[Se];await u._OrtBindInput(ae,m[Be],C[Se])!==0&&Ae(`Can\'t bind input[${Se}] for session=${e}.`)}for(let Se=0;Se<w;Se++){let Be=i[Se];n[Se]?.[3]?u._OrtBindOutput(ae,g[Be],A[Se],0)!==0&&Ae(`Can\'t bind pre-allocated output[${Se}] for session=${e}.`):u._OrtBindOutput(ae,g[Be],0,K[Be])!==0&&Ae(`Can\'t bind output[${Se}] to ${we[Se]} for session=${e}.`)}}let q;x?q=await u._OrtRunWithBinding(o,x.handle,w,_,$):q=await u._OrtRun(o,D,B,b,z,w,_,$),q!==0&&Ae("failed to call OrtRun().");let Ce=[];for(let ae=0;ae<w;ae++){let we=u.HEAPU32[_/4+ae];if(we===A[ae]){Ce.push(n[ae]);continue}let K=u.stackSave(),Se=u.stackAlloc(4*4),Be=!1,xe,Ie=0;try{u._OrtGetTensorData(we,Se,Se+4,Se+8,Se+12)!==0&&Ae(`Can\'t access output tensor data on index ${ae}.`);let Ge=Se/4,it=u.HEAPU32[Ge++];Ie=u.HEAPU32[Ge++];let V=u.HEAPU32[Ge++],ce=u.HEAPU32[Ge++],pe=[];for(let Ee=0;Ee<ce;Ee++)pe.push(u.HEAPU32[V/4+Ee]);u._OrtFree(V);let ze=pe.reduce((Ee,Te)=>Ee*Te,1);xe=Jt(it);let Ve=x?.outputPreferredLocations[i[ae]];if(xe==="string"){if(Ve==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Ee=[],Te=Ie/4;for(let He=0;He<ze;He++){let Le=u.HEAPU32[Te++],Ue=He===ze-1?void 0:u.HEAPU32[Te]-Le;Ee.push(u.UTF8ToString(Le,Ue))}Ce.push([xe,pe,Ee,"cpu"])}else if(Ve==="gpu-buffer"&&ze>0){let Ee=u.jsepGetBuffer(Ie),Te=Zt(it);if(Te===void 0||!vo(xe))throw new Error(`Unsupported data type: ${xe}`);Be=!0,Ce.push([xe,pe,{gpuBuffer:Ee,download:u.jsepCreateDownloader(Ee,ze*Te,xe),dispose:()=>{u._OrtReleaseTensor(we)}},"gpu-buffer"])}else{let Ee=Sr(xe),Te=new Ee(ze);new Uint8Array(Te.buffer,Te.byteOffset,Te.byteLength).set(u.HEAPU8.subarray(Ie,Ie+Te.byteLength)),Ce.push([xe,pe,Te,"cpu"])}}finally{u.stackRestore(K),xe==="string"&&Ie&&u._free(Ie),Be||u._OrtReleaseTensor(we)}}return x&&u._OrtClearBoundOutputs(x.handle),Ce}finally{u.stackRestore(W),C.forEach(N=>u._OrtReleaseTensor(N)),A.forEach(N=>u._OrtReleaseTensor(N)),P.forEach(N=>u._free(N)),$!==0&&u._OrtReleaseRunOptions($),y.forEach(N=>u._free(N))}},qs=e=>{let t=_e(),r=ar.get(e);if(!r)throw new Error("invalid session id");let i=r[0],n=t._OrtEndProfiling(i);n===0&&Ae("Can\'t get an profile file name."),t._OrtFree(n)},Ys=e=>{let t=[];for(let r of e){let i=r[2];!Array.isArray(i)&&"buffer"in i&&t.push(i.buffer)}return t};self.onmessage=e=>{switch(e.data.type){case"init-wasm":try{yo(e.data.in).then(()=>postMessage({type:"init-wasm"}),t=>postMessage({type:"init-wasm",err:t}))}catch(t){postMessage({type:"init-wasm",err:t})}break;case"init-ort":try{Fs(e.data.in).then(()=>postMessage({type:"init-ort"}),t=>postMessage({type:"init-ort",err:t}))}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{let{model:t}=e.data.in,r=kn(t);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{let{modeldata:t,options:r}=e.data.in,i=Dn(t,r);postMessage({type:"create_finalize",out:i})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{let{model:t,options:r}=e.data.in,i=Ls(t,r);postMessage({type:"create",out:i})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{let t=e.data.in;js(t),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{let{sessionId:t,inputIndices:r,inputs:i,outputIndices:n,options:s}=e.data.in;Ks(t,r,i,n,s).then(u=>{postMessage({type:"run",out:u},Ys(u))},u=>{postMessage({type:"run",err:u})})}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{let t=e.data.in;qs(t),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}break;case"is-ort-env-initialized":try{let t=Hs();postMessage({type:"is-ort-env-initialized",out:t})}catch(t){postMessage({type:"is-ort-env-initialized",err:t})}break;default:}};})();\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n'});var mt,Le,fn,ya,ba,ua,la,da,ca,pa,fa,ma,ha,ga,xt,Uc,pn,qu,Ku,Yu,Xu,wa,Ju,Qu,Zu,el,va=L(()=>{"use strict";wt();Fu();Ut();mt=()=>!!Ie.wasm.proxy&&typeof document<"u",fn=!1,ya=!1,ba=!1,da=[],ca=[],pa=[],fa=[],ma=[],ha=[],ga=[],xt=()=>{if(fn||!ya||ba||!Le)throw new Error("worker not ready")},Uc=e=>{switch(e.data.type){case"init-wasm":fn=!1,e.data.err?(ba=!0,ua[1](e.data.err)):(ya=!0,ua[0]());break;case"init-ort":e.data.err?la[1](e.data.err):la[0]();break;case"create_allocate":e.data.err?da.shift()[1](e.data.err):da.shift()[0](e.data.out);break;case"create_finalize":e.data.err?ca.shift()[1](e.data.err):ca.shift()[0](e.data.out);break;case"create":e.data.err?pa.shift()[1](e.data.err):pa.shift()[0](e.data.out);break;case"release":e.data.err?fa.shift()[1](e.data.err):fa.shift()[0]();break;case"run":e.data.err?ma.shift()[1](e.data.err):ma.shift()[0](e.data.out);break;case"end-profiling":e.data.err?ha.shift()[1](e.data.err):ha.shift()[0]();break;case"is-ort-env-initialized":e.data.err?ga.shift()[1](e.data.err):ga.shift()[0](e.data.out);break;default:}},pn=typeof document<"u"?document?.currentScript?.src:void 0,qu=async()=>{if(mt()){if(ya)return;if(fn)throw new Error("multiple calls to 'initWasm()' detected.");if(ba)throw new Error("previous call to 'initWasm()' failed.");return fn=!0,Ie.wasm.wasmPaths===void 0&&pn&&pn.indexOf("blob:")!==0&&(Ie.wasm.wasmPaths=pn.substr(0,+pn.lastIndexOf("/")+1)),new Promise((e,t)=>{Le?.terminate();let r=URL.createObjectURL(new Blob([ju()],{type:"text/javascript"}));Le=new Worker(r,{name:"ort-wasm-proxy-worker"}),Le.onerror=n=>t(n),Le.onmessage=Uc,URL.revokeObjectURL(r),ua=[e,t];let o={type:"init-wasm",in:Ie.wasm};Le.postMessage(o)})}else return Oo(Ie.wasm)},Ku=async e=>{if(mt())return xt(),new Promise((t,r)=>{la=[t,r];let o={type:"init-ort",in:e};Le.postMessage(o)});await Wu(e)},Yu=async e=>mt()?(xt(),new Promise((t,r)=>{da.push([t,r]);let o={type:"create_allocate",in:{model:e}};Le.postMessage(o,[e.buffer])})):ia(e),Xu=async(e,t)=>mt()?(xt(),new Promise((r,o)=>{ca.push([r,o]);let n={type:"create_finalize",in:{modeldata:e,options:t}};Le.postMessage(n)})):sa(e,t),wa=async(e,t)=>{if(mt()){if(t?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return xt(),new Promise((r,o)=>{pa.push([r,o]);let n={type:"create",in:{model:e,options:t}};Le.postMessage(n,[e.buffer])})}else return Gu(e,t)},Ju=async e=>{if(mt())return xt(),new Promise((t,r)=>{fa.push([t,r]);let o={type:"release",in:e};Le.postMessage(o)});Uu(e)},Qu=async(e,t,r,o,n,s)=>{if(mt()){if(r.some(u=>u[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(n.some(u=>u))throw new Error("pre-allocated output tensor is not supported for proxy.");return xt(),new Promise((u,l)=>{ma.push([u,l]);let a=r,p={type:"run",in:{sessionId:e,inputIndices:t,inputs:a,outputIndices:o,options:s}};Le.postMessage(p,Hu(a))})}else return Vu(e,t,r,o,n,s)},Zu=async e=>{if(mt())return xt(),new Promise((t,r)=>{ha.push([t,r]);let o={type:"end-profiling",in:e};Le.postMessage(o)});Lu(e)},el=async()=>mt()?(xt(),new Promise((e,t)=>{ga.push([e,t]);let r={type:"is-ort-env-initialized"};Le.postMessage(r)})):Nu()});var mn,tl,Vc,hn,rl=L(()=>{"use strict";wt();va();De();tl=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},Vc=e=>{switch(e[3]){case"cpu":return new Ze(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!Hr(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:r,download:o,dispose:n}=e[2];return Ze.fromGpuBuffer(r,{dataType:t,dims:e[1],download:o,dispose:n})}default:throw new Error(`invalid data location: ${e[3]}`)}},hn=class{async createSessionAllocate(t){let r=await fetch(t);if(r.status!==200)throw new Error(`failed to load model: ${t}`);let o=await r.arrayBuffer();return Yu(new Uint8Array(o))}async loadModel(t,r){if(await el()||(mn||(mn=Ku(Ie)),await mn,mn=void 0),typeof t=="string")if(typeof process<"u"&&process.versions&&process.versions.node){let o=await(void 0)(t);[this.sessionId,this.inputNames,this.outputNames]=await wa(o,r)}else{let o=await this.createSessionAllocate(t);[this.sessionId,this.inputNames,this.outputNames]=await Xu(o,r)}else[this.sessionId,this.inputNames,this.outputNames]=await wa(t,r)}async dispose(){return Ju(this.sessionId)}async run(t,r,o){let n=[],s=[];Object.entries(t).forEach(g=>{let v=g[0],$=g[1],w=this.inputNames.indexOf(v);if(w===-1)throw new Error(`invalid input '${v}'`);n.push($),s.push(w)});let u=[],l=[];Object.entries(r).forEach(g=>{let v=g[0],$=g[1],w=this.outputNames.indexOf(v);if(w===-1)throw new Error(`invalid output '${v}'`);u.push($),l.push(w)});let a=n.map((g,v)=>tl(g,()=>`input "${this.inputNames[s[v]]}"`)),p=u.map((g,v)=>g?tl(g,()=>`output "${this.outputNames[l[v]]}"`):null),h=await Qu(this.sessionId,s,a,l,p,o),b={};for(let g=0;g<h.length;g++)b[this.outputNames[l[g]]]=u[g]??Vc(h[g]);return b}startProfiling(){}endProfiling(){Zu(this.sessionId)}}});var Lc,gn,nl=L(()=>{"use strict";wt();va();rl();Lc=()=>{if((typeof Ie.wasm.initTimeout!="number"||Ie.wasm.initTimeout<0)&&(Ie.wasm.initTimeout=0),typeof Ie.wasm.simd!="boolean"&&(Ie.wasm.simd=!0),typeof Ie.wasm.proxy!="boolean"&&(Ie.wasm.proxy=!1),typeof Ie.wasm.numThreads!="number"||!Number.isInteger(Ie.wasm.numThreads)||Ie.wasm.numThreads<=0){let e=typeof navigator>"u"?(void 0)().length:navigator.hardwareConcurrency;Ie.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},gn=class{async init(){Lc(),await qu()}async createInferenceSessionHandler(t,r){let o=new hn;return await o.loadModel(t,r),Promise.resolve(o)}}});var al={};_t(al,{wasmBackend:()=>Hc});var Hc,ol=L(()=>{"use strict";nl();Hc=new gn});var jc={};_t(jc,{InferenceSession:()=>uo,Tensor:()=>Ze,TrainingSession:()=>fo,default:()=>Fc,env:()=>Ie,registerBackend:()=>pt});wt();wt();wt();var ho="1.17.0";var Fc=_n;{let e=(ol(),bt(al)).wasmBackend;typeof navigator<"u"&&navigator.gpu&&pt("webgpu",e,5),pt("cpu",e,10),pt("wasm",e,10),pt("xnnpack",e,9),pt("webnn",e,9)}Object.defineProperty(Ie.versions,"web",{value:ho,enumerable:!0});return bt(jc);})();
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
//# sourceMappingURL=ort.webgpu.min.js.map
