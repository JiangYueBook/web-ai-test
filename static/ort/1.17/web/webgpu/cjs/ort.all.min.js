/*!
 * ONNX Runtime Web v1.17.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
"use strict";var x1=Object.create;var Ho=Object.defineProperty;var T1=Object.getOwnPropertyDescriptor;var _1=Object.getOwnPropertyNames;var $1=Object.getPrototypeOf,S1=Object.prototype.hasOwnProperty;var X=(n,e)=>()=>(n&&(e=n(n=0)),e);var et=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),ln=(n,e)=>{for(var r in e)Ho(n,r,{get:e[r],enumerable:!0})},Jc=(n,e,r,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of _1(e))!S1.call(n,i)&&i!==r&&Ho(n,i,{get:()=>e[i],enumerable:!(t=T1(e,i))||t.enumerable});return n};var Un=(n,e,r)=>(r=n!=null?x1($1(n)):{},Jc(e||!n||!n.__esModule?Ho(r,"default",{value:n,enumerable:!0}):r,n)),Rr=n=>Jc(Ho({},"__esModule",{value:!0}),n);var qo,cn,Mr,Zc,ys=X(()=>{"use strict";qo=new Map,cn=[],Mr=(n,e,r)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){let t=qo.get(n);if(t===void 0)qo.set(n,{backend:e,priority:r});else{if(t.priority>r)return;if(t.priority===r&&t.backend!==e)throw new Error(`cannot register backend "${n}" using priority ${r}`)}if(r>=0){let i=cn.indexOf(n);i!==-1&&cn.splice(i,1);for(let o=0;o<cn.length;o++)if(qo.get(cn[o]).priority<=r){cn.splice(o,0,n);return}cn.push(n)}return}throw new TypeError("not a valid backend")},Zc=async n=>{let e=n.length===0?cn:n,r=[];for(let t of e){let i=qo.get(t);if(i){if(i.initialized)return i.backend;if(i.aborted)continue;let o=!!i.initPromise;try{return o||(i.initPromise=i.backend.init()),await i.initPromise,i.initialized=!0,i.backend}catch(s){o||r.push({name:t,err:s}),i.aborted=!0}finally{delete i.initPromise}}}throw new Error(`no available backend found. ERR: ${r.map(t=>`[${t.name}] ${t.err}`).join(", ")}`)}});var Qc=X(()=>{"use strict";ys()});var ef,tf=X(()=>{"use strict";ef="1.17.0"});var rf,bs,nf=X(()=>{"use strict";tf();rf="warning",bs={wasm:{},webgl:{},webgpu:{},versions:{common:ef},set logLevel(n){if(n!==void 0){if(typeof n!="string"||["verbose","info","warning","error","fatal"].indexOf(n)===-1)throw new Error(`Unsupported logging level: ${n}`);rf=n}},get logLevel(){return rf}};Object.defineProperty(bs,"logLevel",{enumerable:!0})});var De,of=X(()=>{"use strict";nf();De=bs});var af,sf,uf=X(()=>{"use strict";af=(n,e)=>{let r=document.createElement("canvas");r.width=n.dims[3],r.height=n.dims[2];let t=r.getContext("2d");if(t!=null){let i,o;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(i=n.dims[2],o=n.dims[3]):(i=n.dims[3],o=n.dims[2]);let s=e?.format!==void 0?e.format:"RGB",a=e?.norm,u,c;a===void 0||a.mean===void 0?u=[255,255,255,255]:typeof a.mean=="number"?u=[a.mean,a.mean,a.mean,a.mean]:(u=[a.mean[0],a.mean[1],a.mean[2],0],a.mean[3]!==void 0&&(u[3]=a.mean[3])),a===void 0||a.bias===void 0?c=[0,0,0,0]:typeof a.bias=="number"?c=[a.bias,a.bias,a.bias,a.bias]:(c=[a.bias[0],a.bias[1],a.bias[2],0],a.bias[3]!==void 0&&(c[3]=a.bias[3]));let g=o*i,v=0,T=g,S=g*2,O=-1;s==="RGBA"?(v=0,T=g,S=g*2,O=g*3):s==="RGB"?(v=0,T=g,S=g*2):s==="RBG"&&(v=0,S=g,T=g*2);for(let I=0;I<o;I++)for(let k=0;k<i;k++){let M=(n.data[v++]-c[0])*u[0],F=(n.data[T++]-c[1])*u[1],j=(n.data[S++]-c[2])*u[2],Y=O===-1?255:(n.data[O++]-c[3])*u[3];t.fillStyle="rgba("+M+","+F+","+j+","+Y+")",t.fillRect(k,I,1,1)}return r.toDataURL()}else throw new Error("Can not access image data")},sf=(n,e)=>{let r=document.createElement("canvas").getContext("2d"),t;if(r!=null){let i,o,s;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(i=n.dims[2],o=n.dims[1],s=n.dims[3]):(i=n.dims[3],o=n.dims[2],s=n.dims[1]);let a=e!==void 0&&e.format!==void 0?e.format:"RGB",u=e?.norm,c,g;u===void 0||u.mean===void 0?c=[255,255,255,255]:typeof u.mean=="number"?c=[u.mean,u.mean,u.mean,u.mean]:(c=[u.mean[0],u.mean[1],u.mean[2],255],u.mean[3]!==void 0&&(c[3]=u.mean[3])),u===void 0||u.bias===void 0?g=[0,0,0,0]:typeof u.bias=="number"?g=[u.bias,u.bias,u.bias,u.bias]:(g=[u.bias[0],u.bias[1],u.bias[2],0],u.bias[3]!==void 0&&(g[3]=u.bias[3]));let v=o*i;if(e!==void 0&&(e.format!==void 0&&s===4&&e.format!=="RGBA"||s===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let T=4,S=0,O=1,I=2,k=3,M=0,F=v,j=v*2,Y=-1;a==="RGBA"?(M=0,F=v,j=v*2,Y=v*3):a==="RGB"?(M=0,F=v,j=v*2):a==="RBG"&&(M=0,j=v,F=v*2),t=r.createImageData(i,o);for(let Z=0;Z<o*i;S+=T,O+=T,I+=T,k+=T,Z++)t.data[S]=(n.data[M++]-g[0])*c[0],t.data[O]=(n.data[F++]-g[1])*c[1],t.data[I]=(n.data[j++]-g[2])*c[2],t.data[k]=Y===-1?255:(n.data[Y++]-g[3])*c[3]}else throw new Error("Can not access image data");return t}});var vs,lf,cf,ff,df,pf=X(()=>{"use strict";Ko();vs=(n,e)=>{if(n===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:r,width:t}=e,i=e.norm??{mean:255,bias:0},o,s;typeof i.mean=="number"?o=[i.mean,i.mean,i.mean,i.mean]:o=[i.mean[0],i.mean[1],i.mean[2],i.mean[3]??255],typeof i.bias=="number"?s=[i.bias,i.bias,i.bias,i.bias]:s=[i.bias[0],i.bias[1],i.bias[2],i.bias[3]??0];let a=e.format!==void 0?e.format:"RGBA",u=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",c=r*t,g=u==="RGBA"?new Float32Array(c*4):new Float32Array(c*3),v=4,T=0,S=1,O=2,I=3,k=0,M=c,F=c*2,j=-1;a==="RGB"&&(v=3,T=0,S=1,O=2,I=-1),u==="RGBA"?j=c*3:u==="RBG"?(k=0,F=c,M=c*2):u==="BGR"&&(F=0,M=c,k=c*2);for(let Z=0;Z<c;Z++,T+=v,O+=v,S+=v,I+=v)g[k++]=(n[T]+s[0])/o[0],g[M++]=(n[S]+s[1])/o[1],g[F++]=(n[O]+s[2])/o[2],j!==-1&&I!==-1&&(g[j++]=(n[I]+s[3])/o[3]);return u==="RGBA"?new Bt("float32",g,[1,4,r,t]):new Bt("float32",g,[1,3,r,t])},lf=async(n,e)=>{let r=typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement,t=typeof ImageData<"u"&&n instanceof ImageData,i=typeof ImageBitmap<"u"&&n instanceof ImageBitmap,o=typeof n=="string",s,a=e??{};if(r){let u=document.createElement("canvas");u.width=n.width,u.height=n.height;let c=u.getContext("2d");if(c!=null){let g=n.height,v=n.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(g=e.resizedHeight,v=e.resizedWidth),e!==void 0){if(a=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");a.tensorFormat="RGBA",a.height=g,a.width=v}else a.tensorFormat="RGBA",a.height=g,a.width=v;c.drawImage(n,0,0),s=c.getImageData(0,0,v,g).data}else throw new Error("Can not access image data")}else if(t){let u,c;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(u=e.resizedHeight,c=e.resizedWidth):(u=n.height,c=n.width),e!==void 0&&(a=e),a.format="RGBA",a.height=u,a.width=c,e!==void 0){let g=document.createElement("canvas");g.width=c,g.height=u;let v=g.getContext("2d");if(v!=null)v.putImageData(n,0,0),s=v.getImageData(0,0,c,u).data;else throw new Error("Can not access image data")}else s=n.data}else if(i){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");let u=document.createElement("canvas");u.width=n.width,u.height=n.height;let c=u.getContext("2d");if(c!=null){let g=n.height,v=n.width;return c.drawImage(n,0,0,v,g),s=c.getImageData(0,0,v,g).data,a.height=g,a.width=v,vs(s,a)}else throw new Error("Can not access image data")}else{if(o)return new Promise((u,c)=>{let g=document.createElement("canvas"),v=g.getContext("2d");if(!n||!v)return c();let T=new Image;T.crossOrigin="Anonymous",T.src=n,T.onload=()=>{g.width=T.width,g.height=T.height,v.drawImage(T,0,0,g.width,g.height);let S=v.getImageData(0,0,g.width,g.height);a.height=g.height,a.width=g.width,u(vs(S.data,a))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(s!==void 0)return vs(s,a);throw new Error("Input data provided is not supported - aborted tensor creation")},cf=(n,e)=>{let{width:r,height:t,download:i,dispose:o}=e,s=[1,t,r,4];return new Bt({location:"texture",type:"float32",texture:n,dims:s,download:i,dispose:o})},ff=(n,e)=>{let{dataType:r,dims:t,download:i,dispose:o}=e;return new Bt({location:"gpu-buffer",type:r??"float32",gpuBuffer:n,dims:t,download:i,dispose:o})},df=(n,e,r)=>new Bt({location:"cpu-pinned",type:n,data:e,dims:r??[e.length]})});var qi,Xo,hf,mf,gf=X(()=>{"use strict";qi=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),Xo=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),hf=!1,mf=()=>{if(!hf){hf=!0;let n=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",e=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function";n&&(qi.set("int64",BigInt64Array),Xo.set(BigInt64Array,"int64")),e&&(qi.set("uint64",BigUint64Array),Xo.set(BigUint64Array,"uint64"))}}});var yf,bf,vf=X(()=>{"use strict";Ko();yf=n=>{let e=1;for(let r=0;r<n.length;r++){let t=n[r];if(typeof t!="number"||!Number.isSafeInteger(t))throw new TypeError(`dims[${r}] must be an integer, got: ${t}`);if(t<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${t}`);e*=t}return e},bf=(n,e)=>{switch(n.location){case"cpu":return new Bt(n.type,n.data,e);case"cpu-pinned":return new Bt({location:"cpu-pinned",data:n.data,type:n.type,dims:e});case"texture":return new Bt({location:"texture",texture:n.texture,type:n.type,dims:e});case"gpu-buffer":return new Bt({location:"gpu-buffer",gpuBuffer:n.gpuBuffer,type:n.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${n.location} is not supported`)}}});var Bt,Ko=X(()=>{"use strict";uf();pf();gf();vf();Bt=class{constructor(e,r,t){mf();let i,o;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,i=e.type,o=e.dims,e.location){case"cpu-pinned":{let a=qi.get(i);if(!a)throw new TypeError(`unsupported type "${i}" to create tensor from pinned buffer`);if(!(e.data instanceof a))throw new TypeError(`buffer should be of type ${a.name}`);this.cpuData=e.data;break}case"texture":{if(i!=="float32")throw new TypeError(`unsupported type "${i}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(i!=="float32"&&i!=="float16"&&i!=="int32"&&i!=="int64"&&i!=="uint32"&&i!=="bool")throw new TypeError(`unsupported type "${i}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let a,u;if(typeof e=="string")if(i=e,u=t,e==="string"){if(!Array.isArray(r))throw new TypeError("A string tensor's data must be a string array.");a=r}else{let c=qi.get(e);if(c===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(r)){if(e==="float16")throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");e==="uint64"||e==="int64"?a=c.from(r,BigInt):a=c.from(r)}else if(r instanceof c)a=r;else throw new TypeError(`A ${i} tensor's data must be type of ${c}`)}else if(u=r,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let c=typeof e[0];if(c==="string")i="string",a=e;else if(c==="boolean")i="bool",a=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${c}.`)}else{let c=Xo.get(e.constructor);if(c===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);i=c,a=e}if(u===void 0)u=[a.length];else if(!Array.isArray(u))throw new TypeError("A tensor's dims must be a number array");o=u,this.cpuData=a,this.dataLocation="cpu"}let s=yf(o);if(this.cpuData&&s!==this.cpuData.length)throw new Error(`Tensor's size(${s}) does not match data length(${this.cpuData.length}).`);this.type=i,this.dims=o,this.size=s}static async fromImage(e,r){return lf(e,r)}static fromTexture(e,r){return cf(e,r)}static fromGpuBuffer(e,r){return ff(e,r)}static fromPinnedBuffer(e,r,t){return df(e,r,t)}toDataURL(e){return af(this,e)}toImageData(e){return sf(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let r=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=r,e&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return bf(this,e)}}});var qt,ws=X(()=>{"use strict";Ko();qt=Bt});var Yo,wf=X(()=>{"use strict";ys();ws();Yo=class n{constructor(e){this.handler=e}async run(e,r,t){let i={},o={};if(typeof e!="object"||e===null||e instanceof qt||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let s=!0;if(typeof r=="object"){if(r===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof qt)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(r.length===0)throw new TypeError("'fetches' cannot be an empty array.");s=!1;for(let c of r){if(typeof c!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(c)===-1)throw new RangeError(`'fetches' contains invalid output name: ${c}.`);i[c]=null}if(typeof t=="object"&&t!==null)o=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else{let c=!1,g=Object.getOwnPropertyNames(r);for(let v of this.outputNames)if(g.indexOf(v)!==-1){let T=r[v];(T===null||T instanceof qt)&&(c=!0,s=!1,i[v]=T)}if(c){if(typeof t=="object"&&t!==null)o=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else o=r}}else if(typeof r<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let c of this.inputNames)if(typeof e[c]>"u")throw new Error(`input '${c}' is missing in 'feeds'.`);if(s)for(let c of this.outputNames)i[c]=null;let a=await this.handler.run(e,i,o),u={};for(let c in a)if(Object.hasOwnProperty.call(a,c)){let g=a[c];g instanceof qt?u[c]=g:u[c]=new qt(g.type,g.data,g.dims)}return u}async release(){return this.handler.dispose()}static async create(e,r,t,i){let o,s={};if(typeof e=="string"){if(o=e,typeof r=="object"&&r!==null)s=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(o=e,typeof r=="object"&&r!==null)s=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){let v=e,T=0,S=e.byteLength;if(typeof r=="object"&&r!==null)s=r;else if(typeof r=="number"){if(T=r,!Number.isSafeInteger(T))throw new RangeError("'byteOffset' must be an integer.");if(T<0||T>=v.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${v.byteLength}).`);if(S=e.byteLength-T,typeof t=="number"){if(S=t,!Number.isSafeInteger(S))throw new RangeError("'byteLength' must be an integer.");if(S<=0||T+S>v.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${v.byteLength-T}].`);if(typeof i=="object"&&i!==null)s=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else if(typeof t<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof r<"u")throw new TypeError("'options' must be an object.");o=new Uint8Array(v,T,S)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let u=(s.executionProviders||[]).map(v=>typeof v=="string"?v:v.name),g=await(await Zc(u)).createInferenceSessionHandler(o,s);return new n(g)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var I1,xf=X(()=>{"use strict";wf();I1=Yo});var Tf=X(()=>{"use strict"});var Jo,_f=X(()=>{"use strict";Jo=class{constructor(e){this.handler=e}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}static async create(e,r){throw new Error("Method not implemented")}async loadParametersBuffer(e,r){throw new Error("Method not implemented.")}async getContiguousParameters(e){throw new Error("Method not implemented.")}async runTrainStep(e,r,t){throw new Error("Method not implemented.")}async release(){return this.handler.dispose()}}});var C1,$f=X(()=>{"use strict";_f();C1=Jo});var lr=X(()=>{"use strict";Qc();of();xf();ws();Tf();$f()});function Fr(n,e,r,t){if(e===void 0)return O1(n);if(r===void 0)Zo(n,e,1);else if(typeof r=="number"&&t===void 0)Zo(n,e,r);else if(typeof r=="string"&&t===void 0)Zo(n,r,1,e);else if(typeof r=="string"&&typeof t=="number")Zo(n,r,t,e);else throw new TypeError("input is valid")}function O1(n){return{verbose:Fr.verbose.bind(null,n),info:Fr.info.bind(null,n),warning:Fr.warning.bind(null,n),error:Fr.error.bind(null,n),fatal:Fr.fatal.bind(null,n)}}function Zo(n,e,r,t){let i=Ki[t||""]||Ki[""];If[n]<If[i.minimalSeverity]||(i.logDateTime&&(e=`${new Date().toISOString()}|${e}`),i.logSourceLocation,A1[i.provider].log(n,e,t))}var xs,Ts,If,A1,Cf,Ki,Xe,ea,ta,ra,Qo,Kt=X(()=>{"use strict";xs=class{log(e,r,t){}},Ts=class{log(e,r,t){console.log(`${this.color(e)} ${t?"\x1B[35m"+t+"\x1B[0m ":""}${r}`)}color(e){switch(e){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${e}`)}}},If={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},A1={none:new xs,console:new Ts},Cf={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1},Ki={"":Cf};(u=>{function n(c,g){u("verbose",c,g)}u.verbose=n;function e(c,g){u("info",c,g)}u.info=e;function r(c,g){u("warning",c,g)}u.warning=r;function t(c,g){u("error",c,g)}u.error=t;function i(c,g){u("fatal",c,g)}u.fatal=i;function o(c){Ki={},s("",c||{})}u.reset=o;function s(c,g){if(c==="*")o(g);else{let v=Ki[c]||Cf;Ki[c]={provider:g.provider||v.provider,minimalSeverity:g.minimalSeverity||v.minimalSeverity,logDateTime:g.logDateTime===void 0?v.logDateTime:g.logDateTime,logSourceLocation:g.logSourceLocation===void 0?v.logSourceLocation:g.logSourceLocation}}}u.set=s;function a(c){let g={};c.logLevel&&(g.minimalSeverity=c.logLevel),s("",g)}u.setWithEnv=a})(Fr||={});Xe=Fr,ea=class{constructor(e,r,t,i,o,s){this.category=e;this.name=r;this.startTime=t;this.endCallback=i;this.timer=o;this.ctx=s}async end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}},ta=class{constructor(e,r,t,i){this.category=e;this.name=r;this.startTime=t;this.endTime=i}},ra=class{constructor(e,r,t){this._started=!1;this._flushPointer=0;this._started=!1,this._maxNumberEvents=e===void 0?1e4:e,this._flushBatchSize=r===void 0?10:r,this._flushIntervalInMilliseconds=t===void 0?5e3:t}static create(e){return e===void 0?new this:new this(e.maxNumberEvents,e.flushBatchSize,e.flushIntervalInMilliseconds)}start(){this._started=!0,this._timingEvents=[],this._flushTime=Qo(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(e,r,t,i){let o=this._started?this.begin(e,r,i):void 0,s=!1,a=t();if(a&&typeof a.then=="function")return s=!0,new Promise((u,c)=>{a.then(async g=>{o&&await o.end(),u(g)},async g=>{o&&await o.end(),c(g)})});if(!s&&o){let u=o.end();if(u&&typeof u.then=="function")return new Promise((c,g)=>{u.then(()=>{c(a)},v=>{g(v)})})}return a}begin(e,r,t){if(!this._started)throw new Error("profiler is not started yet");if(t===void 0){let i=Qo();return this.flush(i),new ea(e,r,i,o=>this.endSync(o))}else{let i=t.beginTimer();return new ea(e,r,0,async o=>this.end(o),i,t)}}async end(e){let r=await e.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new ta(e.category,e.name,e.startTime,r)),this.flush(r))}endSync(e){let r=Qo();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new ta(e.category,e.name,e.startTime,r)),this.flush(r))}logOneEvent(e){Xe.verbose(`Profiler.${e.category}`,`${(e.endTime-e.startTime).toFixed(2)}ms on event '${e.name}' at ${e.endTime.toFixed(2)}`)}flush(e){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||e-this._flushTime>=this._flushIntervalInMilliseconds){for(let r=this._flushPointer;this._flushPointer<r+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=Qo()}}get started(){return this._started}},Qo=typeof performance<"u"&&performance.now?()=>performance.now():Date.now});function Af(n,e,r){for(let t of r){let i=t[0],o=t[1],s=t[2],a=t[3],u=t[4];if(n.opType===i){for(let c of e)if((c.domain===o||c.domain==="ai.onnx"&&o==="")&&E1(c.version,s))return{opImpl:a,opInit:u}}}throw new TypeError(`cannot resolve operator '${n.opType}' with opsets: ${e.map(t=>`${t.domain||"ai.onnx"} v${t.version}`).join(", ")}`)}function E1(n,e){if(e.endsWith("+")){let r=Number.parseInt(e.substring(0,e.length-1),10);return!isNaN(r)&&r<=n}else if(e.split("-").length===2){let r=e.split("-"),t=Number.parseInt(r[0],10),i=Number.parseInt(r[1],10);return!isNaN(t)&&!isNaN(i)&&t<=n&&n<=i}else return Number.parseInt(e,10)===n}var Of=X(()=>{"use strict"});var Ef=et(_s=>{"use strict";_s.__esModule=!0;var P1=function(){function n(e){if(!e)throw new TypeError("Invalid argument; `value` has no value.");this.value=n.EMPTY,e&&n.isGuid(e)&&(this.value=e)}return n.isGuid=function(e){var r=e.toString();return e&&(e instanceof n||n.validator.test(r))},n.create=function(){return new n([n.gen(2),n.gen(1),n.gen(1),n.gen(1),n.gen(3)].join("-"))},n.createEmpty=function(){return new n("emptyguid")},n.parse=function(e){return new n(e)},n.raw=function(){return[n.gen(2),n.gen(1),n.gen(1),n.gen(1),n.gen(3)].join("-")},n.gen=function(e){for(var r="",t=0;t<e;t++)r+=((1+Math.random())*65536|0).toString(16).substring(1);return r},n.prototype.equals=function(e){return n.isGuid(e)&&this.value===e.toString()},n.prototype.isEmpty=function(){return this.value===n.EMPTY},n.prototype.toString=function(){return this.value},n.prototype.toJSON=function(){return{value:this.value}},n.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),n.EMPTY="00000000-0000-0000-0000-000000000000",n}();_s.Guid=P1});function tt(n,e,r){this.low=n|0,this.high=e|0,this.unsigned=!!r}function Pt(n){return(n&&n.__isLong__)===!0}function Pf(n){var e=Math.clz32(n&-n);return n?31-e:e}function fn(n,e){var r,t,i;return e?(n>>>=0,(i=0<=n&&n<256)&&(t=kf[n],t)?t:(r=qe(n,0,!0),i&&(kf[n]=r),r)):(n|=0,(i=-128<=n&&n<128)&&(t=Df[n],t)?t:(r=qe(n,n<0?-1:0,!1),i&&(Df[n]=r),r))}function Yt(n,e){if(isNaN(n))return e?Lr:cr;if(e){if(n<0)return Lr;if(n>=Lf)return Ff}else{if(n<=-Rf)return zt;if(n+1>=Rf)return zf}return n<0?Yt(-n,e).neg():qe(n%qn|0,n/qn|0,e)}function qe(n,e,r){return new tt(n,e,r)}function Ss(n,e,r){if(n.length===0)throw Error("empty string");if(typeof e=="number"?(r=e,e=!1):e=!!e,n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return e?Lr:cr;if(r=r||10,r<2||36<r)throw RangeError("radix");var t;if((t=n.indexOf("-"))>0)throw Error("interior hyphen");if(t===0)return Ss(n.substring(1),e,r).neg();for(var i=Yt(na(r,8)),o=cr,s=0;s<n.length;s+=8){var a=Math.min(8,n.length-s),u=parseInt(n.substring(s,s+a),r);if(a<8){var c=Yt(na(r,a));o=o.mul(c).add(Yt(u))}else o=o.mul(i),o=o.add(Yt(u))}return o.unsigned=e,o}function fr(n,e){return typeof n=="number"?Yt(n,e):typeof n=="string"?Ss(n,e):qe(n.low,n.high,typeof e=="boolean"?e:n.unsigned)}var Xt,Df,kf,na,Bf,D1,qn,Lf,Rf,Mf,cr,Lr,Hn,Nf,$s,zf,Ff,zt,oe,Nr,Is=X(()=>{Xt=null;try{Xt=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}tt.prototype.__isLong__;Object.defineProperty(tt.prototype,"__isLong__",{value:!0});tt.isLong=Pt;Df={},kf={};tt.fromInt=fn;tt.fromNumber=Yt;tt.fromBits=qe;na=Math.pow;tt.fromString=Ss;tt.fromValue=fr;Bf=65536,D1=1<<24,qn=Bf*Bf,Lf=qn*qn,Rf=Lf/2,Mf=fn(D1),cr=fn(0);tt.ZERO=cr;Lr=fn(0,!0);tt.UZERO=Lr;Hn=fn(1);tt.ONE=Hn;Nf=fn(1,!0);tt.UONE=Nf;$s=fn(-1);tt.NEG_ONE=$s;zf=qe(-1,2147483647,!1);tt.MAX_VALUE=zf;Ff=qe(-1,-1,!0);tt.MAX_UNSIGNED_VALUE=Ff;zt=qe(0,-2147483648,!1);tt.MIN_VALUE=zt;oe=tt.prototype;oe.toInt=function(){return this.unsigned?this.low>>>0:this.low};oe.toNumber=function(){return this.unsigned?(this.high>>>0)*qn+(this.low>>>0):this.high*qn+(this.low>>>0)};oe.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(zt)){var r=Yt(e),t=this.div(r),i=t.mul(r).sub(this);return t.toString(e)+i.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var o=Yt(na(e,6),this.unsigned),s=this,a="";;){var u=s.div(o),c=s.sub(u.mul(o)).toInt()>>>0,g=c.toString(e);if(s=u,s.isZero())return g+a;for(;g.length<6;)g="0"+g;a=""+g+a}};oe.getHighBits=function(){return this.high};oe.getHighBitsUnsigned=function(){return this.high>>>0};oe.getLowBits=function(){return this.low};oe.getLowBitsUnsigned=function(){return this.low>>>0};oe.getNumBitsAbs=function(){if(this.isNegative())return this.eq(zt)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,r=31;r>0&&!(e&1<<r);r--);return this.high!=0?r+33:r+1};oe.isZero=function(){return this.high===0&&this.low===0};oe.eqz=oe.isZero;oe.isNegative=function(){return!this.unsigned&&this.high<0};oe.isPositive=function(){return this.unsigned||this.high>=0};oe.isOdd=function(){return(this.low&1)===1};oe.isEven=function(){return(this.low&1)===0};oe.equals=function(e){return Pt(e)||(e=fr(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};oe.eq=oe.equals;oe.notEquals=function(e){return!this.eq(e)};oe.neq=oe.notEquals;oe.ne=oe.notEquals;oe.lessThan=function(e){return this.comp(e)<0};oe.lt=oe.lessThan;oe.lessThanOrEqual=function(e){return this.comp(e)<=0};oe.lte=oe.lessThanOrEqual;oe.le=oe.lessThanOrEqual;oe.greaterThan=function(e){return this.comp(e)>0};oe.gt=oe.greaterThan;oe.greaterThanOrEqual=function(e){return this.comp(e)>=0};oe.gte=oe.greaterThanOrEqual;oe.ge=oe.greaterThanOrEqual;oe.compare=function(e){if(Pt(e)||(e=fr(e)),this.eq(e))return 0;var r=this.isNegative(),t=e.isNegative();return r&&!t?-1:!r&&t?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};oe.comp=oe.compare;oe.negate=function(){return!this.unsigned&&this.eq(zt)?zt:this.not().add(Hn)};oe.neg=oe.negate;oe.add=function(e){Pt(e)||(e=fr(e));var r=this.high>>>16,t=this.high&65535,i=this.low>>>16,o=this.low&65535,s=e.high>>>16,a=e.high&65535,u=e.low>>>16,c=e.low&65535,g=0,v=0,T=0,S=0;return S+=o+c,T+=S>>>16,S&=65535,T+=i+u,v+=T>>>16,T&=65535,v+=t+a,g+=v>>>16,v&=65535,g+=r+s,g&=65535,qe(T<<16|S,g<<16|v,this.unsigned)};oe.subtract=function(e){return Pt(e)||(e=fr(e)),this.add(e.neg())};oe.sub=oe.subtract;oe.multiply=function(e){if(this.isZero())return this;if(Pt(e)||(e=fr(e)),Xt){var r=Xt.mul(this.low,this.high,e.low,e.high);return qe(r,Xt.get_high(),this.unsigned)}if(e.isZero())return this.unsigned?Lr:cr;if(this.eq(zt))return e.isOdd()?zt:cr;if(e.eq(zt))return this.isOdd()?zt:cr;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(Mf)&&e.lt(Mf))return Yt(this.toNumber()*e.toNumber(),this.unsigned);var t=this.high>>>16,i=this.high&65535,o=this.low>>>16,s=this.low&65535,a=e.high>>>16,u=e.high&65535,c=e.low>>>16,g=e.low&65535,v=0,T=0,S=0,O=0;return O+=s*g,S+=O>>>16,O&=65535,S+=o*g,T+=S>>>16,S&=65535,S+=s*c,T+=S>>>16,S&=65535,T+=i*g,v+=T>>>16,T&=65535,T+=o*c,v+=T>>>16,T&=65535,T+=s*u,v+=T>>>16,T&=65535,v+=t*g+i*c+o*u+s*a,v&=65535,qe(S<<16|O,v<<16|T,this.unsigned)};oe.mul=oe.multiply;oe.divide=function(e){if(Pt(e)||(e=fr(e)),e.isZero())throw Error("division by zero");if(Xt){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var r=(this.unsigned?Xt.div_u:Xt.div_s)(this.low,this.high,e.low,e.high);return qe(r,Xt.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Lr:cr;var t,i,o;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Lr;if(e.gt(this.shru(1)))return Nf;o=Lr}else{if(this.eq(zt)){if(e.eq(Hn)||e.eq($s))return zt;if(e.eq(zt))return Hn;var s=this.shr(1);return t=s.div(e).shl(1),t.eq(cr)?e.isNegative()?Hn:$s:(i=this.sub(e.mul(t)),o=t.add(i.div(e)),o)}else if(e.eq(zt))return this.unsigned?Lr:cr;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();o=cr}for(i=this;i.gte(e);){t=Math.max(1,Math.floor(i.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(t)/Math.LN2),u=a<=48?1:na(2,a-48),c=Yt(t),g=c.mul(e);g.isNegative()||g.gt(i);)t-=u,c=Yt(t,this.unsigned),g=c.mul(e);c.isZero()&&(c=Hn),o=o.add(c),i=i.sub(g)}return o};oe.div=oe.divide;oe.modulo=function(e){if(Pt(e)||(e=fr(e)),Xt){var r=(this.unsigned?Xt.rem_u:Xt.rem_s)(this.low,this.high,e.low,e.high);return qe(r,Xt.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};oe.mod=oe.modulo;oe.rem=oe.modulo;oe.not=function(){return qe(~this.low,~this.high,this.unsigned)};oe.countLeadingZeros=function(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32};oe.clz=oe.countLeadingZeros;oe.countTrailingZeros=function(){return this.low?Pf(this.low):Pf(this.high)+32};oe.ctz=oe.countTrailingZeros;oe.and=function(e){return Pt(e)||(e=fr(e)),qe(this.low&e.low,this.high&e.high,this.unsigned)};oe.or=function(e){return Pt(e)||(e=fr(e)),qe(this.low|e.low,this.high|e.high,this.unsigned)};oe.xor=function(e){return Pt(e)||(e=fr(e)),qe(this.low^e.low,this.high^e.high,this.unsigned)};oe.shiftLeft=function(e){return Pt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?qe(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):qe(0,this.low<<e-32,this.unsigned)};oe.shl=oe.shiftLeft;oe.shiftRight=function(e){return Pt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?qe(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):qe(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};oe.shr=oe.shiftRight;oe.shiftRightUnsigned=function(e){return Pt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?qe(this.low>>>e|this.high<<32-e,this.high>>>e,this.unsigned):e===32?qe(this.high,0,this.unsigned):qe(this.high>>>e-32,0,this.unsigned)};oe.shru=oe.shiftRightUnsigned;oe.shr_u=oe.shiftRightUnsigned;oe.rotateLeft=function(e){var r;return Pt(e)&&(e=e.toInt()),(e&=63)===0?this:e===32?qe(this.high,this.low,this.unsigned):e<32?(r=32-e,qe(this.low<<e|this.high>>>r,this.high<<e|this.low>>>r,this.unsigned)):(e-=32,r=32-e,qe(this.high<<e|this.low>>>r,this.low<<e|this.high>>>r,this.unsigned))};oe.rotl=oe.rotateLeft;oe.rotateRight=function(e){var r;return Pt(e)&&(e=e.toInt()),(e&=63)===0?this:e===32?qe(this.high,this.low,this.unsigned):e<32?(r=32-e,qe(this.high<<r|this.low>>>e,this.low<<r|this.high>>>e,this.unsigned)):(e-=32,r=32-e,qe(this.low<<r|this.high>>>e,this.high<<r|this.low>>>e,this.unsigned))};oe.rotr=oe.rotateRight;oe.toSigned=function(){return this.unsigned?qe(this.low,this.high,!1):this};oe.toUnsigned=function(){return this.unsigned?this:qe(this.low,this.high,!0)};oe.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};oe.toBytesLE=function(){var e=this.high,r=this.low;return[r&255,r>>>8&255,r>>>16&255,r>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};oe.toBytesBE=function(){var e=this.high,r=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,r>>>24,r>>>16&255,r>>>8&255,r&255]};tt.fromBytes=function(e,r,t){return t?tt.fromBytesLE(e,r):tt.fromBytesBE(e,r)};tt.fromBytesLE=function(e,r){return new tt(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,r)};tt.fromBytesBE=function(e,r){return new tt(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],r)};Nr=tt});var G,ia=X(()=>{G={};G.Offset;G.Table;G.SIZEOF_SHORT=2;G.SIZEOF_INT=4;G.FILE_IDENTIFIER_LENGTH=4;G.SIZE_PREFIX_LENGTH=4;G.Encoding={UTF8_BYTES:1,UTF16_STRING:2};G.int32=new Int32Array(2);G.float32=new Float32Array(G.int32.buffer);G.float64=new Float64Array(G.int32.buffer);G.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1;G.Long=function(n,e){this.low=n|0,this.high=e|0};G.Long.create=function(n,e){return n==0&&e==0?G.Long.ZERO:new G.Long(n,e)};G.Long.prototype.toFloat64=function(){return(this.low>>>0)+this.high*4294967296};G.Long.prototype.equals=function(n){return this.low==n.low&&this.high==n.high};G.Long.ZERO=new G.Long(0,0);G.Builder=function(n){if(n)var e=n;else var e=1024;this.bb=G.ByteBuffer.allocate(e),this.space=e,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1};G.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1};G.Builder.prototype.forceDefaults=function(n){this.force_defaults=n};G.Builder.prototype.dataBuffer=function(){return this.bb};G.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())};G.Builder.prototype.prep=function(n,e){n>this.minalign&&(this.minalign=n);for(var r=~(this.bb.capacity()-this.space+e)+1&n-1;this.space<r+n+e;){var t=this.bb.capacity();this.bb=G.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-t}this.pad(r)};G.Builder.prototype.pad=function(n){for(var e=0;e<n;e++)this.bb.writeInt8(--this.space,0)};G.Builder.prototype.writeInt8=function(n){this.bb.writeInt8(this.space-=1,n)};G.Builder.prototype.writeInt16=function(n){this.bb.writeInt16(this.space-=2,n)};G.Builder.prototype.writeInt32=function(n){this.bb.writeInt32(this.space-=4,n)};G.Builder.prototype.writeInt64=function(n){this.bb.writeInt64(this.space-=8,n)};G.Builder.prototype.writeFloat32=function(n){this.bb.writeFloat32(this.space-=4,n)};G.Builder.prototype.writeFloat64=function(n){this.bb.writeFloat64(this.space-=8,n)};G.Builder.prototype.addInt8=function(n){this.prep(1,0),this.writeInt8(n)};G.Builder.prototype.addInt16=function(n){this.prep(2,0),this.writeInt16(n)};G.Builder.prototype.addInt32=function(n){this.prep(4,0),this.writeInt32(n)};G.Builder.prototype.addInt64=function(n){this.prep(8,0),this.writeInt64(n)};G.Builder.prototype.addFloat32=function(n){this.prep(4,0),this.writeFloat32(n)};G.Builder.prototype.addFloat64=function(n){this.prep(8,0),this.writeFloat64(n)};G.Builder.prototype.addFieldInt8=function(n,e,r){(this.force_defaults||e!=r)&&(this.addInt8(e),this.slot(n))};G.Builder.prototype.addFieldInt16=function(n,e,r){(this.force_defaults||e!=r)&&(this.addInt16(e),this.slot(n))};G.Builder.prototype.addFieldInt32=function(n,e,r){(this.force_defaults||e!=r)&&(this.addInt32(e),this.slot(n))};G.Builder.prototype.addFieldInt64=function(n,e,r){(this.force_defaults||!e.equals(r))&&(this.addInt64(e),this.slot(n))};G.Builder.prototype.addFieldFloat32=function(n,e,r){(this.force_defaults||e!=r)&&(this.addFloat32(e),this.slot(n))};G.Builder.prototype.addFieldFloat64=function(n,e,r){(this.force_defaults||e!=r)&&(this.addFloat64(e),this.slot(n))};G.Builder.prototype.addFieldOffset=function(n,e,r){(this.force_defaults||e!=r)&&(this.addOffset(e),this.slot(n))};G.Builder.prototype.addFieldStruct=function(n,e,r){e!=r&&(this.nested(e),this.slot(n))};G.Builder.prototype.nested=function(n){if(n!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")};G.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")};G.Builder.prototype.slot=function(n){this.vtable[n]=this.offset()};G.Builder.prototype.offset=function(){return this.bb.capacity()-this.space};G.Builder.growByteBuffer=function(n){var e=n.capacity();if(e&3221225472)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var r=e<<1,t=G.ByteBuffer.allocate(r);return t.setPosition(r-e),t.bytes().set(n.bytes(),r-e),t};G.Builder.prototype.addOffset=function(n){this.prep(G.SIZEOF_INT,0),this.writeInt32(this.offset()-n+G.SIZEOF_INT)};G.Builder.prototype.startObject=function(n){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=n;for(var e=0;e<n;e++)this.vtable[e]=0;this.isNested=!0,this.object_start=this.offset()};G.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var n=this.offset(),e=this.vtable_in_use-1;e>=0&&this.vtable[e]==0;e--);for(var r=e+1;e>=0;e--)this.addInt16(this.vtable[e]!=0?n-this.vtable[e]:0);var t=2;this.addInt16(n-this.object_start);var i=(r+t)*G.SIZEOF_SHORT;this.addInt16(i);var o=0,s=this.space;e:for(e=0;e<this.vtables.length;e++){var a=this.bb.capacity()-this.vtables[e];if(i==this.bb.readInt16(a)){for(var u=G.SIZEOF_SHORT;u<i;u+=G.SIZEOF_SHORT)if(this.bb.readInt16(s+u)!=this.bb.readInt16(a+u))continue e;o=this.vtables[e];break}}return o?(this.space=this.bb.capacity()-n,this.bb.writeInt32(this.space,o-n)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-n,this.offset()-n)),this.isNested=!1,n};G.Builder.prototype.finish=function(n,e,r){var t=r?G.SIZE_PREFIX_LENGTH:0;if(e){var i=e;if(this.prep(this.minalign,G.SIZEOF_INT+G.FILE_IDENTIFIER_LENGTH+t),i.length!=G.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+G.FILE_IDENTIFIER_LENGTH);for(var o=G.FILE_IDENTIFIER_LENGTH-1;o>=0;o--)this.writeInt8(i.charCodeAt(o))}this.prep(this.minalign,G.SIZEOF_INT+t),this.addOffset(n),t&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)};G.Builder.prototype.finishSizePrefixed=function(n,e){this.finish(n,e,!0)};G.Builder.prototype.requiredField=function(n,e){var r=this.bb.capacity()-n,t=r-this.bb.readInt32(r),i=this.bb.readInt16(t+e)!=0;if(!i)throw new Error("FlatBuffers: field "+e+" must be set")};G.Builder.prototype.startVector=function(n,e,r){this.notNested(),this.vector_num_elems=e,this.prep(G.SIZEOF_INT,n*e),this.prep(r,n*e)};G.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()};G.Builder.prototype.createString=function(n){if(n instanceof Uint8Array)var e=n;else for(var e=[],r=0;r<n.length;){var t,i=n.charCodeAt(r++);if(i<55296||i>=56320)t=i;else{var o=n.charCodeAt(r++);t=(i<<10)+o+(65536-56623104-56320)}t<128?e.push(t):(t<2048?e.push(t>>6&31|192):(t<65536?e.push(t>>12&15|224):e.push(t>>18&7|240,t>>12&63|128),e.push(t>>6&63|128)),e.push(t&63|128))}this.addInt8(0),this.startVector(1,e.length,1),this.bb.setPosition(this.space-=e.length);for(var r=0,s=this.space,a=this.bb.bytes();r<e.length;r++)a[s++]=e[r];return this.endVector()};G.Builder.prototype.createLong=function(n,e){return G.Long.create(n,e)};G.ByteBuffer=function(n){this.bytes_=n,this.position_=0};G.ByteBuffer.allocate=function(n){return new G.ByteBuffer(new Uint8Array(n))};G.ByteBuffer.prototype.clear=function(){this.position_=0};G.ByteBuffer.prototype.bytes=function(){return this.bytes_};G.ByteBuffer.prototype.position=function(){return this.position_};G.ByteBuffer.prototype.setPosition=function(n){this.position_=n};G.ByteBuffer.prototype.capacity=function(){return this.bytes_.length};G.ByteBuffer.prototype.readInt8=function(n){return this.readUint8(n)<<24>>24};G.ByteBuffer.prototype.readUint8=function(n){return this.bytes_[n]};G.ByteBuffer.prototype.readInt16=function(n){return this.readUint16(n)<<16>>16};G.ByteBuffer.prototype.readUint16=function(n){return this.bytes_[n]|this.bytes_[n+1]<<8};G.ByteBuffer.prototype.readInt32=function(n){return this.bytes_[n]|this.bytes_[n+1]<<8|this.bytes_[n+2]<<16|this.bytes_[n+3]<<24};G.ByteBuffer.prototype.readUint32=function(n){return this.readInt32(n)>>>0};G.ByteBuffer.prototype.readInt64=function(n){return new G.Long(this.readInt32(n),this.readInt32(n+4))};G.ByteBuffer.prototype.readUint64=function(n){return new G.Long(this.readUint32(n),this.readUint32(n+4))};G.ByteBuffer.prototype.readFloat32=function(n){return G.int32[0]=this.readInt32(n),G.float32[0]};G.ByteBuffer.prototype.readFloat64=function(n){return G.int32[G.isLittleEndian?0:1]=this.readInt32(n),G.int32[G.isLittleEndian?1:0]=this.readInt32(n+4),G.float64[0]};G.ByteBuffer.prototype.writeInt8=function(n,e){this.bytes_[n]=e};G.ByteBuffer.prototype.writeUint8=function(n,e){this.bytes_[n]=e};G.ByteBuffer.prototype.writeInt16=function(n,e){this.bytes_[n]=e,this.bytes_[n+1]=e>>8};G.ByteBuffer.prototype.writeUint16=function(n,e){this.bytes_[n]=e,this.bytes_[n+1]=e>>8};G.ByteBuffer.prototype.writeInt32=function(n,e){this.bytes_[n]=e,this.bytes_[n+1]=e>>8,this.bytes_[n+2]=e>>16,this.bytes_[n+3]=e>>24};G.ByteBuffer.prototype.writeUint32=function(n,e){this.bytes_[n]=e,this.bytes_[n+1]=e>>8,this.bytes_[n+2]=e>>16,this.bytes_[n+3]=e>>24};G.ByteBuffer.prototype.writeInt64=function(n,e){this.writeInt32(n,e.low),this.writeInt32(n+4,e.high)};G.ByteBuffer.prototype.writeUint64=function(n,e){this.writeUint32(n,e.low),this.writeUint32(n+4,e.high)};G.ByteBuffer.prototype.writeFloat32=function(n,e){G.float32[0]=e,this.writeInt32(n,G.int32[0])};G.ByteBuffer.prototype.writeFloat64=function(n,e){G.float64[0]=e,this.writeInt32(n,G.int32[G.isLittleEndian?0:1]),this.writeInt32(n+4,G.int32[G.isLittleEndian?1:0])};G.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+G.SIZEOF_INT+G.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var n="",e=0;e<G.FILE_IDENTIFIER_LENGTH;e++)n+=String.fromCharCode(this.readInt8(this.position_+G.SIZEOF_INT+e));return n};G.ByteBuffer.prototype.__offset=function(n,e){var r=n-this.readInt32(n);return e<this.readInt16(r)?this.readInt16(r+e):0};G.ByteBuffer.prototype.__union=function(n,e){return n.bb_pos=e+this.readInt32(e),n.bb=this,n};G.ByteBuffer.prototype.__string=function(n,e){n+=this.readInt32(n);var r=this.readInt32(n),t="",i=0;if(n+=G.SIZEOF_INT,e===G.Encoding.UTF8_BYTES)return this.bytes_.subarray(n,n+r);for(;i<r;){var o,s=this.readUint8(n+i++);if(s<192)o=s;else{var a=this.readUint8(n+i++);if(s<224)o=(s&31)<<6|a&63;else{var u=this.readUint8(n+i++);if(s<240)o=(s&15)<<12|(a&63)<<6|u&63;else{var c=this.readUint8(n+i++);o=(s&7)<<18|(a&63)<<12|(u&63)<<6|c&63}}}o<65536?t+=String.fromCharCode(o):(o-=65536,t+=String.fromCharCode((o>>10)+55296,(o&1024-1)+56320))}return t};G.ByteBuffer.prototype.__indirect=function(n){return n+this.readInt32(n)};G.ByteBuffer.prototype.__vector=function(n){return n+this.readInt32(n)+G.SIZEOF_INT};G.ByteBuffer.prototype.__vector_len=function(n){return this.readInt32(n+this.readInt32(n))};G.ByteBuffer.prototype.__has_identifier=function(n){if(n.length!=G.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+G.FILE_IDENTIFIER_LENGTH);for(var e=0;e<G.FILE_IDENTIFIER_LENGTH;e++)if(n.charCodeAt(e)!=this.readInt8(this.position_+G.SIZEOF_INT+e))return!1;return!0};G.ByteBuffer.prototype.createLong=function(n,e){return G.Long.create(n,e)}});var be,Xi=X(()=>{"use strict";ia();(e=>{let n;(t=>{let r;(o=>{let i;(j=>(j[j.UNDEFINED=0]="UNDEFINED",j[j.FLOAT=1]="FLOAT",j[j.INT=2]="INT",j[j.STRING=3]="STRING",j[j.TENSOR=4]="TENSOR",j[j.GRAPH=5]="GRAPH",j[j.FLOATS=6]="FLOATS",j[j.INTS=7]="INTS",j[j.STRINGS=8]="STRINGS",j[j.TENSORS=9]="TENSORS",j[j.GRAPHS=10]="GRAPHS",j[j.SPARSE_TENSOR=11]="SPARSE_TENSOR",j[j.SPARSE_TENSORS=12]="SPARSE_TENSORS"))(i=o.AttributeType||={})})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{let i;(c=>(c[c.UNKNOWN=0]="UNKNOWN",c[c.VALUE=1]="VALUE",c[c.PARAM=2]="PARAM"))(i=o.DimensionValueType||={})})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{let i;(q=>(q[q.UNDEFINED=0]="UNDEFINED",q[q.FLOAT=1]="FLOAT",q[q.UINT8=2]="UINT8",q[q.INT8=3]="INT8",q[q.UINT16=4]="UINT16",q[q.INT16=5]="INT16",q[q.INT32=6]="INT32",q[q.INT64=7]="INT64",q[q.STRING=8]="STRING",q[q.BOOL=9]="BOOL",q[q.FLOAT16=10]="FLOAT16",q[q.DOUBLE=11]="DOUBLE",q[q.UINT32=12]="UINT32",q[q.UINT64=13]="UINT64",q[q.COMPLEX64=14]="COMPLEX64",q[q.COMPLEX128=15]="COMPLEX128",q[q.BFLOAT16=16]="BFLOAT16",q[q.FLOAT8E4M3FN=17]="FLOAT8E4M3FN",q[q.FLOAT8E4M3FNUZ=18]="FLOAT8E4M3FNUZ",q[q.FLOAT8E5M2=19]="FLOAT8E5M2",q[q.FLOAT8E5M2FNUZ=20]="FLOAT8E5M2FNUZ"))(i=o.TensorDataType||={})})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{let i;(u=>(u[u.Primitive=0]="Primitive",u[u.Fused=1]="Fused"))(i=o.NodeType||={})})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{let i;(g=>(g[g.NONE=0]="NONE",g[g.tensor_type=1]="tensor_type",g[g.sequence_type=2]="sequence_type",g[g.map_type=3]="map_type"))(i=o.TypeInfoValue||={})})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{class i{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsShape(a,u){return(u||new i).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsShape(a,u){return a.setPosition(a.position()+G.SIZE_PREFIX_LENGTH),(u||new i).__init(a.readInt32(a.position())+a.position(),a)}dim(a,u){let c=this.bb.__offset(this.bb_pos,4);return c?(u||new e.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+c)+a*4),this.bb):null}dimLength(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__vector_len(this.bb_pos+a):0}static startShape(a){a.startObject(1)}static addDim(a,u){a.addFieldOffset(0,u,0)}static createDimVector(a,u){a.startVector(4,u.length,4);for(let c=u.length-1;c>=0;c--)a.addOffset(u[c]);return a.endVector()}static startDimVector(a,u){a.startVector(4,u,4)}static endShape(a){return a.endObject()}static createShape(a,u){return i.startShape(a),i.addDim(a,u),i.endShape(a)}}o.Shape=i})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{class i{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsDimension(a,u){return(u||new i).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsDimension(a,u){return a.setPosition(a.position()+G.SIZE_PREFIX_LENGTH),(u||new i).__init(a.readInt32(a.position())+a.position(),a)}value(a){let u=this.bb.__offset(this.bb_pos,4);return u?(a||new e.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}denotation(a){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,a):null}static startDimension(a){a.startObject(2)}static addValue(a,u){a.addFieldOffset(0,u,0)}static addDenotation(a,u){a.addFieldOffset(1,u,0)}static endDimension(a){return a.endObject()}static createDimension(a,u,c){return i.startDimension(a),i.addValue(a,u),i.addDenotation(a,c),i.endDimension(a)}}o.Dimension=i})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{class i{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsDimensionValue(a,u){return(u||new i).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsDimensionValue(a,u){return a.setPosition(a.position()+G.SIZE_PREFIX_LENGTH),(u||new i).__init(a.readInt32(a.position())+a.position(),a)}dimType(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readInt8(this.bb_pos+a):0}dimValue(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}dimParam(a){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.__string(this.bb_pos+u,a):null}static startDimensionValue(a){a.startObject(3)}static addDimType(a,u){a.addFieldInt8(0,u,0)}static addDimValue(a,u){a.addFieldInt64(1,u,a.createLong(0,0))}static addDimParam(a,u){a.addFieldOffset(2,u,0)}static endDimensionValue(a){return a.endObject()}static createDimensionValue(a,u,c,g){return i.startDimensionValue(a),i.addDimType(a,u),i.addDimValue(a,c),i.addDimParam(a,g),i.endDimensionValue(a)}}o.DimensionValue=i})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{class i{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsTensorTypeAndShape(a,u){return(u||new i).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsTensorTypeAndShape(a,u){return a.setPosition(a.position()+G.SIZE_PREFIX_LENGTH),(u||new i).__init(a.readInt32(a.position())+a.position(),a)}elemType(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readInt32(this.bb_pos+a):0}shape(a){let u=this.bb.__offset(this.bb_pos,6);return u?(a||new e.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startTensorTypeAndShape(a){a.startObject(2)}static addElemType(a,u){a.addFieldInt32(0,u,0)}static addShape(a,u){a.addFieldOffset(1,u,0)}static endTensorTypeAndShape(a){return a.endObject()}static createTensorTypeAndShape(a,u,c){return i.startTensorTypeAndShape(a),i.addElemType(a,u),i.addShape(a,c),i.endTensorTypeAndShape(a)}}o.TensorTypeAndShape=i})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{class i{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsMapType(a,u){return(u||new i).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsMapType(a,u){return a.setPosition(a.position()+G.SIZE_PREFIX_LENGTH),(u||new i).__init(a.readInt32(a.position())+a.position(),a)}keyType(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readInt32(this.bb_pos+a):0}valueType(a){let u=this.bb.__offset(this.bb_pos,6);return u?(a||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startMapType(a){a.startObject(2)}static addKeyType(a,u){a.addFieldInt32(0,u,0)}static addValueType(a,u){a.addFieldOffset(1,u,0)}static endMapType(a){return a.endObject()}static createMapType(a,u,c){return i.startMapType(a),i.addKeyType(a,u),i.addValueType(a,c),i.endMapType(a)}}o.MapType=i})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{class i{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsSequenceType(a,u){return(u||new i).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsSequenceType(a,u){return a.setPosition(a.position()+G.SIZE_PREFIX_LENGTH),(u||new i).__init(a.readInt32(a.position())+a.position(),a)}elemType(a){let u=this.bb.__offset(this.bb_pos,4);return u?(a||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startSequenceType(a){a.startObject(1)}static addElemType(a,u){a.addFieldOffset(0,u,0)}static endSequenceType(a){return a.endObject()}static createSequenceType(a,u){return i.startSequenceType(a),i.addElemType(a,u),i.endSequenceType(a)}}o.SequenceType=i})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{class i{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(a,u,c,g){return a.prep(4,12),a.writeInt32(g),a.writeInt32(c),a.writeInt32(u),a.offset()}}o.EdgeEnd=i})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{class i{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsNodeEdge(a,u){return(u||new i).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsNodeEdge(a,u){return a.setPosition(a.position()+G.SIZE_PREFIX_LENGTH),(u||new i).__init(a.readInt32(a.position())+a.position(),a)}nodeIndex(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readUint32(this.bb_pos+a):0}inputEdges(a,u){let c=this.bb.__offset(this.bb_pos,6);return c?(u||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+c)+a*12,this.bb):null}inputEdgesLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}outputEdges(a,u){let c=this.bb.__offset(this.bb_pos,8);return c?(u||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+c)+a*12,this.bb):null}outputEdgesLength(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__vector_len(this.bb_pos+a):0}static startNodeEdge(a){a.startObject(3)}static addNodeIndex(a,u){a.addFieldInt32(0,u,0)}static addInputEdges(a,u){a.addFieldOffset(1,u,0)}static startInputEdgesVector(a,u){a.startVector(12,u,4)}static addOutputEdges(a,u){a.addFieldOffset(2,u,0)}static startOutputEdgesVector(a,u){a.startVector(12,u,4)}static endNodeEdge(a){return a.endObject()}static createNodeEdge(a,u,c,g){return i.startNodeEdge(a),i.addNodeIndex(a,u),i.addInputEdges(a,c),i.addOutputEdges(a,g),i.endNodeEdge(a)}}o.NodeEdge=i})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{class i{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsNode(a,u){return(u||new i).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsNode(a,u){return a.setPosition(a.position()+G.SIZE_PREFIX_LENGTH),(u||new i).__init(a.readInt32(a.position())+a.position(),a)}name(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,a):null}docString(a){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,a):null}domain(a){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.__string(this.bb_pos+u,a):null}sinceVersion(){let a=this.bb.__offset(this.bb_pos,10);return a?this.bb.readInt32(this.bb_pos+a):0}index(){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.readUint32(this.bb_pos+a):0}opType(a){let u=this.bb.__offset(this.bb_pos,14);return u?this.bb.__string(this.bb_pos+u,a):null}type(){let a=this.bb.__offset(this.bb_pos,16);return a?this.bb.readInt32(this.bb_pos+a):0}executionProviderType(a){let u=this.bb.__offset(this.bb_pos,18);return u?this.bb.__string(this.bb_pos+u,a):null}inputs(a,u){let c=this.bb.__offset(this.bb_pos,20);return c?this.bb.__string(this.bb.__vector(this.bb_pos+c)+a*4,u):null}inputsLength(){let a=this.bb.__offset(this.bb_pos,20);return a?this.bb.__vector_len(this.bb_pos+a):0}outputs(a,u){let c=this.bb.__offset(this.bb_pos,22);return c?this.bb.__string(this.bb.__vector(this.bb_pos+c)+a*4,u):null}outputsLength(){let a=this.bb.__offset(this.bb_pos,22);return a?this.bb.__vector_len(this.bb_pos+a):0}attributes(a,u){let c=this.bb.__offset(this.bb_pos,24);return c?(u||new e.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+c)+a*4),this.bb):null}attributesLength(){let a=this.bb.__offset(this.bb_pos,24);return a?this.bb.__vector_len(this.bb_pos+a):0}inputArgCounts(a){let u=this.bb.__offset(this.bb_pos,26);return u?this.bb.readInt32(this.bb.__vector(this.bb_pos+u)+a*4):0}inputArgCountsLength(){let a=this.bb.__offset(this.bb_pos,26);return a?this.bb.__vector_len(this.bb_pos+a):0}inputArgCountsArray(){let a=this.bb.__offset(this.bb_pos,26);return a?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+a),this.bb.__vector_len(this.bb_pos+a)):null}implicitInputs(a,u){let c=this.bb.__offset(this.bb_pos,28);return c?this.bb.__string(this.bb.__vector(this.bb_pos+c)+a*4,u):null}implicitInputsLength(){let a=this.bb.__offset(this.bb_pos,28);return a?this.bb.__vector_len(this.bb_pos+a):0}static startNode(a){a.startObject(13)}static addName(a,u){a.addFieldOffset(0,u,0)}static addDocString(a,u){a.addFieldOffset(1,u,0)}static addDomain(a,u){a.addFieldOffset(2,u,0)}static addSinceVersion(a,u){a.addFieldInt32(3,u,0)}static addIndex(a,u){a.addFieldInt32(4,u,0)}static addOpType(a,u){a.addFieldOffset(5,u,0)}static addType(a,u){a.addFieldInt32(6,u,0)}static addExecutionProviderType(a,u){a.addFieldOffset(7,u,0)}static addInputs(a,u){a.addFieldOffset(8,u,0)}static createInputsVector(a,u){a.startVector(4,u.length,4);for(let c=u.length-1;c>=0;c--)a.addOffset(u[c]);return a.endVector()}static startInputsVector(a,u){a.startVector(4,u,4)}static addOutputs(a,u){a.addFieldOffset(9,u,0)}static createOutputsVector(a,u){a.startVector(4,u.length,4);for(let c=u.length-1;c>=0;c--)a.addOffset(u[c]);return a.endVector()}static startOutputsVector(a,u){a.startVector(4,u,4)}static addAttributes(a,u){a.addFieldOffset(10,u,0)}static createAttributesVector(a,u){a.startVector(4,u.length,4);for(let c=u.length-1;c>=0;c--)a.addOffset(u[c]);return a.endVector()}static startAttributesVector(a,u){a.startVector(4,u,4)}static addInputArgCounts(a,u){a.addFieldOffset(11,u,0)}static createInputArgCountsVector(a,u){a.startVector(4,u.length,4);for(let c=u.length-1;c>=0;c--)a.addInt32(u[c]);return a.endVector()}static startInputArgCountsVector(a,u){a.startVector(4,u,4)}static addImplicitInputs(a,u){a.addFieldOffset(12,u,0)}static createImplicitInputsVector(a,u){a.startVector(4,u.length,4);for(let c=u.length-1;c>=0;c--)a.addOffset(u[c]);return a.endVector()}static startImplicitInputsVector(a,u){a.startVector(4,u,4)}static endNode(a){return a.endObject()}static createNode(a,u,c,g,v,T,S,O,I,k,M,F,j,Y){return i.startNode(a),i.addName(a,u),i.addDocString(a,c),i.addDomain(a,g),i.addSinceVersion(a,v),i.addIndex(a,T),i.addOpType(a,S),i.addType(a,O),i.addExecutionProviderType(a,I),i.addInputs(a,k),i.addOutputs(a,M),i.addAttributes(a,F),i.addInputArgCounts(a,j),i.addImplicitInputs(a,Y),i.endNode(a)}}o.Node=i})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{class i{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsValueInfo(a,u){return(u||new i).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsValueInfo(a,u){return a.setPosition(a.position()+G.SIZE_PREFIX_LENGTH),(u||new i).__init(a.readInt32(a.position())+a.position(),a)}name(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,a):null}docString(a){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,a):null}type(a){let u=this.bb.__offset(this.bb_pos,8);return u?(a||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startValueInfo(a){a.startObject(3)}static addName(a,u){a.addFieldOffset(0,u,0)}static addDocString(a,u){a.addFieldOffset(1,u,0)}static addType(a,u){a.addFieldOffset(2,u,0)}static endValueInfo(a){return a.endObject()}static createValueInfo(a,u,c,g){return i.startValueInfo(a),i.addName(a,u),i.addDocString(a,c),i.addType(a,g),i.endValueInfo(a)}}o.ValueInfo=i})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{class i{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsTypeInfo(a,u){return(u||new i).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsTypeInfo(a,u){return a.setPosition(a.position()+G.SIZE_PREFIX_LENGTH),(u||new i).__init(a.readInt32(a.position())+a.position(),a)}denotation(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,a):null}valueType(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.readUint8(this.bb_pos+a):0}value(a){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.__union(a,this.bb_pos+u):null}static startTypeInfo(a){a.startObject(3)}static addDenotation(a,u){a.addFieldOffset(0,u,0)}static addValueType(a,u){a.addFieldInt8(1,u,0)}static addValue(a,u){a.addFieldOffset(2,u,0)}static endTypeInfo(a){return a.endObject()}static createTypeInfo(a,u,c,g){return i.startTypeInfo(a),i.addDenotation(a,u),i.addValueType(a,c),i.addValue(a,g),i.endTypeInfo(a)}}o.TypeInfo=i})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{class i{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsOperatorSetId(a,u){return(u||new i).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsOperatorSetId(a,u){return a.setPosition(a.position()+G.SIZE_PREFIX_LENGTH),(u||new i).__init(a.readInt32(a.position())+a.position(),a)}domain(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,a):null}version(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}static startOperatorSetId(a){a.startObject(2)}static addDomain(a,u){a.addFieldOffset(0,u,0)}static addVersion(a,u){a.addFieldInt64(1,u,a.createLong(0,0))}static endOperatorSetId(a){return a.endObject()}static createOperatorSetId(a,u,c){return i.startOperatorSetId(a),i.addDomain(a,u),i.addVersion(a,c),i.endOperatorSetId(a)}}o.OperatorSetId=i})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{class i{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsTensor(a,u){return(u||new i).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsTensor(a,u){return a.setPosition(a.position()+G.SIZE_PREFIX_LENGTH),(u||new i).__init(a.readInt32(a.position())+a.position(),a)}name(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,a):null}docString(a){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,a):null}dims(a){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.readInt64(this.bb.__vector(this.bb_pos+u)+a*8):this.bb.createLong(0,0)}dimsLength(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__vector_len(this.bb_pos+a):0}dataType(){let a=this.bb.__offset(this.bb_pos,10);return a?this.bb.readInt32(this.bb_pos+a):0}rawData(a){let u=this.bb.__offset(this.bb_pos,12);return u?this.bb.readUint8(this.bb.__vector(this.bb_pos+u)+a):0}rawDataLength(){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.__vector_len(this.bb_pos+a):0}rawDataArray(){let a=this.bb.__offset(this.bb_pos,12);return a?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+a),this.bb.__vector_len(this.bb_pos+a)):null}stringData(a,u){let c=this.bb.__offset(this.bb_pos,14);return c?this.bb.__string(this.bb.__vector(this.bb_pos+c)+a*4,u):null}stringDataLength(){let a=this.bb.__offset(this.bb_pos,14);return a?this.bb.__vector_len(this.bb_pos+a):0}static startTensor(a){a.startObject(6)}static addName(a,u){a.addFieldOffset(0,u,0)}static addDocString(a,u){a.addFieldOffset(1,u,0)}static addDims(a,u){a.addFieldOffset(2,u,0)}static createDimsVector(a,u){a.startVector(8,u.length,8);for(let c=u.length-1;c>=0;c--)a.addInt64(u[c]);return a.endVector()}static startDimsVector(a,u){a.startVector(8,u,8)}static addDataType(a,u){a.addFieldInt32(3,u,0)}static addRawData(a,u){a.addFieldOffset(4,u,0)}static createRawDataVector(a,u){a.startVector(1,u.length,1);for(let c=u.length-1;c>=0;c--)a.addInt8(u[c]);return a.endVector()}static startRawDataVector(a,u){a.startVector(1,u,1)}static addStringData(a,u){a.addFieldOffset(5,u,0)}static createStringDataVector(a,u){a.startVector(4,u.length,4);for(let c=u.length-1;c>=0;c--)a.addOffset(u[c]);return a.endVector()}static startStringDataVector(a,u){a.startVector(4,u,4)}static endTensor(a){return a.endObject()}static createTensor(a,u,c,g,v,T,S){return i.startTensor(a),i.addName(a,u),i.addDocString(a,c),i.addDims(a,g),i.addDataType(a,v),i.addRawData(a,T),i.addStringData(a,S),i.endTensor(a)}}o.Tensor=i})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{class i{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsSparseTensor(a,u){return(u||new i).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsSparseTensor(a,u){return a.setPosition(a.position()+G.SIZE_PREFIX_LENGTH),(u||new i).__init(a.readInt32(a.position())+a.position(),a)}values(a){let u=this.bb.__offset(this.bb_pos,4);return u?(a||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}indices(a){let u=this.bb.__offset(this.bb_pos,6);return u?(a||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}dims(a){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.readInt64(this.bb.__vector(this.bb_pos+u)+a*8):this.bb.createLong(0,0)}dimsLength(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__vector_len(this.bb_pos+a):0}static startSparseTensor(a){a.startObject(3)}static addValues(a,u){a.addFieldOffset(0,u,0)}static addIndices(a,u){a.addFieldOffset(1,u,0)}static addDims(a,u){a.addFieldOffset(2,u,0)}static createDimsVector(a,u){a.startVector(8,u.length,8);for(let c=u.length-1;c>=0;c--)a.addInt64(u[c]);return a.endVector()}static startDimsVector(a,u){a.startVector(8,u,8)}static endSparseTensor(a){return a.endObject()}static createSparseTensor(a,u,c,g){return i.startSparseTensor(a),i.addValues(a,u),i.addIndices(a,c),i.addDims(a,g),i.endSparseTensor(a)}}o.SparseTensor=i})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{class i{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsAttribute(a,u){return(u||new i).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsAttribute(a,u){return a.setPosition(a.position()+G.SIZE_PREFIX_LENGTH),(u||new i).__init(a.readInt32(a.position())+a.position(),a)}name(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,a):null}docString(a){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,a):null}type(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.readInt32(this.bb_pos+a):0}f(){let a=this.bb.__offset(this.bb_pos,10);return a?this.bb.readFloat32(this.bb_pos+a):0}i(){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}s(a){let u=this.bb.__offset(this.bb_pos,14);return u?this.bb.__string(this.bb_pos+u,a):null}t(a){let u=this.bb.__offset(this.bb_pos,16);return u?(a||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}g(a){let u=this.bb.__offset(this.bb_pos,18);return u?(a||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}floats(a){let u=this.bb.__offset(this.bb_pos,20);return u?this.bb.readFloat32(this.bb.__vector(this.bb_pos+u)+a*4):0}floatsLength(){let a=this.bb.__offset(this.bb_pos,20);return a?this.bb.__vector_len(this.bb_pos+a):0}floatsArray(){let a=this.bb.__offset(this.bb_pos,20);return a?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+a),this.bb.__vector_len(this.bb_pos+a)):null}ints(a){let u=this.bb.__offset(this.bb_pos,22);return u?this.bb.readInt64(this.bb.__vector(this.bb_pos+u)+a*8):this.bb.createLong(0,0)}intsLength(){let a=this.bb.__offset(this.bb_pos,22);return a?this.bb.__vector_len(this.bb_pos+a):0}strings(a,u){let c=this.bb.__offset(this.bb_pos,24);return c?this.bb.__string(this.bb.__vector(this.bb_pos+c)+a*4,u):null}stringsLength(){let a=this.bb.__offset(this.bb_pos,24);return a?this.bb.__vector_len(this.bb_pos+a):0}tensors(a,u){let c=this.bb.__offset(this.bb_pos,26);return c?(u||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+c)+a*4),this.bb):null}tensorsLength(){let a=this.bb.__offset(this.bb_pos,26);return a?this.bb.__vector_len(this.bb_pos+a):0}graphs(a,u){let c=this.bb.__offset(this.bb_pos,28);return c?(u||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+c)+a*4),this.bb):null}graphsLength(){let a=this.bb.__offset(this.bb_pos,28);return a?this.bb.__vector_len(this.bb_pos+a):0}static startAttribute(a){a.startObject(13)}static addName(a,u){a.addFieldOffset(0,u,0)}static addDocString(a,u){a.addFieldOffset(1,u,0)}static addType(a,u){a.addFieldInt32(2,u,0)}static addF(a,u){a.addFieldFloat32(3,u,0)}static addI(a,u){a.addFieldInt64(4,u,a.createLong(0,0))}static addS(a,u){a.addFieldOffset(5,u,0)}static addT(a,u){a.addFieldOffset(6,u,0)}static addG(a,u){a.addFieldOffset(7,u,0)}static addFloats(a,u){a.addFieldOffset(8,u,0)}static createFloatsVector(a,u){a.startVector(4,u.length,4);for(let c=u.length-1;c>=0;c--)a.addFloat32(u[c]);return a.endVector()}static startFloatsVector(a,u){a.startVector(4,u,4)}static addInts(a,u){a.addFieldOffset(9,u,0)}static createIntsVector(a,u){a.startVector(8,u.length,8);for(let c=u.length-1;c>=0;c--)a.addInt64(u[c]);return a.endVector()}static startIntsVector(a,u){a.startVector(8,u,8)}static addStrings(a,u){a.addFieldOffset(10,u,0)}static createStringsVector(a,u){a.startVector(4,u.length,4);for(let c=u.length-1;c>=0;c--)a.addOffset(u[c]);return a.endVector()}static startStringsVector(a,u){a.startVector(4,u,4)}static addTensors(a,u){a.addFieldOffset(11,u,0)}static createTensorsVector(a,u){a.startVector(4,u.length,4);for(let c=u.length-1;c>=0;c--)a.addOffset(u[c]);return a.endVector()}static startTensorsVector(a,u){a.startVector(4,u,4)}static addGraphs(a,u){a.addFieldOffset(12,u,0)}static createGraphsVector(a,u){a.startVector(4,u.length,4);for(let c=u.length-1;c>=0;c--)a.addOffset(u[c]);return a.endVector()}static startGraphsVector(a,u){a.startVector(4,u,4)}static endAttribute(a){return a.endObject()}static createAttribute(a,u,c,g,v,T,S,O,I,k,M,F,j,Y){return i.startAttribute(a),i.addName(a,u),i.addDocString(a,c),i.addType(a,g),i.addF(a,v),i.addI(a,T),i.addS(a,S),i.addT(a,O),i.addG(a,I),i.addFloats(a,k),i.addInts(a,M),i.addStrings(a,F),i.addTensors(a,j),i.addGraphs(a,Y),i.endAttribute(a)}}o.Attribute=i})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{class i{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsGraph(a,u){return(u||new i).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsGraph(a,u){return a.setPosition(a.position()+G.SIZE_PREFIX_LENGTH),(u||new i).__init(a.readInt32(a.position())+a.position(),a)}initializers(a,u){let c=this.bb.__offset(this.bb_pos,4);return c?(u||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+c)+a*4),this.bb):null}initializersLength(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__vector_len(this.bb_pos+a):0}nodeArgs(a,u){let c=this.bb.__offset(this.bb_pos,6);return c?(u||new e.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+c)+a*4),this.bb):null}nodeArgsLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}nodes(a,u){let c=this.bb.__offset(this.bb_pos,8);return c?(u||new e.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+c)+a*4),this.bb):null}nodesLength(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__vector_len(this.bb_pos+a):0}maxNodeIndex(){let a=this.bb.__offset(this.bb_pos,10);return a?this.bb.readUint32(this.bb_pos+a):0}nodeEdges(a,u){let c=this.bb.__offset(this.bb_pos,12);return c?(u||new e.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+c)+a*4),this.bb):null}nodeEdgesLength(){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.__vector_len(this.bb_pos+a):0}inputs(a,u){let c=this.bb.__offset(this.bb_pos,14);return c?this.bb.__string(this.bb.__vector(this.bb_pos+c)+a*4,u):null}inputsLength(){let a=this.bb.__offset(this.bb_pos,14);return a?this.bb.__vector_len(this.bb_pos+a):0}outputs(a,u){let c=this.bb.__offset(this.bb_pos,16);return c?this.bb.__string(this.bb.__vector(this.bb_pos+c)+a*4,u):null}outputsLength(){let a=this.bb.__offset(this.bb_pos,16);return a?this.bb.__vector_len(this.bb_pos+a):0}sparseInitializers(a,u){let c=this.bb.__offset(this.bb_pos,18);return c?(u||new e.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+c)+a*4),this.bb):null}sparseInitializersLength(){let a=this.bb.__offset(this.bb_pos,18);return a?this.bb.__vector_len(this.bb_pos+a):0}static startGraph(a){a.startObject(8)}static addInitializers(a,u){a.addFieldOffset(0,u,0)}static createInitializersVector(a,u){a.startVector(4,u.length,4);for(let c=u.length-1;c>=0;c--)a.addOffset(u[c]);return a.endVector()}static startInitializersVector(a,u){a.startVector(4,u,4)}static addNodeArgs(a,u){a.addFieldOffset(1,u,0)}static createNodeArgsVector(a,u){a.startVector(4,u.length,4);for(let c=u.length-1;c>=0;c--)a.addOffset(u[c]);return a.endVector()}static startNodeArgsVector(a,u){a.startVector(4,u,4)}static addNodes(a,u){a.addFieldOffset(2,u,0)}static createNodesVector(a,u){a.startVector(4,u.length,4);for(let c=u.length-1;c>=0;c--)a.addOffset(u[c]);return a.endVector()}static startNodesVector(a,u){a.startVector(4,u,4)}static addMaxNodeIndex(a,u){a.addFieldInt32(3,u,0)}static addNodeEdges(a,u){a.addFieldOffset(4,u,0)}static createNodeEdgesVector(a,u){a.startVector(4,u.length,4);for(let c=u.length-1;c>=0;c--)a.addOffset(u[c]);return a.endVector()}static startNodeEdgesVector(a,u){a.startVector(4,u,4)}static addInputs(a,u){a.addFieldOffset(5,u,0)}static createInputsVector(a,u){a.startVector(4,u.length,4);for(let c=u.length-1;c>=0;c--)a.addOffset(u[c]);return a.endVector()}static startInputsVector(a,u){a.startVector(4,u,4)}static addOutputs(a,u){a.addFieldOffset(6,u,0)}static createOutputsVector(a,u){a.startVector(4,u.length,4);for(let c=u.length-1;c>=0;c--)a.addOffset(u[c]);return a.endVector()}static startOutputsVector(a,u){a.startVector(4,u,4)}static addSparseInitializers(a,u){a.addFieldOffset(7,u,0)}static createSparseInitializersVector(a,u){a.startVector(4,u.length,4);for(let c=u.length-1;c>=0;c--)a.addOffset(u[c]);return a.endVector()}static startSparseInitializersVector(a,u){a.startVector(4,u,4)}static endGraph(a){return a.endObject()}static createGraph(a,u,c,g,v,T,S,O,I){return i.startGraph(a),i.addInitializers(a,u),i.addNodeArgs(a,c),i.addNodes(a,g),i.addMaxNodeIndex(a,v),i.addNodeEdges(a,T),i.addInputs(a,S),i.addOutputs(a,O),i.addSparseInitializers(a,I),i.endGraph(a)}}o.Graph=i})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{class i{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsModel(a,u){return(u||new i).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsModel(a,u){return a.setPosition(a.position()+G.SIZE_PREFIX_LENGTH),(u||new i).__init(a.readInt32(a.position())+a.position(),a)}irVersion(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}opsetImport(a,u){let c=this.bb.__offset(this.bb_pos,6);return c?(u||new e.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+c)+a*4),this.bb):null}opsetImportLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}producerName(a){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.__string(this.bb_pos+u,a):null}producerVersion(a){let u=this.bb.__offset(this.bb_pos,10);return u?this.bb.__string(this.bb_pos+u,a):null}domain(a){let u=this.bb.__offset(this.bb_pos,12);return u?this.bb.__string(this.bb_pos+u,a):null}modelVersion(){let a=this.bb.__offset(this.bb_pos,14);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}docString(a){let u=this.bb.__offset(this.bb_pos,16);return u?this.bb.__string(this.bb_pos+u,a):null}graph(a){let u=this.bb.__offset(this.bb_pos,18);return u?(a||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}graphDocString(a){let u=this.bb.__offset(this.bb_pos,20);return u?this.bb.__string(this.bb_pos+u,a):null}static startModel(a){a.startObject(9)}static addIrVersion(a,u){a.addFieldInt64(0,u,a.createLong(0,0))}static addOpsetImport(a,u){a.addFieldOffset(1,u,0)}static createOpsetImportVector(a,u){a.startVector(4,u.length,4);for(let c=u.length-1;c>=0;c--)a.addOffset(u[c]);return a.endVector()}static startOpsetImportVector(a,u){a.startVector(4,u,4)}static addProducerName(a,u){a.addFieldOffset(2,u,0)}static addProducerVersion(a,u){a.addFieldOffset(3,u,0)}static addDomain(a,u){a.addFieldOffset(4,u,0)}static addModelVersion(a,u){a.addFieldInt64(5,u,a.createLong(0,0))}static addDocString(a,u){a.addFieldOffset(6,u,0)}static addGraph(a,u){a.addFieldOffset(7,u,0)}static addGraphDocString(a,u){a.addFieldOffset(8,u,0)}static endModel(a){return a.endObject()}static createModel(a,u,c,g,v,T,S,O,I,k){return i.startModel(a),i.addIrVersion(a,u),i.addOpsetImport(a,c),i.addProducerName(a,g),i.addProducerVersion(a,v),i.addDomain(a,T),i.addModelVersion(a,S),i.addDocString(a,O),i.addGraph(a,I),i.addGraphDocString(a,k),i.endModel(a)}}o.Model=i})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{class i{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsKernelCreateInfos(a,u){return(u||new i).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsKernelCreateInfos(a,u){return a.setPosition(a.position()+G.SIZE_PREFIX_LENGTH),(u||new i).__init(a.readInt32(a.position())+a.position(),a)}nodeIndices(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.readUint32(this.bb.__vector(this.bb_pos+u)+a*4):0}nodeIndicesLength(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__vector_len(this.bb_pos+a):0}nodeIndicesArray(){let a=this.bb.__offset(this.bb_pos,4);return a?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+a),this.bb.__vector_len(this.bb_pos+a)):null}kernelDefHashes(a){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.readUint64(this.bb.__vector(this.bb_pos+u)+a*8):this.bb.createLong(0,0)}kernelDefHashesLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}static startKernelCreateInfos(a){a.startObject(2)}static addNodeIndices(a,u){a.addFieldOffset(0,u,0)}static createNodeIndicesVector(a,u){a.startVector(4,u.length,4);for(let c=u.length-1;c>=0;c--)a.addInt32(u[c]);return a.endVector()}static startNodeIndicesVector(a,u){a.startVector(4,u,4)}static addKernelDefHashes(a,u){a.addFieldOffset(1,u,0)}static createKernelDefHashesVector(a,u){a.startVector(8,u.length,8);for(let c=u.length-1;c>=0;c--)a.addInt64(u[c]);return a.endVector()}static startKernelDefHashesVector(a,u){a.startVector(8,u,8)}static endKernelCreateInfos(a){return a.endObject()}static createKernelCreateInfos(a,u,c){return i.startKernelCreateInfos(a),i.addNodeIndices(a,u),i.addKernelDefHashes(a,c),i.endKernelCreateInfos(a)}}o.KernelCreateInfos=i})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{class i{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsSubGraphSessionState(a,u){return(u||new i).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsSubGraphSessionState(a,u){return a.setPosition(a.position()+G.SIZE_PREFIX_LENGTH),(u||new i).__init(a.readInt32(a.position())+a.position(),a)}graphId(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,a):null}sessionState(a){let u=this.bb.__offset(this.bb_pos,6);return u?(a||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startSubGraphSessionState(a){a.startObject(2)}static addGraphId(a,u){a.addFieldOffset(0,u,0)}static addSessionState(a,u){a.addFieldOffset(1,u,0)}static endSubGraphSessionState(a){let u=a.endObject();return a.requiredField(u,4),u}static createSubGraphSessionState(a,u,c){return i.startSubGraphSessionState(a),i.addGraphId(a,u),i.addSessionState(a,c),i.endSubGraphSessionState(a)}}o.SubGraphSessionState=i})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{class i{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsSessionState(a,u){return(u||new i).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsSessionState(a,u){return a.setPosition(a.position()+G.SIZE_PREFIX_LENGTH),(u||new i).__init(a.readInt32(a.position())+a.position(),a)}kernels(a){let u=this.bb.__offset(this.bb_pos,4);return u?(a||new e.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}subGraphSessionStates(a,u){let c=this.bb.__offset(this.bb_pos,6);return c?(u||new e.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+c)+a*4),this.bb):null}subGraphSessionStatesLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}static startSessionState(a){a.startObject(2)}static addKernels(a,u){a.addFieldOffset(0,u,0)}static addSubGraphSessionStates(a,u){a.addFieldOffset(1,u,0)}static createSubGraphSessionStatesVector(a,u){a.startVector(4,u.length,4);for(let c=u.length-1;c>=0;c--)a.addOffset(u[c]);return a.endVector()}static startSubGraphSessionStatesVector(a,u){a.startVector(4,u,4)}static endSessionState(a){return a.endObject()}static createSessionState(a,u,c){return i.startSessionState(a),i.addKernels(a,u),i.addSubGraphSessionStates(a,c),i.endSessionState(a)}}o.SessionState=i})(r=t.fbs||={})})(n=e.experimental||={})})(be||={});(e=>{let n;(t=>{let r;(o=>{class i{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsInferenceSession(a,u){return(u||new i).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsInferenceSession(a,u){return a.setPosition(a.position()+G.SIZE_PREFIX_LENGTH),(u||new i).__init(a.readInt32(a.position())+a.position(),a)}static bufferHasIdentifier(a){return a.__has_identifier("ORTM")}ortVersion(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,a):null}model(a){let u=this.bb.__offset(this.bb_pos,6);return u?(a||new e.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}sessionState(a){let u=this.bb.__offset(this.bb_pos,8);return u?(a||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startInferenceSession(a){a.startObject(3)}static addOrtVersion(a,u){a.addFieldOffset(0,u,0)}static addModel(a,u){a.addFieldOffset(1,u,0)}static addSessionState(a,u){a.addFieldOffset(2,u,0)}static endInferenceSession(a){return a.endObject()}static finishInferenceSessionBuffer(a,u){a.finish(u,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(a,u){a.finish(u,"ORTM",!0)}static createInferenceSession(a,u,c,g){return i.startInferenceSession(a),i.addOrtVersion(a,u),i.addModel(a,c),i.addSessionState(a,g),i.endInferenceSession(a)}}o.InferenceSession=i})(r=t.fbs||={})})(n=e.experimental||={})})(be||={})});var Gf=et((dC,jf)=>{"use strict";jf.exports=k1;function k1(n,e){for(var r=new Array(arguments.length-1),t=0,i=2,o=!0;i<arguments.length;)r[t++]=arguments[i++];return new Promise(function(a,u){r[t]=function(g){if(o)if(o=!1,g)u(g);else{for(var v=new Array(arguments.length-1),T=0;T<v.length;)v[T++]=arguments[T];a.apply(null,v)}};try{n.apply(e||null,r)}catch(c){o&&(o=!1,u(c))}})}});var Hf=et(Uf=>{"use strict";var oa=Uf;oa.length=function(e){var r=e.length;if(!r)return 0;for(var t=0;--r%4>1&&e.charAt(r)==="=";)++t;return Math.ceil(e.length*3)/4-t};var Kn=new Array(64),Vf=new Array(123);for(dr=0;dr<64;)Vf[Kn[dr]=dr<26?dr+65:dr<52?dr+71:dr<62?dr-4:dr-59|43]=dr++;var dr;oa.encode=function(e,r,t){for(var i=null,o=[],s=0,a=0,u;r<t;){var c=e[r++];switch(a){case 0:o[s++]=Kn[c>>2],u=(c&3)<<4,a=1;break;case 1:o[s++]=Kn[u|c>>4],u=(c&15)<<2,a=2;break;case 2:o[s++]=Kn[u|c>>6],o[s++]=Kn[c&63],a=0;break}s>8191&&((i||(i=[])).push(String.fromCharCode.apply(String,o)),s=0)}return a&&(o[s++]=Kn[u],o[s++]=61,a===1&&(o[s++]=61)),i?(s&&i.push(String.fromCharCode.apply(String,o.slice(0,s))),i.join("")):String.fromCharCode.apply(String,o.slice(0,s))};var Wf="invalid encoding";oa.decode=function(e,r,t){for(var i=t,o=0,s,a=0;a<e.length;){var u=e.charCodeAt(a++);if(u===61&&o>1)break;if((u=Vf[u])===void 0)throw Error(Wf);switch(o){case 0:s=u,o=1;break;case 1:r[t++]=s<<2|(u&48)>>4,s=u,o=2;break;case 2:r[t++]=(s&15)<<4|(u&60)>>2,s=u,o=3;break;case 3:r[t++]=(s&3)<<6|u,o=0;break}}if(o===1)throw Error(Wf);return t-i};oa.test=function(e){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e)}});var Kf=et((hC,qf)=>{"use strict";qf.exports=aa;function aa(){this._listeners={}}aa.prototype.on=function(e,r,t){return(this._listeners[e]||(this._listeners[e]=[])).push({fn:r,ctx:t||this}),this};aa.prototype.off=function(e,r){if(e===void 0)this._listeners={};else if(r===void 0)this._listeners[e]=[];else for(var t=this._listeners[e],i=0;i<t.length;)t[i].fn===r?t.splice(i,1):++i;return this};aa.prototype.emit=function(e){var r=this._listeners[e];if(r){for(var t=[],i=1;i<arguments.length;)t.push(arguments[i++]);for(i=0;i<r.length;)r[i].fn.apply(r[i++].ctx,t)}return this}});var td=et((mC,ed)=>{"use strict";ed.exports=Xf(Xf);function Xf(n){return typeof Float32Array<"u"?function(){var e=new Float32Array([-0]),r=new Uint8Array(e.buffer),t=r[3]===128;function i(u,c,g){e[0]=u,c[g]=r[0],c[g+1]=r[1],c[g+2]=r[2],c[g+3]=r[3]}function o(u,c,g){e[0]=u,c[g]=r[3],c[g+1]=r[2],c[g+2]=r[1],c[g+3]=r[0]}n.writeFloatLE=t?i:o,n.writeFloatBE=t?o:i;function s(u,c){return r[0]=u[c],r[1]=u[c+1],r[2]=u[c+2],r[3]=u[c+3],e[0]}function a(u,c){return r[3]=u[c],r[2]=u[c+1],r[1]=u[c+2],r[0]=u[c+3],e[0]}n.readFloatLE=t?s:a,n.readFloatBE=t?a:s}():function(){function e(t,i,o,s){var a=i<0?1:0;if(a&&(i=-i),i===0)t(1/i>0?0:2147483648,o,s);else if(isNaN(i))t(2143289344,o,s);else if(i>34028234663852886e22)t((a<<31|2139095040)>>>0,o,s);else if(i<11754943508222875e-54)t((a<<31|Math.round(i/1401298464324817e-60))>>>0,o,s);else{var u=Math.floor(Math.log(i)/Math.LN2),c=Math.round(i*Math.pow(2,-u)*8388608)&8388607;t((a<<31|u+127<<23|c)>>>0,o,s)}}n.writeFloatLE=e.bind(null,Yf),n.writeFloatBE=e.bind(null,Jf);function r(t,i,o){var s=t(i,o),a=(s>>31)*2+1,u=s>>>23&255,c=s&8388607;return u===255?c?NaN:a*(1/0):u===0?a*1401298464324817e-60*c:a*Math.pow(2,u-150)*(c+8388608)}n.readFloatLE=r.bind(null,Zf),n.readFloatBE=r.bind(null,Qf)}(),typeof Float64Array<"u"?function(){var e=new Float64Array([-0]),r=new Uint8Array(e.buffer),t=r[7]===128;function i(u,c,g){e[0]=u,c[g]=r[0],c[g+1]=r[1],c[g+2]=r[2],c[g+3]=r[3],c[g+4]=r[4],c[g+5]=r[5],c[g+6]=r[6],c[g+7]=r[7]}function o(u,c,g){e[0]=u,c[g]=r[7],c[g+1]=r[6],c[g+2]=r[5],c[g+3]=r[4],c[g+4]=r[3],c[g+5]=r[2],c[g+6]=r[1],c[g+7]=r[0]}n.writeDoubleLE=t?i:o,n.writeDoubleBE=t?o:i;function s(u,c){return r[0]=u[c],r[1]=u[c+1],r[2]=u[c+2],r[3]=u[c+3],r[4]=u[c+4],r[5]=u[c+5],r[6]=u[c+6],r[7]=u[c+7],e[0]}function a(u,c){return r[7]=u[c],r[6]=u[c+1],r[5]=u[c+2],r[4]=u[c+3],r[3]=u[c+4],r[2]=u[c+5],r[1]=u[c+6],r[0]=u[c+7],e[0]}n.readDoubleLE=t?s:a,n.readDoubleBE=t?a:s}():function(){function e(t,i,o,s,a,u){var c=s<0?1:0;if(c&&(s=-s),s===0)t(0,a,u+i),t(1/s>0?0:2147483648,a,u+o);else if(isNaN(s))t(0,a,u+i),t(2146959360,a,u+o);else if(s>17976931348623157e292)t(0,a,u+i),t((c<<31|2146435072)>>>0,a,u+o);else{var g;if(s<22250738585072014e-324)g=s/5e-324,t(g>>>0,a,u+i),t((c<<31|g/4294967296)>>>0,a,u+o);else{var v=Math.floor(Math.log(s)/Math.LN2);v===1024&&(v=1023),g=s*Math.pow(2,-v),t(g*4503599627370496>>>0,a,u+i),t((c<<31|v+1023<<20|g*1048576&1048575)>>>0,a,u+o)}}}n.writeDoubleLE=e.bind(null,Yf,0,4),n.writeDoubleBE=e.bind(null,Jf,4,0);function r(t,i,o,s,a){var u=t(s,a+i),c=t(s,a+o),g=(c>>31)*2+1,v=c>>>20&2047,T=4294967296*(c&1048575)+u;return v===2047?T?NaN:g*(1/0):v===0?g*5e-324*T:g*Math.pow(2,v-1075)*(T+4503599627370496)}n.readDoubleLE=r.bind(null,Zf,0,4),n.readDoubleBE=r.bind(null,Qf,4,0)}(),n}function Yf(n,e,r){e[r]=n&255,e[r+1]=n>>>8&255,e[r+2]=n>>>16&255,e[r+3]=n>>>24}function Jf(n,e,r){e[r]=n>>>24,e[r+1]=n>>>16&255,e[r+2]=n>>>8&255,e[r+3]=n&255}function Zf(n,e){return(n[e]|n[e+1]<<8|n[e+2]<<16|n[e+3]<<24)>>>0}function Qf(n,e){return(n[e]<<24|n[e+1]<<16|n[e+2]<<8|n[e+3])>>>0}});var rd=et((exports,module)=>{"use strict";module.exports=inquire;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(n){}return null}});var id=et(nd=>{"use strict";var Cs=nd;Cs.length=function(e){for(var r=0,t=0,i=0;i<e.length;++i)t=e.charCodeAt(i),t<128?r+=1:t<2048?r+=2:(t&64512)===55296&&(e.charCodeAt(i+1)&64512)===56320?(++i,r+=4):r+=3;return r};Cs.read=function(e,r,t){var i=t-r;if(i<1)return"";for(var o=null,s=[],a=0,u;r<t;)u=e[r++],u<128?s[a++]=u:u>191&&u<224?s[a++]=(u&31)<<6|e[r++]&63:u>239&&u<365?(u=((u&7)<<18|(e[r++]&63)<<12|(e[r++]&63)<<6|e[r++]&63)-65536,s[a++]=55296+(u>>10),s[a++]=56320+(u&1023)):s[a++]=(u&15)<<12|(e[r++]&63)<<6|e[r++]&63,a>8191&&((o||(o=[])).push(String.fromCharCode.apply(String,s)),a=0);return o?(a&&o.push(String.fromCharCode.apply(String,s.slice(0,a))),o.join("")):String.fromCharCode.apply(String,s.slice(0,a))};Cs.write=function(e,r,t){for(var i=t,o,s,a=0;a<e.length;++a)o=e.charCodeAt(a),o<128?r[t++]=o:o<2048?(r[t++]=o>>6|192,r[t++]=o&63|128):(o&64512)===55296&&((s=e.charCodeAt(a+1))&64512)===56320?(o=65536+((o&1023)<<10)+(s&1023),++a,r[t++]=o>>18|240,r[t++]=o>>12&63|128,r[t++]=o>>6&63|128,r[t++]=o&63|128):(r[t++]=o>>12|224,r[t++]=o>>6&63|128,r[t++]=o&63|128);return t-i}});var ad=et((yC,od)=>{"use strict";od.exports=B1;function B1(n,e,r){var t=r||8192,i=t>>>1,o=null,s=t;return function(u){if(u<1||u>i)return n(u);s+u>t&&(o=n(t),s=0);var c=e.call(o,s,s+=u);return s&7&&(s=(s|7)+1),c}}});var ud=et((bC,sd)=>{"use strict";sd.exports=It;var Yi=Gr();function It(n,e){this.lo=n>>>0,this.hi=e>>>0}var dn=It.zero=new It(0,0);dn.toNumber=function(){return 0};dn.zzEncode=dn.zzDecode=function(){return this};dn.length=function(){return 1};var R1=It.zeroHash="\0\0\0\0\0\0\0\0";It.fromNumber=function(e){if(e===0)return dn;var r=e<0;r&&(e=-e);var t=e>>>0,i=(e-t)/4294967296>>>0;return r&&(i=~i>>>0,t=~t>>>0,++t>4294967295&&(t=0,++i>4294967295&&(i=0))),new It(t,i)};It.from=function(e){if(typeof e=="number")return It.fromNumber(e);if(Yi.isString(e))if(Yi.Long)e=Yi.Long.fromString(e);else return It.fromNumber(parseInt(e,10));return e.low||e.high?new It(e.low>>>0,e.high>>>0):dn};It.prototype.toNumber=function(e){if(!e&&this.hi>>>31){var r=~this.lo+1>>>0,t=~this.hi>>>0;return r||(t=t+1>>>0),-(r+t*4294967296)}return this.lo+this.hi*4294967296};It.prototype.toLong=function(e){return Yi.Long?new Yi.Long(this.lo|0,this.hi|0,!!e):{low:this.lo|0,high:this.hi|0,unsigned:!!e}};var jr=String.prototype.charCodeAt;It.fromHash=function(e){return e===R1?dn:new It((jr.call(e,0)|jr.call(e,1)<<8|jr.call(e,2)<<16|jr.call(e,3)<<24)>>>0,(jr.call(e,4)|jr.call(e,5)<<8|jr.call(e,6)<<16|jr.call(e,7)<<24)>>>0)};It.prototype.toHash=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)};It.prototype.zzEncode=function(){var e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this};It.prototype.zzDecode=function(){var e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this};It.prototype.length=function(){var e=this.lo,r=(this.lo>>>28|this.hi<<4)>>>0,t=this.hi>>>24;return t===0?r===0?e<16384?e<128?1:2:e<2097152?3:4:r<16384?r<128?5:6:r<2097152?7:8:t<128?9:10}});var Gr=et(As=>{"use strict";var we=As;we.asPromise=Gf();we.base64=Hf();we.EventEmitter=Kf();we.float=td();we.inquire=rd();we.utf8=id();we.pool=ad();we.LongBits=ud();we.isNode=!!(typeof global<"u"&&global&&global.process&&global.process.versions&&global.process.versions.node);we.global=we.isNode&&global||typeof window<"u"&&window||typeof self<"u"&&self||As;we.emptyArray=Object.freeze?Object.freeze([]):[];we.emptyObject=Object.freeze?Object.freeze({}):{};we.isInteger=Number.isInteger||function(e){return typeof e=="number"&&isFinite(e)&&Math.floor(e)===e};we.isString=function(e){return typeof e=="string"||e instanceof String};we.isObject=function(e){return e&&typeof e=="object"};we.isset=we.isSet=function(e,r){var t=e[r];return t!=null&&e.hasOwnProperty(r)?typeof t!="object"||(Array.isArray(t)?t.length:Object.keys(t).length)>0:!1};we.Buffer=function(){try{var n=we.inquire("buffer").Buffer;return n.prototype.utf8Write?n:null}catch{return null}}();we._Buffer_from=null;we._Buffer_allocUnsafe=null;we.newBuffer=function(e){return typeof e=="number"?we.Buffer?we._Buffer_allocUnsafe(e):new we.Array(e):we.Buffer?we._Buffer_from(e):typeof Uint8Array>"u"?e:new Uint8Array(e)};we.Array=typeof Uint8Array<"u"?Uint8Array:Array;we.Long=we.global.dcodeIO&&we.global.dcodeIO.Long||we.global.Long||we.inquire("long");we.key2Re=/^true|false|0|1$/;we.key32Re=/^-?(?:0|[1-9][0-9]*)$/;we.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;we.longToHash=function(e){return e?we.LongBits.from(e).toHash():we.LongBits.zeroHash};we.longFromHash=function(e,r){var t=we.LongBits.fromHash(e);return we.Long?we.Long.fromBits(t.lo,t.hi,r):t.toNumber(!!r)};function ld(n,e,r){for(var t=Object.keys(e),i=0;i<t.length;++i)(n[t[i]]===void 0||!r)&&(n[t[i]]=e[t[i]]);return n}we.merge=ld;we.lcFirst=function(e){return e.charAt(0).toLowerCase()+e.substring(1)};function cd(n){function e(r,t){if(!(this instanceof e))return new e(r,t);Object.defineProperty(this,"message",{get:function(){return r}}),Error.captureStackTrace?Error.captureStackTrace(this,e):Object.defineProperty(this,"stack",{value:new Error().stack||""}),t&&ld(this,t)}return e.prototype=Object.create(Error.prototype,{constructor:{value:e,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return n},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),e}we.newError=cd;we.ProtocolError=cd("ProtocolError");we.oneOfGetter=function(e){for(var r={},t=0;t<e.length;++t)r[e[t]]=1;return function(){for(var i=Object.keys(this),o=i.length-1;o>-1;--o)if(r[i[o]]===1&&this[i[o]]!==void 0&&this[i[o]]!==null)return i[o]}};we.oneOfSetter=function(e){return function(r){for(var t=0;t<e.length;++t)e[t]!==r&&delete this[e[t]]}};we.toJSONOptions={longs:String,enums:String,bytes:String,json:!0};we._configure=function(){var n=we.Buffer;if(!n){we._Buffer_from=we._Buffer_allocUnsafe=null;return}we._Buffer_from=n.from!==Uint8Array.from&&n.from||function(r,t){return new n(r,t)},we._Buffer_allocUnsafe=n.allocUnsafe||function(r){return new n(r)}}});var Rs=et((wC,hd)=>{"use strict";hd.exports=Ve;var Jt=Gr(),Os,sa=Jt.LongBits,fd=Jt.base64,dd=Jt.utf8;function Ji(n,e,r){this.fn=n,this.len=e,this.next=void 0,this.val=r}function Ps(){}function M1(n){this.head=n.head,this.tail=n.tail,this.len=n.len,this.next=n.states}function Ve(){this.len=0,this.head=new Ji(Ps,0,0),this.tail=this.head,this.states=null}var pd=function(){return Jt.Buffer?function(){return(Ve.create=function(){return new Os})()}:function(){return new Ve}};Ve.create=pd();Ve.alloc=function(e){return new Jt.Array(e)};Jt.Array!==Array&&(Ve.alloc=Jt.pool(Ve.alloc,Jt.Array.prototype.subarray));Ve.prototype._push=function(e,r,t){return this.tail=this.tail.next=new Ji(e,r,t),this.len+=r,this};function Ds(n,e,r){e[r]=n&255}function L1(n,e,r){for(;n>127;)e[r++]=n&127|128,n>>>=7;e[r]=n}function ks(n,e){this.len=n,this.next=void 0,this.val=e}ks.prototype=Object.create(Ji.prototype);ks.prototype.fn=L1;Ve.prototype.uint32=function(e){return this.len+=(this.tail=this.tail.next=new ks((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this};Ve.prototype.int32=function(e){return e<0?this._push(Bs,10,sa.fromNumber(e)):this.uint32(e)};Ve.prototype.sint32=function(e){return this.uint32((e<<1^e>>31)>>>0)};function Bs(n,e,r){for(;n.hi;)e[r++]=n.lo&127|128,n.lo=(n.lo>>>7|n.hi<<25)>>>0,n.hi>>>=7;for(;n.lo>127;)e[r++]=n.lo&127|128,n.lo=n.lo>>>7;e[r++]=n.lo}Ve.prototype.uint64=function(e){var r=sa.from(e);return this._push(Bs,r.length(),r)};Ve.prototype.int64=Ve.prototype.uint64;Ve.prototype.sint64=function(e){var r=sa.from(e).zzEncode();return this._push(Bs,r.length(),r)};Ve.prototype.bool=function(e){return this._push(Ds,1,e?1:0)};function Es(n,e,r){e[r]=n&255,e[r+1]=n>>>8&255,e[r+2]=n>>>16&255,e[r+3]=n>>>24}Ve.prototype.fixed32=function(e){return this._push(Es,4,e>>>0)};Ve.prototype.sfixed32=Ve.prototype.fixed32;Ve.prototype.fixed64=function(e){var r=sa.from(e);return this._push(Es,4,r.lo)._push(Es,4,r.hi)};Ve.prototype.sfixed64=Ve.prototype.fixed64;Ve.prototype.float=function(e){return this._push(Jt.float.writeFloatLE,4,e)};Ve.prototype.double=function(e){return this._push(Jt.float.writeDoubleLE,8,e)};var N1=Jt.Array.prototype.set?function(e,r,t){r.set(e,t)}:function(e,r,t){for(var i=0;i<e.length;++i)r[t+i]=e[i]};Ve.prototype.bytes=function(e){var r=e.length>>>0;if(!r)return this._push(Ds,1,0);if(Jt.isString(e)){var t=Ve.alloc(r=fd.length(e));fd.decode(e,t,0),e=t}return this.uint32(r)._push(N1,r,e)};Ve.prototype.string=function(e){var r=dd.length(e);return r?this.uint32(r)._push(dd.write,r,e):this._push(Ds,1,0)};Ve.prototype.fork=function(){return this.states=new M1(this),this.head=this.tail=new Ji(Ps,0,0),this.len=0,this};Ve.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Ji(Ps,0,0),this.len=0),this};Ve.prototype.ldelim=function(){var e=this.head,r=this.tail,t=this.len;return this.reset().uint32(t),t&&(this.tail.next=e.next,this.tail=r,this.len+=t),this};Ve.prototype.finish=function(){for(var e=this.head.next,r=this.constructor.alloc(this.len),t=0;e;)e.fn(e.val,r,t),t+=e.len,e=e.next;return r};Ve._configure=function(n){Os=n,Ve.create=pd(),Os._configure()}});var yd=et((xC,gd)=>{"use strict";gd.exports=Tr;var md=Rs();(Tr.prototype=Object.create(md.prototype)).constructor=Tr;var Wr=Gr();function Tr(){md.call(this)}Tr._configure=function(){Tr.alloc=Wr._Buffer_allocUnsafe,Tr.writeBytesBuffer=Wr.Buffer&&Wr.Buffer.prototype instanceof Uint8Array&&Wr.Buffer.prototype.set.name==="set"?function(e,r,t){r.set(e,t)}:function(e,r,t){if(e.copy)e.copy(r,t,0,e.length);else for(var i=0;i<e.length;)r[t++]=e[i++]}};Tr.prototype.bytes=function(e){Wr.isString(e)&&(e=Wr._Buffer_from(e,"base64"));var r=e.length>>>0;return this.uint32(r),r&&this._push(Tr.writeBytesBuffer,r,e),this};function z1(n,e,r){n.length<40?Wr.utf8.write(n,e,r):e.utf8Write?e.utf8Write(n,r):e.write(n,r)}Tr.prototype.string=function(e){var r=Wr.Buffer.byteLength(e);return this.uint32(r),r&&this._push(z1,r,e),this};Tr._configure()});var Ns=et((TC,Td)=>{"use strict";Td.exports=pt;var _r=Gr(),Ls,wd=_r.LongBits,F1=_r.utf8;function pr(n,e){return RangeError("index out of range: "+n.pos+" + "+(e||1)+" > "+n.len)}function pt(n){this.buf=n,this.pos=0,this.len=n.length}var bd=typeof Uint8Array<"u"?function(e){if(e instanceof Uint8Array||Array.isArray(e))return new pt(e);throw Error("illegal buffer")}:function(e){if(Array.isArray(e))return new pt(e);throw Error("illegal buffer")},xd=function(){return _r.Buffer?function(r){return(pt.create=function(i){return _r.Buffer.isBuffer(i)?new Ls(i):bd(i)})(r)}:bd};pt.create=xd();pt.prototype._slice=_r.Array.prototype.subarray||_r.Array.prototype.slice;pt.prototype.uint32=function(){var e=4294967295;return function(){if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,pr(this,10);return e}}();pt.prototype.int32=function(){return this.uint32()|0};pt.prototype.sint32=function(){var e=this.uint32();return e>>>1^-(e&1)|0};function Ms(){var n=new wd(0,0),e=0;if(this.len-this.pos>4){for(;e<4;++e)if(n.lo=(n.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return n;if(n.lo=(n.lo|(this.buf[this.pos]&127)<<28)>>>0,n.hi=(n.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return n;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw pr(this);if(n.lo=(n.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return n}return n.lo=(n.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,n}if(this.len-this.pos>4){for(;e<5;++e)if(n.hi=(n.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return n}else for(;e<5;++e){if(this.pos>=this.len)throw pr(this);if(n.hi=(n.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return n}throw Error("invalid varint encoding")}pt.prototype.bool=function(){return this.uint32()!==0};function ua(n,e){return(n[e-4]|n[e-3]<<8|n[e-2]<<16|n[e-1]<<24)>>>0}pt.prototype.fixed32=function(){if(this.pos+4>this.len)throw pr(this,4);return ua(this.buf,this.pos+=4)};pt.prototype.sfixed32=function(){if(this.pos+4>this.len)throw pr(this,4);return ua(this.buf,this.pos+=4)|0};function vd(){if(this.pos+8>this.len)throw pr(this,8);return new wd(ua(this.buf,this.pos+=4),ua(this.buf,this.pos+=4))}pt.prototype.float=function(){if(this.pos+4>this.len)throw pr(this,4);var e=_r.float.readFloatLE(this.buf,this.pos);return this.pos+=4,e};pt.prototype.double=function(){if(this.pos+8>this.len)throw pr(this,4);var e=_r.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,e};pt.prototype.bytes=function(){var e=this.uint32(),r=this.pos,t=this.pos+e;if(t>this.len)throw pr(this,e);return this.pos+=e,Array.isArray(this.buf)?this.buf.slice(r,t):r===t?new this.buf.constructor(0):this._slice.call(this.buf,r,t)};pt.prototype.string=function(){var e=this.bytes();return F1.read(e,0,e.length)};pt.prototype.skip=function(e){if(typeof e=="number"){if(this.pos+e>this.len)throw pr(this,e);this.pos+=e}else do if(this.pos>=this.len)throw pr(this);while(this.buf[this.pos++]&128);return this};pt.prototype.skipType=function(n){switch(n){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(n=this.uint32()&7)!==4;)this.skipType(n);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+n+" at offset "+this.pos)}return this};pt._configure=function(n){Ls=n,pt.create=xd(),Ls._configure();var e=_r.Long?"toLong":"toNumber";_r.merge(pt.prototype,{int64:function(){return Ms.call(this)[e](!1)},uint64:function(){return Ms.call(this)[e](!0)},sint64:function(){return Ms.call(this).zzDecode()[e](!1)},fixed64:function(){return vd.call(this)[e](!0)},sfixed64:function(){return vd.call(this)[e](!1)}})}});var Id=et((_C,Sd)=>{"use strict";Sd.exports=pn;var $d=Ns();(pn.prototype=Object.create($d.prototype)).constructor=pn;var _d=Gr();function pn(n){$d.call(this,n)}pn._configure=function(){_d.Buffer&&(pn.prototype._slice=_d.Buffer.prototype.slice)};pn.prototype.string=function(){var e=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+e,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+e,this.len))};pn._configure()});var Ad=et(($C,Cd)=>{"use strict";Cd.exports=Zi;var zs=Gr();(Zi.prototype=Object.create(zs.EventEmitter.prototype)).constructor=Zi;function Zi(n,e,r){if(typeof n!="function")throw TypeError("rpcImpl must be a function");zs.EventEmitter.call(this),this.rpcImpl=n,this.requestDelimited=!!e,this.responseDelimited=!!r}Zi.prototype.rpcCall=function n(e,r,t,i,o){if(!i)throw TypeError("request must be specified");var s=this;if(!o)return zs.asPromise(n,s,e,r,t,i);if(!s.rpcImpl){setTimeout(function(){o(Error("already ended"))},0);return}try{return s.rpcImpl(e,r[s.requestDelimited?"encodeDelimited":"encode"](i).finish(),function(u,c){if(u)return s.emit("error",u,e),o(u);if(c===null){s.end(!0);return}if(!(c instanceof t))try{c=t[s.responseDelimited?"decodeDelimited":"decode"](c)}catch(g){return s.emit("error",g,e),o(g)}return s.emit("data",c,e),o(null,c)})}catch(a){s.emit("error",a,e),setTimeout(function(){o(a)},0);return}};Zi.prototype.end=function(e){return this.rpcImpl&&(e||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}});var Ed=et(Od=>{"use strict";var j1=Od;j1.Service=Ad()});var Dd=et((IC,Pd)=>{"use strict";Pd.exports={}});var Rd=et(Bd=>{"use strict";var Ft=Bd;Ft.build="minimal";Ft.Writer=Rs();Ft.BufferWriter=yd();Ft.Reader=Ns();Ft.BufferReader=Id();Ft.util=Gr();Ft.rpc=Ed();Ft.roots=Dd();Ft.configure=kd;function kd(){Ft.util._configure(),Ft.Writer._configure(Ft.BufferWriter),Ft.Reader._configure(Ft.BufferReader)}kd()});var Ld=et((AC,Md)=>{"use strict";Md.exports=Rd()});var Xn=et((OC,Nd)=>{"use strict";var rt=Ld(),se=rt.Reader,ht=rt.Writer,N=rt.util,B=rt.roots.default||(rt.roots.default={});B.onnx=function(){var n={};return n.Version=function(){var e={},r=Object.create(e);return r[e[0]="_START_VERSION"]=0,r[e[1]="IR_VERSION_2017_10_10"]=1,r[e[2]="IR_VERSION_2017_10_30"]=2,r[e[3]="IR_VERSION_2017_11_3"]=3,r[e[4]="IR_VERSION_2019_1_22"]=4,r[e[5]="IR_VERSION_2019_3_18"]=5,r[e[6]="IR_VERSION_2019_9_19"]=6,r[e[7]="IR_VERSION_2020_5_8"]=7,r[e[8]="IR_VERSION_2021_7_30"]=8,r[e[9]="IR_VERSION"]=9,r}(),n.AttributeProto=function(){function e(r){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],this.sparseTensors=[],this.typeProtos=[],r)for(var t=Object.keys(r),i=0;i<t.length;++i)r[t[i]]!=null&&(this[t[i]]=r[t[i]])}return e.prototype.name="",e.prototype.refAttrName="",e.prototype.docString="",e.prototype.type=0,e.prototype.f=0,e.prototype.i=N.Long?N.Long.fromBits(0,0,!1):0,e.prototype.s=N.newBuffer([]),e.prototype.t=null,e.prototype.g=null,e.prototype.sparseTensor=null,e.prototype.tp=null,e.prototype.floats=N.emptyArray,e.prototype.ints=N.emptyArray,e.prototype.strings=N.emptyArray,e.prototype.tensors=N.emptyArray,e.prototype.graphs=N.emptyArray,e.prototype.sparseTensors=N.emptyArray,e.prototype.typeProtos=N.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,i){if(i||(i=ht.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&i.uint32(10).string(t.name),t.f!=null&&Object.hasOwnProperty.call(t,"f")&&i.uint32(21).float(t.f),t.i!=null&&Object.hasOwnProperty.call(t,"i")&&i.uint32(24).int64(t.i),t.s!=null&&Object.hasOwnProperty.call(t,"s")&&i.uint32(34).bytes(t.s),t.t!=null&&Object.hasOwnProperty.call(t,"t")&&B.onnx.TensorProto.encode(t.t,i.uint32(42).fork()).ldelim(),t.g!=null&&Object.hasOwnProperty.call(t,"g")&&B.onnx.GraphProto.encode(t.g,i.uint32(50).fork()).ldelim(),t.floats!=null&&t.floats.length){i.uint32(58).fork();for(var o=0;o<t.floats.length;++o)i.float(t.floats[o]);i.ldelim()}if(t.ints!=null&&t.ints.length){i.uint32(66).fork();for(var o=0;o<t.ints.length;++o)i.int64(t.ints[o]);i.ldelim()}if(t.strings!=null&&t.strings.length)for(var o=0;o<t.strings.length;++o)i.uint32(74).bytes(t.strings[o]);if(t.tensors!=null&&t.tensors.length)for(var o=0;o<t.tensors.length;++o)B.onnx.TensorProto.encode(t.tensors[o],i.uint32(82).fork()).ldelim();if(t.graphs!=null&&t.graphs.length)for(var o=0;o<t.graphs.length;++o)B.onnx.GraphProto.encode(t.graphs[o],i.uint32(90).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&i.uint32(106).string(t.docString),t.tp!=null&&Object.hasOwnProperty.call(t,"tp")&&B.onnx.TypeProto.encode(t.tp,i.uint32(114).fork()).ldelim(),t.typeProtos!=null&&t.typeProtos.length)for(var o=0;o<t.typeProtos.length;++o)B.onnx.TypeProto.encode(t.typeProtos[o],i.uint32(122).fork()).ldelim();if(t.type!=null&&Object.hasOwnProperty.call(t,"type")&&i.uint32(160).int32(t.type),t.refAttrName!=null&&Object.hasOwnProperty.call(t,"refAttrName")&&i.uint32(170).string(t.refAttrName),t.sparseTensor!=null&&Object.hasOwnProperty.call(t,"sparseTensor")&&B.onnx.SparseTensorProto.encode(t.sparseTensor,i.uint32(178).fork()).ldelim(),t.sparseTensors!=null&&t.sparseTensors.length)for(var o=0;o<t.sparseTensors.length;++o)B.onnx.SparseTensorProto.encode(t.sparseTensors[o],i.uint32(186).fork()).ldelim();return i},e.encodeDelimited=function(t,i){return this.encode(t,i).ldelim()},e.decode=function(t,i){t instanceof se||(t=se.create(t));for(var o=i===void 0?t.len:t.pos+i,s=new B.onnx.AttributeProto;t.pos<o;){var a=t.uint32();switch(a>>>3){case 1:{s.name=t.string();break}case 21:{s.refAttrName=t.string();break}case 13:{s.docString=t.string();break}case 20:{s.type=t.int32();break}case 2:{s.f=t.float();break}case 3:{s.i=t.int64();break}case 4:{s.s=t.bytes();break}case 5:{s.t=B.onnx.TensorProto.decode(t,t.uint32());break}case 6:{s.g=B.onnx.GraphProto.decode(t,t.uint32());break}case 22:{s.sparseTensor=B.onnx.SparseTensorProto.decode(t,t.uint32());break}case 14:{s.tp=B.onnx.TypeProto.decode(t,t.uint32());break}case 7:{if(s.floats&&s.floats.length||(s.floats=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.floats.push(t.float());else s.floats.push(t.float());break}case 8:{if(s.ints&&s.ints.length||(s.ints=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.ints.push(t.int64());else s.ints.push(t.int64());break}case 9:{s.strings&&s.strings.length||(s.strings=[]),s.strings.push(t.bytes());break}case 10:{s.tensors&&s.tensors.length||(s.tensors=[]),s.tensors.push(B.onnx.TensorProto.decode(t,t.uint32()));break}case 11:{s.graphs&&s.graphs.length||(s.graphs=[]),s.graphs.push(B.onnx.GraphProto.decode(t,t.uint32()));break}case 23:{s.sparseTensors&&s.sparseTensors.length||(s.sparseTensors=[]),s.sparseTensors.push(B.onnx.SparseTensorProto.decode(t,t.uint32()));break}case 15:{s.typeProtos&&s.typeProtos.length||(s.typeProtos=[]),s.typeProtos.push(B.onnx.TypeProto.decode(t,t.uint32()));break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof se||(t=new se(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!N.isString(t.name))return"name: string expected";if(t.refAttrName!=null&&t.hasOwnProperty("refAttrName")&&!N.isString(t.refAttrName))return"refAttrName: string expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!N.isString(t.docString))return"docString: string expected";if(t.type!=null&&t.hasOwnProperty("type"))switch(t.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 11:case 13:case 6:case 7:case 8:case 9:case 10:case 12:case 14:break}if(t.f!=null&&t.hasOwnProperty("f")&&typeof t.f!="number")return"f: number expected";if(t.i!=null&&t.hasOwnProperty("i")&&!N.isInteger(t.i)&&!(t.i&&N.isInteger(t.i.low)&&N.isInteger(t.i.high)))return"i: integer|Long expected";if(t.s!=null&&t.hasOwnProperty("s")&&!(t.s&&typeof t.s.length=="number"||N.isString(t.s)))return"s: buffer expected";if(t.t!=null&&t.hasOwnProperty("t")){var i=B.onnx.TensorProto.verify(t.t);if(i)return"t."+i}if(t.g!=null&&t.hasOwnProperty("g")){var i=B.onnx.GraphProto.verify(t.g);if(i)return"g."+i}if(t.sparseTensor!=null&&t.hasOwnProperty("sparseTensor")){var i=B.onnx.SparseTensorProto.verify(t.sparseTensor);if(i)return"sparseTensor."+i}if(t.tp!=null&&t.hasOwnProperty("tp")){var i=B.onnx.TypeProto.verify(t.tp);if(i)return"tp."+i}if(t.floats!=null&&t.hasOwnProperty("floats")){if(!Array.isArray(t.floats))return"floats: array expected";for(var o=0;o<t.floats.length;++o)if(typeof t.floats[o]!="number")return"floats: number[] expected"}if(t.ints!=null&&t.hasOwnProperty("ints")){if(!Array.isArray(t.ints))return"ints: array expected";for(var o=0;o<t.ints.length;++o)if(!N.isInteger(t.ints[o])&&!(t.ints[o]&&N.isInteger(t.ints[o].low)&&N.isInteger(t.ints[o].high)))return"ints: integer|Long[] expected"}if(t.strings!=null&&t.hasOwnProperty("strings")){if(!Array.isArray(t.strings))return"strings: array expected";for(var o=0;o<t.strings.length;++o)if(!(t.strings[o]&&typeof t.strings[o].length=="number"||N.isString(t.strings[o])))return"strings: buffer[] expected"}if(t.tensors!=null&&t.hasOwnProperty("tensors")){if(!Array.isArray(t.tensors))return"tensors: array expected";for(var o=0;o<t.tensors.length;++o){var i=B.onnx.TensorProto.verify(t.tensors[o]);if(i)return"tensors."+i}}if(t.graphs!=null&&t.hasOwnProperty("graphs")){if(!Array.isArray(t.graphs))return"graphs: array expected";for(var o=0;o<t.graphs.length;++o){var i=B.onnx.GraphProto.verify(t.graphs[o]);if(i)return"graphs."+i}}if(t.sparseTensors!=null&&t.hasOwnProperty("sparseTensors")){if(!Array.isArray(t.sparseTensors))return"sparseTensors: array expected";for(var o=0;o<t.sparseTensors.length;++o){var i=B.onnx.SparseTensorProto.verify(t.sparseTensors[o]);if(i)return"sparseTensors."+i}}if(t.typeProtos!=null&&t.hasOwnProperty("typeProtos")){if(!Array.isArray(t.typeProtos))return"typeProtos: array expected";for(var o=0;o<t.typeProtos.length;++o){var i=B.onnx.TypeProto.verify(t.typeProtos[o]);if(i)return"typeProtos."+i}}return null},e.fromObject=function(t){if(t instanceof B.onnx.AttributeProto)return t;var i=new B.onnx.AttributeProto;switch(t.name!=null&&(i.name=String(t.name)),t.refAttrName!=null&&(i.refAttrName=String(t.refAttrName)),t.docString!=null&&(i.docString=String(t.docString)),t.type){default:if(typeof t.type=="number"){i.type=t.type;break}break;case"UNDEFINED":case 0:i.type=0;break;case"FLOAT":case 1:i.type=1;break;case"INT":case 2:i.type=2;break;case"STRING":case 3:i.type=3;break;case"TENSOR":case 4:i.type=4;break;case"GRAPH":case 5:i.type=5;break;case"SPARSE_TENSOR":case 11:i.type=11;break;case"TYPE_PROTO":case 13:i.type=13;break;case"FLOATS":case 6:i.type=6;break;case"INTS":case 7:i.type=7;break;case"STRINGS":case 8:i.type=8;break;case"TENSORS":case 9:i.type=9;break;case"GRAPHS":case 10:i.type=10;break;case"SPARSE_TENSORS":case 12:i.type=12;break;case"TYPE_PROTOS":case 14:i.type=14;break}if(t.f!=null&&(i.f=Number(t.f)),t.i!=null&&(N.Long?(i.i=N.Long.fromValue(t.i)).unsigned=!1:typeof t.i=="string"?i.i=parseInt(t.i,10):typeof t.i=="number"?i.i=t.i:typeof t.i=="object"&&(i.i=new N.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber())),t.s!=null&&(typeof t.s=="string"?N.base64.decode(t.s,i.s=N.newBuffer(N.base64.length(t.s)),0):t.s.length>=0&&(i.s=t.s)),t.t!=null){if(typeof t.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");i.t=B.onnx.TensorProto.fromObject(t.t)}if(t.g!=null){if(typeof t.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");i.g=B.onnx.GraphProto.fromObject(t.g)}if(t.sparseTensor!=null){if(typeof t.sparseTensor!="object")throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");i.sparseTensor=B.onnx.SparseTensorProto.fromObject(t.sparseTensor)}if(t.tp!=null){if(typeof t.tp!="object")throw TypeError(".onnx.AttributeProto.tp: object expected");i.tp=B.onnx.TypeProto.fromObject(t.tp)}if(t.floats){if(!Array.isArray(t.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");i.floats=[];for(var o=0;o<t.floats.length;++o)i.floats[o]=Number(t.floats[o])}if(t.ints){if(!Array.isArray(t.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");i.ints=[];for(var o=0;o<t.ints.length;++o)N.Long?(i.ints[o]=N.Long.fromValue(t.ints[o])).unsigned=!1:typeof t.ints[o]=="string"?i.ints[o]=parseInt(t.ints[o],10):typeof t.ints[o]=="number"?i.ints[o]=t.ints[o]:typeof t.ints[o]=="object"&&(i.ints[o]=new N.LongBits(t.ints[o].low>>>0,t.ints[o].high>>>0).toNumber())}if(t.strings){if(!Array.isArray(t.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");i.strings=[];for(var o=0;o<t.strings.length;++o)typeof t.strings[o]=="string"?N.base64.decode(t.strings[o],i.strings[o]=N.newBuffer(N.base64.length(t.strings[o])),0):t.strings[o].length>=0&&(i.strings[o]=t.strings[o])}if(t.tensors){if(!Array.isArray(t.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");i.tensors=[];for(var o=0;o<t.tensors.length;++o){if(typeof t.tensors[o]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");i.tensors[o]=B.onnx.TensorProto.fromObject(t.tensors[o])}}if(t.graphs){if(!Array.isArray(t.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");i.graphs=[];for(var o=0;o<t.graphs.length;++o){if(typeof t.graphs[o]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");i.graphs[o]=B.onnx.GraphProto.fromObject(t.graphs[o])}}if(t.sparseTensors){if(!Array.isArray(t.sparseTensors))throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");i.sparseTensors=[];for(var o=0;o<t.sparseTensors.length;++o){if(typeof t.sparseTensors[o]!="object")throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");i.sparseTensors[o]=B.onnx.SparseTensorProto.fromObject(t.sparseTensors[o])}}if(t.typeProtos){if(!Array.isArray(t.typeProtos))throw TypeError(".onnx.AttributeProto.typeProtos: array expected");i.typeProtos=[];for(var o=0;o<t.typeProtos.length;++o){if(typeof t.typeProtos[o]!="object")throw TypeError(".onnx.AttributeProto.typeProtos: object expected");i.typeProtos[o]=B.onnx.TypeProto.fromObject(t.typeProtos[o])}}return i},e.toObject=function(t,i){i||(i={});var o={};if((i.arrays||i.defaults)&&(o.floats=[],o.ints=[],o.strings=[],o.tensors=[],o.graphs=[],o.typeProtos=[],o.sparseTensors=[]),i.defaults){if(o.name="",o.f=0,N.Long){var s=new N.Long(0,0,!1);o.i=i.longs===String?s.toString():i.longs===Number?s.toNumber():s}else o.i=i.longs===String?"0":0;i.bytes===String?o.s="":(o.s=[],i.bytes!==Array&&(o.s=N.newBuffer(o.s))),o.t=null,o.g=null,o.docString="",o.tp=null,o.type=i.enums===String?"UNDEFINED":0,o.refAttrName="",o.sparseTensor=null}if(t.name!=null&&t.hasOwnProperty("name")&&(o.name=t.name),t.f!=null&&t.hasOwnProperty("f")&&(o.f=i.json&&!isFinite(t.f)?String(t.f):t.f),t.i!=null&&t.hasOwnProperty("i")&&(typeof t.i=="number"?o.i=i.longs===String?String(t.i):t.i:o.i=i.longs===String?N.Long.prototype.toString.call(t.i):i.longs===Number?new N.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber():t.i),t.s!=null&&t.hasOwnProperty("s")&&(o.s=i.bytes===String?N.base64.encode(t.s,0,t.s.length):i.bytes===Array?Array.prototype.slice.call(t.s):t.s),t.t!=null&&t.hasOwnProperty("t")&&(o.t=B.onnx.TensorProto.toObject(t.t,i)),t.g!=null&&t.hasOwnProperty("g")&&(o.g=B.onnx.GraphProto.toObject(t.g,i)),t.floats&&t.floats.length){o.floats=[];for(var a=0;a<t.floats.length;++a)o.floats[a]=i.json&&!isFinite(t.floats[a])?String(t.floats[a]):t.floats[a]}if(t.ints&&t.ints.length){o.ints=[];for(var a=0;a<t.ints.length;++a)typeof t.ints[a]=="number"?o.ints[a]=i.longs===String?String(t.ints[a]):t.ints[a]:o.ints[a]=i.longs===String?N.Long.prototype.toString.call(t.ints[a]):i.longs===Number?new N.LongBits(t.ints[a].low>>>0,t.ints[a].high>>>0).toNumber():t.ints[a]}if(t.strings&&t.strings.length){o.strings=[];for(var a=0;a<t.strings.length;++a)o.strings[a]=i.bytes===String?N.base64.encode(t.strings[a],0,t.strings[a].length):i.bytes===Array?Array.prototype.slice.call(t.strings[a]):t.strings[a]}if(t.tensors&&t.tensors.length){o.tensors=[];for(var a=0;a<t.tensors.length;++a)o.tensors[a]=B.onnx.TensorProto.toObject(t.tensors[a],i)}if(t.graphs&&t.graphs.length){o.graphs=[];for(var a=0;a<t.graphs.length;++a)o.graphs[a]=B.onnx.GraphProto.toObject(t.graphs[a],i)}if(t.docString!=null&&t.hasOwnProperty("docString")&&(o.docString=t.docString),t.tp!=null&&t.hasOwnProperty("tp")&&(o.tp=B.onnx.TypeProto.toObject(t.tp,i)),t.typeProtos&&t.typeProtos.length){o.typeProtos=[];for(var a=0;a<t.typeProtos.length;++a)o.typeProtos[a]=B.onnx.TypeProto.toObject(t.typeProtos[a],i)}if(t.type!=null&&t.hasOwnProperty("type")&&(o.type=i.enums===String?B.onnx.AttributeProto.AttributeType[t.type]===void 0?t.type:B.onnx.AttributeProto.AttributeType[t.type]:t.type),t.refAttrName!=null&&t.hasOwnProperty("refAttrName")&&(o.refAttrName=t.refAttrName),t.sparseTensor!=null&&t.hasOwnProperty("sparseTensor")&&(o.sparseTensor=B.onnx.SparseTensorProto.toObject(t.sparseTensor,i)),t.sparseTensors&&t.sparseTensors.length){o.sparseTensors=[];for(var a=0;a<t.sparseTensors.length;++a)o.sparseTensors[a]=B.onnx.SparseTensorProto.toObject(t.sparseTensors[a],i)}return o},e.prototype.toJSON=function(){return this.constructor.toObject(this,rt.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.AttributeProto"},e.AttributeType=function(){var r={},t=Object.create(r);return t[r[0]="UNDEFINED"]=0,t[r[1]="FLOAT"]=1,t[r[2]="INT"]=2,t[r[3]="STRING"]=3,t[r[4]="TENSOR"]=4,t[r[5]="GRAPH"]=5,t[r[11]="SPARSE_TENSOR"]=11,t[r[13]="TYPE_PROTO"]=13,t[r[6]="FLOATS"]=6,t[r[7]="INTS"]=7,t[r[8]="STRINGS"]=8,t[r[9]="TENSORS"]=9,t[r[10]="GRAPHS"]=10,t[r[12]="SPARSE_TENSORS"]=12,t[r[14]="TYPE_PROTOS"]=14,t}(),e}(),n.ValueInfoProto=function(){function e(r){if(r)for(var t=Object.keys(r),i=0;i<t.length;++i)r[t[i]]!=null&&(this[t[i]]=r[t[i]])}return e.prototype.name="",e.prototype.type=null,e.prototype.docString="",e.create=function(t){return new e(t)},e.encode=function(t,i){return i||(i=ht.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&i.uint32(10).string(t.name),t.type!=null&&Object.hasOwnProperty.call(t,"type")&&B.onnx.TypeProto.encode(t.type,i.uint32(18).fork()).ldelim(),t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&i.uint32(26).string(t.docString),i},e.encodeDelimited=function(t,i){return this.encode(t,i).ldelim()},e.decode=function(t,i){t instanceof se||(t=se.create(t));for(var o=i===void 0?t.len:t.pos+i,s=new B.onnx.ValueInfoProto;t.pos<o;){var a=t.uint32();switch(a>>>3){case 1:{s.name=t.string();break}case 2:{s.type=B.onnx.TypeProto.decode(t,t.uint32());break}case 3:{s.docString=t.string();break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof se||(t=new se(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!N.isString(t.name))return"name: string expected";if(t.type!=null&&t.hasOwnProperty("type")){var i=B.onnx.TypeProto.verify(t.type);if(i)return"type."+i}return t.docString!=null&&t.hasOwnProperty("docString")&&!N.isString(t.docString)?"docString: string expected":null},e.fromObject=function(t){if(t instanceof B.onnx.ValueInfoProto)return t;var i=new B.onnx.ValueInfoProto;if(t.name!=null&&(i.name=String(t.name)),t.type!=null){if(typeof t.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");i.type=B.onnx.TypeProto.fromObject(t.type)}return t.docString!=null&&(i.docString=String(t.docString)),i},e.toObject=function(t,i){i||(i={});var o={};return i.defaults&&(o.name="",o.type=null,o.docString=""),t.name!=null&&t.hasOwnProperty("name")&&(o.name=t.name),t.type!=null&&t.hasOwnProperty("type")&&(o.type=B.onnx.TypeProto.toObject(t.type,i)),t.docString!=null&&t.hasOwnProperty("docString")&&(o.docString=t.docString),o},e.prototype.toJSON=function(){return this.constructor.toObject(this,rt.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.ValueInfoProto"},e}(),n.NodeProto=function(){function e(r){if(this.input=[],this.output=[],this.attribute=[],r)for(var t=Object.keys(r),i=0;i<t.length;++i)r[t[i]]!=null&&(this[t[i]]=r[t[i]])}return e.prototype.input=N.emptyArray,e.prototype.output=N.emptyArray,e.prototype.name="",e.prototype.opType="",e.prototype.domain="",e.prototype.attribute=N.emptyArray,e.prototype.docString="",e.create=function(t){return new e(t)},e.encode=function(t,i){if(i||(i=ht.create()),t.input!=null&&t.input.length)for(var o=0;o<t.input.length;++o)i.uint32(10).string(t.input[o]);if(t.output!=null&&t.output.length)for(var o=0;o<t.output.length;++o)i.uint32(18).string(t.output[o]);if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&i.uint32(26).string(t.name),t.opType!=null&&Object.hasOwnProperty.call(t,"opType")&&i.uint32(34).string(t.opType),t.attribute!=null&&t.attribute.length)for(var o=0;o<t.attribute.length;++o)B.onnx.AttributeProto.encode(t.attribute[o],i.uint32(42).fork()).ldelim();return t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&i.uint32(50).string(t.docString),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&i.uint32(58).string(t.domain),i},e.encodeDelimited=function(t,i){return this.encode(t,i).ldelim()},e.decode=function(t,i){t instanceof se||(t=se.create(t));for(var o=i===void 0?t.len:t.pos+i,s=new B.onnx.NodeProto;t.pos<o;){var a=t.uint32();switch(a>>>3){case 1:{s.input&&s.input.length||(s.input=[]),s.input.push(t.string());break}case 2:{s.output&&s.output.length||(s.output=[]),s.output.push(t.string());break}case 3:{s.name=t.string();break}case 4:{s.opType=t.string();break}case 7:{s.domain=t.string();break}case 5:{s.attribute&&s.attribute.length||(s.attribute=[]),s.attribute.push(B.onnx.AttributeProto.decode(t,t.uint32()));break}case 6:{s.docString=t.string();break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof se||(t=new se(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var i=0;i<t.input.length;++i)if(!N.isString(t.input[i]))return"input: string[] expected"}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(var i=0;i<t.output.length;++i)if(!N.isString(t.output[i]))return"output: string[] expected"}if(t.name!=null&&t.hasOwnProperty("name")&&!N.isString(t.name))return"name: string expected";if(t.opType!=null&&t.hasOwnProperty("opType")&&!N.isString(t.opType))return"opType: string expected";if(t.domain!=null&&t.hasOwnProperty("domain")&&!N.isString(t.domain))return"domain: string expected";if(t.attribute!=null&&t.hasOwnProperty("attribute")){if(!Array.isArray(t.attribute))return"attribute: array expected";for(var i=0;i<t.attribute.length;++i){var o=B.onnx.AttributeProto.verify(t.attribute[i]);if(o)return"attribute."+o}}return t.docString!=null&&t.hasOwnProperty("docString")&&!N.isString(t.docString)?"docString: string expected":null},e.fromObject=function(t){if(t instanceof B.onnx.NodeProto)return t;var i=new B.onnx.NodeProto;if(t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.NodeProto.input: array expected");i.input=[];for(var o=0;o<t.input.length;++o)i.input[o]=String(t.input[o])}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.NodeProto.output: array expected");i.output=[];for(var o=0;o<t.output.length;++o)i.output[o]=String(t.output[o])}if(t.name!=null&&(i.name=String(t.name)),t.opType!=null&&(i.opType=String(t.opType)),t.domain!=null&&(i.domain=String(t.domain)),t.attribute){if(!Array.isArray(t.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");i.attribute=[];for(var o=0;o<t.attribute.length;++o){if(typeof t.attribute[o]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");i.attribute[o]=B.onnx.AttributeProto.fromObject(t.attribute[o])}}return t.docString!=null&&(i.docString=String(t.docString)),i},e.toObject=function(t,i){i||(i={});var o={};if((i.arrays||i.defaults)&&(o.input=[],o.output=[],o.attribute=[]),i.defaults&&(o.name="",o.opType="",o.docString="",o.domain=""),t.input&&t.input.length){o.input=[];for(var s=0;s<t.input.length;++s)o.input[s]=t.input[s]}if(t.output&&t.output.length){o.output=[];for(var s=0;s<t.output.length;++s)o.output[s]=t.output[s]}if(t.name!=null&&t.hasOwnProperty("name")&&(o.name=t.name),t.opType!=null&&t.hasOwnProperty("opType")&&(o.opType=t.opType),t.attribute&&t.attribute.length){o.attribute=[];for(var s=0;s<t.attribute.length;++s)o.attribute[s]=B.onnx.AttributeProto.toObject(t.attribute[s],i)}return t.docString!=null&&t.hasOwnProperty("docString")&&(o.docString=t.docString),t.domain!=null&&t.hasOwnProperty("domain")&&(o.domain=t.domain),o},e.prototype.toJSON=function(){return this.constructor.toObject(this,rt.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.NodeProto"},e}(),n.TrainingInfoProto=function(){function e(r){if(this.initializationBinding=[],this.updateBinding=[],r)for(var t=Object.keys(r),i=0;i<t.length;++i)r[t[i]]!=null&&(this[t[i]]=r[t[i]])}return e.prototype.initialization=null,e.prototype.algorithm=null,e.prototype.initializationBinding=N.emptyArray,e.prototype.updateBinding=N.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,i){if(i||(i=ht.create()),t.initialization!=null&&Object.hasOwnProperty.call(t,"initialization")&&B.onnx.GraphProto.encode(t.initialization,i.uint32(10).fork()).ldelim(),t.algorithm!=null&&Object.hasOwnProperty.call(t,"algorithm")&&B.onnx.GraphProto.encode(t.algorithm,i.uint32(18).fork()).ldelim(),t.initializationBinding!=null&&t.initializationBinding.length)for(var o=0;o<t.initializationBinding.length;++o)B.onnx.StringStringEntryProto.encode(t.initializationBinding[o],i.uint32(26).fork()).ldelim();if(t.updateBinding!=null&&t.updateBinding.length)for(var o=0;o<t.updateBinding.length;++o)B.onnx.StringStringEntryProto.encode(t.updateBinding[o],i.uint32(34).fork()).ldelim();return i},e.encodeDelimited=function(t,i){return this.encode(t,i).ldelim()},e.decode=function(t,i){t instanceof se||(t=se.create(t));for(var o=i===void 0?t.len:t.pos+i,s=new B.onnx.TrainingInfoProto;t.pos<o;){var a=t.uint32();switch(a>>>3){case 1:{s.initialization=B.onnx.GraphProto.decode(t,t.uint32());break}case 2:{s.algorithm=B.onnx.GraphProto.decode(t,t.uint32());break}case 3:{s.initializationBinding&&s.initializationBinding.length||(s.initializationBinding=[]),s.initializationBinding.push(B.onnx.StringStringEntryProto.decode(t,t.uint32()));break}case 4:{s.updateBinding&&s.updateBinding.length||(s.updateBinding=[]),s.updateBinding.push(B.onnx.StringStringEntryProto.decode(t,t.uint32()));break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof se||(t=new se(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.initialization!=null&&t.hasOwnProperty("initialization")){var i=B.onnx.GraphProto.verify(t.initialization);if(i)return"initialization."+i}if(t.algorithm!=null&&t.hasOwnProperty("algorithm")){var i=B.onnx.GraphProto.verify(t.algorithm);if(i)return"algorithm."+i}if(t.initializationBinding!=null&&t.hasOwnProperty("initializationBinding")){if(!Array.isArray(t.initializationBinding))return"initializationBinding: array expected";for(var o=0;o<t.initializationBinding.length;++o){var i=B.onnx.StringStringEntryProto.verify(t.initializationBinding[o]);if(i)return"initializationBinding."+i}}if(t.updateBinding!=null&&t.hasOwnProperty("updateBinding")){if(!Array.isArray(t.updateBinding))return"updateBinding: array expected";for(var o=0;o<t.updateBinding.length;++o){var i=B.onnx.StringStringEntryProto.verify(t.updateBinding[o]);if(i)return"updateBinding."+i}}return null},e.fromObject=function(t){if(t instanceof B.onnx.TrainingInfoProto)return t;var i=new B.onnx.TrainingInfoProto;if(t.initialization!=null){if(typeof t.initialization!="object")throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");i.initialization=B.onnx.GraphProto.fromObject(t.initialization)}if(t.algorithm!=null){if(typeof t.algorithm!="object")throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");i.algorithm=B.onnx.GraphProto.fromObject(t.algorithm)}if(t.initializationBinding){if(!Array.isArray(t.initializationBinding))throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");i.initializationBinding=[];for(var o=0;o<t.initializationBinding.length;++o){if(typeof t.initializationBinding[o]!="object")throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");i.initializationBinding[o]=B.onnx.StringStringEntryProto.fromObject(t.initializationBinding[o])}}if(t.updateBinding){if(!Array.isArray(t.updateBinding))throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");i.updateBinding=[];for(var o=0;o<t.updateBinding.length;++o){if(typeof t.updateBinding[o]!="object")throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");i.updateBinding[o]=B.onnx.StringStringEntryProto.fromObject(t.updateBinding[o])}}return i},e.toObject=function(t,i){i||(i={});var o={};if((i.arrays||i.defaults)&&(o.initializationBinding=[],o.updateBinding=[]),i.defaults&&(o.initialization=null,o.algorithm=null),t.initialization!=null&&t.hasOwnProperty("initialization")&&(o.initialization=B.onnx.GraphProto.toObject(t.initialization,i)),t.algorithm!=null&&t.hasOwnProperty("algorithm")&&(o.algorithm=B.onnx.GraphProto.toObject(t.algorithm,i)),t.initializationBinding&&t.initializationBinding.length){o.initializationBinding=[];for(var s=0;s<t.initializationBinding.length;++s)o.initializationBinding[s]=B.onnx.StringStringEntryProto.toObject(t.initializationBinding[s],i)}if(t.updateBinding&&t.updateBinding.length){o.updateBinding=[];for(var s=0;s<t.updateBinding.length;++s)o.updateBinding[s]=B.onnx.StringStringEntryProto.toObject(t.updateBinding[s],i)}return o},e.prototype.toJSON=function(){return this.constructor.toObject(this,rt.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TrainingInfoProto"},e}(),n.ModelProto=function(){function e(r){if(this.opsetImport=[],this.metadataProps=[],this.trainingInfo=[],this.functions=[],r)for(var t=Object.keys(r),i=0;i<t.length;++i)r[t[i]]!=null&&(this[t[i]]=r[t[i]])}return e.prototype.irVersion=N.Long?N.Long.fromBits(0,0,!1):0,e.prototype.opsetImport=N.emptyArray,e.prototype.producerName="",e.prototype.producerVersion="",e.prototype.domain="",e.prototype.modelVersion=N.Long?N.Long.fromBits(0,0,!1):0,e.prototype.docString="",e.prototype.graph=null,e.prototype.metadataProps=N.emptyArray,e.prototype.trainingInfo=N.emptyArray,e.prototype.functions=N.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,i){if(i||(i=ht.create()),t.irVersion!=null&&Object.hasOwnProperty.call(t,"irVersion")&&i.uint32(8).int64(t.irVersion),t.producerName!=null&&Object.hasOwnProperty.call(t,"producerName")&&i.uint32(18).string(t.producerName),t.producerVersion!=null&&Object.hasOwnProperty.call(t,"producerVersion")&&i.uint32(26).string(t.producerVersion),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&i.uint32(34).string(t.domain),t.modelVersion!=null&&Object.hasOwnProperty.call(t,"modelVersion")&&i.uint32(40).int64(t.modelVersion),t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&i.uint32(50).string(t.docString),t.graph!=null&&Object.hasOwnProperty.call(t,"graph")&&B.onnx.GraphProto.encode(t.graph,i.uint32(58).fork()).ldelim(),t.opsetImport!=null&&t.opsetImport.length)for(var o=0;o<t.opsetImport.length;++o)B.onnx.OperatorSetIdProto.encode(t.opsetImport[o],i.uint32(66).fork()).ldelim();if(t.metadataProps!=null&&t.metadataProps.length)for(var o=0;o<t.metadataProps.length;++o)B.onnx.StringStringEntryProto.encode(t.metadataProps[o],i.uint32(114).fork()).ldelim();if(t.trainingInfo!=null&&t.trainingInfo.length)for(var o=0;o<t.trainingInfo.length;++o)B.onnx.TrainingInfoProto.encode(t.trainingInfo[o],i.uint32(162).fork()).ldelim();if(t.functions!=null&&t.functions.length)for(var o=0;o<t.functions.length;++o)B.onnx.FunctionProto.encode(t.functions[o],i.uint32(202).fork()).ldelim();return i},e.encodeDelimited=function(t,i){return this.encode(t,i).ldelim()},e.decode=function(t,i){t instanceof se||(t=se.create(t));for(var o=i===void 0?t.len:t.pos+i,s=new B.onnx.ModelProto;t.pos<o;){var a=t.uint32();switch(a>>>3){case 1:{s.irVersion=t.int64();break}case 8:{s.opsetImport&&s.opsetImport.length||(s.opsetImport=[]),s.opsetImport.push(B.onnx.OperatorSetIdProto.decode(t,t.uint32()));break}case 2:{s.producerName=t.string();break}case 3:{s.producerVersion=t.string();break}case 4:{s.domain=t.string();break}case 5:{s.modelVersion=t.int64();break}case 6:{s.docString=t.string();break}case 7:{s.graph=B.onnx.GraphProto.decode(t,t.uint32());break}case 14:{s.metadataProps&&s.metadataProps.length||(s.metadataProps=[]),s.metadataProps.push(B.onnx.StringStringEntryProto.decode(t,t.uint32()));break}case 20:{s.trainingInfo&&s.trainingInfo.length||(s.trainingInfo=[]),s.trainingInfo.push(B.onnx.TrainingInfoProto.decode(t,t.uint32()));break}case 25:{s.functions&&s.functions.length||(s.functions=[]),s.functions.push(B.onnx.FunctionProto.decode(t,t.uint32()));break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof se||(t=new se(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.irVersion!=null&&t.hasOwnProperty("irVersion")&&!N.isInteger(t.irVersion)&&!(t.irVersion&&N.isInteger(t.irVersion.low)&&N.isInteger(t.irVersion.high)))return"irVersion: integer|Long expected";if(t.opsetImport!=null&&t.hasOwnProperty("opsetImport")){if(!Array.isArray(t.opsetImport))return"opsetImport: array expected";for(var i=0;i<t.opsetImport.length;++i){var o=B.onnx.OperatorSetIdProto.verify(t.opsetImport[i]);if(o)return"opsetImport."+o}}if(t.producerName!=null&&t.hasOwnProperty("producerName")&&!N.isString(t.producerName))return"producerName: string expected";if(t.producerVersion!=null&&t.hasOwnProperty("producerVersion")&&!N.isString(t.producerVersion))return"producerVersion: string expected";if(t.domain!=null&&t.hasOwnProperty("domain")&&!N.isString(t.domain))return"domain: string expected";if(t.modelVersion!=null&&t.hasOwnProperty("modelVersion")&&!N.isInteger(t.modelVersion)&&!(t.modelVersion&&N.isInteger(t.modelVersion.low)&&N.isInteger(t.modelVersion.high)))return"modelVersion: integer|Long expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!N.isString(t.docString))return"docString: string expected";if(t.graph!=null&&t.hasOwnProperty("graph")){var o=B.onnx.GraphProto.verify(t.graph);if(o)return"graph."+o}if(t.metadataProps!=null&&t.hasOwnProperty("metadataProps")){if(!Array.isArray(t.metadataProps))return"metadataProps: array expected";for(var i=0;i<t.metadataProps.length;++i){var o=B.onnx.StringStringEntryProto.verify(t.metadataProps[i]);if(o)return"metadataProps."+o}}if(t.trainingInfo!=null&&t.hasOwnProperty("trainingInfo")){if(!Array.isArray(t.trainingInfo))return"trainingInfo: array expected";for(var i=0;i<t.trainingInfo.length;++i){var o=B.onnx.TrainingInfoProto.verify(t.trainingInfo[i]);if(o)return"trainingInfo."+o}}if(t.functions!=null&&t.hasOwnProperty("functions")){if(!Array.isArray(t.functions))return"functions: array expected";for(var i=0;i<t.functions.length;++i){var o=B.onnx.FunctionProto.verify(t.functions[i]);if(o)return"functions."+o}}return null},e.fromObject=function(t){if(t instanceof B.onnx.ModelProto)return t;var i=new B.onnx.ModelProto;if(t.irVersion!=null&&(N.Long?(i.irVersion=N.Long.fromValue(t.irVersion)).unsigned=!1:typeof t.irVersion=="string"?i.irVersion=parseInt(t.irVersion,10):typeof t.irVersion=="number"?i.irVersion=t.irVersion:typeof t.irVersion=="object"&&(i.irVersion=new N.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber())),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");i.opsetImport=[];for(var o=0;o<t.opsetImport.length;++o){if(typeof t.opsetImport[o]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");i.opsetImport[o]=B.onnx.OperatorSetIdProto.fromObject(t.opsetImport[o])}}if(t.producerName!=null&&(i.producerName=String(t.producerName)),t.producerVersion!=null&&(i.producerVersion=String(t.producerVersion)),t.domain!=null&&(i.domain=String(t.domain)),t.modelVersion!=null&&(N.Long?(i.modelVersion=N.Long.fromValue(t.modelVersion)).unsigned=!1:typeof t.modelVersion=="string"?i.modelVersion=parseInt(t.modelVersion,10):typeof t.modelVersion=="number"?i.modelVersion=t.modelVersion:typeof t.modelVersion=="object"&&(i.modelVersion=new N.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber())),t.docString!=null&&(i.docString=String(t.docString)),t.graph!=null){if(typeof t.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");i.graph=B.onnx.GraphProto.fromObject(t.graph)}if(t.metadataProps){if(!Array.isArray(t.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");i.metadataProps=[];for(var o=0;o<t.metadataProps.length;++o){if(typeof t.metadataProps[o]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");i.metadataProps[o]=B.onnx.StringStringEntryProto.fromObject(t.metadataProps[o])}}if(t.trainingInfo){if(!Array.isArray(t.trainingInfo))throw TypeError(".onnx.ModelProto.trainingInfo: array expected");i.trainingInfo=[];for(var o=0;o<t.trainingInfo.length;++o){if(typeof t.trainingInfo[o]!="object")throw TypeError(".onnx.ModelProto.trainingInfo: object expected");i.trainingInfo[o]=B.onnx.TrainingInfoProto.fromObject(t.trainingInfo[o])}}if(t.functions){if(!Array.isArray(t.functions))throw TypeError(".onnx.ModelProto.functions: array expected");i.functions=[];for(var o=0;o<t.functions.length;++o){if(typeof t.functions[o]!="object")throw TypeError(".onnx.ModelProto.functions: object expected");i.functions[o]=B.onnx.FunctionProto.fromObject(t.functions[o])}}return i},e.toObject=function(t,i){i||(i={});var o={};if((i.arrays||i.defaults)&&(o.opsetImport=[],o.metadataProps=[],o.trainingInfo=[],o.functions=[]),i.defaults){if(N.Long){var s=new N.Long(0,0,!1);o.irVersion=i.longs===String?s.toString():i.longs===Number?s.toNumber():s}else o.irVersion=i.longs===String?"0":0;if(o.producerName="",o.producerVersion="",o.domain="",N.Long){var s=new N.Long(0,0,!1);o.modelVersion=i.longs===String?s.toString():i.longs===Number?s.toNumber():s}else o.modelVersion=i.longs===String?"0":0;o.docString="",o.graph=null}if(t.irVersion!=null&&t.hasOwnProperty("irVersion")&&(typeof t.irVersion=="number"?o.irVersion=i.longs===String?String(t.irVersion):t.irVersion:o.irVersion=i.longs===String?N.Long.prototype.toString.call(t.irVersion):i.longs===Number?new N.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber():t.irVersion),t.producerName!=null&&t.hasOwnProperty("producerName")&&(o.producerName=t.producerName),t.producerVersion!=null&&t.hasOwnProperty("producerVersion")&&(o.producerVersion=t.producerVersion),t.domain!=null&&t.hasOwnProperty("domain")&&(o.domain=t.domain),t.modelVersion!=null&&t.hasOwnProperty("modelVersion")&&(typeof t.modelVersion=="number"?o.modelVersion=i.longs===String?String(t.modelVersion):t.modelVersion:o.modelVersion=i.longs===String?N.Long.prototype.toString.call(t.modelVersion):i.longs===Number?new N.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber():t.modelVersion),t.docString!=null&&t.hasOwnProperty("docString")&&(o.docString=t.docString),t.graph!=null&&t.hasOwnProperty("graph")&&(o.graph=B.onnx.GraphProto.toObject(t.graph,i)),t.opsetImport&&t.opsetImport.length){o.opsetImport=[];for(var a=0;a<t.opsetImport.length;++a)o.opsetImport[a]=B.onnx.OperatorSetIdProto.toObject(t.opsetImport[a],i)}if(t.metadataProps&&t.metadataProps.length){o.metadataProps=[];for(var a=0;a<t.metadataProps.length;++a)o.metadataProps[a]=B.onnx.StringStringEntryProto.toObject(t.metadataProps[a],i)}if(t.trainingInfo&&t.trainingInfo.length){o.trainingInfo=[];for(var a=0;a<t.trainingInfo.length;++a)o.trainingInfo[a]=B.onnx.TrainingInfoProto.toObject(t.trainingInfo[a],i)}if(t.functions&&t.functions.length){o.functions=[];for(var a=0;a<t.functions.length;++a)o.functions[a]=B.onnx.FunctionProto.toObject(t.functions[a],i)}return o},e.prototype.toJSON=function(){return this.constructor.toObject(this,rt.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.ModelProto"},e}(),n.StringStringEntryProto=function(){function e(r){if(r)for(var t=Object.keys(r),i=0;i<t.length;++i)r[t[i]]!=null&&(this[t[i]]=r[t[i]])}return e.prototype.key="",e.prototype.value="",e.create=function(t){return new e(t)},e.encode=function(t,i){return i||(i=ht.create()),t.key!=null&&Object.hasOwnProperty.call(t,"key")&&i.uint32(10).string(t.key),t.value!=null&&Object.hasOwnProperty.call(t,"value")&&i.uint32(18).string(t.value),i},e.encodeDelimited=function(t,i){return this.encode(t,i).ldelim()},e.decode=function(t,i){t instanceof se||(t=se.create(t));for(var o=i===void 0?t.len:t.pos+i,s=new B.onnx.StringStringEntryProto;t.pos<o;){var a=t.uint32();switch(a>>>3){case 1:{s.key=t.string();break}case 2:{s.value=t.string();break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof se||(t=new se(t)),this.decode(t,t.uint32())},e.verify=function(t){return typeof t!="object"||t===null?"object expected":t.key!=null&&t.hasOwnProperty("key")&&!N.isString(t.key)?"key: string expected":t.value!=null&&t.hasOwnProperty("value")&&!N.isString(t.value)?"value: string expected":null},e.fromObject=function(t){if(t instanceof B.onnx.StringStringEntryProto)return t;var i=new B.onnx.StringStringEntryProto;return t.key!=null&&(i.key=String(t.key)),t.value!=null&&(i.value=String(t.value)),i},e.toObject=function(t,i){i||(i={});var o={};return i.defaults&&(o.key="",o.value=""),t.key!=null&&t.hasOwnProperty("key")&&(o.key=t.key),t.value!=null&&t.hasOwnProperty("value")&&(o.value=t.value),o},e.prototype.toJSON=function(){return this.constructor.toObject(this,rt.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.StringStringEntryProto"},e}(),n.TensorAnnotation=function(){function e(r){if(this.quantParameterTensorNames=[],r)for(var t=Object.keys(r),i=0;i<t.length;++i)r[t[i]]!=null&&(this[t[i]]=r[t[i]])}return e.prototype.tensorName="",e.prototype.quantParameterTensorNames=N.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,i){if(i||(i=ht.create()),t.tensorName!=null&&Object.hasOwnProperty.call(t,"tensorName")&&i.uint32(10).string(t.tensorName),t.quantParameterTensorNames!=null&&t.quantParameterTensorNames.length)for(var o=0;o<t.quantParameterTensorNames.length;++o)B.onnx.StringStringEntryProto.encode(t.quantParameterTensorNames[o],i.uint32(18).fork()).ldelim();return i},e.encodeDelimited=function(t,i){return this.encode(t,i).ldelim()},e.decode=function(t,i){t instanceof se||(t=se.create(t));for(var o=i===void 0?t.len:t.pos+i,s=new B.onnx.TensorAnnotation;t.pos<o;){var a=t.uint32();switch(a>>>3){case 1:{s.tensorName=t.string();break}case 2:{s.quantParameterTensorNames&&s.quantParameterTensorNames.length||(s.quantParameterTensorNames=[]),s.quantParameterTensorNames.push(B.onnx.StringStringEntryProto.decode(t,t.uint32()));break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof se||(t=new se(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.tensorName!=null&&t.hasOwnProperty("tensorName")&&!N.isString(t.tensorName))return"tensorName: string expected";if(t.quantParameterTensorNames!=null&&t.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(t.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var i=0;i<t.quantParameterTensorNames.length;++i){var o=B.onnx.StringStringEntryProto.verify(t.quantParameterTensorNames[i]);if(o)return"quantParameterTensorNames."+o}}return null},e.fromObject=function(t){if(t instanceof B.onnx.TensorAnnotation)return t;var i=new B.onnx.TensorAnnotation;if(t.tensorName!=null&&(i.tensorName=String(t.tensorName)),t.quantParameterTensorNames){if(!Array.isArray(t.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");i.quantParameterTensorNames=[];for(var o=0;o<t.quantParameterTensorNames.length;++o){if(typeof t.quantParameterTensorNames[o]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");i.quantParameterTensorNames[o]=B.onnx.StringStringEntryProto.fromObject(t.quantParameterTensorNames[o])}}return i},e.toObject=function(t,i){i||(i={});var o={};if((i.arrays||i.defaults)&&(o.quantParameterTensorNames=[]),i.defaults&&(o.tensorName=""),t.tensorName!=null&&t.hasOwnProperty("tensorName")&&(o.tensorName=t.tensorName),t.quantParameterTensorNames&&t.quantParameterTensorNames.length){o.quantParameterTensorNames=[];for(var s=0;s<t.quantParameterTensorNames.length;++s)o.quantParameterTensorNames[s]=B.onnx.StringStringEntryProto.toObject(t.quantParameterTensorNames[s],i)}return o},e.prototype.toJSON=function(){return this.constructor.toObject(this,rt.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorAnnotation"},e}(),n.GraphProto=function(){function e(r){if(this.node=[],this.initializer=[],this.sparseInitializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],r)for(var t=Object.keys(r),i=0;i<t.length;++i)r[t[i]]!=null&&(this[t[i]]=r[t[i]])}return e.prototype.node=N.emptyArray,e.prototype.name="",e.prototype.initializer=N.emptyArray,e.prototype.sparseInitializer=N.emptyArray,e.prototype.docString="",e.prototype.input=N.emptyArray,e.prototype.output=N.emptyArray,e.prototype.valueInfo=N.emptyArray,e.prototype.quantizationAnnotation=N.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,i){if(i||(i=ht.create()),t.node!=null&&t.node.length)for(var o=0;o<t.node.length;++o)B.onnx.NodeProto.encode(t.node[o],i.uint32(10).fork()).ldelim();if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&i.uint32(18).string(t.name),t.initializer!=null&&t.initializer.length)for(var o=0;o<t.initializer.length;++o)B.onnx.TensorProto.encode(t.initializer[o],i.uint32(42).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&i.uint32(82).string(t.docString),t.input!=null&&t.input.length)for(var o=0;o<t.input.length;++o)B.onnx.ValueInfoProto.encode(t.input[o],i.uint32(90).fork()).ldelim();if(t.output!=null&&t.output.length)for(var o=0;o<t.output.length;++o)B.onnx.ValueInfoProto.encode(t.output[o],i.uint32(98).fork()).ldelim();if(t.valueInfo!=null&&t.valueInfo.length)for(var o=0;o<t.valueInfo.length;++o)B.onnx.ValueInfoProto.encode(t.valueInfo[o],i.uint32(106).fork()).ldelim();if(t.quantizationAnnotation!=null&&t.quantizationAnnotation.length)for(var o=0;o<t.quantizationAnnotation.length;++o)B.onnx.TensorAnnotation.encode(t.quantizationAnnotation[o],i.uint32(114).fork()).ldelim();if(t.sparseInitializer!=null&&t.sparseInitializer.length)for(var o=0;o<t.sparseInitializer.length;++o)B.onnx.SparseTensorProto.encode(t.sparseInitializer[o],i.uint32(122).fork()).ldelim();return i},e.encodeDelimited=function(t,i){return this.encode(t,i).ldelim()},e.decode=function(t,i){t instanceof se||(t=se.create(t));for(var o=i===void 0?t.len:t.pos+i,s=new B.onnx.GraphProto;t.pos<o;){var a=t.uint32();switch(a>>>3){case 1:{s.node&&s.node.length||(s.node=[]),s.node.push(B.onnx.NodeProto.decode(t,t.uint32()));break}case 2:{s.name=t.string();break}case 5:{s.initializer&&s.initializer.length||(s.initializer=[]),s.initializer.push(B.onnx.TensorProto.decode(t,t.uint32()));break}case 15:{s.sparseInitializer&&s.sparseInitializer.length||(s.sparseInitializer=[]),s.sparseInitializer.push(B.onnx.SparseTensorProto.decode(t,t.uint32()));break}case 10:{s.docString=t.string();break}case 11:{s.input&&s.input.length||(s.input=[]),s.input.push(B.onnx.ValueInfoProto.decode(t,t.uint32()));break}case 12:{s.output&&s.output.length||(s.output=[]),s.output.push(B.onnx.ValueInfoProto.decode(t,t.uint32()));break}case 13:{s.valueInfo&&s.valueInfo.length||(s.valueInfo=[]),s.valueInfo.push(B.onnx.ValueInfoProto.decode(t,t.uint32()));break}case 14:{s.quantizationAnnotation&&s.quantizationAnnotation.length||(s.quantizationAnnotation=[]),s.quantizationAnnotation.push(B.onnx.TensorAnnotation.decode(t,t.uint32()));break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof se||(t=new se(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.node!=null&&t.hasOwnProperty("node")){if(!Array.isArray(t.node))return"node: array expected";for(var i=0;i<t.node.length;++i){var o=B.onnx.NodeProto.verify(t.node[i]);if(o)return"node."+o}}if(t.name!=null&&t.hasOwnProperty("name")&&!N.isString(t.name))return"name: string expected";if(t.initializer!=null&&t.hasOwnProperty("initializer")){if(!Array.isArray(t.initializer))return"initializer: array expected";for(var i=0;i<t.initializer.length;++i){var o=B.onnx.TensorProto.verify(t.initializer[i]);if(o)return"initializer."+o}}if(t.sparseInitializer!=null&&t.hasOwnProperty("sparseInitializer")){if(!Array.isArray(t.sparseInitializer))return"sparseInitializer: array expected";for(var i=0;i<t.sparseInitializer.length;++i){var o=B.onnx.SparseTensorProto.verify(t.sparseInitializer[i]);if(o)return"sparseInitializer."+o}}if(t.docString!=null&&t.hasOwnProperty("docString")&&!N.isString(t.docString))return"docString: string expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var i=0;i<t.input.length;++i){var o=B.onnx.ValueInfoProto.verify(t.input[i]);if(o)return"input."+o}}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(var i=0;i<t.output.length;++i){var o=B.onnx.ValueInfoProto.verify(t.output[i]);if(o)return"output."+o}}if(t.valueInfo!=null&&t.hasOwnProperty("valueInfo")){if(!Array.isArray(t.valueInfo))return"valueInfo: array expected";for(var i=0;i<t.valueInfo.length;++i){var o=B.onnx.ValueInfoProto.verify(t.valueInfo[i]);if(o)return"valueInfo."+o}}if(t.quantizationAnnotation!=null&&t.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(t.quantizationAnnotation))return"quantizationAnnotation: array expected";for(var i=0;i<t.quantizationAnnotation.length;++i){var o=B.onnx.TensorAnnotation.verify(t.quantizationAnnotation[i]);if(o)return"quantizationAnnotation."+o}}return null},e.fromObject=function(t){if(t instanceof B.onnx.GraphProto)return t;var i=new B.onnx.GraphProto;if(t.node){if(!Array.isArray(t.node))throw TypeError(".onnx.GraphProto.node: array expected");i.node=[];for(var o=0;o<t.node.length;++o){if(typeof t.node[o]!="object")throw TypeError(".onnx.GraphProto.node: object expected");i.node[o]=B.onnx.NodeProto.fromObject(t.node[o])}}if(t.name!=null&&(i.name=String(t.name)),t.initializer){if(!Array.isArray(t.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");i.initializer=[];for(var o=0;o<t.initializer.length;++o){if(typeof t.initializer[o]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");i.initializer[o]=B.onnx.TensorProto.fromObject(t.initializer[o])}}if(t.sparseInitializer){if(!Array.isArray(t.sparseInitializer))throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");i.sparseInitializer=[];for(var o=0;o<t.sparseInitializer.length;++o){if(typeof t.sparseInitializer[o]!="object")throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");i.sparseInitializer[o]=B.onnx.SparseTensorProto.fromObject(t.sparseInitializer[o])}}if(t.docString!=null&&(i.docString=String(t.docString)),t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.GraphProto.input: array expected");i.input=[];for(var o=0;o<t.input.length;++o){if(typeof t.input[o]!="object")throw TypeError(".onnx.GraphProto.input: object expected");i.input[o]=B.onnx.ValueInfoProto.fromObject(t.input[o])}}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.GraphProto.output: array expected");i.output=[];for(var o=0;o<t.output.length;++o){if(typeof t.output[o]!="object")throw TypeError(".onnx.GraphProto.output: object expected");i.output[o]=B.onnx.ValueInfoProto.fromObject(t.output[o])}}if(t.valueInfo){if(!Array.isArray(t.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");i.valueInfo=[];for(var o=0;o<t.valueInfo.length;++o){if(typeof t.valueInfo[o]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");i.valueInfo[o]=B.onnx.ValueInfoProto.fromObject(t.valueInfo[o])}}if(t.quantizationAnnotation){if(!Array.isArray(t.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");i.quantizationAnnotation=[];for(var o=0;o<t.quantizationAnnotation.length;++o){if(typeof t.quantizationAnnotation[o]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");i.quantizationAnnotation[o]=B.onnx.TensorAnnotation.fromObject(t.quantizationAnnotation[o])}}return i},e.toObject=function(t,i){i||(i={});var o={};if((i.arrays||i.defaults)&&(o.node=[],o.initializer=[],o.input=[],o.output=[],o.valueInfo=[],o.quantizationAnnotation=[],o.sparseInitializer=[]),i.defaults&&(o.name="",o.docString=""),t.node&&t.node.length){o.node=[];for(var s=0;s<t.node.length;++s)o.node[s]=B.onnx.NodeProto.toObject(t.node[s],i)}if(t.name!=null&&t.hasOwnProperty("name")&&(o.name=t.name),t.initializer&&t.initializer.length){o.initializer=[];for(var s=0;s<t.initializer.length;++s)o.initializer[s]=B.onnx.TensorProto.toObject(t.initializer[s],i)}if(t.docString!=null&&t.hasOwnProperty("docString")&&(o.docString=t.docString),t.input&&t.input.length){o.input=[];for(var s=0;s<t.input.length;++s)o.input[s]=B.onnx.ValueInfoProto.toObject(t.input[s],i)}if(t.output&&t.output.length){o.output=[];for(var s=0;s<t.output.length;++s)o.output[s]=B.onnx.ValueInfoProto.toObject(t.output[s],i)}if(t.valueInfo&&t.valueInfo.length){o.valueInfo=[];for(var s=0;s<t.valueInfo.length;++s)o.valueInfo[s]=B.onnx.ValueInfoProto.toObject(t.valueInfo[s],i)}if(t.quantizationAnnotation&&t.quantizationAnnotation.length){o.quantizationAnnotation=[];for(var s=0;s<t.quantizationAnnotation.length;++s)o.quantizationAnnotation[s]=B.onnx.TensorAnnotation.toObject(t.quantizationAnnotation[s],i)}if(t.sparseInitializer&&t.sparseInitializer.length){o.sparseInitializer=[];for(var s=0;s<t.sparseInitializer.length;++s)o.sparseInitializer[s]=B.onnx.SparseTensorProto.toObject(t.sparseInitializer[s],i)}return o},e.prototype.toJSON=function(){return this.constructor.toObject(this,rt.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.GraphProto"},e}(),n.TensorProto=function(){function e(r){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],r)for(var t=Object.keys(r),i=0;i<t.length;++i)r[t[i]]!=null&&(this[t[i]]=r[t[i]])}return e.prototype.dims=N.emptyArray,e.prototype.dataType=0,e.prototype.segment=null,e.prototype.floatData=N.emptyArray,e.prototype.int32Data=N.emptyArray,e.prototype.stringData=N.emptyArray,e.prototype.int64Data=N.emptyArray,e.prototype.name="",e.prototype.docString="",e.prototype.rawData=N.newBuffer([]),e.prototype.externalData=N.emptyArray,e.prototype.dataLocation=0,e.prototype.doubleData=N.emptyArray,e.prototype.uint64Data=N.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,i){if(i||(i=ht.create()),t.dims!=null&&t.dims.length){i.uint32(10).fork();for(var o=0;o<t.dims.length;++o)i.int64(t.dims[o]);i.ldelim()}if(t.dataType!=null&&Object.hasOwnProperty.call(t,"dataType")&&i.uint32(16).int32(t.dataType),t.segment!=null&&Object.hasOwnProperty.call(t,"segment")&&B.onnx.TensorProto.Segment.encode(t.segment,i.uint32(26).fork()).ldelim(),t.floatData!=null&&t.floatData.length){i.uint32(34).fork();for(var o=0;o<t.floatData.length;++o)i.float(t.floatData[o]);i.ldelim()}if(t.int32Data!=null&&t.int32Data.length){i.uint32(42).fork();for(var o=0;o<t.int32Data.length;++o)i.int32(t.int32Data[o]);i.ldelim()}if(t.stringData!=null&&t.stringData.length)for(var o=0;o<t.stringData.length;++o)i.uint32(50).bytes(t.stringData[o]);if(t.int64Data!=null&&t.int64Data.length){i.uint32(58).fork();for(var o=0;o<t.int64Data.length;++o)i.int64(t.int64Data[o]);i.ldelim()}if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&i.uint32(66).string(t.name),t.rawData!=null&&Object.hasOwnProperty.call(t,"rawData")&&i.uint32(74).bytes(t.rawData),t.doubleData!=null&&t.doubleData.length){i.uint32(82).fork();for(var o=0;o<t.doubleData.length;++o)i.double(t.doubleData[o]);i.ldelim()}if(t.uint64Data!=null&&t.uint64Data.length){i.uint32(90).fork();for(var o=0;o<t.uint64Data.length;++o)i.uint64(t.uint64Data[o]);i.ldelim()}if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&i.uint32(98).string(t.docString),t.externalData!=null&&t.externalData.length)for(var o=0;o<t.externalData.length;++o)B.onnx.StringStringEntryProto.encode(t.externalData[o],i.uint32(106).fork()).ldelim();return t.dataLocation!=null&&Object.hasOwnProperty.call(t,"dataLocation")&&i.uint32(112).int32(t.dataLocation),i},e.encodeDelimited=function(t,i){return this.encode(t,i).ldelim()},e.decode=function(t,i){t instanceof se||(t=se.create(t));for(var o=i===void 0?t.len:t.pos+i,s=new B.onnx.TensorProto;t.pos<o;){var a=t.uint32();switch(a>>>3){case 1:{if(s.dims&&s.dims.length||(s.dims=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.dims.push(t.int64());else s.dims.push(t.int64());break}case 2:{s.dataType=t.int32();break}case 3:{s.segment=B.onnx.TensorProto.Segment.decode(t,t.uint32());break}case 4:{if(s.floatData&&s.floatData.length||(s.floatData=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.floatData.push(t.float());else s.floatData.push(t.float());break}case 5:{if(s.int32Data&&s.int32Data.length||(s.int32Data=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.int32Data.push(t.int32());else s.int32Data.push(t.int32());break}case 6:{s.stringData&&s.stringData.length||(s.stringData=[]),s.stringData.push(t.bytes());break}case 7:{if(s.int64Data&&s.int64Data.length||(s.int64Data=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.int64Data.push(t.int64());else s.int64Data.push(t.int64());break}case 8:{s.name=t.string();break}case 12:{s.docString=t.string();break}case 9:{s.rawData=t.bytes();break}case 13:{s.externalData&&s.externalData.length||(s.externalData=[]),s.externalData.push(B.onnx.StringStringEntryProto.decode(t,t.uint32()));break}case 14:{s.dataLocation=t.int32();break}case 10:{if(s.doubleData&&s.doubleData.length||(s.doubleData=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.doubleData.push(t.double());else s.doubleData.push(t.double());break}case 11:{if(s.uint64Data&&s.uint64Data.length||(s.uint64Data=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.uint64Data.push(t.uint64());else s.uint64Data.push(t.uint64());break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof se||(t=new se(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.dims!=null&&t.hasOwnProperty("dims")){if(!Array.isArray(t.dims))return"dims: array expected";for(var i=0;i<t.dims.length;++i)if(!N.isInteger(t.dims[i])&&!(t.dims[i]&&N.isInteger(t.dims[i].low)&&N.isInteger(t.dims[i].high)))return"dims: integer|Long[] expected"}if(t.dataType!=null&&t.hasOwnProperty("dataType")&&!N.isInteger(t.dataType))return"dataType: integer expected";if(t.segment!=null&&t.hasOwnProperty("segment")){var o=B.onnx.TensorProto.Segment.verify(t.segment);if(o)return"segment."+o}if(t.floatData!=null&&t.hasOwnProperty("floatData")){if(!Array.isArray(t.floatData))return"floatData: array expected";for(var i=0;i<t.floatData.length;++i)if(typeof t.floatData[i]!="number")return"floatData: number[] expected"}if(t.int32Data!=null&&t.hasOwnProperty("int32Data")){if(!Array.isArray(t.int32Data))return"int32Data: array expected";for(var i=0;i<t.int32Data.length;++i)if(!N.isInteger(t.int32Data[i]))return"int32Data: integer[] expected"}if(t.stringData!=null&&t.hasOwnProperty("stringData")){if(!Array.isArray(t.stringData))return"stringData: array expected";for(var i=0;i<t.stringData.length;++i)if(!(t.stringData[i]&&typeof t.stringData[i].length=="number"||N.isString(t.stringData[i])))return"stringData: buffer[] expected"}if(t.int64Data!=null&&t.hasOwnProperty("int64Data")){if(!Array.isArray(t.int64Data))return"int64Data: array expected";for(var i=0;i<t.int64Data.length;++i)if(!N.isInteger(t.int64Data[i])&&!(t.int64Data[i]&&N.isInteger(t.int64Data[i].low)&&N.isInteger(t.int64Data[i].high)))return"int64Data: integer|Long[] expected"}if(t.name!=null&&t.hasOwnProperty("name")&&!N.isString(t.name))return"name: string expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!N.isString(t.docString))return"docString: string expected";if(t.rawData!=null&&t.hasOwnProperty("rawData")&&!(t.rawData&&typeof t.rawData.length=="number"||N.isString(t.rawData)))return"rawData: buffer expected";if(t.externalData!=null&&t.hasOwnProperty("externalData")){if(!Array.isArray(t.externalData))return"externalData: array expected";for(var i=0;i<t.externalData.length;++i){var o=B.onnx.StringStringEntryProto.verify(t.externalData[i]);if(o)return"externalData."+o}}if(t.dataLocation!=null&&t.hasOwnProperty("dataLocation"))switch(t.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:break}if(t.doubleData!=null&&t.hasOwnProperty("doubleData")){if(!Array.isArray(t.doubleData))return"doubleData: array expected";for(var i=0;i<t.doubleData.length;++i)if(typeof t.doubleData[i]!="number")return"doubleData: number[] expected"}if(t.uint64Data!=null&&t.hasOwnProperty("uint64Data")){if(!Array.isArray(t.uint64Data))return"uint64Data: array expected";for(var i=0;i<t.uint64Data.length;++i)if(!N.isInteger(t.uint64Data[i])&&!(t.uint64Data[i]&&N.isInteger(t.uint64Data[i].low)&&N.isInteger(t.uint64Data[i].high)))return"uint64Data: integer|Long[] expected"}return null},e.fromObject=function(t){if(t instanceof B.onnx.TensorProto)return t;var i=new B.onnx.TensorProto;if(t.dims){if(!Array.isArray(t.dims))throw TypeError(".onnx.TensorProto.dims: array expected");i.dims=[];for(var o=0;o<t.dims.length;++o)N.Long?(i.dims[o]=N.Long.fromValue(t.dims[o])).unsigned=!1:typeof t.dims[o]=="string"?i.dims[o]=parseInt(t.dims[o],10):typeof t.dims[o]=="number"?i.dims[o]=t.dims[o]:typeof t.dims[o]=="object"&&(i.dims[o]=new N.LongBits(t.dims[o].low>>>0,t.dims[o].high>>>0).toNumber())}if(t.dataType!=null&&(i.dataType=t.dataType|0),t.segment!=null){if(typeof t.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");i.segment=B.onnx.TensorProto.Segment.fromObject(t.segment)}if(t.floatData){if(!Array.isArray(t.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");i.floatData=[];for(var o=0;o<t.floatData.length;++o)i.floatData[o]=Number(t.floatData[o])}if(t.int32Data){if(!Array.isArray(t.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");i.int32Data=[];for(var o=0;o<t.int32Data.length;++o)i.int32Data[o]=t.int32Data[o]|0}if(t.stringData){if(!Array.isArray(t.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");i.stringData=[];for(var o=0;o<t.stringData.length;++o)typeof t.stringData[o]=="string"?N.base64.decode(t.stringData[o],i.stringData[o]=N.newBuffer(N.base64.length(t.stringData[o])),0):t.stringData[o].length>=0&&(i.stringData[o]=t.stringData[o])}if(t.int64Data){if(!Array.isArray(t.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");i.int64Data=[];for(var o=0;o<t.int64Data.length;++o)N.Long?(i.int64Data[o]=N.Long.fromValue(t.int64Data[o])).unsigned=!1:typeof t.int64Data[o]=="string"?i.int64Data[o]=parseInt(t.int64Data[o],10):typeof t.int64Data[o]=="number"?i.int64Data[o]=t.int64Data[o]:typeof t.int64Data[o]=="object"&&(i.int64Data[o]=new N.LongBits(t.int64Data[o].low>>>0,t.int64Data[o].high>>>0).toNumber())}if(t.name!=null&&(i.name=String(t.name)),t.docString!=null&&(i.docString=String(t.docString)),t.rawData!=null&&(typeof t.rawData=="string"?N.base64.decode(t.rawData,i.rawData=N.newBuffer(N.base64.length(t.rawData)),0):t.rawData.length>=0&&(i.rawData=t.rawData)),t.externalData){if(!Array.isArray(t.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");i.externalData=[];for(var o=0;o<t.externalData.length;++o){if(typeof t.externalData[o]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");i.externalData[o]=B.onnx.StringStringEntryProto.fromObject(t.externalData[o])}}switch(t.dataLocation){default:if(typeof t.dataLocation=="number"){i.dataLocation=t.dataLocation;break}break;case"DEFAULT":case 0:i.dataLocation=0;break;case"EXTERNAL":case 1:i.dataLocation=1;break}if(t.doubleData){if(!Array.isArray(t.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");i.doubleData=[];for(var o=0;o<t.doubleData.length;++o)i.doubleData[o]=Number(t.doubleData[o])}if(t.uint64Data){if(!Array.isArray(t.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");i.uint64Data=[];for(var o=0;o<t.uint64Data.length;++o)N.Long?(i.uint64Data[o]=N.Long.fromValue(t.uint64Data[o])).unsigned=!0:typeof t.uint64Data[o]=="string"?i.uint64Data[o]=parseInt(t.uint64Data[o],10):typeof t.uint64Data[o]=="number"?i.uint64Data[o]=t.uint64Data[o]:typeof t.uint64Data[o]=="object"&&(i.uint64Data[o]=new N.LongBits(t.uint64Data[o].low>>>0,t.uint64Data[o].high>>>0).toNumber(!0))}return i},e.toObject=function(t,i){i||(i={});var o={};if((i.arrays||i.defaults)&&(o.dims=[],o.floatData=[],o.int32Data=[],o.stringData=[],o.int64Data=[],o.doubleData=[],o.uint64Data=[],o.externalData=[]),i.defaults&&(o.dataType=0,o.segment=null,o.name="",i.bytes===String?o.rawData="":(o.rawData=[],i.bytes!==Array&&(o.rawData=N.newBuffer(o.rawData))),o.docString="",o.dataLocation=i.enums===String?"DEFAULT":0),t.dims&&t.dims.length){o.dims=[];for(var s=0;s<t.dims.length;++s)typeof t.dims[s]=="number"?o.dims[s]=i.longs===String?String(t.dims[s]):t.dims[s]:o.dims[s]=i.longs===String?N.Long.prototype.toString.call(t.dims[s]):i.longs===Number?new N.LongBits(t.dims[s].low>>>0,t.dims[s].high>>>0).toNumber():t.dims[s]}if(t.dataType!=null&&t.hasOwnProperty("dataType")&&(o.dataType=t.dataType),t.segment!=null&&t.hasOwnProperty("segment")&&(o.segment=B.onnx.TensorProto.Segment.toObject(t.segment,i)),t.floatData&&t.floatData.length){o.floatData=[];for(var s=0;s<t.floatData.length;++s)o.floatData[s]=i.json&&!isFinite(t.floatData[s])?String(t.floatData[s]):t.floatData[s]}if(t.int32Data&&t.int32Data.length){o.int32Data=[];for(var s=0;s<t.int32Data.length;++s)o.int32Data[s]=t.int32Data[s]}if(t.stringData&&t.stringData.length){o.stringData=[];for(var s=0;s<t.stringData.length;++s)o.stringData[s]=i.bytes===String?N.base64.encode(t.stringData[s],0,t.stringData[s].length):i.bytes===Array?Array.prototype.slice.call(t.stringData[s]):t.stringData[s]}if(t.int64Data&&t.int64Data.length){o.int64Data=[];for(var s=0;s<t.int64Data.length;++s)typeof t.int64Data[s]=="number"?o.int64Data[s]=i.longs===String?String(t.int64Data[s]):t.int64Data[s]:o.int64Data[s]=i.longs===String?N.Long.prototype.toString.call(t.int64Data[s]):i.longs===Number?new N.LongBits(t.int64Data[s].low>>>0,t.int64Data[s].high>>>0).toNumber():t.int64Data[s]}if(t.name!=null&&t.hasOwnProperty("name")&&(o.name=t.name),t.rawData!=null&&t.hasOwnProperty("rawData")&&(o.rawData=i.bytes===String?N.base64.encode(t.rawData,0,t.rawData.length):i.bytes===Array?Array.prototype.slice.call(t.rawData):t.rawData),t.doubleData&&t.doubleData.length){o.doubleData=[];for(var s=0;s<t.doubleData.length;++s)o.doubleData[s]=i.json&&!isFinite(t.doubleData[s])?String(t.doubleData[s]):t.doubleData[s]}if(t.uint64Data&&t.uint64Data.length){o.uint64Data=[];for(var s=0;s<t.uint64Data.length;++s)typeof t.uint64Data[s]=="number"?o.uint64Data[s]=i.longs===String?String(t.uint64Data[s]):t.uint64Data[s]:o.uint64Data[s]=i.longs===String?N.Long.prototype.toString.call(t.uint64Data[s]):i.longs===Number?new N.LongBits(t.uint64Data[s].low>>>0,t.uint64Data[s].high>>>0).toNumber(!0):t.uint64Data[s]}if(t.docString!=null&&t.hasOwnProperty("docString")&&(o.docString=t.docString),t.externalData&&t.externalData.length){o.externalData=[];for(var s=0;s<t.externalData.length;++s)o.externalData[s]=B.onnx.StringStringEntryProto.toObject(t.externalData[s],i)}return t.dataLocation!=null&&t.hasOwnProperty("dataLocation")&&(o.dataLocation=i.enums===String?B.onnx.TensorProto.DataLocation[t.dataLocation]===void 0?t.dataLocation:B.onnx.TensorProto.DataLocation[t.dataLocation]:t.dataLocation),o},e.prototype.toJSON=function(){return this.constructor.toObject(this,rt.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorProto"},e.DataType=function(){var r={},t=Object.create(r);return t[r[0]="UNDEFINED"]=0,t[r[1]="FLOAT"]=1,t[r[2]="UINT8"]=2,t[r[3]="INT8"]=3,t[r[4]="UINT16"]=4,t[r[5]="INT16"]=5,t[r[6]="INT32"]=6,t[r[7]="INT64"]=7,t[r[8]="STRING"]=8,t[r[9]="BOOL"]=9,t[r[10]="FLOAT16"]=10,t[r[11]="DOUBLE"]=11,t[r[12]="UINT32"]=12,t[r[13]="UINT64"]=13,t[r[14]="COMPLEX64"]=14,t[r[15]="COMPLEX128"]=15,t[r[16]="BFLOAT16"]=16,t[r[17]="FLOAT8E4M3FN"]=17,t[r[18]="FLOAT8E4M3FNUZ"]=18,t[r[19]="FLOAT8E5M2"]=19,t[r[20]="FLOAT8E5M2FNUZ"]=20,t}(),e.Segment=function(){function r(t){if(t)for(var i=Object.keys(t),o=0;o<i.length;++o)t[i[o]]!=null&&(this[i[o]]=t[i[o]])}return r.prototype.begin=N.Long?N.Long.fromBits(0,0,!1):0,r.prototype.end=N.Long?N.Long.fromBits(0,0,!1):0,r.create=function(i){return new r(i)},r.encode=function(i,o){return o||(o=ht.create()),i.begin!=null&&Object.hasOwnProperty.call(i,"begin")&&o.uint32(8).int64(i.begin),i.end!=null&&Object.hasOwnProperty.call(i,"end")&&o.uint32(16).int64(i.end),o},r.encodeDelimited=function(i,o){return this.encode(i,o).ldelim()},r.decode=function(i,o){i instanceof se||(i=se.create(i));for(var s=o===void 0?i.len:i.pos+o,a=new B.onnx.TensorProto.Segment;i.pos<s;){var u=i.uint32();switch(u>>>3){case 1:{a.begin=i.int64();break}case 2:{a.end=i.int64();break}default:i.skipType(u&7);break}}return a},r.decodeDelimited=function(i){return i instanceof se||(i=new se(i)),this.decode(i,i.uint32())},r.verify=function(i){return typeof i!="object"||i===null?"object expected":i.begin!=null&&i.hasOwnProperty("begin")&&!N.isInteger(i.begin)&&!(i.begin&&N.isInteger(i.begin.low)&&N.isInteger(i.begin.high))?"begin: integer|Long expected":i.end!=null&&i.hasOwnProperty("end")&&!N.isInteger(i.end)&&!(i.end&&N.isInteger(i.end.low)&&N.isInteger(i.end.high))?"end: integer|Long expected":null},r.fromObject=function(i){if(i instanceof B.onnx.TensorProto.Segment)return i;var o=new B.onnx.TensorProto.Segment;return i.begin!=null&&(N.Long?(o.begin=N.Long.fromValue(i.begin)).unsigned=!1:typeof i.begin=="string"?o.begin=parseInt(i.begin,10):typeof i.begin=="number"?o.begin=i.begin:typeof i.begin=="object"&&(o.begin=new N.LongBits(i.begin.low>>>0,i.begin.high>>>0).toNumber())),i.end!=null&&(N.Long?(o.end=N.Long.fromValue(i.end)).unsigned=!1:typeof i.end=="string"?o.end=parseInt(i.end,10):typeof i.end=="number"?o.end=i.end:typeof i.end=="object"&&(o.end=new N.LongBits(i.end.low>>>0,i.end.high>>>0).toNumber())),o},r.toObject=function(i,o){o||(o={});var s={};if(o.defaults){if(N.Long){var a=new N.Long(0,0,!1);s.begin=o.longs===String?a.toString():o.longs===Number?a.toNumber():a}else s.begin=o.longs===String?"0":0;if(N.Long){var a=new N.Long(0,0,!1);s.end=o.longs===String?a.toString():o.longs===Number?a.toNumber():a}else s.end=o.longs===String?"0":0}return i.begin!=null&&i.hasOwnProperty("begin")&&(typeof i.begin=="number"?s.begin=o.longs===String?String(i.begin):i.begin:s.begin=o.longs===String?N.Long.prototype.toString.call(i.begin):o.longs===Number?new N.LongBits(i.begin.low>>>0,i.begin.high>>>0).toNumber():i.begin),i.end!=null&&i.hasOwnProperty("end")&&(typeof i.end=="number"?s.end=o.longs===String?String(i.end):i.end:s.end=o.longs===String?N.Long.prototype.toString.call(i.end):o.longs===Number?new N.LongBits(i.end.low>>>0,i.end.high>>>0).toNumber():i.end),s},r.prototype.toJSON=function(){return this.constructor.toObject(this,rt.util.toJSONOptions)},r.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TensorProto.Segment"},r}(),e.DataLocation=function(){var r={},t=Object.create(r);return t[r[0]="DEFAULT"]=0,t[r[1]="EXTERNAL"]=1,t}(),e}(),n.SparseTensorProto=function(){function e(r){if(this.dims=[],r)for(var t=Object.keys(r),i=0;i<t.length;++i)r[t[i]]!=null&&(this[t[i]]=r[t[i]])}return e.prototype.values=null,e.prototype.indices=null,e.prototype.dims=N.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,i){if(i||(i=ht.create()),t.values!=null&&Object.hasOwnProperty.call(t,"values")&&B.onnx.TensorProto.encode(t.values,i.uint32(10).fork()).ldelim(),t.indices!=null&&Object.hasOwnProperty.call(t,"indices")&&B.onnx.TensorProto.encode(t.indices,i.uint32(18).fork()).ldelim(),t.dims!=null&&t.dims.length){i.uint32(26).fork();for(var o=0;o<t.dims.length;++o)i.int64(t.dims[o]);i.ldelim()}return i},e.encodeDelimited=function(t,i){return this.encode(t,i).ldelim()},e.decode=function(t,i){t instanceof se||(t=se.create(t));for(var o=i===void 0?t.len:t.pos+i,s=new B.onnx.SparseTensorProto;t.pos<o;){var a=t.uint32();switch(a>>>3){case 1:{s.values=B.onnx.TensorProto.decode(t,t.uint32());break}case 2:{s.indices=B.onnx.TensorProto.decode(t,t.uint32());break}case 3:{if(s.dims&&s.dims.length||(s.dims=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.dims.push(t.int64());else s.dims.push(t.int64());break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof se||(t=new se(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.values!=null&&t.hasOwnProperty("values")){var i=B.onnx.TensorProto.verify(t.values);if(i)return"values."+i}if(t.indices!=null&&t.hasOwnProperty("indices")){var i=B.onnx.TensorProto.verify(t.indices);if(i)return"indices."+i}if(t.dims!=null&&t.hasOwnProperty("dims")){if(!Array.isArray(t.dims))return"dims: array expected";for(var o=0;o<t.dims.length;++o)if(!N.isInteger(t.dims[o])&&!(t.dims[o]&&N.isInteger(t.dims[o].low)&&N.isInteger(t.dims[o].high)))return"dims: integer|Long[] expected"}return null},e.fromObject=function(t){if(t instanceof B.onnx.SparseTensorProto)return t;var i=new B.onnx.SparseTensorProto;if(t.values!=null){if(typeof t.values!="object")throw TypeError(".onnx.SparseTensorProto.values: object expected");i.values=B.onnx.TensorProto.fromObject(t.values)}if(t.indices!=null){if(typeof t.indices!="object")throw TypeError(".onnx.SparseTensorProto.indices: object expected");i.indices=B.onnx.TensorProto.fromObject(t.indices)}if(t.dims){if(!Array.isArray(t.dims))throw TypeError(".onnx.SparseTensorProto.dims: array expected");i.dims=[];for(var o=0;o<t.dims.length;++o)N.Long?(i.dims[o]=N.Long.fromValue(t.dims[o])).unsigned=!1:typeof t.dims[o]=="string"?i.dims[o]=parseInt(t.dims[o],10):typeof t.dims[o]=="number"?i.dims[o]=t.dims[o]:typeof t.dims[o]=="object"&&(i.dims[o]=new N.LongBits(t.dims[o].low>>>0,t.dims[o].high>>>0).toNumber())}return i},e.toObject=function(t,i){i||(i={});var o={};if((i.arrays||i.defaults)&&(o.dims=[]),i.defaults&&(o.values=null,o.indices=null),t.values!=null&&t.hasOwnProperty("values")&&(o.values=B.onnx.TensorProto.toObject(t.values,i)),t.indices!=null&&t.hasOwnProperty("indices")&&(o.indices=B.onnx.TensorProto.toObject(t.indices,i)),t.dims&&t.dims.length){o.dims=[];for(var s=0;s<t.dims.length;++s)typeof t.dims[s]=="number"?o.dims[s]=i.longs===String?String(t.dims[s]):t.dims[s]:o.dims[s]=i.longs===String?N.Long.prototype.toString.call(t.dims[s]):i.longs===Number?new N.LongBits(t.dims[s].low>>>0,t.dims[s].high>>>0).toNumber():t.dims[s]}return o},e.prototype.toJSON=function(){return this.constructor.toObject(this,rt.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.SparseTensorProto"},e}(),n.TensorShapeProto=function(){function e(r){if(this.dim=[],r)for(var t=Object.keys(r),i=0;i<t.length;++i)r[t[i]]!=null&&(this[t[i]]=r[t[i]])}return e.prototype.dim=N.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,i){if(i||(i=ht.create()),t.dim!=null&&t.dim.length)for(var o=0;o<t.dim.length;++o)B.onnx.TensorShapeProto.Dimension.encode(t.dim[o],i.uint32(10).fork()).ldelim();return i},e.encodeDelimited=function(t,i){return this.encode(t,i).ldelim()},e.decode=function(t,i){t instanceof se||(t=se.create(t));for(var o=i===void 0?t.len:t.pos+i,s=new B.onnx.TensorShapeProto;t.pos<o;){var a=t.uint32();switch(a>>>3){case 1:{s.dim&&s.dim.length||(s.dim=[]),s.dim.push(B.onnx.TensorShapeProto.Dimension.decode(t,t.uint32()));break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof se||(t=new se(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.dim!=null&&t.hasOwnProperty("dim")){if(!Array.isArray(t.dim))return"dim: array expected";for(var i=0;i<t.dim.length;++i){var o=B.onnx.TensorShapeProto.Dimension.verify(t.dim[i]);if(o)return"dim."+o}}return null},e.fromObject=function(t){if(t instanceof B.onnx.TensorShapeProto)return t;var i=new B.onnx.TensorShapeProto;if(t.dim){if(!Array.isArray(t.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");i.dim=[];for(var o=0;o<t.dim.length;++o){if(typeof t.dim[o]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");i.dim[o]=B.onnx.TensorShapeProto.Dimension.fromObject(t.dim[o])}}return i},e.toObject=function(t,i){i||(i={});var o={};if((i.arrays||i.defaults)&&(o.dim=[]),t.dim&&t.dim.length){o.dim=[];for(var s=0;s<t.dim.length;++s)o.dim[s]=B.onnx.TensorShapeProto.Dimension.toObject(t.dim[s],i)}return o},e.prototype.toJSON=function(){return this.constructor.toObject(this,rt.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorShapeProto"},e.Dimension=function(){function r(i){if(i)for(var o=Object.keys(i),s=0;s<o.length;++s)i[o[s]]!=null&&(this[o[s]]=i[o[s]])}r.prototype.dimValue=null,r.prototype.dimParam=null,r.prototype.denotation="";var t;return Object.defineProperty(r.prototype,"value",{get:N.oneOfGetter(t=["dimValue","dimParam"]),set:N.oneOfSetter(t)}),r.create=function(o){return new r(o)},r.encode=function(o,s){return s||(s=ht.create()),o.dimValue!=null&&Object.hasOwnProperty.call(o,"dimValue")&&s.uint32(8).int64(o.dimValue),o.dimParam!=null&&Object.hasOwnProperty.call(o,"dimParam")&&s.uint32(18).string(o.dimParam),o.denotation!=null&&Object.hasOwnProperty.call(o,"denotation")&&s.uint32(26).string(o.denotation),s},r.encodeDelimited=function(o,s){return this.encode(o,s).ldelim()},r.decode=function(o,s){o instanceof se||(o=se.create(o));for(var a=s===void 0?o.len:o.pos+s,u=new B.onnx.TensorShapeProto.Dimension;o.pos<a;){var c=o.uint32();switch(c>>>3){case 1:{u.dimValue=o.int64();break}case 2:{u.dimParam=o.string();break}case 3:{u.denotation=o.string();break}default:o.skipType(c&7);break}}return u},r.decodeDelimited=function(o){return o instanceof se||(o=new se(o)),this.decode(o,o.uint32())},r.verify=function(o){if(typeof o!="object"||o===null)return"object expected";var s={};if(o.dimValue!=null&&o.hasOwnProperty("dimValue")&&(s.value=1,!N.isInteger(o.dimValue)&&!(o.dimValue&&N.isInteger(o.dimValue.low)&&N.isInteger(o.dimValue.high))))return"dimValue: integer|Long expected";if(o.dimParam!=null&&o.hasOwnProperty("dimParam")){if(s.value===1)return"value: multiple values";if(s.value=1,!N.isString(o.dimParam))return"dimParam: string expected"}return o.denotation!=null&&o.hasOwnProperty("denotation")&&!N.isString(o.denotation)?"denotation: string expected":null},r.fromObject=function(o){if(o instanceof B.onnx.TensorShapeProto.Dimension)return o;var s=new B.onnx.TensorShapeProto.Dimension;return o.dimValue!=null&&(N.Long?(s.dimValue=N.Long.fromValue(o.dimValue)).unsigned=!1:typeof o.dimValue=="string"?s.dimValue=parseInt(o.dimValue,10):typeof o.dimValue=="number"?s.dimValue=o.dimValue:typeof o.dimValue=="object"&&(s.dimValue=new N.LongBits(o.dimValue.low>>>0,o.dimValue.high>>>0).toNumber())),o.dimParam!=null&&(s.dimParam=String(o.dimParam)),o.denotation!=null&&(s.denotation=String(o.denotation)),s},r.toObject=function(o,s){s||(s={});var a={};return s.defaults&&(a.denotation=""),o.dimValue!=null&&o.hasOwnProperty("dimValue")&&(typeof o.dimValue=="number"?a.dimValue=s.longs===String?String(o.dimValue):o.dimValue:a.dimValue=s.longs===String?N.Long.prototype.toString.call(o.dimValue):s.longs===Number?new N.LongBits(o.dimValue.low>>>0,o.dimValue.high>>>0).toNumber():o.dimValue,s.oneofs&&(a.value="dimValue")),o.dimParam!=null&&o.hasOwnProperty("dimParam")&&(a.dimParam=o.dimParam,s.oneofs&&(a.value="dimParam")),o.denotation!=null&&o.hasOwnProperty("denotation")&&(a.denotation=o.denotation),a},r.prototype.toJSON=function(){return this.constructor.toObject(this,rt.util.toJSONOptions)},r.getTypeUrl=function(o){return o===void 0&&(o="type.googleapis.com"),o+"/onnx.TensorShapeProto.Dimension"},r}(),e}(),n.TypeProto=function(){function e(t){if(t)for(var i=Object.keys(t),o=0;o<i.length;++o)t[i[o]]!=null&&(this[i[o]]=t[i[o]])}e.prototype.tensorType=null,e.prototype.sequenceType=null,e.prototype.mapType=null,e.prototype.optionalType=null,e.prototype.sparseTensorType=null,e.prototype.denotation="";var r;return Object.defineProperty(e.prototype,"value",{get:N.oneOfGetter(r=["tensorType","sequenceType","mapType","optionalType","sparseTensorType"]),set:N.oneOfSetter(r)}),e.create=function(i){return new e(i)},e.encode=function(i,o){return o||(o=ht.create()),i.tensorType!=null&&Object.hasOwnProperty.call(i,"tensorType")&&B.onnx.TypeProto.Tensor.encode(i.tensorType,o.uint32(10).fork()).ldelim(),i.sequenceType!=null&&Object.hasOwnProperty.call(i,"sequenceType")&&B.onnx.TypeProto.Sequence.encode(i.sequenceType,o.uint32(34).fork()).ldelim(),i.mapType!=null&&Object.hasOwnProperty.call(i,"mapType")&&B.onnx.TypeProto.Map.encode(i.mapType,o.uint32(42).fork()).ldelim(),i.denotation!=null&&Object.hasOwnProperty.call(i,"denotation")&&o.uint32(50).string(i.denotation),i.sparseTensorType!=null&&Object.hasOwnProperty.call(i,"sparseTensorType")&&B.onnx.TypeProto.SparseTensor.encode(i.sparseTensorType,o.uint32(66).fork()).ldelim(),i.optionalType!=null&&Object.hasOwnProperty.call(i,"optionalType")&&B.onnx.TypeProto.Optional.encode(i.optionalType,o.uint32(74).fork()).ldelim(),o},e.encodeDelimited=function(i,o){return this.encode(i,o).ldelim()},e.decode=function(i,o){i instanceof se||(i=se.create(i));for(var s=o===void 0?i.len:i.pos+o,a=new B.onnx.TypeProto;i.pos<s;){var u=i.uint32();switch(u>>>3){case 1:{a.tensorType=B.onnx.TypeProto.Tensor.decode(i,i.uint32());break}case 4:{a.sequenceType=B.onnx.TypeProto.Sequence.decode(i,i.uint32());break}case 5:{a.mapType=B.onnx.TypeProto.Map.decode(i,i.uint32());break}case 9:{a.optionalType=B.onnx.TypeProto.Optional.decode(i,i.uint32());break}case 8:{a.sparseTensorType=B.onnx.TypeProto.SparseTensor.decode(i,i.uint32());break}case 6:{a.denotation=i.string();break}default:i.skipType(u&7);break}}return a},e.decodeDelimited=function(i){return i instanceof se||(i=new se(i)),this.decode(i,i.uint32())},e.verify=function(i){if(typeof i!="object"||i===null)return"object expected";var o={};if(i.tensorType!=null&&i.hasOwnProperty("tensorType")){o.value=1;{var s=B.onnx.TypeProto.Tensor.verify(i.tensorType);if(s)return"tensorType."+s}}if(i.sequenceType!=null&&i.hasOwnProperty("sequenceType")){if(o.value===1)return"value: multiple values";o.value=1;{var s=B.onnx.TypeProto.Sequence.verify(i.sequenceType);if(s)return"sequenceType."+s}}if(i.mapType!=null&&i.hasOwnProperty("mapType")){if(o.value===1)return"value: multiple values";o.value=1;{var s=B.onnx.TypeProto.Map.verify(i.mapType);if(s)return"mapType."+s}}if(i.optionalType!=null&&i.hasOwnProperty("optionalType")){if(o.value===1)return"value: multiple values";o.value=1;{var s=B.onnx.TypeProto.Optional.verify(i.optionalType);if(s)return"optionalType."+s}}if(i.sparseTensorType!=null&&i.hasOwnProperty("sparseTensorType")){if(o.value===1)return"value: multiple values";o.value=1;{var s=B.onnx.TypeProto.SparseTensor.verify(i.sparseTensorType);if(s)return"sparseTensorType."+s}}return i.denotation!=null&&i.hasOwnProperty("denotation")&&!N.isString(i.denotation)?"denotation: string expected":null},e.fromObject=function(i){if(i instanceof B.onnx.TypeProto)return i;var o=new B.onnx.TypeProto;if(i.tensorType!=null){if(typeof i.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");o.tensorType=B.onnx.TypeProto.Tensor.fromObject(i.tensorType)}if(i.sequenceType!=null){if(typeof i.sequenceType!="object")throw TypeError(".onnx.TypeProto.sequenceType: object expected");o.sequenceType=B.onnx.TypeProto.Sequence.fromObject(i.sequenceType)}if(i.mapType!=null){if(typeof i.mapType!="object")throw TypeError(".onnx.TypeProto.mapType: object expected");o.mapType=B.onnx.TypeProto.Map.fromObject(i.mapType)}if(i.optionalType!=null){if(typeof i.optionalType!="object")throw TypeError(".onnx.TypeProto.optionalType: object expected");o.optionalType=B.onnx.TypeProto.Optional.fromObject(i.optionalType)}if(i.sparseTensorType!=null){if(typeof i.sparseTensorType!="object")throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");o.sparseTensorType=B.onnx.TypeProto.SparseTensor.fromObject(i.sparseTensorType)}return i.denotation!=null&&(o.denotation=String(i.denotation)),o},e.toObject=function(i,o){o||(o={});var s={};return o.defaults&&(s.denotation=""),i.tensorType!=null&&i.hasOwnProperty("tensorType")&&(s.tensorType=B.onnx.TypeProto.Tensor.toObject(i.tensorType,o),o.oneofs&&(s.value="tensorType")),i.sequenceType!=null&&i.hasOwnProperty("sequenceType")&&(s.sequenceType=B.onnx.TypeProto.Sequence.toObject(i.sequenceType,o),o.oneofs&&(s.value="sequenceType")),i.mapType!=null&&i.hasOwnProperty("mapType")&&(s.mapType=B.onnx.TypeProto.Map.toObject(i.mapType,o),o.oneofs&&(s.value="mapType")),i.denotation!=null&&i.hasOwnProperty("denotation")&&(s.denotation=i.denotation),i.sparseTensorType!=null&&i.hasOwnProperty("sparseTensorType")&&(s.sparseTensorType=B.onnx.TypeProto.SparseTensor.toObject(i.sparseTensorType,o),o.oneofs&&(s.value="sparseTensorType")),i.optionalType!=null&&i.hasOwnProperty("optionalType")&&(s.optionalType=B.onnx.TypeProto.Optional.toObject(i.optionalType,o),o.oneofs&&(s.value="optionalType")),s},e.prototype.toJSON=function(){return this.constructor.toObject(this,rt.util.toJSONOptions)},e.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto"},e.Tensor=function(){function t(i){if(i)for(var o=Object.keys(i),s=0;s<o.length;++s)i[o[s]]!=null&&(this[o[s]]=i[o[s]])}return t.prototype.elemType=0,t.prototype.shape=null,t.create=function(o){return new t(o)},t.encode=function(o,s){return s||(s=ht.create()),o.elemType!=null&&Object.hasOwnProperty.call(o,"elemType")&&s.uint32(8).int32(o.elemType),o.shape!=null&&Object.hasOwnProperty.call(o,"shape")&&B.onnx.TensorShapeProto.encode(o.shape,s.uint32(18).fork()).ldelim(),s},t.encodeDelimited=function(o,s){return this.encode(o,s).ldelim()},t.decode=function(o,s){o instanceof se||(o=se.create(o));for(var a=s===void 0?o.len:o.pos+s,u=new B.onnx.TypeProto.Tensor;o.pos<a;){var c=o.uint32();switch(c>>>3){case 1:{u.elemType=o.int32();break}case 2:{u.shape=B.onnx.TensorShapeProto.decode(o,o.uint32());break}default:o.skipType(c&7);break}}return u},t.decodeDelimited=function(o){return o instanceof se||(o=new se(o)),this.decode(o,o.uint32())},t.verify=function(o){if(typeof o!="object"||o===null)return"object expected";if(o.elemType!=null&&o.hasOwnProperty("elemType")&&!N.isInteger(o.elemType))return"elemType: integer expected";if(o.shape!=null&&o.hasOwnProperty("shape")){var s=B.onnx.TensorShapeProto.verify(o.shape);if(s)return"shape."+s}return null},t.fromObject=function(o){if(o instanceof B.onnx.TypeProto.Tensor)return o;var s=new B.onnx.TypeProto.Tensor;if(o.elemType!=null&&(s.elemType=o.elemType|0),o.shape!=null){if(typeof o.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");s.shape=B.onnx.TensorShapeProto.fromObject(o.shape)}return s},t.toObject=function(o,s){s||(s={});var a={};return s.defaults&&(a.elemType=0,a.shape=null),o.elemType!=null&&o.hasOwnProperty("elemType")&&(a.elemType=o.elemType),o.shape!=null&&o.hasOwnProperty("shape")&&(a.shape=B.onnx.TensorShapeProto.toObject(o.shape,s)),a},t.prototype.toJSON=function(){return this.constructor.toObject(this,rt.util.toJSONOptions)},t.getTypeUrl=function(o){return o===void 0&&(o="type.googleapis.com"),o+"/onnx.TypeProto.Tensor"},t}(),e.Sequence=function(){function t(i){if(i)for(var o=Object.keys(i),s=0;s<o.length;++s)i[o[s]]!=null&&(this[o[s]]=i[o[s]])}return t.prototype.elemType=null,t.create=function(o){return new t(o)},t.encode=function(o,s){return s||(s=ht.create()),o.elemType!=null&&Object.hasOwnProperty.call(o,"elemType")&&B.onnx.TypeProto.encode(o.elemType,s.uint32(10).fork()).ldelim(),s},t.encodeDelimited=function(o,s){return this.encode(o,s).ldelim()},t.decode=function(o,s){o instanceof se||(o=se.create(o));for(var a=s===void 0?o.len:o.pos+s,u=new B.onnx.TypeProto.Sequence;o.pos<a;){var c=o.uint32();switch(c>>>3){case 1:{u.elemType=B.onnx.TypeProto.decode(o,o.uint32());break}default:o.skipType(c&7);break}}return u},t.decodeDelimited=function(o){return o instanceof se||(o=new se(o)),this.decode(o,o.uint32())},t.verify=function(o){if(typeof o!="object"||o===null)return"object expected";if(o.elemType!=null&&o.hasOwnProperty("elemType")){var s=B.onnx.TypeProto.verify(o.elemType);if(s)return"elemType."+s}return null},t.fromObject=function(o){if(o instanceof B.onnx.TypeProto.Sequence)return o;var s=new B.onnx.TypeProto.Sequence;if(o.elemType!=null){if(typeof o.elemType!="object")throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");s.elemType=B.onnx.TypeProto.fromObject(o.elemType)}return s},t.toObject=function(o,s){s||(s={});var a={};return s.defaults&&(a.elemType=null),o.elemType!=null&&o.hasOwnProperty("elemType")&&(a.elemType=B.onnx.TypeProto.toObject(o.elemType,s)),a},t.prototype.toJSON=function(){return this.constructor.toObject(this,rt.util.toJSONOptions)},t.getTypeUrl=function(o){return o===void 0&&(o="type.googleapis.com"),o+"/onnx.TypeProto.Sequence"},t}(),e.Map=function(){function t(i){if(i)for(var o=Object.keys(i),s=0;s<o.length;++s)i[o[s]]!=null&&(this[o[s]]=i[o[s]])}return t.prototype.keyType=0,t.prototype.valueType=null,t.create=function(o){return new t(o)},t.encode=function(o,s){return s||(s=ht.create()),o.keyType!=null&&Object.hasOwnProperty.call(o,"keyType")&&s.uint32(8).int32(o.keyType),o.valueType!=null&&Object.hasOwnProperty.call(o,"valueType")&&B.onnx.TypeProto.encode(o.valueType,s.uint32(18).fork()).ldelim(),s},t.encodeDelimited=function(o,s){return this.encode(o,s).ldelim()},t.decode=function(o,s){o instanceof se||(o=se.create(o));for(var a=s===void 0?o.len:o.pos+s,u=new B.onnx.TypeProto.Map;o.pos<a;){var c=o.uint32();switch(c>>>3){case 1:{u.keyType=o.int32();break}case 2:{u.valueType=B.onnx.TypeProto.decode(o,o.uint32());break}default:o.skipType(c&7);break}}return u},t.decodeDelimited=function(o){return o instanceof se||(o=new se(o)),this.decode(o,o.uint32())},t.verify=function(o){if(typeof o!="object"||o===null)return"object expected";if(o.keyType!=null&&o.hasOwnProperty("keyType")&&!N.isInteger(o.keyType))return"keyType: integer expected";if(o.valueType!=null&&o.hasOwnProperty("valueType")){var s=B.onnx.TypeProto.verify(o.valueType);if(s)return"valueType."+s}return null},t.fromObject=function(o){if(o instanceof B.onnx.TypeProto.Map)return o;var s=new B.onnx.TypeProto.Map;if(o.keyType!=null&&(s.keyType=o.keyType|0),o.valueType!=null){if(typeof o.valueType!="object")throw TypeError(".onnx.TypeProto.Map.valueType: object expected");s.valueType=B.onnx.TypeProto.fromObject(o.valueType)}return s},t.toObject=function(o,s){s||(s={});var a={};return s.defaults&&(a.keyType=0,a.valueType=null),o.keyType!=null&&o.hasOwnProperty("keyType")&&(a.keyType=o.keyType),o.valueType!=null&&o.hasOwnProperty("valueType")&&(a.valueType=B.onnx.TypeProto.toObject(o.valueType,s)),a},t.prototype.toJSON=function(){return this.constructor.toObject(this,rt.util.toJSONOptions)},t.getTypeUrl=function(o){return o===void 0&&(o="type.googleapis.com"),o+"/onnx.TypeProto.Map"},t}(),e.Optional=function(){function t(i){if(i)for(var o=Object.keys(i),s=0;s<o.length;++s)i[o[s]]!=null&&(this[o[s]]=i[o[s]])}return t.prototype.elemType=null,t.create=function(o){return new t(o)},t.encode=function(o,s){return s||(s=ht.create()),o.elemType!=null&&Object.hasOwnProperty.call(o,"elemType")&&B.onnx.TypeProto.encode(o.elemType,s.uint32(10).fork()).ldelim(),s},t.encodeDelimited=function(o,s){return this.encode(o,s).ldelim()},t.decode=function(o,s){o instanceof se||(o=se.create(o));for(var a=s===void 0?o.len:o.pos+s,u=new B.onnx.TypeProto.Optional;o.pos<a;){var c=o.uint32();switch(c>>>3){case 1:{u.elemType=B.onnx.TypeProto.decode(o,o.uint32());break}default:o.skipType(c&7);break}}return u},t.decodeDelimited=function(o){return o instanceof se||(o=new se(o)),this.decode(o,o.uint32())},t.verify=function(o){if(typeof o!="object"||o===null)return"object expected";if(o.elemType!=null&&o.hasOwnProperty("elemType")){var s=B.onnx.TypeProto.verify(o.elemType);if(s)return"elemType."+s}return null},t.fromObject=function(o){if(o instanceof B.onnx.TypeProto.Optional)return o;var s=new B.onnx.TypeProto.Optional;if(o.elemType!=null){if(typeof o.elemType!="object")throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");s.elemType=B.onnx.TypeProto.fromObject(o.elemType)}return s},t.toObject=function(o,s){s||(s={});var a={};return s.defaults&&(a.elemType=null),o.elemType!=null&&o.hasOwnProperty("elemType")&&(a.elemType=B.onnx.TypeProto.toObject(o.elemType,s)),a},t.prototype.toJSON=function(){return this.constructor.toObject(this,rt.util.toJSONOptions)},t.getTypeUrl=function(o){return o===void 0&&(o="type.googleapis.com"),o+"/onnx.TypeProto.Optional"},t}(),e.SparseTensor=function(){function t(i){if(i)for(var o=Object.keys(i),s=0;s<o.length;++s)i[o[s]]!=null&&(this[o[s]]=i[o[s]])}return t.prototype.elemType=0,t.prototype.shape=null,t.create=function(o){return new t(o)},t.encode=function(o,s){return s||(s=ht.create()),o.elemType!=null&&Object.hasOwnProperty.call(o,"elemType")&&s.uint32(8).int32(o.elemType),o.shape!=null&&Object.hasOwnProperty.call(o,"shape")&&B.onnx.TensorShapeProto.encode(o.shape,s.uint32(18).fork()).ldelim(),s},t.encodeDelimited=function(o,s){return this.encode(o,s).ldelim()},t.decode=function(o,s){o instanceof se||(o=se.create(o));for(var a=s===void 0?o.len:o.pos+s,u=new B.onnx.TypeProto.SparseTensor;o.pos<a;){var c=o.uint32();switch(c>>>3){case 1:{u.elemType=o.int32();break}case 2:{u.shape=B.onnx.TensorShapeProto.decode(o,o.uint32());break}default:o.skipType(c&7);break}}return u},t.decodeDelimited=function(o){return o instanceof se||(o=new se(o)),this.decode(o,o.uint32())},t.verify=function(o){if(typeof o!="object"||o===null)return"object expected";if(o.elemType!=null&&o.hasOwnProperty("elemType")&&!N.isInteger(o.elemType))return"elemType: integer expected";if(o.shape!=null&&o.hasOwnProperty("shape")){var s=B.onnx.TensorShapeProto.verify(o.shape);if(s)return"shape."+s}return null},t.fromObject=function(o){if(o instanceof B.onnx.TypeProto.SparseTensor)return o;var s=new B.onnx.TypeProto.SparseTensor;if(o.elemType!=null&&(s.elemType=o.elemType|0),o.shape!=null){if(typeof o.shape!="object")throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");s.shape=B.onnx.TensorShapeProto.fromObject(o.shape)}return s},t.toObject=function(o,s){s||(s={});var a={};return s.defaults&&(a.elemType=0,a.shape=null),o.elemType!=null&&o.hasOwnProperty("elemType")&&(a.elemType=o.elemType),o.shape!=null&&o.hasOwnProperty("shape")&&(a.shape=B.onnx.TensorShapeProto.toObject(o.shape,s)),a},t.prototype.toJSON=function(){return this.constructor.toObject(this,rt.util.toJSONOptions)},t.getTypeUrl=function(o){return o===void 0&&(o="type.googleapis.com"),o+"/onnx.TypeProto.SparseTensor"},t}(),e}(),n.OperatorSetIdProto=function(){function e(r){if(r)for(var t=Object.keys(r),i=0;i<t.length;++i)r[t[i]]!=null&&(this[t[i]]=r[t[i]])}return e.prototype.domain="",e.prototype.version=N.Long?N.Long.fromBits(0,0,!1):0,e.create=function(t){return new e(t)},e.encode=function(t,i){return i||(i=ht.create()),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&i.uint32(10).string(t.domain),t.version!=null&&Object.hasOwnProperty.call(t,"version")&&i.uint32(16).int64(t.version),i},e.encodeDelimited=function(t,i){return this.encode(t,i).ldelim()},e.decode=function(t,i){t instanceof se||(t=se.create(t));for(var o=i===void 0?t.len:t.pos+i,s=new B.onnx.OperatorSetIdProto;t.pos<o;){var a=t.uint32();switch(a>>>3){case 1:{s.domain=t.string();break}case 2:{s.version=t.int64();break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof se||(t=new se(t)),this.decode(t,t.uint32())},e.verify=function(t){return typeof t!="object"||t===null?"object expected":t.domain!=null&&t.hasOwnProperty("domain")&&!N.isString(t.domain)?"domain: string expected":t.version!=null&&t.hasOwnProperty("version")&&!N.isInteger(t.version)&&!(t.version&&N.isInteger(t.version.low)&&N.isInteger(t.version.high))?"version: integer|Long expected":null},e.fromObject=function(t){if(t instanceof B.onnx.OperatorSetIdProto)return t;var i=new B.onnx.OperatorSetIdProto;return t.domain!=null&&(i.domain=String(t.domain)),t.version!=null&&(N.Long?(i.version=N.Long.fromValue(t.version)).unsigned=!1:typeof t.version=="string"?i.version=parseInt(t.version,10):typeof t.version=="number"?i.version=t.version:typeof t.version=="object"&&(i.version=new N.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber())),i},e.toObject=function(t,i){i||(i={});var o={};if(i.defaults)if(o.domain="",N.Long){var s=new N.Long(0,0,!1);o.version=i.longs===String?s.toString():i.longs===Number?s.toNumber():s}else o.version=i.longs===String?"0":0;return t.domain!=null&&t.hasOwnProperty("domain")&&(o.domain=t.domain),t.version!=null&&t.hasOwnProperty("version")&&(typeof t.version=="number"?o.version=i.longs===String?String(t.version):t.version:o.version=i.longs===String?N.Long.prototype.toString.call(t.version):i.longs===Number?new N.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber():t.version),o},e.prototype.toJSON=function(){return this.constructor.toObject(this,rt.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.OperatorSetIdProto"},e}(),n.OperatorStatus=function(){var e={},r=Object.create(e);return r[e[0]="EXPERIMENTAL"]=0,r[e[1]="STABLE"]=1,r}(),n.FunctionProto=function(){function e(r){if(this.input=[],this.output=[],this.attribute=[],this.attributeProto=[],this.node=[],this.opsetImport=[],r)for(var t=Object.keys(r),i=0;i<t.length;++i)r[t[i]]!=null&&(this[t[i]]=r[t[i]])}return e.prototype.name="",e.prototype.input=N.emptyArray,e.prototype.output=N.emptyArray,e.prototype.attribute=N.emptyArray,e.prototype.attributeProto=N.emptyArray,e.prototype.node=N.emptyArray,e.prototype.docString="",e.prototype.opsetImport=N.emptyArray,e.prototype.domain="",e.create=function(t){return new e(t)},e.encode=function(t,i){if(i||(i=ht.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&i.uint32(10).string(t.name),t.input!=null&&t.input.length)for(var o=0;o<t.input.length;++o)i.uint32(34).string(t.input[o]);if(t.output!=null&&t.output.length)for(var o=0;o<t.output.length;++o)i.uint32(42).string(t.output[o]);if(t.attribute!=null&&t.attribute.length)for(var o=0;o<t.attribute.length;++o)i.uint32(50).string(t.attribute[o]);if(t.node!=null&&t.node.length)for(var o=0;o<t.node.length;++o)B.onnx.NodeProto.encode(t.node[o],i.uint32(58).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&i.uint32(66).string(t.docString),t.opsetImport!=null&&t.opsetImport.length)for(var o=0;o<t.opsetImport.length;++o)B.onnx.OperatorSetIdProto.encode(t.opsetImport[o],i.uint32(74).fork()).ldelim();if(t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&i.uint32(82).string(t.domain),t.attributeProto!=null&&t.attributeProto.length)for(var o=0;o<t.attributeProto.length;++o)B.onnx.AttributeProto.encode(t.attributeProto[o],i.uint32(90).fork()).ldelim();return i},e.encodeDelimited=function(t,i){return this.encode(t,i).ldelim()},e.decode=function(t,i){t instanceof se||(t=se.create(t));for(var o=i===void 0?t.len:t.pos+i,s=new B.onnx.FunctionProto;t.pos<o;){var a=t.uint32();switch(a>>>3){case 1:{s.name=t.string();break}case 4:{s.input&&s.input.length||(s.input=[]),s.input.push(t.string());break}case 5:{s.output&&s.output.length||(s.output=[]),s.output.push(t.string());break}case 6:{s.attribute&&s.attribute.length||(s.attribute=[]),s.attribute.push(t.string());break}case 11:{s.attributeProto&&s.attributeProto.length||(s.attributeProto=[]),s.attributeProto.push(B.onnx.AttributeProto.decode(t,t.uint32()));break}case 7:{s.node&&s.node.length||(s.node=[]),s.node.push(B.onnx.NodeProto.decode(t,t.uint32()));break}case 8:{s.docString=t.string();break}case 9:{s.opsetImport&&s.opsetImport.length||(s.opsetImport=[]),s.opsetImport.push(B.onnx.OperatorSetIdProto.decode(t,t.uint32()));break}case 10:{s.domain=t.string();break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof se||(t=new se(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!N.isString(t.name))return"name: string expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var i=0;i<t.input.length;++i)if(!N.isString(t.input[i]))return"input: string[] expected"}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(var i=0;i<t.output.length;++i)if(!N.isString(t.output[i]))return"output: string[] expected"}if(t.attribute!=null&&t.hasOwnProperty("attribute")){if(!Array.isArray(t.attribute))return"attribute: array expected";for(var i=0;i<t.attribute.length;++i)if(!N.isString(t.attribute[i]))return"attribute: string[] expected"}if(t.attributeProto!=null&&t.hasOwnProperty("attributeProto")){if(!Array.isArray(t.attributeProto))return"attributeProto: array expected";for(var i=0;i<t.attributeProto.length;++i){var o=B.onnx.AttributeProto.verify(t.attributeProto[i]);if(o)return"attributeProto."+o}}if(t.node!=null&&t.hasOwnProperty("node")){if(!Array.isArray(t.node))return"node: array expected";for(var i=0;i<t.node.length;++i){var o=B.onnx.NodeProto.verify(t.node[i]);if(o)return"node."+o}}if(t.docString!=null&&t.hasOwnProperty("docString")&&!N.isString(t.docString))return"docString: string expected";if(t.opsetImport!=null&&t.hasOwnProperty("opsetImport")){if(!Array.isArray(t.opsetImport))return"opsetImport: array expected";for(var i=0;i<t.opsetImport.length;++i){var o=B.onnx.OperatorSetIdProto.verify(t.opsetImport[i]);if(o)return"opsetImport."+o}}return t.domain!=null&&t.hasOwnProperty("domain")&&!N.isString(t.domain)?"domain: string expected":null},e.fromObject=function(t){if(t instanceof B.onnx.FunctionProto)return t;var i=new B.onnx.FunctionProto;if(t.name!=null&&(i.name=String(t.name)),t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.FunctionProto.input: array expected");i.input=[];for(var o=0;o<t.input.length;++o)i.input[o]=String(t.input[o])}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.FunctionProto.output: array expected");i.output=[];for(var o=0;o<t.output.length;++o)i.output[o]=String(t.output[o])}if(t.attribute){if(!Array.isArray(t.attribute))throw TypeError(".onnx.FunctionProto.attribute: array expected");i.attribute=[];for(var o=0;o<t.attribute.length;++o)i.attribute[o]=String(t.attribute[o])}if(t.attributeProto){if(!Array.isArray(t.attributeProto))throw TypeError(".onnx.FunctionProto.attributeProto: array expected");i.attributeProto=[];for(var o=0;o<t.attributeProto.length;++o){if(typeof t.attributeProto[o]!="object")throw TypeError(".onnx.FunctionProto.attributeProto: object expected");i.attributeProto[o]=B.onnx.AttributeProto.fromObject(t.attributeProto[o])}}if(t.node){if(!Array.isArray(t.node))throw TypeError(".onnx.FunctionProto.node: array expected");i.node=[];for(var o=0;o<t.node.length;++o){if(typeof t.node[o]!="object")throw TypeError(".onnx.FunctionProto.node: object expected");i.node[o]=B.onnx.NodeProto.fromObject(t.node[o])}}if(t.docString!=null&&(i.docString=String(t.docString)),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(".onnx.FunctionProto.opsetImport: array expected");i.opsetImport=[];for(var o=0;o<t.opsetImport.length;++o){if(typeof t.opsetImport[o]!="object")throw TypeError(".onnx.FunctionProto.opsetImport: object expected");i.opsetImport[o]=B.onnx.OperatorSetIdProto.fromObject(t.opsetImport[o])}}return t.domain!=null&&(i.domain=String(t.domain)),i},e.toObject=function(t,i){i||(i={});var o={};if((i.arrays||i.defaults)&&(o.input=[],o.output=[],o.attribute=[],o.node=[],o.opsetImport=[],o.attributeProto=[]),i.defaults&&(o.name="",o.docString="",o.domain=""),t.name!=null&&t.hasOwnProperty("name")&&(o.name=t.name),t.input&&t.input.length){o.input=[];for(var s=0;s<t.input.length;++s)o.input[s]=t.input[s]}if(t.output&&t.output.length){o.output=[];for(var s=0;s<t.output.length;++s)o.output[s]=t.output[s]}if(t.attribute&&t.attribute.length){o.attribute=[];for(var s=0;s<t.attribute.length;++s)o.attribute[s]=t.attribute[s]}if(t.node&&t.node.length){o.node=[];for(var s=0;s<t.node.length;++s)o.node[s]=B.onnx.NodeProto.toObject(t.node[s],i)}if(t.docString!=null&&t.hasOwnProperty("docString")&&(o.docString=t.docString),t.opsetImport&&t.opsetImport.length){o.opsetImport=[];for(var s=0;s<t.opsetImport.length;++s)o.opsetImport[s]=B.onnx.OperatorSetIdProto.toObject(t.opsetImport[s],i)}if(t.domain!=null&&t.hasOwnProperty("domain")&&(o.domain=t.domain),t.attributeProto&&t.attributeProto.length){o.attributeProto=[];for(var s=0;s<t.attributeProto.length;++s)o.attributeProto[s]=B.onnx.AttributeProto.toObject(t.attributeProto[s],i)}return o},e.prototype.toJSON=function(){return this.constructor.toObject(this,rt.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.FunctionProto"},e}(),n}();Nd.exports=B});function Yn(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function eo(n){return new TextDecoder().decode(n)}var nt,hn,Fs,Rt,la,Ot,jt,he,Qi,mn,gn,yn,Ke=X(()=>{"use strict";ia();Is();nt=Un(Xn());bn();hn=class{static arraysEqual(e,r){if(e.length!==r.length)return!1;for(let t=0;t<e.length;t++)if(e[t]!==r[t])return!1;return!0}},Fs=class{static preprocessInputShapes(e,r){let t=e.length===1?[1,e[0]]:e,i=r.length===1?[r[0],1]:r;return[t,i]}static postprocessOutputShape(e,r,t){r===1&&e.splice(e.length-2,1),t===1&&e.pop()}static calcMatMulShape(e,r){return e[1]!==r[0]?void 0:[e[0],r[1]]}},Rt=class n{static calcShape(e,r,t=!1){let i=e.length,o=r.length;if(i===0)return r;if(o===0)return e;let s=Math.max(e.length,r.length),a=new Array(s);if(t){if(i<2||o<2)return;let u=Fs.calcMatMulShape([e[i-2],e[i-1]],[r[o-2],r[o-1]]);if(u===void 0)return;[a[s-2],a[s-1]]=u}for(let u=t?3:1;u<=s;u++){let c=i-u<0?1:e[i-u],g=o-u<0?1:r[o-u];if(c!==g&&c>1&&g>1)return;a[s-u]=Math.max(c,g)}return a}static index(e,r){let t=new Array(r.length);return n.fillIndex(e,r,t),t}static fillIndex(e,r,t){let i=e.length-r.length;for(let o=0;o<r.length;o++)t[o]=e[i+o]%r[o]}static calc(e,r,t,i,o){let s=n.calcShape(e.dims,r.dims);if(s){if(i&&!he.areEqual(s,e.dims))return;let a=he.size(s),u=i?e:new vt(s,o||e.type);if(s.length===0)u.set([],t(e.get([]),r.get([])));else{let c=new Array(s.length),g=new Array(e.dims.length),v=new Array(r.dims.length),T=0,S=0,O=!1,I=!1;e.dims.length===0&&(T=e.get([]),O=!0),r.dims.length===0&&(S=r.get([]),I=!0);let k;for(let M=0;M<a;M++){k=M;for(let F=s.length-1;F>=0;F--)c[F]=k%s[F],k=Math.floor(k/s[F]);O||(n.fillIndex(c,e.dims,g),T=e.get(g)),I||(n.fillIndex(c,r.dims,v),S=r.get(v)),u.set(c,t(T,S))}}return u}}static isValidBroadcast(e,r){let t=e.length,i=r.length;if(t>i)return!1;for(let o=1;o<=t;o++)if(e[t-o]!==1&&e[t-o]!==r[i-o])return!1;return!0}static getBroadcastDims(e,r){let t=e.length,i=[];for(let o=0;o<t;o++){let s=t-1-o,a=e[s]||1;(r[r.length-1-o]||1)>1&&a===1&&i.unshift(s)}return i}},la=class{static getShapeOfGemmResult(e,r,t,i,o){if(e.length!==2||t.length!==2)throw new Error("shape need to be of size 2");let s,a,u;r?(s=e[1],a=e[0]):(s=e[0],a=e[1]);let c=-1;if(i?(u=t[0],c=1):(u=t[1],c=0),t[c]!==a)throw new Error("dimension mismatch");if(s<=0||u<=0||a<=0)throw new Error("invalid shape specified");if(o&&!Rt.isValidBroadcast(o,[s,u]))throw new Error("gemm: invalid bias shape for broadcast");return[s,u,a]}},Ot=class n{static tensorDataTypeFromProto(e){switch(e){case nt.onnx.TensorProto.DataType.INT8:return"int8";case nt.onnx.TensorProto.DataType.UINT8:return"uint8";case nt.onnx.TensorProto.DataType.BOOL:return"bool";case nt.onnx.TensorProto.DataType.INT16:return"int16";case nt.onnx.TensorProto.DataType.UINT16:return"uint16";case nt.onnx.TensorProto.DataType.INT32:return"int32";case nt.onnx.TensorProto.DataType.UINT32:return"uint32";case nt.onnx.TensorProto.DataType.FLOAT:return"float32";case nt.onnx.TensorProto.DataType.DOUBLE:return"float64";case nt.onnx.TensorProto.DataType.STRING:return"string";case nt.onnx.TensorProto.DataType.INT64:return"int32";case nt.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${nt.onnx.TensorProto.DataType[e]}`)}}static tensorDataTypeStringToEnum(e){switch(e){case"int8":return nt.onnx.TensorProto.DataType.INT8;case"uint8":return nt.onnx.TensorProto.DataType.UINT8;case"bool":return nt.onnx.TensorProto.DataType.BOOL;case"int16":return nt.onnx.TensorProto.DataType.INT16;case"uint16":return nt.onnx.TensorProto.DataType.UINT16;case"int32":return nt.onnx.TensorProto.DataType.INT32;case"uint32":return nt.onnx.TensorProto.DataType.UINT32;case"float32":return nt.onnx.TensorProto.DataType.FLOAT;case"float64":return nt.onnx.TensorProto.DataType.DOUBLE;case"string":return nt.onnx.TensorProto.DataType.STRING;case"int64":return nt.onnx.TensorProto.DataType.INT64;case"uint64":return nt.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${e}`)}}static tensorDimsFromProto(e){return e.map(r=>Nr.isLong(r)?r.toNumber():r)}static tensorValueTypeFromProto(e){return{tensorType:n.tensorDataTypeFromProto(e.elemType),shape:{dims:n.tensorDimsFromProto(e.shape.dim.map(r=>r.dimValue))}}}static tensorDimsFromORTFormat(e){let r=[];for(let t=0;t<e.dimsLength();t++)r.push(jt.longToNumber(e.dims(t)));return r}static tensorAttributesFromORTFormat(e){let r=[];for(let t=0;t<e.attributesLength();t++)r.push(e.attributes(t));return r}},jt=class{static longToNumber(e,r){return Nr.isLong(e)?e.toNumber():e instanceof G.Long?Nr.fromValue({low:e.low,high:e.high,unsigned:r??!1}).toNumber():e}static isLong(e){return Nr.isLong(e)||e instanceof G.Long}},he=class n{static size(e){return n.getSizeFromDimensionRange(e,0,e.length)}static sizeFromDimension(e,r){if(r<0||r>e.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return n.getSizeFromDimensionRange(e,r,e.length)}static sizeToDimension(e,r){if(r<0||r>e.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${e.length} dimensions.`);return n.getSizeFromDimensionRange(e,0,r)}static getSizeFromDimensionRange(e,r,t){let i=1;for(let o=r;o<t;o++){if(e[o]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");i*=e[o]}return i}static computeStrides(e){let r=e.length;if(r===0)return[];if(r===1)return[1];let t=new Array(r);t[r-1]=1,t[r-2]=e[r-1];for(let i=r-3;i>=0;--i)t[i]=t[i+1]*e[i+1];return t}static transpose(e){return e.slice().reverse()}static indicesToOffset(e,r,t){t===void 0&&(t=e.length);let i=0;for(let o=0;o<t;++o)i+=r[o]*e[o];return i}static offsetToIndices(e,r){let t=r.length;if(t===0)return[];if(t===1)return[e*r[0]];let i=new Array(r.length);for(let o=0;o<i.length-1;++o)i[o]=Math.floor(e/r[o]),e-=i[o]*r[o];return i[i.length-1]=e,i}static normalizeAxis(e,r){if(e<-r&&e>=r)throw new Error("unsupported axis for this operation.");return e<0?e+r:e}static normalizeAxes(e,r){return e.map(t=>this.normalizeAxis(t,r))}static incrementIndex(e,r,t){if(r.length===0||e.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(t===void 0)t=r.length;else if(t<=0||t>r.length)throw new Error("Incorrect axis to increment on");for(let i=t-1;i>=0&&(e[i]++,!(e[i]<r[i]));--i)e[i]=0}static calculateReshapedDims(e,r){if(r.length===0){if(e.length===0||n.size(e)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}let t=r.length,i=new Array(t),o=-1,s=1;for(let u=0;u<t;u++){if(r[u]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(r[u]===-1){if(o!==-1)throw new Error("at most one dimension in shape hints can be -1");o=u}else{if(r[u]===0){if(u>=e.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");i[u]=e[u]}else i[u]=r[u];s*=i[u]}}let a=n.size(e);if(o!==-1){if(a%s!==0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${e}] Output shape: [${r}]`);i[o]=a/s}else if(s!==a)throw new Error("reshapedDims and originalDims don't have matching sizes");return i}static sortBasedOnPerm(e,r){return r?r.map(t=>e[t]):e.slice().reverse()}static padShape(e,r){let t=e.length;return e.map((i,o)=>i+r[o]+r[o+t])}static areEqual(e,r){return e.length!==r.length?!1:e.every((t,i)=>t===r[i])}static validateDimsAndCalcSize(e){if(e.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let r=1;for(let t of e){if(!Number.isInteger(t))throw new TypeError(`Invalid shape: ${t} is not an integer`);if(t<0||t>2147483647)throw new TypeError(`Invalid shape: length ${t} is not allowed`);r*=t}return r}static flattenShape(e,r){r<0&&(r+=e.length);let t=e.reduce((s,a)=>s*a,1),i=e.slice(r).reduce((s,a)=>s*a,1);return[t/i,i]}static squeezeShape(e,r){let t=new Array;r=n.normalizeAxes(r,e.length);for(let i=0;i<e.length;i++){let o=r.indexOf(i)>=0;if(o&&e[i]!==1)throw new Error("squeeze an axis of size different than 1");(r.length===0&&e[i]>1||r.length>0&&!o)&&t.push(e[i])}return t}static unsqueezeShape(e,r){let t=new Array(e.length+r.length);t.fill(0);for(let o=0;o<r.length;o++){let s=n.normalizeAxis(r[o],t.length);if(s>=t.length)throw new Error("'axes' has an out of range axis");if(t[s]!==0)throw new Error("'axes' has a duplicate axis");t[s]=1}let i=0;for(let o=0;o<t.length;o++)t[o]===0&&(t[o]=e[i++]);if(i!==e.length)throw new Error("the unsqueezed dimension could not be established");return t}},Qi=class n{static splitShape(e,r,t,i){if(t.length===0){if(!i)throw new Error("need to know number of outputs when the 'split' attribute is not specified");n.determineSplit(e[r],i,t)}let o=[],s=[0];for(let a=0;a<t.length;++a){a!==0&&s.push(s[a-1]+t[a-1]);let u=e.slice();u[r]=t[a],o.push(u)}return[o,s]}static determineSplit(e,r,t){if(e%r!==0)throw new Error("cannot split tensor to equal sized parts");for(let i=0;i<r;++i)t.push(e/r)}},mn=class n{static adjustPoolAttributes(e,r,t,i,o,s){if(!e&&t.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let a=0;a<r.length-2;a++)a>=t.length?t.push(r[a+2]):t[a]=r[a+2];for(let a=0;a<t.length;a++)if(a<i.length){if(i[a]<0)throw new Error("strides should be greater than or equal to 1")}else i.push(1);for(let a=0;a<t.length;a++)if(a<o.length){if(o[a]<0)throw new Error("dilations should be greater than or equal to 1")}else o.push(1);for(let a=0;a<t.length*2;a++)if(a<s.length){if(s[a]<0)throw new Error("pad should be greater than or equal to 1")}else s.push(0);for(let a=0;a<t.length;a++){if(t[a]<=0)throw new Error("kernel shapes need to be greater than 0");if(s[a]>=t[a]||s[a+t.length]>=t[a])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,r,t,i,o,s){if(s){if(o.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(i.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let a=0;a<e.length-2;a++)n.adjustPadAndReturnShape(e[a+2],r[a],t[a],i[a],o,a,a+e.length-2,s)}}static computePoolOutputShape(e,r,t,i,o,s,a){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let u=[r[0],r[1]];return n.computeShapeHelper(e,r,u,t,i,o,s,a),u}static computeConvOutputShape(e,r,t,i,o,s,a){if(e.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let u=[e[0],r[0]];return n.computeShapeHelper(!1,e,u,t,i,o,s,a),u}static computeShapeHelper(e,r,t,i,o,s,a,u){if(e)for(let c=0;c<r.length-2;c++)t.push(1);else for(let c=0;c<r.length-2;c++)t.push(n.adjustPadAndReturnShape(r[c+2],i[c],o[c],s[c],a,c,c+r.length-2,u))}static adjustPadAndReturnShape(e,r,t,i,o,s,a,u){let c=t*(i-1)+1;if(u&&u!=="NOTSET")switch(u){case"VALID":return o[s]=0,o[a]=0,Math.floor((e-c)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(t!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let v=((e+r-1)/r-1)*r+i-e;return o[s]=Math.floor(u==="SAME_LOWER"?(v+1)/2:v/2),o[a]=v-o[s],Math.floor((e+v-i)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((e+o[s]+o[a]-c)/r+1)}},gn=-34028234663852886e22,yn=34028234663852886e22});function G1(n){switch(n){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${n}`)}}function zd(n){switch(n){case Re.onnx.TensorProto.DataType.UINT8:case Re.onnx.TensorProto.DataType.INT8:case Re.onnx.TensorProto.DataType.BOOL:return 1;case Re.onnx.TensorProto.DataType.UINT16:case Re.onnx.TensorProto.DataType.INT16:return 2;case Re.onnx.TensorProto.DataType.FLOAT:case Re.onnx.TensorProto.DataType.INT32:case Re.onnx.TensorProto.DataType.UINT32:return 4;case Re.onnx.TensorProto.DataType.INT64:case Re.onnx.TensorProto.DataType.DOUBLE:case Re.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${Re.onnx.TensorProto.DataType[n]}`)}}function W1(n,e){return new(Gd(e))(n)}function Gd(n){switch(n){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function Gs(n,e){if(e===Re.onnx.TensorProto.DataType.INT64||e===js.TensorDataType.INT64){if(n.greaterThanOrEqual(2147483648)||n.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else if(e===Re.onnx.TensorProto.DataType.UINT32||e===js.TensorDataType.UINT32||e===Re.onnx.TensorProto.DataType.UINT64||e===js.TensorDataType.UINT64){if(n.greaterThanOrEqual(4294967296)||n.lessThan(0))throw new TypeError("uint64 is not supported")}else throw new TypeError(`not a LONG type: ${Re.onnx.TensorProto.DataType[e]}`);return n.toNumber()}function Fd(n,e,r){switch(e){case Re.onnx.TensorProto.DataType.BOOL:case Re.onnx.TensorProto.DataType.UINT8:return n.getUint8(r);case Re.onnx.TensorProto.DataType.INT8:return n.getInt8(r);case Re.onnx.TensorProto.DataType.UINT16:return n.getUint16(r,!0);case Re.onnx.TensorProto.DataType.INT16:return n.getInt16(r,!0);case Re.onnx.TensorProto.DataType.FLOAT:return n.getFloat32(r,!0);case Re.onnx.TensorProto.DataType.INT32:return n.getInt32(r,!0);case Re.onnx.TensorProto.DataType.UINT32:return n.getUint32(r,!0);case Re.onnx.TensorProto.DataType.INT64:return Gs(Nr.fromBits(n.getUint32(r,!0),n.getUint32(r+4,!0),!1),e);case Re.onnx.TensorProto.DataType.DOUBLE:return n.getFloat64(r,!0);case Re.onnx.TensorProto.DataType.UINT64:return Gs(Nr.fromBits(n.getUint32(r,!0),n.getUint32(r+4,!0),!0),e);default:throw new Error(`cannot read from DataView for type ${Re.onnx.TensorProto.DataType[e]}`)}}var jd,Re,js,vt,bn=X(()=>{"use strict";jd=Un(Ef());Is();Xi();Re=Un(Xn());Ke();js=be.experimental.fbs,vt=class n{constructor(e,r,t,i,o,s=jd.Guid.create()){this.dims=e;this.type=r;this.dataProvider=t;this.asyncDataProvider=i;this.cache=o;this.dataId=s;this.size=he.validateDimsAndCalcSize(e);let a=this.size,u=t===void 0&&i===void 0&&o===void 0;if(o!==void 0&&o.length!==a)throw new RangeError("Input dims doesn't match data length.");if(r==="string"){if(o!==void 0&&(!Array.isArray(o)||!o.every(c=>typeof c=="string")))throw new TypeError("cache should be a string array");u&&(this.cache=new Array(a))}else{if(o!==void 0){let c=Gd(r);if(!(o instanceof c))throw new TypeError(`cache should be type ${c.name}`)}if(u){let c=new ArrayBuffer(a*G1(r));this.cache=W1(c,r)}}}get data(){if(this.cache===void 0){let e=this.dataProvider(this.dataId);if(e.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=e}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(e){return this.data[he.indicesToOffset(e,this.strides)]}set(e,r){this.data[he.indicesToOffset(e,this.strides)]=r}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=he.computeStrides(this.dims)),this._strides}static fromProto(e){if(!e)throw new Error("cannot construct Value from an empty tensor");let r=Ot.tensorDataTypeFromProto(e.dataType),t=Ot.tensorDimsFromProto(e.dims),i=new n(t,r);if(r==="string")e.stringData.forEach((o,s)=>{i.data[s]=eo(o)});else if(e.rawData&&typeof e.rawData.byteLength=="number"&&e.rawData.byteLength>0){let o=i.data,s=new DataView(e.rawData.buffer,e.rawData.byteOffset,e.rawData.byteLength),a=zd(e.dataType),u=e.rawData.byteLength/a;if(e.rawData.byteLength%a!==0)throw new Error("invalid buffer length");if(o.length!==u)throw new Error("buffer length mismatch");for(let c=0;c<u;c++){let g=Fd(s,e.dataType,c*a);o[c]=g}}else{let o;switch(e.dataType){case Re.onnx.TensorProto.DataType.FLOAT:o=e.floatData;break;case Re.onnx.TensorProto.DataType.INT32:case Re.onnx.TensorProto.DataType.INT16:case Re.onnx.TensorProto.DataType.UINT16:case Re.onnx.TensorProto.DataType.INT8:case Re.onnx.TensorProto.DataType.UINT8:case Re.onnx.TensorProto.DataType.BOOL:o=e.int32Data;break;case Re.onnx.TensorProto.DataType.INT64:o=e.int64Data;break;case Re.onnx.TensorProto.DataType.DOUBLE:o=e.doubleData;break;case Re.onnx.TensorProto.DataType.UINT32:case Re.onnx.TensorProto.DataType.UINT64:o=e.uint64Data;break;default:throw new Error("unspecific error")}if(o==null)throw new Error("failed to populate data from a tensorproto value");let s=i.data;if(s.length!==o.length)throw new Error("array length mismatch");for(let a=0;a<o.length;a++){let u=o[a];Nr.isLong(u)?s[a]=Gs(u,e.dataType):s[a]=u}}return i}static fromData(e,r,t){return new n(r,t,void 0,void 0,e)}static fromOrtTensor(e){if(!e)throw new Error("cannot construct Value from an empty tensor");let r=Ot.tensorDimsFromORTFormat(e),t=Ot.tensorDataTypeFromProto(e.dataType()),i=new n(r,t);if(t==="string")for(let o=0;o<e.stringDataLength();o++)i.data[o]=e.stringData(o);else if(e.rawDataArray()&&typeof e.rawDataLength()=="number"&&e.rawDataLength()>0){let o=i.data,s=new DataView(e.rawDataArray().buffer,e.rawDataArray().byteOffset,e.rawDataLength()),a=zd(e.dataType()),u=e.rawDataLength()/a;if(e.rawDataLength()%a!==0)throw new Error("invalid buffer length");if(o.length!==u)throw new Error("buffer length mismatch");for(let c=0;c<u;c++){let g=Fd(s,e.dataType(),c*a);o[c]=g}}return i}}});function xe(n){return n===1?V1:U1}function Wd(n){let e=xe(n);return`${e.version}
      precision highp float;
      ${e.attribute} vec3 position;
      ${e.attribute} vec2 textureCoord;

      ${e.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`}function Vd(n){let e=xe(n);return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFrag} vec2 TexCoords;
    ${e.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `}function Ud(n,e){let r=xe(n);return`
  void main() {
    int indices[${e}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${r.output} = result;
  }
  `}var V1,U1,lt=X(()=>{"use strict";V1={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},U1={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"}});var ze=X(()=>{"use strict"});async function Ws(n,e=t=>0,r){return new Promise((t,i)=>{let o=0,s=()=>{if(n()){t();return}o++;let a=e(o);if(r!=null&&o>=r){i();return}setTimeout(s,a)};s()})}function ca(n){return Yn(typeof n<"u"&&n.length!==0,()=>"empty string found for sampler name"),"get"+n.charAt(0).toUpperCase()+n.slice(1)}function Hd(n){return Yn(typeof n<"u"&&n.length!==0,()=>"empty string found for sampler name"),"get"+n.charAt(0).toUpperCase()+n.slice(1)+"AtOutCoords"}function Jn(n,e){let r=JSON.parse(JSON.stringify(n));return r=e,r}function Zn(n,e){return e.map(r=>n[r]).join(", ")}function Mt(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function hr(n=6){return["x","y","z","w","u","v"].slice(0,n)}var $r=X(()=>{"use strict";Ke()});function H1(n,e){return hr(e).map(r=>`${n}.${r}`)}function Qn(n,e){return e===1?[n]:H1(n,e)}function Sr(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}var vn=X(()=>{"use strict";$r()});function K1(n,e,r){if(n===0)return"false";if(n===1)return`rc > ${e[0]}`;let t="";for(let i=n-2;i<n;i++)t+=`${r[i]} >= ${e[i-n+2]}`,i<n-1&&(t+="||");return t}function X1(n,e){let r=n.length;if(r===0)return"getA(), 0, 0, 0";if(r===1)return`getA(rc),
            rc + 1 >= ${n[0]} ? 0. : getA(rc + 1),
            0, 0`;let t="r, c",i="r, cp1",o="rp1, c",s="rp1, cp1",a="";if(r>2)for(let u=0;u<r-2;++u)a=a+`${e[u]},`;return`getA(${a}${t}),
          rEdge ? 0. : getA(${a}${o}),
          cEdge ? 0. : getA(${a}${i}),
          rEdge || cEdge ? 0. : getA(${a}${s})`}function Y1(n,e,r,t){return n===0||n===1?"":`
    int r = ${e[n-2]};
    int c = ${e[n-1]};
    int rp1 = ${e[n-2]} + 1;
    int cp1 = ${e[n-1]} + 1;
    bool rEdge = rp1 >= ${t};
    bool cEdge = cp1 >= ${r};
    `}var qd,q1,Kd,Xd=X(()=>{"use strict";lt();ze();$r();vn();qd={name:"pack",inputNames:["A"],inputTypes:[1]},q1=(n,e)=>{let r=xe(n.session.backend.glContext.version),t=e.dims,i=t.length,o=e.dims.length,s=Mt(o),a=Qn("rc",o),u=Y1(o,a,t[t.length-2],t[t.length-1]),c;i===0?c=[1,1]:i===1?c=[t[0],1]:c=[t[o-1],t[o-2]];let g=K1(o,c,a),v=X1(t,a),T=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${g}) {
            ${r.output} = vec4(0);
          } else {
            ${u}

            ${r.output} = vec4(${v});
          }
        }
      `;return{...qd,hasMain:!0,output:{dims:e.dims,type:e.type,textureType:2},shaderSource:T}},Kd=(n,e)=>({...qd,get:()=>q1(n,e)})});function Vs(n){if(n.length===0)return[1,1,1];let e=1;for(let r=0;r<n.length-2;++r)e*=n[r];return[e,n.length>1?n[n.length-2]:1,n[n.length-1]]}function Jd(n,e){let r=!1;return n.length===0||e.length===0?r=!0:n.length<2||e.length<2?r=n[n.length-1]===e[e.length-1]:r=n[n.length-1]===e[e.length-1]&&n[n.length-2]===e[e.length-2],r}function Q1(n){let e=he.computeStrides(n),r=["b","r","c"],t="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e.map((o,s)=>{let a=`int ${r[s]} = ${t} / ${o}`,u=s===e.length-1?`int ${r[s+1]} = ${t} - ${r[s]} * ${o}`:`index -= ${r[s]} * ${o}`;return`${a}; ${u};`}).join("")}
      return ivec3(b, r, c);
    }
  `}function e2(n){let e=he.computeStrides(n);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${e[0]} + coords.z * ${e[1]} + coords.y;
  }
`}var J1,Z1,Yd,Zd=X(()=>{"use strict";Ke();lt();ze();vn();J1=n=>({name:"Reshape (packed)",inputTypes:[2],inputNames:["A"],cacheHint:`${n}`}),Z1=(n,e,r,t)=>{let i=e.dims,o=t,s="";for(let c=0;c<4;c++){let g="";switch(c){case 0:g="outputCoords = rc;";break;case 1:g="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:g="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:g="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}s+=`
        ${g}
        ${c>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${c}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${c>0?"}":""}
      `}let a=xe(n.session.backend.glContext.version),u=`
      ${Q1(i)}
      ${e2(o)}
      ${Sr()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${o[2]};
        int cols = ${o[1]};

        ${s}
        ${a.output} = result;
      }
    `;return{...r,output:{dims:o,type:e.type,textureType:2},shaderSource:u,hasMain:!0}},Yd=(n,e,r)=>{let t=J1(r);return{...t,get:()=>Z1(n,e,t,r)}}});var Us,Qd=X(()=>{"use strict";lt();ze();Us=(n,e)=>{let r=e.shape,t=xe(n.session.backend.glContext.version),i=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${t.texture2D}(X,TexCoords).r;
      ${t.output} = encodeAsUint8(value);
    }`,o={name:"Uint8Encode",inputTypes:[0],inputNames:["X"],output:{dims:r,type:e.tensor.type,textureType:3},shaderSource:i,hasMain:!0};return n.executeProgram(o,[e.tensor])}});function r2(n,e){if(n===1)return"rc";let r="";for(let t=0;t<n;t++)r+=e[t],t<n-1&&(r+=",");return r}var ep,t2,tp,rp=X(()=>{"use strict";lt();ze();$r();vn();ep={name:"unpack",inputNames:["A"],inputTypes:[2]},t2=(n,e)=>{let r=e.dims.length,t=Qn("rc",r),i=t.slice(-2),o=Mt(r),s=Sr(),u=e.dims.length===0?"":r2(r,t),c=r<=1?"rc":`vec2(${i.join(",")})`,g=xe(n.session.backend.glContext.version),v=`
    ${s}
    void main() {
      ${o} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${u});

       ${g.output} = vec4(getChannel(packedInput, ${c}), 0, 0, 0);
     }
   `;return{...ep,hasMain:!0,output:{dims:e.dims,type:e.type,textureType:0},shaderSource:v}},tp=(n,e)=>({...ep,get:()=>t2(n,e)})});var fa,to,da,ro=X(()=>{"use strict";Kt();fa=class{constructor(e,r=1){if(r===1)this.internalFormat=e.R32F,this.format=e.RED,this.textureType=e.FLOAT,this.channelSize=r;else if(r===4)this.internalFormat=e.RGBA32F,this.format=e.RGBA,this.textureType=e.FLOAT,this.channelSize=r;else throw new Error(`Invalid number of channels: ${r}`)}encode(e,r){let t,i;return e.constructor!==Float32Array&&(Xe.warning("Encoder","data was not of type Float32; creating new Float32Array"),i=new Float32Array(e)),r*this.channelSize>e.length?(Xe.warning("Encoder","Source data too small. Allocating larger array"),i=e,t=this.allocate(r*this.channelSize),i.forEach((o,s)=>t[s]=o)):(i=e,t=i),t}allocate(e){return new Float32Array(e*4)}decode(e,r){return this.channelSize===1?e.filter((i,o)=>o%4===0).subarray(0,r):e.subarray(0,r)}},to=class{constructor(e,r=1,t){if(r!==1&&r!==4)throw new Error(`Invalid number of channels: ${r}`);this.internalFormat=e.RGBA,this.format=e.RGBA,this.channelSize=r,this.textureType=t||e.FLOAT}encode(e,r){let t=e;return this.channelSize===1&&(Xe.verbose("Encoder","Exploding into a larger array"),t=this.allocate(r),e.forEach((i,o)=>t[o*4]=i)),t}allocate(e){return new Float32Array(e*4)}decode(e,r){return this.channelSize===1?e.filter((i,o)=>o%4===0).subarray(0,r):e.subarray(0,r)}},da=class{constructor(e,r=1){this.channelSize=4;if(r===1)this.internalFormat=e.ALPHA,this.format=e.ALPHA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=r;else if(r===4)this.internalFormat=e.RGBA,this.format=e.RGBA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=r;else throw new Error(`Invalid number of channels: ${r}`)}encode(e,r){return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}allocate(e){return new Uint8Array(e*this.channelSize)}decode(e,r){if(e instanceof Uint8Array)return e.subarray(0,r);throw new Error(`Invalid array type: ${e.constructor}`)}}});var no,np,Hs,ip=X(()=>{"use strict";Ke();ze();no=(n,e,r)=>{let t=r===0||r===1?1:4,i=r===2,o=r===1||r===2,s=r===4?e.length-1:void 0,a=r===4?e.map((u,c)=>c===e.length-1?u*4:u):void 0;return Hs(n,e,t,a,{isPacked:i,reverseWH:o,breakAxis:s})},np=(n,e,r)=>{let t=no(n,e,r);return[t.width,t.height]},Hs=(n,e,r=1,t,i)=>{let o=!!(i&&i.isPacked),[s,a]=n.computeTextureWH(o&&t||e,i),u=e.length,c=e.slice(0);if(u===0&&(c=[1]),r===1)t=e;else if(o){if(r!==4)throw new Error("a packed texture must be 4-channel");t=e,u>0&&(c[u-1]=Math.ceil(c[u-1]/2)),u>1&&(c[u-2]=Math.ceil(c[u-2]/2))}else if(!t)throw new Error("Unpacked shape is needed when using channels > 1");return{width:s,height:a,channels:r,isPacked:o,shape:c,strides:he.computeStrides(c),unpackedShape:t,reversedWH:i&&i.reverseWH}}});var i2,pa,ap=X(()=>{"use strict";Kt();bn();Ke();Xd();Zd();Qd();rp();ro();ip();ze();i2=(n,e)=>{let r=e.map(i=>`${i.unpackedShape.join(",")};${i.width}x${i.height}`).join("_"),t=n.name;return n.cacheHint&&(t+="["+n.cacheHint+"]"),t+=":"+r,t},pa=class{constructor(e){this.session=e;this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(e,r){return np(this.session.layoutStrategy,e,r)}executeProgram(e,r){if(r.length<e.inputNames.length)throw new Error(`Input size mustn't be less than ${e.inputNames.length}.`);if(e.inputNames.length!==e.inputTypes.length)throw new Error("input names size does not match input types");let t=[];for(let c=0;c<e.inputNames.length;++c)t[c]=this.getOrCreateTextureData(r[c],e.inputTypes[c]);let i=i2(e,t),o=this.session.programManager.getArtifact(i),s=o?o.programInfo:typeof e.get=="function"?e.get():e,a=no(this.session.layoutStrategy,s.output.dims,s.output.textureType),u=this.createTextureData(a,s.output.type);return o||(o=this.session.programManager.build(s,t,u),this.session.programManager.setArtifact(i,o)),this.runProgram(o,t,u),u}run(e,r){return this.executeProgram(e,r).tensor}runProgram(e,r,t){for(let i=0;i<r.length;++i)if(!!r[i].isPacked!=(e.programInfo.inputTypes[i]===2))throw new Error(`input[${i}] property packed inconsistent`);if(!!t.isPacked!=(e.programInfo.output.textureType===2))throw new Error("output property packed inconsistent");this.session.programManager.run(e,r,t)}getOrCreateTextureData(e,r){let t=this.getTextureData(e.dataId,r===2);if(!t&&(t=this.getTextureData(e.dataId,r!==2),t))return r===2?this.pack(t):this.unpack(t);if(!t){let i=no(this.session.layoutStrategy,e.dims,r);if(r===4){let a=e.dims;if(a.length===4){let u=[a[0],Math.ceil(a[1]*a[2]*a[3]/4)],c=no(this.session.layoutStrategy,u,r),g=e.numberData;if(a[1]*a[2]*a[3]%4!==0){let v=a[0],T=a[1]*a[2]*a[3],S=Math.ceil(T*1/4)*4,O=v*S;g=new Float32Array(O);for(let I=0;I<v;++I){let k=I*T,M=I*S+I%1*T;g.set(e.numberData.subarray(k,k+T),M)}}return this.createTextureData(c,e.type,g,e,1)}}if(r===2){let o=Hs(this.session.layoutStrategy,e.dims,1,[],{reverseWH:!0}),s=this.createTextureData(o,e.type,e.numberData,e,1);t=this.pack(s)}else t=this.createTextureData(i,e.type,e.numberData,e,1)}return t}createTextureDataFromLayoutBindTensor(e,r,t,i){return this.createTextureData(e,r,t,i,1)}createTextureData(e,r,t,i,o){Xe.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(e)}]`);let s=this.session.textureManager.createTextureFromLayout(r,e,t,o);return this.createTextureDataFromTexture(e,r,s,i)}reshapeUnpacked(e,r){let t=this.getOrCreateTextureData(e,0),i={channels:t.channels,height:t.height,width:t.width,shape:r.length!==0?r:[1],strides:he.computeStrides(r),unpackedShape:r};return this.createTextureDataFromTexture(i,e.type,t.texture).tensor}reshapePacked(e,r){let t=this.getOrCreateTextureData(e,2);if(Jd(e.dims,r)){let c={channels:t.channels,height:t.height,width:t.width,shape:r.length!==0?r:[1],strides:he.computeStrides(r),unpackedShape:r,isPacked:!0};return this.createTextureDataFromTexture(c,e.type,t.texture).tensor}let i=Vs(e.dims),o=Vs(r),s=this.reshapePacked(e,i),a=this.run(Yd(this,s,o),[s]);return this.reshapePacked(a,r)}cast(e,r){let t=this.getOrCreateTextureData(e,0);return this.createTextureDataFromTexture(t,r,t.texture).tensor}createTextureDataFromTexture(e,r,t,i,o){let s={...e,tensor:i||new vt(e.unpackedShape,r,a=>this.readTexture(s),async a=>this.readTextureAsync(s),void 0,o),texture:t};return this.setTextureData(s.tensor.dataId,s,e.isPacked),s}getTextureData(e,r=!1){return this.session.isInitializer(e)?this.session.getTextureData(e,r):r?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,r,t=!1){this.session.isInitializer(e)?this.session.setTextureData(e,r,t):(t?this.packedTextureDataCache:this.unpackedTextureDataCache).set(e,r)}isTextureLayoutCached(e,r=!1){return!!this.getTextureData(e.dataId,r)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.unpackedTextureDataCache=new Map}readTexture(e){return e.isPacked?this.readTexture(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat(Us(this,e))}async readTextureAsync(e){return e.isPacked?this.readTextureAsync(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat(Us(this,e))}pack(e){return this.executeProgram(Kd(this,e.tensor),[e.tensor])}unpack(e){return this.executeProgram(tp(this,e.tensor),[e.tensor])}}});var qs,ke,Ct=X(()=>{"use strict";qs=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this._cacheKey}},ke=n=>new qs(n)});var sp,up,lp,o2,a2,cp=X(()=>{"use strict";Ct();lt();ze();sp={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[0,0,0,0,0]},up=(n,e,r)=>(a2(e),[n.run({...sp,cacheHint:r.cacheKey,get:()=>o2(n,e,r)},e)]),lp=n=>{let e=n.attributes.getFloat("epsilon",1e-5),r=n.attributes.getFloat("momentum",.9),t=n.attributes.getInt("spatial",1);return ke({epsilon:e,momentum:r,spatial:t})},o2=(n,e,r)=>{let t=xe(n.session.backend.glContext.version),i=e[0].dims.length,[o,s]=n.calculateTextureWidthAndHeight(e[1].dims,0),a=`
  float process(int[${i}] indices) {
    vec2 position = offsetToCoords(indices[1], ${o}, ${s});
    float scale = getColorAsFloat(${t.texture2D}(Scale, position));
    float mean = getColorAsFloat(${t.texture2D}(Mean, position));
    float variance = getColorAsFloat(${t.texture2D}(Variance, position));
    float b = getColorAsFloat(${t.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${r.epsilon})) ) + b;
  }`;return{...sp,output:{dims:e[0].dims,type:e[0].type,textureType:0},shaderSource:a}},a2=n=>{if(!n||n.length!==5)throw new Error("BatchNormalization requires 5 inputs.");let e=n[0],r=n[1],t=n[2],i=n[3],o=n[4];if(e.dims.length<3||r.dims.length!==1||t.dims.length!==1||i.dims.length!==1||o.dims.length!==1)throw new Error("invalid input shape.");if(r.dims[0]!==e.dims[1]||t.dims[0]!==e.dims[1]||i.dims[0]!==e.dims[1]||o.dims[0]!==e.dims[1])throw new Error("invalid input shape.");if(e.type!=="float32"&&e.type!=="float64"||r.type!=="float32"&&r.type!=="float64"||t.type!=="float32"&&t.type!=="float64"||i.type!=="float32"&&i.type!=="float64"||o.type!=="float32"&&o.type!=="float64")throw new Error("invalid input tensor types.")}});var ha,Zt,ce,io,ma,zr=X(()=>{"use strict";ha=class{constructor(e,r,t,i){this.glContext=e;this.programInfo=r;this.inputTextureLayouts=t;this.outputTextureLayout=i}},Zt=class{constructor(e){this.context=e}},ce=class{constructor(e,r){this.routineBody=e;this.dependencies=r}},io=class{constructor(e,r,t){this.name=e;t?this.dependencies=t:this.dependencies=[],r&&(this.routineBody=r)}addDependency(e){e&&this.dependencies.push(e)}},ma=class{static returnOrderedNodes(e){if(!e||e.length===0)return[];if(e.length===1)return e;let r=new Set,t=new Set,i=new Array;return this.createOrderedNodes(e,r,t,i),i}static createOrderedNodes(e,r,t,i){for(let o=0;o<e.length;++o)this.dfsTraverse(e[o],r,t,i)}static dfsTraverse(e,r,t,i){if(!e||t.has(e.name))return;if(r.has(e.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");r.add(e.name);let o=e.dependencies;if(o&&o.length>0)for(let s=0;s<o.length;++s)this.dfsTraverse(o[s],r,t,i);i.push(e),t.add(e.name),r.delete(e.name)}}});function u2(){let n="add_";return{body:`
  float ${n}(float a, float b) {
    return a + b;
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:n,type:0}}function l2(){let n="div_";return{body:`
  float ${n}(float a, float b) {
    return a / b;
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:n,type:0}}function c2(){let n="mul_";return{body:`
  float ${n}(float a, float b) {
    return a * b;
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:n,type:0}}function f2(){let n="sub_";return{body:`
  float ${n}(float a, float b) {
    return a - b;
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:n,type:0}}function d2(){let n="equal_";return{body:`
  float ${n}(float a, float b) {
    return float(a == b);
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:n,type:0}}function p2(){let n="greater_";return{body:`
  float ${n}(float a, float b) {
    return float(a > b);
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:n,type:0}}function h2(){let n="less_";return{body:`
  float ${n}(float a, float b) {
    return float(a < b);
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:n,type:0}}function m2(){let n="and_";return{body:`
  float ${n}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:n,type:0}}function g2(){let n="or_";return{body:`
  float ${n}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:n,type:0}}function y2(){let n="xor_";return{body:`
  float ${n}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:n,type:0}}function b2(){return w2("pow")}function v2(){let n="prelu_";return{body:`
  float ${n}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:n,type:0}}function w2(n){let e=`${n}_`;return{body:`
  float ${e}(float a, float b) {
    return ${n}(a, b);
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return ${n}(v1, v2);
  }
  `,name:e,type:0}}var Qt,x2,fp,dp,pp,hp,mp,gp,yp,bp,vp,wp,xp,Tp,_p=X(()=>{"use strict";Ke();zr();lt();ze();Qt=(n,e,r,t=e[0].type,i)=>{let o=n.session.pack?2:0;return{name:r.name,inputNames:["A","B"],inputTypes:[o,o],cacheHint:i,get:()=>x2(n,e,r,t)}},x2=(n,e,r,t=e[0].type)=>{let i=n.session.pack?2:0,o=!he.areEqual(e[0].dims,e[1].dims),s=e[0].dims,a=n.session.pack;if(o){let g=Rt.calcShape(e[0].dims,e[1].dims,!1);if(!g)throw new Error("Can't perform binary op on the given tensors");s=g;let v=s.length,T=e[0].dims.length!==0?e[0].dims.length:1,S=e[1].dims.length!==0?e[1].dims.length:1,O=e[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",I=e[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",k=xe(n.session.backend.glContext.version),M=a?`
      ${r.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${r.name}(a, b);
        ${k.output} = result;
      }`:`
      ${r.body}
      float process(int indices[${v}]) {
        int aindices[${T}];
        int bindices[${S}];
        ${O}
        ${I}
        return ${r.name}(_A(aindices), _B(bindices));
      }`;return{name:r.name,inputNames:["A","B"],inputTypes:[i,i],output:{dims:s,type:t,textureType:i},shaderSource:M,hasMain:a}}let u=xe(n.session.backend.glContext.version),c=`
    ${r.body}
    void main() {
      vec4 v1 = ${u.texture2D}(A, TexCoords);
      vec4 v2 = ${u.texture2D}(B, TexCoords);
      vec4 result = ${r.name}(v1, v2);
      ${u.output} = result;
    }
    `;return{name:r.name,inputNames:["A","B"],inputTypes:[i,i],output:{dims:e[0].dims,type:t,textureType:i},shaderSource:c,hasMain:!0}},fp=(n,e)=>[n.run(Qt(n,e,u2()),e)],dp=(n,e)=>[n.run(Qt(n,e,m2(),"bool"),e)],pp=(n,e)=>[n.run(Qt(n,e,l2()),e)],hp=(n,e)=>[n.run(Qt(n,e,d2(),"bool"),e)],mp=(n,e)=>[n.run(Qt(n,e,p2(),"bool"),e)],gp=(n,e)=>[n.run(Qt(n,e,h2(),"bool"),e)],yp=(n,e)=>[n.run(Qt(n,e,c2()),e)],bp=(n,e)=>[n.run(Qt(n,e,g2(),"bool"),e)],vp=(n,e)=>[n.run(Qt(n,e,b2()),e)],wp=(n,e)=>[n.run(Qt(n,e,v2()),e)],xp=(n,e)=>[n.run(Qt(n,e,f2()),e)],Tp=(n,e)=>[n.run(Qt(n,e,y2(),"bool"),e)]});var $p,Sp,_2,Ip=X(()=>{"use strict";Ke();$p=(n,e,r)=>(_2(e),[n.cast(e[0],r)]),Sp=n=>Ot.tensorDataTypeFromProto(n.attributes.getInt("to")),_2=n=>{if(!n||n.length!==1)throw new Error("Cast requires 1 input.");if(n[0].type==="string")throw new Error("Invalid input type.")}});var $2,S2,Cp,ga,Ap=X(()=>{"use strict";lt();ze();$r();vn();$2=(n,e)=>({name:"Concat (packed)",inputNames:Array.from({length:n},(r,t)=>`X${t}`),inputTypes:Array(n).fill(2),cacheHint:e}),S2=(n,e,r,t)=>{let i=r[0].dims.slice();if(t>=i.length||t<-1*i.length)throw new Error("axis specified for concat doesn't match input dimensionality");t<0&&(t=i.length+t);let o=i.slice(0);for(let Z=1;Z<r.length;Z++){let P=r[Z].dims.slice();for(let te=0;te<i.length;te++)if(te===t)o[t]+=P[te];else if(i[te]!==P[te])throw new Error("non concat dimensions must match")}let s=o.length,a=Qn("coords",s),u=Mt(s),c=Sr(),g=r.map(Z=>Z.dims),v=hr(s),T=new Array(g.length-1);T[0]=g[0][t];for(let Z=1;Z<T.length;Z++)T[Z]=T[Z-1]+g[Z][t];let S=v[t],O=v.slice(-2),I=v.join(),k=`if (${S} < ${T[0]}) {
        return getChannel(
            getX0(${I}), vec2(${O.join()}));
        }`;for(let Z=1;Z<T.length;Z++){let P=T[Z-1];k+=`
            if (${S} < ${T[Z]}  && ${S} >= ${T[Z-1]}) {
              return getChannel(
                getX${Z}(${ga(v,S,P)}),
                vec2(${ga(O,S,P)}));
            }`}let M=T.length,F=T[T.length-1];k+=`
            return getChannel(
              getX${M}(${ga(v,S,F)}),
              vec2(${ga(O,S,F)}));`;let j=xe(n.session.backend.glContext.version),Y=`
          ${c}
          float getValue(${v.map(Z=>"int "+Z)}) {
            ${k}
          }

          void main() {
            ${u} coords = getOutputCoords();
            int lastDim = coords.${v[s-1]};
            coords.${v[s-1]} = coords.${v[s-2]};
            coords.${v[s-2]} = lastDim;

            vec4 result = vec4(getValue(${a}), 0., 0., 0.);

            ${a[s-1]} = ${a[s-1]} + 1;
            if (${a[s-1]} < ${o[s-1]}) {
              result.g = getValue(${a});
            }

            ${a[s-2]} = ${a[s-2]} + 1;
            if (${a[s-2]} < ${o[s-2]}) {
              result.a = getValue(${a});
            }

            ${a[s-1]} = ${a[s-1]} - 1;
            if (${a[s-2]} < ${o[s-2]} &&
                ${a[s-1]} < ${o[s-1]}) {
              result.b = getValue(${a});
            }
            ${j.output} = result;
          }
        `;return{...e,output:{dims:o,type:r[0].type,textureType:2},shaderSource:Y,hasMain:!0}},Cp=(n,e,r)=>{let t=$2(e.length,r.cacheKey);return{...t,get:()=>S2(n,t,e,r.axis)}},ga=(n,e,r)=>{let t=n.indexOf(e);return n.map((o,s)=>s===t?`${o} - ${r}`:o).join()}});var Op,I2,C2,A2,Ep,O2,E2,P2,Pp,D2,Dp=X(()=>{"use strict";Ct();ze();Ap();Op=(n,e,r)=>(D2(e),n.session.pack&&e[0].dims.length>1?[n.run(Cp(n,e,r),e)]:[n.run(A2(n,e,r),e)]),I2=(n,e)=>({name:"Concat",inputNames:Array.from({length:n},(r,t)=>`X${t}`),inputTypes:Array(n).fill(0),cacheHint:e}),C2=(n,e,r,t)=>{let i=r[0].dims.slice();if(t>=i.length||t<-1*i.length)throw new Error("axis specified for concat doesn't match input dimensionality");t<0&&(t=i.length+t);let o=i.slice(0);for(let S=1;S<r.length;S++){let O=r[S].dims.slice();for(let I=0;I<i.length;I++)if(I===t)o[t]+=O[I];else if(i[I]!==O[I])throw new Error("non concat dimensions must match")}let s=o.length,a=new Array(r.length),u=0;for(let S=0;S<a.length;++S)u+=r[S].dims[t],a[S]=u;let c="";r.length<5?c=Ep(a):c=O2(a);let g=E2(r.length,s),v=P2(a),T=`
        ${g}
        ${v}
        ${c}
        float process(int indices[${s}]) {
          int textureIndex = getTextureWhereDataResides (indices[${t}]);

          if(textureIndex != 0) {
            indices[${t}] = indices[${t}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return{...e,output:{dims:o,type:r[0].type,textureType:0},shaderSource:T}},A2=(n,e,r)=>{let t=I2(e.length,r.cacheKey);return{...t,get:()=>C2(n,t,e,r.axis)}},Ep=n=>`int getTextureWhereDataResides(int index) {
      ${n.map((r,t)=>`if(index<${r}) {return ${t};}
`).join("")}
    }`,O2=n=>Ep(n),E2=(n,e)=>{let r=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${e}]) {`];for(let t=0;t<n;++t)t===0?r.push(`	if (textureIndex == ${t}) { return _X${t}(indices); }`):t===n-1?r.push(`	else { return _X${t}(indices); }`):r.push(`	else if (textureIndex == ${t}) { return _X${t}(indices); }`);return r.push("	}"),r.join(`
`)},P2=n=>{let e=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let r=0;r<n.length;++r)r===0?e.push(`	if (index == ${r}) { return ${n[r]}; }`):r===n.length-1?e.push(`	else { return ${n[r]}; }`):e.push(`	else if (index == ${r}) { return ${n[r]}; }`);return e.push("	}"),e.join(`
`)},Pp=n=>ke({axis:n.attributes.getInt("axis")}),D2=n=>{if(!n||n.length<1)throw new Error("too few inputs");let e=n[0].type,r=n[0].dims.length;if(e==="string")throw new Error("string tensor is not supported yet");for(let t of n){if(t.type!==e)throw new Error("input tensors should be one type");if(t.dims.length!==r)throw new Error("input tensors should have the same shape")}}});function k2(){return er("abs")}function B2(){return er("acos")}function R2(){return er("asin")}function M2(){return er("atan")}function L2(){return er("ceil")}function N2(){return er("cos")}function z2(n){let e="elu";return{body:`
  const float alpha = float(${n});

  float ${e}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${e}_(vec4 v) {
    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));
  }
  `,name:e,type:0}}function F2(){return er("exp")}function j2(){return er("floor")}function Ks(n,e){let r="clip";return{body:`
  const float min = float(${n});
  const float max = float(${e});

  float ${r}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${r}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:r,type:0}}function G2(){let n="indentity";return{body:`
  float ${n}_(float a) {
    return a;
  }
  vec4 ${n}_(vec4 v) {
    return v;
  }
  `,name:n,type:0}}function W2(n){let e="leakyRelu";return{body:`
  const float alpha = float(${n});

  float ${e}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${e}_(vec4 v) {
    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));
  }
  `,name:e,type:0}}function V2(){return er("log")}function U2(){let n="neg";return{body:`
  float ${n}_(float a) {
    return -a;
  }
  vec4 ${n}_(vec4 v) {
    return -v;
  }
  `,name:n,type:0}}function H2(){let n="not";return{body:`
  float ${n}_(float a) {
    return float( ! bool(a) );
  }
  bool ${n}_(bool a) {
    return !a;
  }
  vec4 ${n}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${n}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:n,type:0}}function q2(){return er("sin")}function Xs(){let n="relu";return{body:`
  float ${n}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${n}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:n,type:0}}function Ys(){let n="sigmoid";return{body:`
  float ${n}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${n}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:n,type:0}}function K2(){return er("sqrt")}function X2(){return er("tan")}function Y2(){let n="tanh";return{body:`
  float ${n}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${n}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:n,type:0}}function er(n){return{body:`
  float ${n}_(float a) {
    return ${n}(a);
  }
  vec4 ${n}_(vec4 v) {
    return ${n}(v);
  }
  `,name:n,type:0}}var J2,mt,kp,Bp,Rp,Mp,Js,Lp,Np,Z2,zp,Fp,jp,Gp,Wp,Vp,Zs,Up,Hp,qp,Kp,Xp,Yp,Jp,Zp,Qp,eh,th,Qs=X(()=>{"use strict";Ct();Ke();zr();lt();ze();J2=(n,e,r,t)=>{let i=n.session.pack?2:0,o=xe(n.session.backend.glContext.version);return{...e,output:{dims:r.dims,type:r.type,textureType:i},shaderSource:`
     ${t.body}
     void main() {
       vec4 v = ${o.texture2D}(A, TexCoords);
       v = ${t.name}_(v);
       ${o.output} = v;
     }
     `,hasMain:!0}},mt=(n,e,r,t)=>{let i=n.session.pack?2:0,o={name:r.name,inputTypes:[i],inputNames:["A"],cacheHint:t};return{...o,get:()=>J2(n,o,e,r)}},kp=(n,e)=>[n.run(mt(n,e[0],k2()),e)],Bp=(n,e)=>[n.run(mt(n,e[0],B2()),e)],Rp=(n,e)=>[n.run(mt(n,e[0],R2()),e)],Mp=(n,e)=>[n.run(mt(n,e[0],M2()),e)],Js=(n,e,r)=>[n.run(mt(n,e[0],Ks(r.min,r.max),r.cacheKey),e)],Lp=n=>ke({min:n.attributes.getFloat("min",gn),max:n.attributes.getFloat("max",yn)}),Np=(n,e)=>{let r=Z2(n,e);return Js(n,[e[0]],r)},Z2=(n,e)=>{if(e.length>=3&&(!n.session.isInitializer(e[1].dataId)||!n.session.isInitializer(e[2].dataId)))throw new Error("dynamic clip attributes are not allowed");let r=e.length>=3?e[1].numberData[0]:gn,t=e.length>=3?e[2].numberData[0]:yn;return ke({min:r,max:t})},zp=(n,e)=>[n.run(mt(n,e[0],L2()),e)],Fp=(n,e)=>[n.run(mt(n,e[0],N2()),e)],jp=(n,e,r)=>[n.run(mt(n,e[0],z2(r.alpha),r.cacheKey),e)],Gp=n=>ke({alpha:n.attributes.getFloat("alpha",1)}),Wp=(n,e)=>[n.run(mt(n,e[0],F2()),e)],Vp=(n,e)=>[n.run(mt(n,e[0],j2()),e)],Zs=(n,e)=>[n.run(mt(n,e[0],G2()),e)],Up=(n,e,r)=>[n.run(mt(n,e[0],W2(r.alpha),r.cacheKey),e)],Hp=n=>ke({alpha:n.attributes.getFloat("alpha",.01)}),qp=(n,e)=>[n.run(mt(n,e[0],V2()),e)],Kp=(n,e)=>[n.run(mt(n,e[0],U2()),e)],Xp=(n,e)=>[n.run(mt(n,e[0],H2()),e)],Yp=(n,e)=>[n.run(mt(n,e[0],Xs()),e)],Jp=(n,e)=>[n.run(mt(n,e[0],Ys()),e)],Zp=(n,e)=>[n.run(mt(n,e[0],q2()),e)],Qp=(n,e)=>[n.run(mt(n,e[0],K2()),e)],eh=(n,e)=>[n.run(mt(n,e[0],X2()),e)],th=(n,e)=>[n.run(mt(n,e[0],Y2()),e)]});function Ir(n){let e;switch(n.activation){case"Relu":e=Xs();break;case"Sigmoid":e=Ys();break;case"Clip":e=Ks(n.clipMin,n.clipMax);break;default:return{activationFunction:"",applyActivation:""}}let r=e.name,t=e.body,i=`value = ${r}_(value);`;return{activationFunction:t,applyActivation:i}}var ei,wn=X(()=>{"use strict";Ke();Qs();ei=n=>{let e=n.getString("activation","");if(e==="Clip"){let[r,t]=n.getFloats("activation_params",[gn,yn]);return{activation:e,clipMax:t,clipMin:r,activationCacheKey:`${e}:${r},${t}`}}return{activation:e,activationCacheKey:e}}});var eT,tT,rh,nh=X(()=>{"use strict";Kt();lt();ze();ya();wn();eT=(n,e)=>({name:"GroupedConv",inputNames:n?["X","W","Bias"]:["X","W"],inputTypes:n?[0,0,0]:[0,0],cacheHint:e}),tT=(n,e,r,t)=>{let o=e.length>2?"value += getBias(output_channel);":"",s=e[0].dims.slice(),a=e[1].dims.slice(),u=a[0]/t.group;Xe.verbose("GroupedConv",`autpPad:${t.autoPad}, dilations:${t.dilations}, group:${t.group}, kernelShape:${t.kernelShape}, pads:${t.pads}, strides:${t.strides}`);let c=ti(s,a,t.dilations,t.pads,t.strides),g=xe(n.session.backend.glContext.version),{activationFunction:v,applyActivation:T}=Ir(t),S=`
  const ivec2 strides = ivec2(${t.strides[0]}, ${t.strides[1]});
  const ivec2 pads = ivec2(${t.pads[0]}, ${t.pads[1]});
  ${v}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${u};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${a[1]}; wInChannel++) {
      int input_channel = group_id * ${a[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${a[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${t.dilations[0]};

        if (xHeight < 0 || xHeight >= ${s[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${a[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${t.dilations[1]};
          if (xWidth < 0 || xWidth >= ${s[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${o}
    ${T}
    ${g.output} = vec4(value, .0, .0, .0);
  }
`;return{...r,output:{dims:c,type:e[0].type,textureType:0},shaderSource:S,hasMain:!0}},rh=(n,e,r)=>{let t=eT(e.length>2,r.cacheKey);return{...t,get:()=>tT(n,e,t,r)}}});var rT,nT,ih,oh=X(()=>{"use strict";lt();ze();vn();rT=n=>({name:"Im2Col (packed)",inputNames:["A"],inputTypes:[2],cacheHint:n}),nT=(n,e,r,t,i,o)=>{let s=r.dims,a=t.dims,u=2,c=3,g=i.length,v=[a[1]*a[2]*a[3],i[2]*i[3]],T=a[2]*a[3],S=Sr(),O=xe(n.session.backend.glContext.version),I="";for(let M=0;M<=1;M++)for(let F=0;F<=1;F++)I+=`
            blockIndex = rc.x + ${F};
            pos = rc.y + ${M};

            if(blockIndex < ${v[1]} && pos < ${v[0]}) {
              offsetY = int(blockIndex / (${i[g-1]})) * ${o.strides[0]} -
                ${o.pads[0]};
              d0 = offsetY + ${o.dilations[0]} * (imod(pos, ${T}) / ${a[2]});

              if(d0 < ${s[u]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${i[g-1]}) * ${o.strides[1]} -
                  ${o.pads[1]};
                d1 = offsetX + ${o.dilations[1]} * imod(imod(pos, ${T}), ${a[2]});

                if(d1 < ${s[c]} && d1 >= 0) {

                  ch = int(float(pos)/ ${T}.);
                    innerDims = vec2(d0, d1);
                    result[${M*2+F}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;let k=`
      ${S}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${I}
          ${O.output} = result;
      }
            `;return{...e,output:{dims:v,type:r.type,textureType:2},shaderSource:k,hasMain:!0}},ih=(n,e,r,t,i)=>{let o=rT(i.cacheKey);return{...o,get:()=>nT(n,o,e,r,t,i)}}});function oT(n,e,r){let t=e[0].dims,i=e[1].dims,o=Rt.calcShape(t,i,!0);if(!o)throw new Error("Can't use matmul on the given tensors");let s=Mt(o.length),a=hr(),{activationFunction:u,applyActivation:c}=Ir(r),g=e.length>2,v=g?"value += getBiasForMatmul();":"",T=g?`${tu(s,a,e[2].dims,o,!1)}`:"",S=o.length,O=t.length,I=i.length,k=t[t.length-1],M=`
    ${u}
    ${T}
    float process(int indices[${S}]) {
        int a[${O}];
        int b[${I}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${k}; ++k) {
            a[${O-1}] = k;
            b[${I-2}] = k;
            value += _A(a) * _B(b);
        }
        ${v}
        ${c}
        return value;
    }`;return{...n,output:{dims:o,type:e[0].type,textureType:0},shaderSource:M}}function eu(n,e){let r=iT(n.length>2,e.activationCacheKey);return{...r,get:()=>oT(r,n,e)}}function tu(n,e,r,t,i){let o="",s=r.length,a=t.length,u=a-s;a<2&&s>0?o="coords":o=r.map((I,k)=>`coords.${e[k+u]}`).join(", ");let g=Rt.getBroadcastDims(r,t).map(I=>`coords.${e[I+u]} = 0;`).join(`
`),T=he.size(r)===1,S="vec4(outputValue.xx, outputValue.yy)";return T&&(S="vec4(outputValue.x)"),i?`
vec4 getBiasForMatmul() {
  ${n} coords = getOutputCoords();
  ${g}
  vec4 outputValue = getBias(${o});
  return ${S};
}`:`
float getBiasForMatmul() {
  ${n} coords = getOutputCoords();
  ${g}
  return getBias(coords.x);
}`}var ah,sh,iT,aT,ba=X(()=>{"use strict";Ke();ze();$r();wn();ru();ah=(n,e,r)=>(aT(e),n.session.pack?[n.run(va(n,e,r),e)]:[n.run(eu(e,r),e)]),sh=n=>ei(n.attributes),iT=(n,e)=>({name:"MatMul",inputNames:n?["A","B","Bias"]:["A","B"],inputTypes:n?[0,0,0]:[0,0],cacheHint:e});aT=n=>{if(!n||n.length!==2)throw new Error("MatMul requires 2 inputs.");if(n[0].dims[n[0].dims.length-1]!==n[1].dims[n[1].dims.length-2])throw new Error("shared dimension does not match.");if(n[0].type!=="float32"&&n[0].type!=="float64"||n[1].type!=="float32"&&n[1].type!=="float64")throw new Error("inputs should be float type");if(n[0].type!==n[1].type)throw new Error("inputs types should match")}});function lT(n,e,r,t){let i=[],o=[],s=r[0].dims,a=r[1].dims,u=s.length,c=a.length,g=t.length,v=g-u,T=g-c;i=s.map((j,Y)=>`coords.${e[Y+v]}`),i[u-1]="i*2",i.join(", "),o=a.map((j,Y)=>`coords.${e[Y+T]}`),o[c-2]="i*2",o.join(", ");let S=Rt.getBroadcastDims(s,t),O=Rt.getBroadcastDims(a,t),I=S.map(j=>`coords.${e[j+v]} = 0;`).join(`
`),k=O.map(j=>`coords.${e[j+T]} = 0;`).join(`
`),M=`int lastDim = coords.${e[g-1]};
  coords.${e[g-1]} = coords.${e[g-2]};
  coords.${e[g-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${n} coords = getOutputCoords();
  ${M}
  ${I}
  vec4 outputValue = getA(${i});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${n} coords = getOutputCoords();
  ${M}
  ${k}
  vec4 outputValue = getB(${o});
  return outputValue;
}`}function cT(n,e){let r="";for(let t=0;t<e-2;t++)r+=`rc.${n[t]}, `;return r+=`rc.${n[e-2]}, i*2`,r}function fT(n,e){let r="";for(let t=0;t<e-2;t++)r+=`rc.${n[t]}, `;return r+=`i*2, rc.${n[e-1]}`,r}var sT,uT,va,ru=X(()=>{"use strict";Ke();lt();ze();$r();wn();ba();sT=(n,e)=>({name:"MatMul (packed)",inputNames:n?["A","B","Bias"]:["A","B"],inputTypes:n?[2,2,2]:[2,2],cacheHint:e}),uT=(n,e,r,t)=>{let i=r.length>2,o=i?"value += getBiasForMatmul();":"",s=r[0].dims,a=r[1].dims,u=Rt.calcShape(s,a,!0),c=!he.areEqual(r[0].dims,r[1].dims);if(!u)throw new Error("Can't use matmul on the given tensors");let g=s[s.length-1],v=Math.ceil(g/2),T=s.length,S=a.length,O=xe(n.session.backend.glContext.version),I=Mt(u.length),k=u.length,M=hr(),{activationFunction:F,applyActivation:j}=Ir(t),Y=i?`${tu(I,M,r[2].dims,u,!0)}`:"",Z=c?`${lT(I,M,r,u)}`:"",P=c?"getAAtOutCoordsMatmul(i)":`getA(${cT(M,T)})`,te=c?"getBAtOutCoordsMatmul(i)":`getB(${fT(M,S)})`,ue=c?"":`${I} rc =
          getOutputCoords(); int lastDim = rc.${M[k-1]}; rc.${M[k-1]} =
          rc.${M[k-2]}; rc.${M[k-2]} = lastDim;
      `,le=`
            ${Z}
            ${Y}
            ${F}
            void main() {
              ${ue}

              vec4 value = vec4(0);
              for (int i = 0; i < ${v}; i++) {
                vec4 a = ${P};
                vec4 b = ${te};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${o}
              ${j}
              ${O.output} = value;
            }`;return{...e,output:{dims:u,type:r[0].type,textureType:2},shaderSource:le,hasMain:!0}},va=(n,e,r)=>{let t=sT(e.length>2,r.activationCacheKey);return{...t,get:()=>uT(n,t,e,r)}}});var uh,lh=X(()=>{"use strict";ya();oh();ru();uh=(n,e,r)=>{let t=e[0].dims,i=e[1].dims,o=ti(t,i,r.dilations,r.pads,r.strides),s=n.run(ih(n,e[0],e[1],o,r),[e[0]]),a=n.reshapePacked(e[1],[i[0],i[1]*i[2]*i[3]]),u=e.length===3?[a,s,e[2]]:[a,s],c=n.run(va(n,u,r),u);return n.reshapePacked(c,o)}});var dT,pT,ch,nu,iu=X(()=>{"use strict";ze();dT=n=>({name:"Im2Col",inputNames:["X"],inputTypes:[0],cacheHint:n}),pT=(n,e,r,t,i,o)=>{let s=r.dims,a=t.dims,u=i.length,c=nu(s,a,i,4),g=`
        const int XC = ${s[1]};
        const int XH = ${s[2]};
        const int XW = ${s[3]};
        const int KH = ${o.kernelShape[0]};
        const int KW = ${o.kernelShape[1]};
        const int dilationH = ${o.dilations[0]};
        const int dilationW = ${o.dilations[1]};
        const int strideH = ${o.strides[0]};
        const int strideW = ${o.strides[1]};
        const int padH = ${o.pads[0]};
        const int padW = ${o.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${u}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${s.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return{...e,output:{dims:c,type:r.type,textureType:4},shaderSource:g}},ch=(n,e,r,t,i)=>{let o=dT(i.cacheKey);return{...o,get:()=>pT(n,o,e,r,t,i)}},nu=(n,e,r,t=4)=>[r[0],r[2],r[3],Math.ceil(n[1]*e[2]*e[3]/t)]});var hT,mT,fh,dh=X(()=>{"use strict";Ke();lt();ze();wn();iu();hT=(n,e)=>({name:"ConvDotProduct",inputNames:n?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:n?[0,4,0]:[0,4],cacheKey:e.activationCacheKey}),mT=(n,e,r,t,i)=>{let o=r[0].dims,s=r[1].dims,a=[s[0],Math.ceil(o[1]*s[2]*s[3]/4)],u=nu(o,s,t),[c,g]=n.calculateTextureWidthAndHeight(a,4),v=he.computeStrides(u),[T,S]=n.calculateTextureWidthAndHeight(u,4),O=t.length,I=r.length<3?"0.0":"_B(b)",k=Math.ceil(o[1]*s[2]*s[3]/4),{activationFunction:M,applyActivation:F}=Ir(i),j=xe(n.session.backend.glContext.version),Y=`
${M}
float process(int indices[${O}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${v[0]} + im2col[1] * ${v[1]} + im2col[2] * ${v[2]};
  int kernelOffset = indices[1] * ${a[1]};
  float value = ${I};
  for (int i = 0; i < ${k}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${T}, ${S});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${c}, ${g});
    value += dot(${j.texture2D}(Im2Col, im2colCoords), ${j.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${F}
  return value;
}`;return{...e,output:{dims:t,type:r[0].type,textureType:0},shaderSource:Y}},fh=(n,e,r,t)=>{let i=hT(e.length>2,t);return{...i,get:()=>mT(n,i,e,r,t)}}});var ti,ou,gT,yT,bT,vT,au,wT,ya=X(()=>{"use strict";Ct();Ke();nh();lh();dh();wn();iu();ba();ti=(n,e,r,t,i)=>{let o=n[0],s=n.slice(2),a=s.length,u=e[0],g=e.slice(2).map((O,I)=>O+(O-1)*(r[I]-1)),T=s.map((O,I)=>O+t[I]+t[I+a]).map((O,I)=>Math.floor((O-g[I]+i[I])/i[I]));return[o,u].concat(...T)},ou=(n,e,r)=>(wT(e,r),gT(n,e,r)),gT=(n,e,r)=>{let t=vT(r,e),i=n.session.pack,o=t.kernelShape[0]===1&&t.kernelShape[1]===1;return t.group>1?[n.run(rh(n,e,t),e)]:o&&i?[yT(n,e,t)]:i&&e[0].dims.length===4&&e[0].dims[0]===1&&!o?[uh(n,e,t)]:[bT(n,e,t)]},yT=(n,e,r)=>{let t=e[0].dims,i=e[1].dims,o=ti(t,i,r.dilations,r.pads,r.strides),s=n.reshapeUnpacked(e[0],[t[1],t[2]*t[3]]),a=n.reshapeUnpacked(e[1],[i[0],i[1]]),u=e.length>2?[a,s,e[2]]:[a,s],c=n.run(eu(u,r),u);return n.reshapeUnpacked(c,o)},bT=(n,e,r)=>{let t=e[0].dims,i=e[1].dims,o=ti(t,i,r.dilations,r.pads,r.strides),s=n.run(ch(n,e[0],e[1],o,r),[e[0]]),a=e.length===3?[s,e[1],e[2]]:[s,e[1]];return n.run(fh(n,e,o,r),a)},vT=(n,e)=>{let r=n.kernelShape.slice();if(n.kernelShape.length===0)for(let o=2;o<e[1].dims.length;++o)r.push(e[1].dims[o]);let t=n.pads.slice();mn.adjustPadsBasedOnAutoPad(e[0].dims,n.strides,n.dilations,r,t,n.autoPad);let i=Object.assign({},n);return Object.assign(i,{kernelShape:r,pads:t,cacheKey:n.cacheKey}),i},au=n=>{let e=n.attributes,r=ei(e),t=e.getString("auto_pad","NOTSET"),i=e.getInts("dilations",[1,1]),o=e.getInt("group",1),s=e.getInts("kernel_shape",[]),a=e.getInts("pads",[0,0,0,0]),u=e.getInts("strides",[1,1]);return ke({autoPad:t,dilations:i,group:o,kernelShape:s,pads:a,strides:u,...r})},wT=(n,e)=>{if(!n||n.length!==2&&n.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(n[0].dims.length!==4||n[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let r=n[0].dims[1],t=n[1].dims[1]*e.group;if(r!==t)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(n.length===3&&(n[2].dims.length!==1||n[1].dims[0]!==n[2].dims[0]))throw new Error("invalid bias");let i=n[0].dims.length-2;if(e.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(e.strides.length!==i)throw new Error(`strides should be ${i}D`);if(e.pads.length!==i*2)throw new Error(`pads should be ${i*2}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==n[1].dims.length-2)throw new Error("invalid kernel shape");if(n[0].type!=="float32"||n[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(n.length===3&&n[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}});var xT,TT,_T,ph,$T,ST,IT,CT,AT,OT,hh,ET,mh=X(()=>{"use strict";Ct();lt();ze();wn();xT=(n,e,r,t,i,o)=>(n-1)*e+r+(t-1)*i+1-o,TT=(n,e,r,t,i)=>{let o=Math.floor(n/2);e==="SAME_UPPER"?(r[t]=o,r[i]=n-o):e==="SAME_LOWER"&&(r[t]=n-o,r[i]=o)},_T=(n,e,r,t,i,o,s,a)=>{let u=n.length-2,c=a.length===0;for(let g=0;g<u;++g){let v=c?n[g+2]*o[g]:a[g],T=xT(n[g+2],o[g],i[g],e[g],r[g],v);TT(T,t,i,g,g+u),c&&a.push(o[g]*(n[g+2]-1)+s[g]+(e[g]-1)*r[g]+1-i[g]-i[g+u])}},ph=(n,e,r)=>(ET(e,r),$T(n,e,r)),$T=(n,e,r)=>{let t=OT(r,e);return[AT(n,e,t)]},ST=(n,e)=>({name:"ConvTranspose",inputNames:n?["X","W","B"]:["X","W"],inputTypes:n?[0,0,0]:[0,0],cacheHint:e}),IT=(n,e,r,t)=>{let o=e.length>2?"getB(output_channel)":"0.0",s=e[0].dims,a=e[1].dims,u=a[1],c=a[0]/t.group,g=[e[0].dims[0],e[1].dims[1]*t.group,...t.outputShape],v=xe(n.session.backend.glContext.version),{activationFunction:T,applyActivation:S}=Ir(t),O=`
  const ivec2 strides = ivec2(${t.strides[0]}, ${t.strides[1]});
  const ivec2 pads = ivec2(${t.pads[0]}, ${t.pads[1]});
  ${T}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${u};
    int wOutChannel = output_channel - group_id * ${u};

    float value = ${o};
    for (int inChannelOffset = 0; inChannelOffset < ${c}; inChannelOffset++) {
      int input_channel = group_id * ${c} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${a[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${a[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${t.dilations[0]}, wHOff * ${t.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${s[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${s[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${S}
    ${v.output} = vec4(value, .0, .0, .0);
  }
`;return{...r,output:{dims:g,type:e[0].type,textureType:0},shaderSource:O,hasMain:!0}},CT=(n,e,r)=>{let t=ST(e.length>2,r.cacheKey);return{...t,get:()=>IT(n,e,t,r)}},AT=(n,e,r)=>n.run(CT(n,e,r),e),OT=(n,e)=>{let r=n.kernelShape.slice();if(n.kernelShape.length===0)for(let a=2;a<e[1].dims.length;++a)r.push(e[1].dims[a]);let t=n.pads.slice(),i=n.outputShape.slice(),o=e[0].dims;_T(o,r,n.dilations,n.autoPad,t,n.strides,n.outputPadding,i);let s=Object.assign({},n);return Object.assign(s,{kernelShape:r,pads:t,outputShape:i,cacheKey:n.cacheKey}),s},hh=n=>{let e=n.attributes,r=ei(e),t=e.getString("auto_pad","NOTSET"),i=e.getInts("dilations",[1,1]),o=e.getInt("group",1),s=e.getInts("kernel_shape",[]),a=e.getInts("output_padding",[0,0]),u=e.getInts("output_shape",[]),c=e.getInts("pads",[0,0,0,0]),g=e.getInts("strides",[1,1]);return ke({autoPad:t,dilations:i,group:o,kernelShape:s,outputPadding:a,outputShape:u,pads:c,strides:g,...r})},ET=(n,e)=>{if(!n||n.length!==2&&n.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(n[0].dims.length!==4||n[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let r=n[0].dims[1],t=n[1].dims[0];if(r!==t)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let i=n[1].dims[1]*e.group;if(n.length===3&&(n[2].dims.length!==1||n[2].dims[0]!==i))throw new Error("invalid bias");let o=n[0].dims.length-2;if(e.dilations.length!==o)throw new Error(`dilations should be ${o}D`);if(e.strides.length!==o)throw new Error(`strides should be ${o}D`);if(e.pads.length!==o*2)throw new Error(`pads should be ${o*2}D`);if(e.outputPadding.length!==o)throw new Error(`output_padding should be ${o}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==n[1].dims.length-2)throw new Error("invalid kernel shape");if(e.outputShape.length!==0&&e.outputShape.length!==n[0].dims.length-2)throw new Error("invalid output shape");if(n[0].type!=="float32"||n[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(n.length===3&&n[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}});var gh,xn,yh,PT,bh,DT,kT,BT,wa=X(()=>{"use strict";Ct();Ke();ze();gh={name:"Transpose",inputNames:["A"],inputTypes:[0]},xn=(n,e,r)=>(BT(e),[n.run({...gh,cacheHint:r.cacheKey,get:()=>PT(n,e[0],r.perm)},e)]),yh=n=>ke({perm:n.attributes.getInts("perm",[])}),PT=(n,e,r)=>{let t=e.dims;r=bh(t,r);let i=DT(t,r),o=t.length,s=`
      ${kT("perm",r,o)}
      float process(int indices[${o}]) {
        int a[${o}];
        perm(a, indices);
        return _A(a);
      }`;return{...gh,output:{dims:i,type:e.type,textureType:0},shaderSource:s}},bh=(n,e)=>(e&&e.length!==n.length&&(e=[...n.keys()].reverse()),e),DT=(n,e)=>(e=bh(n,e),he.sortBasedOnPerm(n,e)),kT=(n,e,r)=>{let t=[];t.push(`void ${n}(out int a[${r}], int src[${r}]) {`);for(let i=0;i<r;++i)t.push(`	a[${e[i]}]=src[${i}];`);return t.push("	}"),t.join(`
`)},BT=n=>{if(!n||n.length!==1)throw new Error("Transpose requires 1 input.");if(n[0].type!=="float32"&&n[0].type!=="float64")throw new Error("input should be float tensor")}});var vh,wh,RT,xh=X(()=>{"use strict";wa();vh=(n,e,r)=>{RT(e);let t=r.blocksize,i=t*t,o=r.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],s=r.mode==="DCR"?[e[0].dims[0],t,t,e[0].dims[1]/i,e[0].dims[2],e[0].dims[3]]:[e[0].dims[0],e[0].dims[1]/i,t,t,e[0].dims[2],e[0].dims[3]],a=n.reshapeUnpacked(e[0],s),u={perm:o,cacheKey:`${o}`},[c]=xn(n,[a],u),g=[e[0].dims[0],e[0].dims[1]/i,e[0].dims[2]*t,e[0].dims[3]*t];return[n.reshapeUnpacked(c,g)]},wh=n=>{let e=n.attributes.getInt("blocksize");if(e<1)throw new Error(`blocksize must be >= 1, but got : ${e} for DepthToSpace`);let r=n.attributes.getString("mode","DCR");if(r!=="DCR"&&r!=="CRD")throw new Error(`unrecognized mode: ${r} for DepthToSpace`);return{mode:r,blocksize:e}},RT=n=>{if(n.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${n.length}`);if(n[0].type==="string"||n[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}});var Th,_h,MT,$h=X(()=>{"use strict";Ke();Th=(n,e,r)=>{MT(e,r);let t=he.flattenShape(e[0].dims,r);return[n.reshapeUnpacked(e[0],t)]},_h=n=>n.attributes.getInt("axis",1),MT=(n,e)=>{if(!n||n.length!==1)throw new Error("Flatten requires 1 input.");let r=n[0].dims.length;if(r===0)throw new Error("scalar tensor is not supported.");if(e<-r||e>r)throw new Error("Invalid axis");if(n[0].type==="string")throw new Error("string tensor is not supported.")}});var Vr,oo=X(()=>{"use strict";Vr=["float32","float64","int32","int16","int8","uint16","uint32","uint8"]});var Sh,Ih,LT,NT,zT,FT,Ch=X(()=>{"use strict";Ct();oo();Ke();ze();Sh=(n,e,r)=>(FT(e,r.axis),[n.run(zT(n,e,r),e)]),Ih=n=>ke({axis:n.attributes.getInt("axis",0)}),LT={name:"Gather",inputNames:["A","B"],inputTypes:[0,0]},NT=(n,e,r,t)=>{let i=r[0].dims.slice(),o=r[1].dims.slice(),s=new Array(i.length+o.length-1);t=he.normalizeAxis(t,i.length);let a=[];for(let T=0;T<s.length;T++)T<t?(s[T]=i[T],a.push(`inputIdx[${T}] = outputIdx[${T}];`)):T<t+o.length?(s[T]=o[T-t],a.push(`indexDataIdx[${T-t}] = outputIdx[${T}];`)):(s[T]=i[T-o.length+1],a.push(`inputIdx[${T-o.length+1}] = outputIdx[${T}];`));let u=s.length||1,c=i.length,g=o.length||1,v=`
      float process(int outputIdx[${u}]) {
        int inputIdx[${c}];
        int indexDataIdx[${g}];
        indexDataIdx[0] = 0;
        ${a.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${t}] = idx < 0 ? idx + ${i[t]} : idx;
        return _A(inputIdx);
      }`;return{...e,output:{dims:s,type:r[0].type,textureType:0},shaderSource:v}},zT=(n,e,r)=>{let t={...LT,cacheHint:r.cacheKey};return{...t,get:()=>NT(n,t,e,r.axis)}},FT=(n,e)=>{if(!n||n.length!==2)throw new Error("Gather requires 2 inputs.");let r=n[0].dims.length;if(r<1)throw new Error("Invalid input shape.");if(e<-r||e>r-1)throw new Error("Invalid axis.");if(Vr.indexOf(n[0].type)===-1)throw new Error("Invaid input type.");if(n[1].type!=="int32"&&n[1].type!=="int16")throw new Error("Invaid input type.")}});var su,Ah,Oh,Eh,jT,GT,WT,Ph=X(()=>{"use strict";Ct();Ke();ze();su=(n,e,r)=>(WT(e,r),[n.run(jT(e,r),e)]),Ah=(n,e)=>{let r=n.attributes.getInt("transA",0)!==0,t=n.attributes.getInt("transB",0)!==0,i=n.attributes.getFloat("alpha",1),o=n.attributes.getFloat("beta",1);return ke({transA:r,transB:t,alpha:i,beta:o,isOptionalC:e})},Oh=n=>Ah(n,!1),Eh=n=>Ah(n,!0),jT=(n,e)=>{let r={name:"Gemm",inputNames:n.length===3?["A","B","C"]:["A","B"],inputTypes:n.length===3?[0,0,0]:[0,0],key:e.cacheKey};return{...r,get:()=>GT(r,n,e)}},GT=(n,e,r)=>{let t=e[0].dims.slice(),i=e[1].dims.slice(),[o,s]=la.getShapeOfGemmResult(t,r.transA,i,r.transB,e.length===3?e[2].dims:void 0),a=[o,s];if(!a)throw new Error("Can't use gemm on the given tensors");let u=t[t.length-1],c="";r.transA&&(u=t[0]),r.transA&&r.transB?c="value += _A_T(a) * _B_T(b);":r.transA&&!r.transB?c="value += _A_T(a) * _B(b);":!r.transA&&r.transB?c="value += _A(a) * _B_T(b);":!r.transA&&!r.transB&&(c="value += _A(a) * _B(b);");let g=a.length,v=e.length===3?`int c[${e[2].dims.length}];`:"",T=e.length===3?"bcastIndices_C(indices, c);":"",S=e.length===3?"value += beta * _C(c);":"",O=`
      float process(int indices[${g}]) {
          int a[${g}];
          int b[${g}];
          ${v}

          copyVec(indices, a);
          copyVec(indices, b);
          ${T}

          float value = 0.0;
          for (int k=0; k<${u}; ++k) {
              a[${g-1}] = k;
              b[${g-2}] = k;
              ${c}
          }

          value = value * alpha;
          ${S}
          return value;
      }`;return{...n,output:{dims:a,type:e[0].type,textureType:0},variables:[{name:"alpha",type:"float",data:r.alpha},{name:"beta",type:"float",data:r.beta}],shaderSource:O}},WT=(n,e)=>{if(!n)throw new Error("Input is missing");if(e.isOptionalC&&(n.length<2||n.length>3))throw new Error("Invaid input shape.");if(!e.isOptionalC&&n.length!==3)throw new Error("Gemm requires 3 inputs");if(n.length===3&&n[2].dims.length!==1&&n[2].dims.length!==2)throw new Error("Invalid input shape of C");if(n[0].type!=="float32"&&n[0].type!=="float64"||n[1].type!=="float32"&&n[1].type!=="float64"||n.length===3&&n[2].type!=="float32"&&n[2].type!=="float64")throw new Error("Invalid input type.");if(n[0].type!==n[1].type||n.length===3&&n[0].type!==n[2].type)throw new Error("Input types are mismatched")}});var Dh,kh,VT,UT,HT,qT,KT,Bh=X(()=>{"use strict";Ct();ze();Dh=(n,e,r)=>(KT(e),[n.run(HT(n,e,r),e)]),kh=n=>{let e=n.attributes.getFloat("scale"),r=n.attributes.getFloats("bias");return ke({scale:e,bias:r})},VT={name:"ImageScaler",inputNames:["X"],inputTypes:[0]},UT=(n,e,r,t)=>{let i=r[0].dims.slice(),o=i.length,a=`
      ${qT(t.bias.length)}
      float process(int indices[${o}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return{...e,output:{dims:i,type:r[0].type,textureType:0},variables:[{name:"bias",type:"float",arrayLength:t.bias.length,data:t.bias},{name:"scale",type:"float",data:t.scale}],shaderSource:a}},HT=(n,e,r)=>{let t={...VT,cacheHint:r.cacheKey};return{...t,get:()=>UT(n,t,e,r)}},qT=n=>{let e=[`float getBias(float bias[${n}], int channel) {`];for(let r=0;r<n;++r)r===0?e.push(`	if (channel == ${r}) { return bias[${r}]; }`):r===n-1?e.push(`	else { return bias[${r}]; }`):e.push(`	else if (channel == ${r}) { return bias[${r}]; }`);return e.push("	}"),e.join(`
`)},KT=n=>{if(!n||n.length!==1)throw new Error("ImageScaler requires 1 input.");if(n[0].dims.length!==4)throw new Error("Invalid input shape.");if(n[0].type!=="float32"&&n[0].type!=="float64")throw new Error("Invalid input type.")}});var Mh,Lh,Rh,XT,YT,JT,ZT,QT,e_,Nh=X(()=>{"use strict";lt();ze();Mh=(n,e,r)=>{e_(e);let t=n.run(YT(e[0]),e);return[n.run(QT(n,e[0],r,t.dims),[e[0],t,e[1],e[2]])]},Lh=n=>n.attributes.getFloat("epsilon",1e-5),Rh={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[0]},XT=(n,e)=>{let r=e.dims.slice(),t=r[1],i=r[2]*r[3],o=[r[0],t],s=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${r[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${r[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${i});
        temp = 0.0;
        for(int a2=0; a2<${r[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${r[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${i});

        return v;
      }`;return{...n,output:{dims:o,type:e.type,textureType:4},shaderSource:s}},YT=n=>({...Rh,get:()=>XT(Rh,n)}),JT={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[0,4,0,0]},ZT=(n,e,r,t,i)=>{let o=xe(n.session.backend.glContext.version),[s,a]=n.calculateTextureWidthAndHeight(i,4),[u,c]=[s/4,a],g=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${u}, ${c});
        return ${o.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return{...e,output:{dims:r.dims,type:r.type,textureType:0},variables:[{name:"epsilon",type:"float",data:t}],shaderSource:g}},QT=(n,e,r,t)=>{let i={...JT,cacheHint:`${r}`};return{...i,get:()=>ZT(n,i,e,r,t)}},e_=n=>{if(!n||n.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");let e=n[0],r=n[1],t=n[2];if(e.dims.length<3||r.dims.length!==1||t.dims.length!==1)throw new Error("Invalid input shape.");if(r.dims[0]!==e.dims[1]||t.dims[0]!==e.dims[1])throw new Error("Input shapes are mismatched.");if(e.type!=="float32"&&e.type!=="float64"||r.type!=="float32"&&r.type!=="float64"||t.type!=="float32"&&t.type!=="float64")throw new Error("Invalid input type.");if(n[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}});function t_(n,e){let r=n[0].dims[1],t=n[0].dims.length,i=-Math.floor((e.size-1)/2),o=Math.ceil((e.size-1)/2),s=`float(${e.alpha}) / float(${e.size})`,a=`float(${e.bias})`,u=`float(${e.beta})`,c=`
    float process(int indices[${t}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${i}; i <= ${o}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${r}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(${a} + ${s} * square_sum, ${u});
    }`;return{...jh,cacheHint:e.cacheKey,output:{dims:n[0].dims,type:n[0].type,textureType:0},shaderSource:c}}function r_(n,e){return{...jh,cacheHint:e.cacheKey,get:()=>t_(n,e)}}var zh,Fh,jh,n_,Gh=X(()=>{"use strict";Ct();ze();zh=(n,e,r)=>(n_(e),[n.run(r_(e,r),e)]),Fh=n=>{let e=n.attributes.getFloat("alpha",1e-4),r=n.attributes.getFloat("beta",.75),t=n.attributes.getFloat("bias",1),i=n.attributes.getInt("size");return ke({alpha:e,beta:r,bias:t,size:i})},jh={name:"LRN",inputNames:["X"],inputTypes:[0]};n_=n=>{if(!n||n.length!==1)throw new Error("LRN requires 1 input.");if(n[0].dims.length!==4)throw new Error('currently only support LRN for input with "NCHW" format');if(n[0].type!=="float32")throw new Error("input should be float type")}});var i_,uu,Wh,Vh,Uh,o_,a_,s_,u_,l_,c_,f_,d_,Hh=X(()=>{"use strict";Ct();Ke();lt();ze();i_={name:"Pad",inputNames:["A"],inputTypes:[0]},uu=(n,e,r)=>(s_(e),[n.run({...i_,cacheHint:r.cacheKey,get:()=>a_(n,e[0],r)},e)]),Wh=n=>{let e=n.attributes.getString("mode","constant"),r=n.attributes.getFloat("value",0),t=n.attributes.getInts("pads");return ke({mode:e,value:r,pads:t})},Vh=(n,e,r)=>{u_(e);let t=o_(n,e,r);return uu(n,[e[0]],t)},Uh=n=>n.attributes.getString("mode","constant"),o_=(n,e,r)=>{if(!n.session.isInitializer(e[1].dataId)||e.length>=3&&!n.session.isInitializer(e[2].dataId))throw new Error("dynamic pad attributes are not allowed");let t=Array.from(e[1].integerData),i=e.length>=3?e[2].floatData[0]:0;return ke({mode:r,pads:t,value:i})},a_=(n,e,r)=>{let t=he.padShape(e.dims.slice(),r.pads),i=t.length,s=`
      ${l_(n,e,r)}
      float process(int[${i}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[0],output:{dims:t,type:e.type,textureType:0},shaderSource:s}},s_=n=>{if(!n||n.length!==1)throw new Error("Pad requires 1 input");if(n[0].type!=="float32"&&n[0].type!=="float64")throw new Error("Invalid input type.")},u_=n=>{if(!n||n.length!==2&&n.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(n[1].type!=="int32")throw new Error("Invalid input type.");if(n.length>=3&&n[2].type==="string")throw new Error("Invalid input type.")},l_=(n,e,r)=>{let t=xe(n.session.backend.glContext.version),[i,o]=n.calculateTextureWidthAndHeight(e.dims,0),s=he.computeStrides(e.dims);switch(r.mode){case"constant":return c_(t,e.dims,s,i,o,r.pads,r.value);case"reflect":return f_(t,e.dims,s,i,o,r.pads);case"edge":return d_(t,e.dims,s,i,o,r.pads);default:throw new Error("Invalid mode")}},c_=(n,e,r,t,i,o,s)=>{let a=e.length,u="";for(let c=a-1;c>=0;--c)u+=`
        k = m[${c}] - ${o[c]};
        if (k < 0)  return constant;
        if (k >= ${e[c]}) return constant;
        offset += k * ${r[c]};
        `;return`
      float padA(int m[${a}]) {
        const float constant = float(${s});
        int offset = 0;
        int k = 0;
        ${u}
        vec2 coords = offsetToCoords(offset, ${t}, ${i});
        float value = getColorAsFloat(${n.texture2D}(A, coords));
        return value;
      }
      `},f_=(n,e,r,t,i,o)=>{let s=e.length,a="";for(let u=s-1;u>=0;--u)a+=`
        k = m[${u}] - ${o[u]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(e[u]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${e[u]}) { k = _2n_1 - k; }
        }
        offset += k * ${r[u]};
        `;return`
      float padA(int m[${s}]) {
        int offset = 0;
        int k = 0;
        ${a}
        vec2 coords = offsetToCoords(offset, ${t}, ${i});
        float value = getColorAsFloat(${n.texture2D}(A, coords));
        return value;
      }
      `},d_=(n,e,r,t,i,o)=>{let s=e.length,a="";for(let u=s-1;u>=0;--u)a+=`
        k = m[${u}] - ${o[u]};
        if (k < 0)  k = 0;
        if (k >= ${e[u]}) k = ${e[u]-1};
        offset += k * ${r[u]};
      `;return`
      float padA(int m[${s}]) {
        int offset = 0;
        int k = 0;
        ${a}
        vec2 coords = offsetToCoords(offset, ${t}, ${i});
        float value = getColorAsFloat(${n.texture2D}(A, coords));
        return value;
      }
      `}});var Kh,Xh,Yh,Jh,Zh,Qh,em,tm,rm,p_,qh,nm,Ta,im,xa,h_,om=X(()=>{"use strict";Ct();Ke();ze();Kh=(n,e,r)=>{Ta(e);let t={name:"AveragePool",inputNames:["X"],inputTypes:[0],cacheHint:r.cacheKey};return[n.run({...t,get:()=>Yh(e,t,!1,r)},e)]},Xh=n=>{let e=n.attributes.getString("auto_pad","NOTSET"),r=n.attributes.getInt("ceil_mode",0),t=n.attributes.getInt("count_include_pad",0)!==0,i=n.attributes.getInts("kernel_shape"),o=n.attributes.getInts("strides",[]),s=n.attributes.getInts("pads",[]);if(r!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return ke({autoPad:e,ceilMode:r,countIncludePad:t,kernelShape:i,strides:o,pads:s})},Yh=(n,e,r,t)=>{let[i,o]=rm(n,t,r),s=he.size(i.kernelShape),a="value += _X(x);",u="";i.countIncludePad?u+=`value /= float(${s});`:u+=`value /= float(${s} - pad);`;let g=`
        ${im(n[0].dims,i,a,u,"0.0")}
      `;return{...e,output:{dims:o,type:n[0].type,textureType:0},shaderSource:g}},Jh=(n,e,r)=>{Ta(e);let t={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[0],cacheHint:`${r.countIncludePad}`};return[n.run({...t,get:()=>Yh(e,t,!0,r)},e)]},Zh=n=>{let e=n.attributes.getInt("count_include_pad",0)!==0;return ke({autoPad:"",ceilMode:0,countIncludePad:e,kernelShape:[],strides:[],pads:[]})},Qh=(n,e,r)=>{Ta(e);let t={name:"MaxPool",inputNames:["X"],inputTypes:[0],cacheHint:r.cacheKey};return[n.run({...t,get:()=>tm(e,t,!1,r)},e)]},em=n=>{let e=n.attributes.getString("auto_pad","NOTSET"),r=n.attributes.getInt("ceil_mode",0),t=n.attributes.getInts("kernel_shape"),i=n.attributes.getInts("strides",[]),o=n.attributes.getInts("pads",[]),s=n.attributes.getInt("storage_order",0),a=n.attributes.getInts("dilations",[]);if(s!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(r!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return ke({autoPad:e,ceilMode:r,countIncludePad:!1,kernelShape:t,strides:i,pads:o,storageOrder:s,dilations:a})},tm=(n,e,r,t)=>{let[i,o]=rm(n,t,r),s=`
      value = max(_X(x), value);
    `,a="",c=`
      ${im(n[0].dims,i,s,a,"-1e5")}
    `;return{...e,output:{dims:o,type:n[0].type,textureType:0},shaderSource:c}},rm=(n,e,r)=>{let t=n[0].dims.slice(),i=Object.hasOwnProperty.call(e,"dilations"),o=e.kernelShape.slice(),s=e.strides.slice(),a=i?e.dilations.slice():[],u=e.pads.slice();mn.adjustPoolAttributes(r,t,o,s,a,u);let c=mn.computePoolOutputShape(r,t,s,a,o,u,e.autoPad),g=Object.assign({},e);return i?Object.assign(g,{kernelShape:o,strides:s,pads:u,dilations:a,cacheKey:e.cacheKey}):Object.assign(g,{kernelShape:o,strides:s,pads:u,cacheKey:e.cacheKey}),[g,c]},p_={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},qh={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[0]},nm=(n,e)=>(Ta(e),[n.run({...qh,get:()=>tm(e,qh,!0,p_)},e)]),Ta=n=>{if(!n||n.length!==1)throw new Error("Pool ops requires 1 input.");if(n[0].type!=="float32"&&n[0].type!=="float64")throw new Error("Invalid input type.")},im=(n,e,r,t,i)=>{let o=n.length;if(e.kernelShape.length<=2){let s=e.kernelShape[e.kernelShape.length-1],a=e.strides[e.strides.length-1],u=e.pads[e.pads.length/2-1],c=e.pads[e.pads.length-1],g=n[o-1],v="",T="",S="";if(u+c!==0?v=`
          for (int i = 0; i < ${s}; i++) {
            x[${o} - 1] = indices[${o} - 1] * ${a} - ${u} + i;
            if (x[${o} - 1] < 0 || x[${o} - 1] >= ${g}) {
              pad++;
              continue;
            }
            ${r}
          }`:v=`
          for (int i = 0; i < ${s}; i++) {
            x[${o} - 1] = indices[${o} - 1] * ${a} - ${u} + i;
            ${r}
          }`,e.kernelShape.length===2){let I=e.kernelShape[e.kernelShape.length-2],k=e.strides[e.strides.length-2],M=e.pads[e.pads.length/2-2],F=e.pads[e.pads.length-2],j=n[o-2];M+F!==0?T=`
            for (int j = 0; j < ${I}; j++) {
              x[${o} - 2] = indices[${o} - 2] * ${k} - ${M} + j;
              if (x[${o} - 2] < 0 || x[${o} - 2] >= ${j}) {
                pad+= ${s};
                continue;
              }
          `:T=`
            for (int j = 0; j < ${I}; j++) {
              x[${o} - 2] = indices[${o} - 2] * ${k} - ${M} + j;
            `,S=`
          }
        `}return`
        float process(int indices[${o}]) {
          int x[${o}];
          copyVec(indices, x);

          float value = ${i};
          int pad = 0;
          ${T}
          ${v}
          ${S}
          ${t}
          return value;
        }
      `}else{let s=he.size(e.kernelShape),a=he.computeStrides(e.kernelShape),u=a.length,c=e.pads.length,g=h_(u),v=xa(n,"inputDims"),T=xa(e.pads,"pads"),S=xa(a,"kernelStrides"),O=xa(e.strides,"strides"),I=e.pads.reduce((F,j)=>F+j),k="";return I?k=`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${r}
          }`:k=`
          }
          ${r}
        `,`
        ${g}
        float process(int indices[${o}]) {
          int x[${o}];
          copyVec(indices, x);
          int offset[${u}];
          int pads[${c}];
          int inputDims[${o}];
          int kernelStrides[${u}];
          int strides[${u}];
          ${T}
          ${v}
          ${O}
          ${S}

          float value = ${i};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${s}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${o} - ${u}; j < ${o}; j++) {
              x[j] = indices[j] * strides[j - ${o} + ${u}]
                + offset[j - ${o} + ${u}] - pads[j - 2];
              ${k}
          }
          ${t}

          return value;
        }
      `}},xa=(n,e)=>{let r="";for(let t=0;t<n.length;t++)r+=`
      ${e}[${t}] = ${n[t]};
    `;return r},h_=n=>`
  void offsetToIndices(int offset, int[${n}] strides, out int[${n}] indices) {
    if (${n} == 0) {
      return;
    }
    for (int i = 0; i < ${n} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${n} - 1] = offset;
  }`});var Tn,Ur,m_,g_,am,sm,um,lm,cm,fm,dm,pm=X(()=>{"use strict";Ct();oo();Ke();ze();Tn=(n,e,r,t,i)=>{g_(e);let o={name:t,inputNames:["A"],inputTypes:[0]};return[n.run({...o,cacheHint:r.cacheKey,get:()=>m_(n,e,r,t,i,o)},e)]},Ur=n=>{let e=n.attributes.getInts("axes",[]),r=n.attributes.getInt("keepdims",1)===1;return ke({axes:e,keepDims:r})},m_=(n,e,r,t,i,o)=>{let s=[],a=e[0].dims.length||1,u=[],c=he.normalizeAxes(r.axes,e[0].dims.length),g=i(e,c),v=g[1];for(let O=0;O<e[0].dims.length;O++)c.indexOf(O)>=0||c.length===0?(r.keepDims&&s.push(1),v=`
          for(int j${O} = 0; j${O} < ${e[0].dims[O]}; j${O}++) {
            inputIdx[${O}] = j${O};
            ${v}
          }`):(u.push(`inputIdx[${O}] = outputIdx[${s.length}];`),s.push(e[0].dims[O]));let S=`
      float process(int outputIdx[${s.length||1}]) {
        float value;                 // final result
        int inputIdx[${a}];      // addressing input data
        ${u.join(`
`)}
        ${g[0]}       // init ops for reduce max/min
        ${v}
        ${g[2]}       // final computation for reduce mean
        return value;
      }`;return{...o,output:{dims:s,type:e[0].type,textureType:0},shaderSource:S}},g_=n=>{if(!n||n.length!==1)throw new Error("Reduce op requires 1 input.");if(Vr.indexOf(n[0].type)===-1)throw new Error("Invalid input type.")},am=(n,e,r)=>Tn(n,e,r,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),sm=(n,e,r)=>Tn(n,e,r,"ReduceMean",(i,o)=>{let s=1;for(let a=0;a<i[0].dims.length;a++)(o.indexOf(a)>=0||o.length===0)&&(s*=i[0].dims[a]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${s}.;`]}),um=(n,e,r)=>Tn(n,e,r,"ReduceMax",(i,o)=>{let s=[];for(let a=0;a<i[0].dims.length;a++)(o.indexOf(a)>=0||o.length===0)&&s.push(`inputIdx[${a}] = 0;`);return[`${s.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),lm=(n,e,r)=>Tn(n,e,r,"ReduceMin",(i,o)=>{let s=[];for(let a=0;a<i[0].dims.length;a++)(o.indexOf(a)>=0||o.length===0)&&s.push(`inputIdx[${a}] = 0;`);return[`${s.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),cm=(n,e,r)=>Tn(n,e,r,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),fm=(n,e,r)=>Tn(n,e,r,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),dm=(n,e,r)=>Tn(n,e,r,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])});var hm,mm=X(()=>{"use strict";Ke();hm=(n,e)=>{let r=he.calculateReshapedDims(e[0].dims,e[1].integerData);return n.session.pack?[n.reshapePacked(e[0],r)]:[n.reshapeUnpacked(e[0],r)]}});var gm,lu,ym,bm,ao,y_,cu,_a,fu=X(()=>{"use strict";Ct();lt();ze();gm={name:"Upsample",inputNames:["X"],inputTypes:[0]},lu=(n,e,r)=>(cu(e,r),[n.run({...gm,cacheHint:r.cacheKey,get:()=>y_(n,e,r)},e)]),ym=n=>ao(n,7),bm=n=>ao(n,9),ao=(n,e)=>{let r=e>=10,t=n.attributes.getString("mode","nearest");if(t!=="nearest"&&t!=="linear"&&(e<11||t!=="cubic"))throw new Error(`unrecognized mode: ${t}`);let i=[];e<9&&(i=n.attributes.getFloats("scales"),_a(i,t,r));let o=n.attributes.getFloat("extrapolation_value",0),s=e>10?n.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(s)===-1)throw new Error(`coordinate_transform_mode '${s}' is not supported`);let a=s==="tf_crop_and_resize",u=a,c=t==="nearest"&&e>=11?n.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(c)===-1)throw new Error(`nearest_mode '${c}' is not supported`);let g=n.attributes.getFloat("cubic_coeff_a",-.75),v=n.attributes.getInt("exclude_outside",0)!==0;if(v&&t!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");let T=e<11?!0:t==="nearest"&&s==="asymmetric"&&c==="floor",S=0,O=0,I=0;return e>10?n.inputs.length>2?(S=1,O=2,I=3):(O=1,I=2):e===9&&(O=1),ke({opset:e,isResize:r,mode:t,scales:i,extrapolationValue:o,coordinateTransformMode:s,useExtrapolation:u,needRoiInput:a,nearestMode:c,cubicCoefficientA:g,excludeOutside:v,useNearest2xOptimization:T,roiInputIdx:S,scalesInputIdx:O,sizesInputIdx:I})},y_=(n,e,r)=>{let t=xe(n.session.backend.glContext.version),[i,o]=n.calculateTextureWidthAndHeight(e[0].dims,0),s=e[0].dims.map((I,k)=>Math.floor(I*r.scales[k])),[a,u]=n.calculateTextureWidthAndHeight(s,0),c=s.length,g=new Array(c),v=new Array(c),T=`
      int output_pitches[${c}];
      int input_pitches[${c}];
      `;for(let I=c-1;I>=0;I--)g[I]=I===c-1?1:g[I+1]*s[I+1],v[I]=I===c-1?1:v[I+1]*e[0].dims[I+1],T+=`
        output_pitches[${I}] = ${g[I]};
        input_pitches[${I}] = ${v[I]};
        `;let S=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${i}, ${o});
        float value = getColorAsFloat(${t.texture2D}(X, coords));
        return value;
      }
      `,O=r.mode==="nearest"?`
    ${S}
    float process(int indices[${c}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${a}, ${u});

      ${T}

      int d, m;
      for (int dim = 0; dim < ${c}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:c===4?`
    ${S}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${a}, ${u});

      ${T}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${e[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${S}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${a}, ${u});

      ${T}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${e[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return{...gm,output:{dims:s,type:e[0].type,textureType:0},shaderSource:O,variables:[{name:"scales",type:"int",arrayLength:r.scales.length,data:r.scales.map(I=>Math.ceil(I))}]}},cu=(n,e)=>{if(!n||e.opset<9&&n.length!==1||e.opset>=9&&e.opset<11&&n.length!==2||e.opset>=11&&n.length<2)throw new Error("invalid inputs.");if(e.scales.length>0&&n[0].dims.length!==e.scales.length)throw new Error("Invalid input shape.");if(n[0].type==="string")throw new Error("Invalid input tensor types.")},_a=(n,e,r)=>{if(r){for(let t of n)if(t<=0)throw new Error("Scale value should be greater than 0.")}else for(let t of n)if(t<1)throw new Error("Scale value should be greater than or equal to 1.");if((e==="linear"||e==="cubic")&&n.length!==2&&(n.length!==4||n[0]!==1||n[1]!==1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${r?"Resize":"Upsample"} opeartor.`)}});var du,pu,vm,wm,b_,v_,w_,x_,xm=X(()=>{"use strict";lt();ze();$r();vn();fu();du={name:"Resize",inputNames:["A"],inputTypes:[2]},pu=(n,e,r)=>(cu(e,r),[n.run({...du,cacheHint:r.cacheKey,get:()=>b_(n,e,r)},e)]),vm=n=>ao(n,10),wm=n=>ao(n,11),b_=(n,e,r)=>{let t=xe(n.session.backend.glContext.version),[i,o]=v_(e,r);if(i.every(j=>j===1)&&r.coordinateTransformMode!=="tf_crop_and_resize")return{...du,output:{dims:o,type:e[0].type,textureType:2},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${t.texture2D}(X, TexCoords);
                    ${t.output} = v;
                }`};let a=o.length;if(a<2)throw new Error(`output dimension should be at least 2, but got ${a}`);let u=o[a-2],c=o[a-1],g=e[0].dims;if(a!==g.length)throw new Error(`output dimension should match input ${g.length}, but got ${a}`);let v=g[a-2],T=g[a-1],S=i[a-2],O=i[a-1],I="";if(r.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${r.mode}'`);switch(r.coordinateTransformMode){case"asymmetric":I=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":I=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":I=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${c}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${u}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${c}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${u}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":I=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${c}.0 - 1.0, ${u}.0 - 1.0, ${c}.0 - 1.0,
                            ${u}.0 - 1.0);
                        vec4 original = vec4(${T}.0 - 1.0, ${v}.0 - 1.0, ${T}.0 - 1.0,
                            ${v}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${r.coordinateTransformMode}'`)}let k=Mt(a),M=Sr(),F=`
            const vec2 inputWH = vec2(${v}.0, ${T}.0);
            const vec4 scaleWHWH = vec4(float(${S}), float(${O}), float(${S}), float(${O}));
            ${M}
            ${I}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${k} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${u-1};
                bool hasNextCol = rc.z < ${c-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${t.output} = vec4(newValue);
            }
        `;return{...du,output:{dims:o,type:e[0].type,textureType:2},hasMain:!0,shaderSource:F}},v_=(n,e)=>{let t=n[0].dims,i=e.scales,o;if(i.length===0){let a=n[e.scalesInputIdx];if(a&&a.size!==0){if(n[e.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");i=w_(a,e.mode,e.isResize)}else{let u=n[e.sizesInputIdx];if(!u||u.size===0)throw new Error("Either scales or sizes MUST be provided as input.");o=Array.from(u.integerData),i=x_(o,t,e.mode,e.isResize)}}else if(n[e.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");let s=o||t.map((a,u)=>Math.floor(a*i[u]));return[i,s]},w_=(n,e,r)=>{let t=Array.from(n.floatData);return _a(t,e,r),t},x_=(n,e,r,t)=>{let i=e.length,o=new Array(i);for(let s=0,a=i;s<a;s++)if(e[s]===0){if(n[s]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");o[s]=1}else o[s]=n[s]/e[s];return _a(o,r,t),o}});var Tm,T_,_m=X(()=>{"use strict";bn();Tm=(n,e)=>(T_(e),[new vt([e[0].dims.length],"int32",void 0,void 0,new Int32Array(e[0].dims))]),T_=n=>{if(!n||n.length!==1)throw new Error("Shape requires 1 input.")}});var hu,$m,Sm,Im,__,Cm,$_,S_,Am=X(()=>{"use strict";Ct();oo();Ke();ze();hu={name:"Slice",inputNames:["A"],inputTypes:[0]},$m=(n,e,r)=>(__(e),[n.run({...hu,cacheHint:r.cacheKey,get:()=>Im(n,e[0],r)},e)]),Sm=n=>{let e=n.attributes.getInts("starts"),r=n.attributes.getInts("ends"),t=n.attributes.getInts("axes",[]);return ke({starts:e,ends:r,axes:t})},Im=(n,e,r)=>{let t=r.axes.length===0?e.dims.slice(0).map((v,T)=>T):r.axes,i=he.normalizeAxes(t,e.dims.length),o=r.starts.map((v,T)=>v>e.dims[i[T]]-1?e.dims[i[T]]:he.normalizeAxis(v,e.dims[i[T]])),s=r.ends.map((v,T)=>v>e.dims[i[T]]-1?e.dims[i[T]]:he.normalizeAxis(v,e.dims[i[T]])),a=e.dims.slice(),u=[];for(let v=0;v<i.length;v++)a[i[v]]=s[v]-o[v],o[v]>0&&u.push(`outputIdx[${i[v]}] += ${o[v]};`);let g=`
      float process(int outputIdx[${a.length}]) {
        ${u.join(`
      `)}
        return _A(outputIdx);
      }`;return{...hu,output:{dims:a,type:e.type,textureType:0},shaderSource:g}},__=n=>{if(!n||n.length!==1)throw new Error("Slice requires 1 input.");if(Vr.indexOf(n[0].type)===-1)throw new Error("Invalid input type.")},Cm=(n,e)=>{S_(e);let r=$_(n,e);return[n.run({...hu,cacheHint:r.cacheKey,get:()=>Im(n,e[0],r)},[e[0]])]},$_=(n,e)=>{if(!n.session.isInitializer(e[1].dataId)||!n.session.isInitializer(e[2].dataId)||e.length>=4&&!n.session.isInitializer(e[3].dataId)||e.length>=5&&!n.session.isInitializer(e[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(e.length>=5&&e[4].integerData.some(s=>s!==1))throw new Error("currently non-1 steps is not supported for Slice");let r=Array.from(e[1].integerData),t=Array.from(e[2].integerData),i=e.length>=4?Array.from(e[3].integerData):[],o=`${i};${r};${t}`;return{starts:r,ends:t,axes:i,cacheKey:o}},S_=n=>{if(!n||n.length<3||n.length>5)throw new Error("Invalid input number.");if(n[1].type!=="int32"||n[1].dims.length!==1)throw new Error("Invalid input type.");if(n[2].type!=="int32"||n[2].dims.length!==1)throw new Error("Invalid input type.");if(n.length>=4&&(n[3].type!=="int32"||n[3].dims.length!==1))throw new Error("Invalid input type.");if(n.length>=5&&(n[4].type!=="int32"||n[4].dims.length!==1))throw new Error("Invalid input type.")}});var Om,Em,Pm,Dm,km,Bm,Rm,Mm,I_,C_,A_,Lm,Nm=X(()=>{"use strict";Ct();Ke();lt();ze();wa();Om={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[0]},Em={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[0,0]},Pm={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[0,0,0]},Dm=(n,e,r)=>{Lm(e);let t=e[0].dims.slice(),i=he.normalizeAxis(r.axis,t.length),o=he.sizeToDimension(t,i),s=he.sizeFromDimension(t,i);return Mm(n,e,r,o,s)},km=n=>ke({axis:n.attributes.getInt("axis",1)}),Bm=n=>ke({axis:n.attributes.getInt("axis",-1)}),Rm=(n,e,r)=>{Lm(e);let t=e[0].dims.slice(),i=he.normalizeAxis(r.axis,t.length),o=t.length,s=i!==o-1,a=[],u=[],c=[],g;s&&(u=Array.from({length:o}).map((O,I)=>I),u[i]=o-1,u[o-1]=i,u.map(O=>a.push(t[O])),g=ke({perm:u}),c=xn(n,e,g));let v=s?he.sizeToDimension(a,o-1):he.sizeToDimension(t,o-1),T=s?he.sizeFromDimension(a,o-1):he.sizeFromDimension(t,o-1),S=Mm(n,s?c:e,r,v,T);return s?xn(n,S,g):S},Mm=(n,e,r,t,i)=>{let o=I_(n,e[0],t,i,[t]),s=n.run({...Om,cacheHint:r.cacheKey,get:()=>o},e),a=C_(n,e[0],t,i,o.output.dims,[t]),u=n.run({...Em,cacheHint:r.cacheKey,get:()=>a},[e[0],s]),c=A_(n,e[0],t,i,o.output.dims,a.output.dims);return[n.run({...Pm,cacheHint:r.cacheKey,get:()=>c},[e[0],s,u])]},I_=(n,e,r,t,i)=>{let[o,s]=n.calculateTextureWidthAndHeight(e.dims,0),a=i.length;if(r<1||t<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(i.length!==1)throw new Error("Dimensionality of the output should be 1");if(i[0]!==r)throw new Error("Shape of the output should be equal to logical row count");let u=xe(n.session.backend.glContext.version),c=`
      float process(int[${a}] indices) {
        int logical_row_start_offset = indices[0] * ${t};

        float max = getColorAsFloat(${u.texture2D}(A, offsetToCoords(logical_row_start_offset, ${o},
        ${s} )));
        for(int i=1; i<${t}; ++i)
        {
          float current = getColorAsFloat(${u.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${o}, ${s})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return{...Om,output:{dims:i,type:e.type,textureType:0},shaderSource:c}},C_=(n,e,r,t,i,o)=>{let[s,a]=n.calculateTextureWidthAndHeight(e.dims,0),u=o.length;if(r<1||t<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(o.length!==1)throw new Error("Dimensionality of the output should be 1");if(o[0]!==r)throw new Error("Shape of the output should be equal to logical row count");if(i.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(i[0]!==r)throw new Error("Shape of the intermediate results should be equal to logical row count");let c=xe(n.session.backend.glContext.version),g=`
      float process(int[${u}] indices) {
        int logical_row_start_offset = indices[0] * ${t};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${t}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${c.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${s}, ${a}))) - max);
        }

        return norm_factor;
      }`;return{...Em,output:{dims:o,type:e.type,textureType:0},shaderSource:g}},A_=(n,e,r,t,i,o)=>{let[s,a]=n.calculateTextureWidthAndHeight(e.dims,0),u=e.dims.length;if(r<1||t<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(i.length!==1||o.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(i[0]!==r||o[0]!==r)throw new Error("Shape of the intermediate results should be equal to logical row count");let c=`
      float process(int[${u}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${s}, ${a});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${t};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return{...Pm,output:{dims:e.dims,type:e.type,textureType:0},shaderSource:c}},Lm=n=>{if(!n||n.length!==1)throw new Error("Softmax requires 1 input.");if(n[0].type!=="float32"&&n[0].type!=="float64")throw new Error("Invalid input type")}});var zm,Fm,jm,O_,E_,P_,Gm=X(()=>{"use strict";Ct();Ke();ze();zm={name:"Split",inputNames:["A"],inputTypes:[0]},Fm=(n,e,r)=>{P_(e);let t=he.normalizeAxis(r.axis,e[0].dims.length),i=O_(n,e,t,r),o=[];for(let s=0;s<i;++s)o.push(n.run({...zm,cacheHint:`${r.cacheKey};${s}`,get:()=>E_(n,e[0],r,t,s)},e));return o},jm=n=>{let e=n.attributes.getInt("axis",0),r=n.attributes.getInts("split",[]),t=n.outputs.length;return ke({axis:e,split:r,numOutputs:t})},O_=(n,e,r,t)=>{let[,i]=Qi.splitShape(e[0].dims,r,t.split,t.numOutputs);return i.length},E_=(n,e,r,t,i)=>{let[o,s]=Qi.splitShape(e.dims,t,r.split,r.numOutputs),a=s[i],u=o[i],g=`
      float process(int indices[${u.length}]) {
        indices[${t}] += ${a};
        return _A(indices);
      }
    `;return{...zm,cacheHint:`${r.cacheKey}:${i}`,output:{dims:u,type:e.type,textureType:0},shaderSource:g}},P_=n=>{if(!n||n.length!==1)throw new Error("Split requires one input.");if(n[0].type!=="int8"&&n[0].type!=="uint8"&&n[0].type!=="int16"&&n[0].type!=="uint16"&&n[0].type!=="int32"&&n[0].type!=="uint32"&&n[0].type!=="float32"&&n[0].type!=="float64"&&n[0].type!=="bool")throw new Error("Invalid input type.")}});var mu,Wm,Vm,D_,k_,Um=X(()=>{"use strict";Ke();mu=(n,e,r)=>{D_(e);let t=he.squeezeShape(e[0].dims,r);return[n.reshapeUnpacked(e[0],t)]},Wm=(n,e)=>(k_(e),mu(n,[e[0]],Array.from(e[1].integerData))),Vm=n=>n.attributes.getInts("axes"),D_=n=>{if(!n||n.length!==1)throw new Error("Squeeze requires 1 input.");if(n[0].type==="string")throw new Error("invalid input tensor types.")},k_=n=>{if(!n||n.length!==2)throw new Error("Squeeze requires 2 inputs.");if(n[1].type!=="int32")throw new Error("Invalid input type.")}});var Hm,B_,R_,qm=X(()=>{"use strict";lt();ze();Hm=(n,e)=>{R_(e);let r={name:"Sum",inputNames:e.map((i,o)=>`X${o}`),inputTypes:new Array(e.length).fill(0)};return[n.run({...r,get:()=>B_(n,e,r)},e)]},B_=(n,e,r)=>{let t=xe(n.session.backend.glContext.version),i=e[0].dims.slice(),s=`
      void main() {
        vec4 result = ${e.map((a,u)=>`${t.texture2D}(X${u},TexCoords)`).join(" + ")};
        ${t.output} = result;
      }
    `;return{...r,output:{dims:i,type:e[0].type,textureType:0},hasMain:!0,shaderSource:s}},R_=n=>{if(!n||n.length===0)throw new Error("Sum requires inputs.");let e=n[0].dims.length;for(let r=1;r<n.length;r++){if(e!==n[r].dims.length)throw new Error("Input shapes are mismatched.");for(let t=0;t<e;t++)if(n[0].dims[t]!==n[r].dims[t])throw new Error("Input shapes are not matched.")}if(n[0].type!=="float32"&&n[0].type!=="float64")throw new Error("Invalid input type.");for(let r=1;r<n.length;r++)if(n[0].type!==n[r].type)throw new Error("Input types are not matched.")}});var Km,M_,L_,Xm=X(()=>{"use strict";oo();ze();Km=(n,e)=>{L_(e);let r={name:"Tile",inputNames:["A"],inputTypes:[0]};return[n.run({...r,get:()=>M_(n,e,r)},e)]},M_=(n,e,r)=>{let t=e[0].dims.slice(),i=new Array(t.length),o=[];for(let u=0;u<t.length;u++)i[u]=t[u]*e[1].numberData[u],o.push(`inputIdx[${u}] = int(mod(float(outputIdx[${u}]), ${t[u]}.));`);let s=i.length,a=`
      float process(int outputIdx[${s}]) {
        int inputIdx[${s}];
        ${o.join(`
`)}
        return _A(inputIdx);
      }
    `;return{...r,output:{dims:i,type:e[0].type,textureType:0},shaderSource:a}},L_=n=>{if(!n||n.length!==2)throw new Error("Tile requires 2 input.");if(n[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(n[1].dims[0]!==n[0].dims.length)throw new Error("Invalid input shape.");if(Vr.indexOf(n[0].type)===-1)throw new Error("Invalid input type.");if(n[1].type!=="int32"&&n[1].type!=="int16")throw new Error("Invalid repeat type.")}});var gu,Ym,Jm,N_,z_,Zm=X(()=>{"use strict";Ke();gu=(n,e,r)=>{N_(e);let t=he.unsqueezeShape(e[0].dims,r);return[n.reshapeUnpacked(e[0],t)]},Ym=(n,e)=>(z_(e),gu(n,[e[0]],Array.from(e[1].integerData))),Jm=n=>n.attributes.getInts("axes"),N_=n=>{if(!n||n.length!==1)throw new Error("Unsqueeze requires 1 input.");if(n[0].type==="string")throw new Error("invalid input tensor types.")},z_=n=>{if(!n||n.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(n[1].type!=="int32")throw new Error("Invalid input type.")}});var Qm,eg=X(()=>{"use strict";cp();_p();Ip();Dp();ya();mh();xh();$h();Ch();Ph();Bh();Nh();Gh();ba();Hh();om();pm();mm();xm();_m();Am();Nm();Gm();Um();qm();Xm();wa();Qs();Zm();fu();Qm=[["Abs","","6+",kp],["Acos","","7+",Bp],["Add","","7+",fp],["And","","7+",dp],["Asin","","7+",Rp],["Atan","","7+",Mp],["AveragePool","","7+",Kh,Xh],["BatchNormalization","","7+",up,lp],["Cast","","6+",$p,Sp],["Ceil","","6+",zp],["Clip","","6-10",Js,Lp],["Clip","","11+",Np],["Concat","","4+",Op,Pp],["Conv","","1+",ou,au],["ConvTranspose","","1+",ph,hh],["Cos","","7+",Fp],["Div","","7+",pp],["Dropout","","7+",Zs],["DepthToSpace","","1+",vh,wh],["Equal","","7+",hp],["Elu","","6+",jp,Gp],["Exp","","6+",Wp],["Flatten","","1+",Th,_h],["Floor","","6+",Vp],["FusedConv","com.microsoft","1+",ou,au],["Gather","","1+",Sh,Ih],["Gemm","","7-10",su,Oh],["Gemm","","11+",su,Eh],["GlobalAveragePool","","1+",Jh,Zh],["GlobalMaxPool","","1+",nm],["Greater","","7+",mp],["Identity","","1+",Zs],["ImageScaler","","1+",Dh,kh],["InstanceNormalization","","6+",Mh,Lh],["LeakyRelu","","6+",Up,Hp],["Less","","7+",gp],["LRN","","1+",zh,Fh],["Log","","6+",qp],["MatMul","","1+",ah,sh],["MaxPool","","1+",Qh,em],["Mul","","7+",yp],["Neg","","6+",Kp],["Not","","1+",Xp],["Or","","7+",bp],["Pad","","2-10",uu,Wh],["Pad","","11+",Vh,Uh],["Pow","","7+",vp],["PRelu","","7+",wp],["ReduceLogSum","","1+",fm,Ur],["ReduceMax","","1+",um,Ur],["ReduceMean","","1+",sm,Ur],["ReduceMin","","1+",lm,Ur],["ReduceProd","","1+",cm,Ur],["ReduceSum","","1-12",am,Ur],["ReduceSumSquare","","1+",dm,Ur],["Relu","","6+",Yp],["Reshape","","5+",hm],["Resize","","10",pu,vm],["Resize","","11+",pu,wm],["Shape","","1+",Tm],["Sigmoid","","6+",Jp],["Sin","","7+",Zp],["Slice","","10+",Cm],["Slice","","1-9",$m,Sm],["Softmax","","1-12",Dm,km],["Softmax","","13+",Rm,Bm],["Split","","2-12",Fm,jm],["Sqrt","","6+",Qp],["Squeeze","","1-12",mu,Vm],["Squeeze","","13+",Wm],["Sub","","7+",xp],["Sum","","6+",Hm],["Tan","","7+",eh],["Tanh","","6+",th],["Tile","","6+",Km],["Transpose","","1+",xn,yh],["Upsample","","7-8",lu,ym],["Upsample","","9",lu,bm],["Unsqueeze","","1-12",gu,Jm],["Unsqueeze","","13+",Ym],["Xor","","7+",Tp]]});function rg(n){let e={},r;for(;(r=tg.exec(n))!==null;){let t=r[3].split(",").map(i=>{let o=i.trim().split(" ");return o&&o.length===2?{type:o[0],name:o[1]}:null}).filter(i=>i!==null);e[r[2]]={params:t,body:r[4]}}for(let t in e){let i=F_.replace("__FUNC__",t),o=new RegExp(i,"gm");for(;(r=o.exec(n))!==null;){let s=r[1],a=r[2],u=r[3].split(","),c=s?`${s} ${a};`:"",g=e[t].body,v="";e[t].params.forEach((S,O)=>{S&&(v+=`${S.type} ${S.name} = ${u[O]};
`)}),g=`${v}
 ${g}`,g=g.replace("return",`${a} = `);let T=`
      ${c}
      {
        ${g}
      }
      `;n=n.replace(r[0],T)}}return n=n.replace(tg,""),n}var tg,F_,ng=X(()=>{"use strict";tg=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm,F_="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;"});function ri(n,e){let r=[],t=[],i=e!=null&&Array.isArray(e)&&e.length===0,o=e==null||i?null:j_(e,n).sort(),s=0;for(let a=0;a<n.length;++a){if(o!=null){if(o[s]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(o[s]==null||o[s]>a)&&n[a]===1&&(r.push(n[a]),t.push(a)),o[s]<=a&&s++}n[a]!==1&&(r.push(n[a]),t.push(a))}return{newShape:r,keptDims:t}}function j_(n,e){let r=e.length;return n=n==null?e.map((t,i)=>i):[].concat(n),Yn(n.every(t=>t>=-r&&t<r),()=>`All values in axis param must be in range [-${r}, ${r}) but got axis ${n}`),Yn(n.every(G_),()=>`All values in axis param must be integers but got axis ${n}`),n.map(t=>t<0?r+t:t)}function G_(n){return n%1===0}function W_(n){if(n.length===0)return 1;let e=n[0];for(let r=1;r<n.length;r++)e*=n[r];return e}function ig(n){let e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}var $a,yu=X(()=>{"use strict";Kt();Ke();$a=class{constructor(e){this.maxTextureSize=e}computeTextureWH(e,r){let t=this.computeTexture(e,r);return r&&r.isPacked&&(t[0]/=2,t[1]/=2),r&&r.reverseWH?[t[1],t[0]]:t}computeTexture(e,r){let t=r&&r.isPacked;if(e.length===0)return t?[2,2]:[1,1];let i=this.maxTextureSize;if(r&&r.breakAxis!==void 0){let a=r.breakAxis>=e.length?1:e.slice(r.breakAxis).reduce((c,g)=>c*g),u=r.breakAxis<=0?1:e.slice(0,r.breakAxis).reduce((c,g)=>c*g);if(a>i||u>i)Xe.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${e}, breakAxis:${r.breakAxis}`);else return[a,u]}let o=e.slice(0);t&&(i=i*2,o=o.map((a,u)=>u>=o.length-2?o[u]%2===0?o[u]:o[u]+1:o[u]),o.length===1&&(o=[2,o[0]])),o.length!==2&&(o=ri(o).newShape);let s=W_(o);return o.length<=1&&s<=i?[1,s]:o.length===2&&o[0]<=i&&o[1]<=i?o:o.length===3&&o[0]*o[1]<=i&&o[2]<=i?[o[0]*o[1],o[2]]:o.length===3&&o[0]<=i&&o[1]*o[2]<=i?[o[0],o[1]*o[2]]:o.length===4&&o[0]*o[1]*o[2]<=i&&o[3]<=i?[o[0]*o[1]*o[2],o[3]]:o.length===4&&o[0]<=i&&o[1]*o[2]*o[3]<=i?[o[0],o[1]*o[2]*o[3]]:t?ig(s/4).map(a=>a*2):ig(s)}}});var Sa,og=X(()=>{"use strict";Ke();zr();lt();yu();$r();Sa=class extends Zt{constructor(r){super(r)}getFunctions(){return{...this.offsetToCoords(),...this.coordsToOffset(),...this.toVec(),...this.valueFrom(),...this.getCommonUtilFuncs(),...this.getInputsSamplingSnippets(),...this.getOutputSamplingSnippet()}}getCustomTypes(){return{}}offsetToCoords(){let r="offsetToCoords";return{offsetToCoords:new ce(`
      vec2 ${r}(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){let r="coordsToOffset";return{coordsToOffset:new ce(`
      int ${r}(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){let r=this.context.outputTextureLayout;return r.isPacked?this.getPackedOutputSamplingSnippet(r):this.getUnpackedOutputSamplingSnippet(r)}getPackedOutputSamplingSnippet(r){let t=r.unpackedShape,i=[r.width,r.height],o={},s="getOutputCoords";switch(t.length){case 0:o[s]=this.getOutputScalarCoords();break;case 1:o[s]=this.getOutputPacked1DCoords(t,i);break;case 2:o[s]=this.getOutputPacked2DCoords(t,i);break;case 3:o[s]=this.getOutputPacked3DCoords(t,i);break;default:o[s]=this.getOutputPackedNDCoords(t,i)}let u=`
      void setOutput(vec4 val) {
        ${xe(this.context.glContext.version).output} = val;
      }
    `,c="floatTextureSetRGBA";return o[c]=new ce(u),o}getUnpackedOutputSamplingSnippet(r){let t=r.unpackedShape,i=[r.width,r.height],o={},s="getOutputCoords";switch(t.length){case 0:o[s]=this.getOutputScalarCoords();break;case 1:o[s]=this.getOutputUnpacked1DCoords(t,i);break;case 2:o[s]=this.getOutputUnpacked2DCoords(t,i);break;case 3:o[s]=this.getOutputUnpacked3DCoords(t,i);break;case 4:o[s]=this.getOutputUnpacked4DCoords(t,i);break;case 5:o[s]=this.getOutputUnpacked5DCoords(t,i);break;case 6:o[s]=this.getOutputUnpacked6DCoords(t,i);break;default:throw new Error(`Unsupported output dimensionality: ${t.length}`)}let u=`
        void setOutput(float val) {
          ${xe(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `,c="floatTextureSetR";return o[c]=new ce(u),o}getOutputScalarCoords(){return new ce(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(r,t){let i=t,o="";return i[0]===1?(o=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${i[1]}.0);
          }
        `,new ce(o)):i[1]===1?(o=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${i[0]}.0);
          }
        `,new ce(o)):(o=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${i[0]}, ${i[1]}));
          return 2 * (resTexRC.y * ${i[0]} + resTexRC.x);
        }
      `,new ce(o))}getOutputPacked2DCoords(r,t){let i="";if(hn.arraysEqual(r,t))return i=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${t[0]}, ${t[1]}));
        }
      `,new ce(i);let o=t,s=Math.ceil(r[1]/2);return i=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${o[0]}, ${o[1]}));

          int index = resTexRC.y * ${o[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${s}) * 2;
          int c = 2 * (index / ${s});

          return ivec2(r, c);
        }
      `,new ce(i)}getOutputPacked3DCoords(r,t){let i=[t[0],t[1]],o=Math.ceil(r[2]/2),s=o*Math.ceil(r[1]/2),a=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${i[0]}, ${i[1]}));
          int index = resTexRC.y * ${i[0]} + resTexRC.x;

          int b = index / ${s};
          index -= b * ${s};

          // reverse r and c order for packed texture
          int r = imod(index, ${o}) * 2;
          int c = 2 * (index / ${o});

          return ivec3(b, r, c);
        }
      `;return new ce(a)}getOutputPackedNDCoords(r,t){let i=[t[0],t[1]],o=Math.ceil(r[r.length-1]/2),s=o*Math.ceil(r[r.length-2]/2),a=s,u="",c="b, r, c";for(let v=2;v<r.length-1;v++)a*=r[r.length-v-1],u=`
      int b${v} = index / ${a};
      index -= b${v} * ${a};
    `+u,c=`b${v}, `+c;let g=`
      ivec${r.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${i[0]}, ${i[1]}));
        int index = resTexRC.y * ${i[0]} + resTexRC.x;

        ${u}

        int b = index / ${s};
        index -= b * ${s};

        // reverse r and c order for packed texture
        int r = imod(index, ${o}) * 2;
        int c = 2 * (index / ${o});

        return ivec${r.length}(${c});
      }
    `;return new ce(g)}getOutputUnpacked1DCoords(r,t){let i=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          return resTexRC.y * ${t[0]} + resTexRC.x;
        }
      `;return new ce(i)}getOutputUnpacked2DCoords(r,t){let i=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;
          int r = index / ${r[1]};
          int c = index - r * ${r[1]};
          return ivec2(r, c);
        }
      `;return new ce(i)}getOutputUnpacked3DCoords(r,t){let i="",o=r.length,s=null;o<2&&(s=[]),s=new Array(o-1),s[o-2]=r[o-1];for(let c=o-3;c>=0;--c)s[c]=s[c+1]*r[c+1];let a=["r","c","d"],u=s.map((c,g)=>{let v=`int ${a[g]} = index / ${c}`,T=g===s.length-1?`int ${a[g+1]} = index - ${a[g]} * ${c}`:`index -= ${a[g]} * ${c}`;return`${v}; ${T};`}).join("");return i=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;
          ${u}
          return ivec3(r, c, d);
        }
      `,new ce(i)}getOutputUnpacked4DCoords(r,t){let i="",o=r.length,s=null;o<2&&(s=[]),s=new Array(o-1),s[o-2]=r[o-1];for(let c=o-3;c>=0;--c)s[c]=s[c+1]*r[c+1];let a=["r","c","d","d2"],u=s.map((c,g)=>{let v=`int ${a[g]} = index / ${c}`,T=g===s.length-1?`int ${a[g+1]} = index - ${a[g]} * ${c}`:`index -= ${a[g]} * ${c}`;return`${v}; ${T};`}).join("");return i=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;
          ${u}
          return ivec4(r, c, d, d2);
        }
      `,new ce(i)}getOutputUnpacked5DCoords(r,t){let i="",o=r.length,s=null;o<2&&(s=[]),s=new Array(o-1),s[o-2]=r[o-1];for(let c=o-3;c>=0;--c)s[c]=s[c+1]*r[c+1];let a=["r","c","d","d2","d3"],u=s.map((c,g)=>{let v=`int ${a[g]} = index / ${c}`,T=g===s.length-1?`int ${a[g+1]} = index - ${a[g]} * ${c}`:`index -= ${a[g]} * ${c}`;return`${v}; ${T};`}).join("");return i=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;
          ${u}
          return ivec5(r, c, d, d2, d3);
        }
      `,new ce(i)}getOutputUnpacked6DCoords(r,t){let i="",o=r.length,s=null;o<2&&(s=[]),s=new Array(o-1),s[o-2]=r[o-1];for(let c=o-3;c>=0;--c)s[c]=s[c+1]*r[c+1];let a=["r","c","d","d2","d3","d4"],u=s.map((c,g)=>{let v=`int ${a[g]} = index / ${c}`,T=g===s.length-1?`int ${a[g+1]} = index - ${a[g]} * ${c}`:`index -= ${a[g]} * ${c}`;return`${v}; ${T};`}).join("");return i=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${t[0]}, ${t[1]}));
         int index = resTexRC.y * ${t[0]} + resTexRC.x;
         ${u}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new ce(i)}getCommonUtilFuncs(){let r={},t="uvFromFlat";r[t]=new ce(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),t="packedUVfrom1D",r[t]=new ce(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),t="packedUVfrom2D",r[t]=new ce(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),t="packedUVfrom3D",r[t]=new ce(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),t="sampleTexture";let i=xe(this.context.glContext.version);return r[t]=new ce(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${i.texture2D}(textureSampler, uv).r;
        }`),r}getInputsSamplingSnippets(){let r={},t=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((i,o)=>{let s=this.context.inputTextureLayouts[o],a=ca(i);s.isPacked?r[a]=this.getPackedSamplerFromInput(a,i,s):r[a]=this.getUnpackedSamplerFromInput(a,i,s);let u=Hd(i);s.unpackedShape.length<=t.unpackedShape.length&&(s.isPacked?r[u]=this.getPackedSamplerAtOutputCoords(u,s,t,i):r[u]=this.getUnpackedSamplerAtOutputCoords(u,s,t,i))}),r}getPackedSamplerAtOutputCoords(r,t,i,o){let s=t.unpackedShape,a=i.unpackedShape,c=ca(o),g=s.length,v=a.length,T=Rt.getBroadcastDims(s,a),S=Mt(v),O=v-g,I,k=hr();g===0?I="":v<2&&T.length>=1?I="coords = 0;":I=T.map(le=>`coords.${k[le+O]} = 0;`).join(`
`);let M="";v<2&&g>0?M="coords":M=s.map((le,Ae)=>`coords.${k[Ae+O]}`).join(", ");let F="return outputValue;",Y=he.size(s)===1,P=he.size(a)===1;if(g===1&&!Y&&!P)F=`
        return vec4(outputValue.xy, outputValue.xy);
      `;else if(Y&&!P)v===1?F=`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:F=`
          return vec4(outputValue.x);
        `;else if(T.length){let le=g-2,Ae=g-1;T.indexOf(le)>-1&&T.indexOf(Ae)>-1?F="return vec4(outputValue.x);":T.indexOf(le)>-1?F="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":T.indexOf(Ae)>-1&&(F="return vec4(outputValue.xx, outputValue.zz);")}let te=`
        int lastDim = coords.${k[v-1]};
        coords.${k[v-1]} = coords.${k[v-2]};
        coords.${k[v-2]} = lastDim;
      `,ue=`
      vec4 ${r}() {
        ${S} coords = getOutputCoords();
        ${te}
        ${I}
        vec4 outputValue = ${c}(${M});
        ${F}
      }
    `;return new ce(ue,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(r,t,i,o){let s=[i.width,i.height],a=[t.width,t.height],u=t.unpackedShape.length,c=i.unpackedShape.length,g=t.unpackedShape,v=i.unpackedShape,T=ca(o);if(u===c&&hn.arraysEqual(a,s)){let Y=`
          float ${r}() {
            return sampleTexture(${o}, TexCoords);
          }
        `;return new ce(Y,["coordinates.sampleTexture"])}let S=Mt(c),O=Rt.getBroadcastDims(g,v),I=c-u,k,M=hr();u===0?k="":c<2&&O.length>=1?k="coords = 0;":k=O.map(Y=>`coords.${M[Y+I]} = 0;`).join(`
`);let F="";c<2&&u>0?F="coords":F=t.unpackedShape.map((Y,Z)=>`coords.${M[Z+I]}`).join(", ");let j=`
        float ${r}() {
          ${S} coords = getOutputCoords();
          ${k}
          return ${T}(${F});
        }
      `;return new ce(j,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(r,t,i){switch(i.unpackedShape.length){case 0:return this.getPackedSamplerScalar(r,t);case 1:return this.getPackedSampler1D(r,t,i);case 2:return this.getPackedSampler2D(r,t,i);case 3:return this.getPackedSampler3D(r,t,i);default:return this.getPackedSamplerND(r,t,i)}}getUnpackedSamplerFromInput(r,t,i){let o=i.unpackedShape;switch(o.length){case 0:return this.getUnpackedSamplerScalar(r,t,i);case 1:return this.getUnpackedSampler1D(r,t,i);case 2:return this.getUnpackedSampler2D(r,t,i);case 3:return this.getUnpackedSampler3D(r,t,i);case 4:return this.getUnpackedSampler4D(r,t,i);case 5:return this.getUnpackedSampler5D(r,t,i);case 6:return this.getUnpackedSampler6D(r,t,i);default:throw new Error(`Unsupported dimension ${o.length}-D`)}}getPackedSamplerScalar(r,t){let i=xe(this.context.glContext.version),o=`
          vec4 ${r}() {
            return ${i.texture2D}(${t}, halfCR);
          }
        `;return new ce(o)}getPackedSampler1D(r,t,i){let o=[i.width,i.height],s=[o[1],o[0]],a=xe(this.context.glContext.version),c=`vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
      ${s[0]}, ${s[1]}, index);
      return ${a.texture2D}(${t}, uv);
    }`;return new ce(c,["coordinates.packedUVfrom1D"])}getPackedSampler2D(r,t,i){let o=i.unpackedShape,s=[i.width,i.height],a=xe(this.context.glContext.version),u=s[0],c=s[1];if(s!=null&&hn.arraysEqual(o,s)){let O=`vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${c}.0, ${u}.0);
        return ${a.texture2D}(${t}, uv);
      }`;return new ce(O)}let g=s,v=Math.ceil(o[1]/2),S=`vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${g[1]}, ${g[0]}, ${v}, row, col);
      return ${a.texture2D}(${t}, uv);
    }`;return new ce(S,["coordinates.packedUVfrom2D"])}getPackedSampler3D(r,t,i){let o=i.unpackedShape,s=[i.width,i.height],a=[s[0],s[1]],u=xe(this.context.glContext.version);if(o[0]===1){let I=o.slice(1),k=[1,2],M=Jn(o,I),F=["b","row","col"],j=JSON.parse(JSON.stringify(i));j.unpackedShape=M;let Y=this.getPackedSamplerFromInput(r,t,j),P=`${Y.routineBody}
      vec4 ${r}(int b, int row, int col) {
        return ${r}(${Zn(F,k)});
      } `;return new ce(P,Y.dependencies)}let c=a[0],g=a[1],v=Math.ceil(o[2]/2),T=v*Math.ceil(o[1]/2),O=`vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${g}, ${c}, ${T}, ${v}, b, row, col);
      return ${u.texture2D}(${t}, uv);}`;return new ce(O,["coordinates.packedUVfrom3D"])}getPackedSamplerND(r,t,i){let o=i.unpackedShape,s=o.length,a=[i.width,i.height],u=xe(this.context.glContext.version),c=[a[0],a[1]],g=c[1],v=c[0],T=Math.ceil(o[s-1]/2),S=T*Math.ceil(o[s-2]/2),O="int b, int row, int col",I=`b * ${S} + (row / 2) * ${T} + (col / 2)`;for(let F=2;F<s-1;F++)O=`int b${F}, `+O,S*=o[s-F-1],I=`b${F} * ${S} + `+I;let M=`vec4 ${r}(${O}) {
      int index = ${I};
      int texR = index / ${v};
      int texC = index - texR * ${v};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${v}, ${g});
      return ${u.texture2D}(${t}, uv);
    }`;return new ce(M)}getUnpackedSamplerScalar(r,t,i){let[o,s]=[i.width,i.height];if(o===1&&s===1){let u=`
          float ${r}() {
            return sampleTexture(${t}, halfCR);
          }
        `;return new ce(u,["coordinates.sampleTexture"])}let a=`
        float ${r}() {
          int offset_${t} = coordsToOffset(TexCoords, ${o}, ${s});
          vec2 uv = uvFromFlat(${o}, ${s}, offset_${t});
          return sampleTexture(${t}, uv);
        }
      `;return new ce(a,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(r,t,i){let o=i.width,s=i.height;if(s===1&&o===1){let u=`
        float ${r}(int index) {
          return sampleTexture(${t}, halfCR);
        }
      `;return new ce(u,["coordinates.sampleTexture"])}if(s===1){let u=`
          float ${r}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${o}.0, 0.5);
            return sampleTexture(${t}, uv);
          }
        `;return new ce(u,["coordinates.sampleTexture"])}if(o===1){let u=`
          float ${r}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${s}.0);
            return sampleTexture(${t}, uv);
          }
        `;return new ce(u,["coordinates.sampleTexture"])}let a=`
        float ${r}(int index) {
          vec2 uv = uvFromFlat(${o}, ${s}, index);
          return sampleTexture(${t}, uv);
        }
      `;return new ce(a,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(r,t,i){let o=i.unpackedShape,s=[i.height,i.width];if(s!=null&&hn.arraysEqual(o,s)){let S=s[1],O=s[0],I=`
          float ${r}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${S}.0, ${O}.0);
            return sampleTexture(${t}, uv);
          }
        `;return new ce(I,["coordinates.sampleTexture"])}let{newShape:a,keptDims:u}=ri(o),c=a;if(c.length<o.length){let S=Jn(o,c),O=JSON.parse(JSON.stringify(i));O.unpackedShape=S;let I=["col","row"],k=`
          ${this.getUnpackedSamplerFromInput(r,t,O).routineBody}
          float ${r}(int row, int col) {
            return ${r}(${Zn(I,u)});
          }
        `;return new ce(k,["coordinates.sampleTexture"])}let g=s[1],v=s[0];if(v===1){let S=`
          float ${r}(int row, int col) {
            int offset_${t} = coordsToOffset(TexCoords, ${g}, ${v});
            float index = dot(vec3(row, col, offset_${t}), vec3(${o[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${g}.0);
            return sampleTexture(${t}, uv);
          }
        `;return new ce(S,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(g===1){let S=`
          float ${r}(int row, int col) {
            int offset_${t} = coordsToOffset(TexCoords, ${g}, ${v});
            float index = dot(vec3(row, col, offset_${t}), vec3(${o[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${v}.0, 0.5);
            return sampleTexture(${t}, uv);
          }
        `;return new ce(S,["coordinates.sampleTexture","coordinates.coordsToOffset"])}let T=`
        float ${r}(int row, int col) {
          int index = col * ${o[1]} + row;
          vec2 uv = uvFromFlat(${g}, ${v}, index);
          return sampleTexture(${t}, uv);
        }
      `;return new ce(T,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(r,t,i){let o=i.unpackedShape,s=o[1]*o[2],a=o[2],{newShape:u,keptDims:c}=ri(o),g=u;if(g.length<o.length){let O=Jn(o,g),I=["batch","col","row"],k=JSON.parse(JSON.stringify(i));k.unpackedShape=O;let M=this.getUnpackedSamplerFromInput(r,t,k),F=c.reverse(),j=`
          ${M.routineBody}
          float ${r}(int batch, int row, int col) {
            return ${r}(${Zn(I,F)});
          }
        `;return new ce(j,M.dependencies)}let v=i.width,T=i.height,S=`
          float ${r}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${s} + col * ${a} + row;
            vec2 uv = uvFromFlat(${v}, ${T}, index);
            return sampleTexture(${t}, uv);
          }
      `;return new ce(S,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(r,t,i){let o=i.unpackedShape,s=o[3],a=o[2]*s,u=o[1]*a,c=i.width,g=i.height,v=`
        float ${r}(int row, int col, int depth, int depth2) {
          int index = row * ${u} + col * ${a} +
              depth2 * ${s} + depth;
          vec2 uv = uvFromFlat(${c}, ${g}, index);
          return sampleTexture(${t}, uv);
        }
      `;return new ce(v,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(r,t,i){let o=i.unpackedShape,s=o[4],a=o[3]*s,u=o[2]*a,c=o[1]*u,{newShape:g,keptDims:v}=ri(o);if(g.length<o.length){let I=Jn(o,g),k=["row","col","depth","depth2","depth3"],M=JSON.parse(JSON.stringify(i));M.unpackedShape=I;let F=`
          ${this.getUnpackedSamplerFromInput(r,t,M).routineBody}
          float ${r}(int row, int col, int depth, int depth2, int depth3) {
            return ${r}(${Zn(k,v)});
          }
        `;return new ce(F,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let T=i.width,S=i.height,O=`
        float ${r}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${c} + col * ${u} + depth * ${a} +
          depth3 * ${s} + depth2;
          vec2 uv = uvFromFlat(${T}, ${S}, index);
          return sampleTexture(${t}, uv);
        }
      `;return new ce(O,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(r,t,i){let o=i.unpackedShape,s=o[5],a=o[4]*s,u=o[3]*a,c=o[2]*u,g=o[1]*c,{newShape:v,keptDims:T}=ri(o);if(v.length<o.length){let k=Jn(o,v),M=["row","col","depth","depth2","depth3","depth4"],F=JSON.parse(JSON.stringify(i));F.unpackedShape=k;let j=`
            ${this.getUnpackedSamplerFromInput(r,t,F).routineBody}
            float ${r}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${r}(${Zn(M,T)});
            }
          `;return new ce(j,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let S=i.width,O=i.height,I=`
          float ${r}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${g} + col * ${c} + depth * ${u} +
            depth2 * ${a} + depth3 * ${s} + depth4;
            vec2 uv = uvFromFlat(${S}, ${O}, index);
            return sampleTexture(${t}, uv);
          }
        `;return new ce(I,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){let r=this.context.outputTextureLayout,t=r.shape.length,i=r.strides,o=r.width,s=r.height,a=[];for(let c=0;c<t-1;++c)a.push(`
        c[${c}] = offset / ${i[c]};`),a.push(`
        offset -= c[${c}] * ${i[c]};`);a.push(`
        c[${t-1}] = offset;`);let u=`
      void toVec(vec2 texCoords, out int c[${t}]) {
        int offset = coordsToOffset(texCoords, ${o}, ${s});
        ${a.join("")}
      }
      void toVec(int offset, out int c[${t}]) {
        ${a.join("")}
      }
    `;return{toVec:new ce(u,["coordinates.coordsToOffset"])}}valueFrom(){let r={};return this.context.programInfo.inputNames.forEach((t,i)=>{let o=this.context.inputTextureLayouts[i],a=(o.unpackedShape.length>0?o.unpackedShape:o.shape).length,u=`_${t}`;r[u]=new ce(this.getValueFromSingle(t,a,o.width,o.height,!1),[`shapeUtils.indicesToOffset${u}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),u=u+"_T",r[u]=new ce(this.getValueFromSingle(t,a,o.width,o.height,!0),[`shapeUtils.indicesToOffset${u}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),r}getValueFromSingle(r,t,i,o,s){let a=`_${r}`;s&&(a=a+"_T");let u=xe(this.context.glContext.version);return`
        float ${a}(int m[${t}]) {
          int offset = indicesToOffset${a}(m);
          vec2 coords = offsetToCoords(offset, ${i}, ${o});
          float value = getColorAsFloat(${u.texture2D}(${r}, coords));
          return value;
        }
        `}getPackedValueFrom(r,t,i,o,s){let a=`_${r}_Pack`;s&&(a=a+"_T");let u=xe(this.context.glContext.version);return`
        vec4 ${a}(int m[${t}]) {
          int offset = indicesToOffset_${r}(m);
          vec2 coords = offsetToCoords(offset, ${i}, ${o});
          return ${u.texture2D}(${r}, coords);
        }
        `}}});var Ia,ag=X(()=>{"use strict";zr();Ia=class n extends Zt{constructor(e){super(e)}getFunctions(){return{...this.encodeFloat32(),...this.decodeFloat32()}}getCustomTypes(){return{}}encodeFloat32(){return{encode:new ce(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new ce(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){let e=n.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new ce(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${e}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){let e=n.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new ce(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${e}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){let e=new ArrayBuffer(4),r=new Uint32Array(e),t=new Uint8Array(e);if(r[0]=3735928559,t[0]===239)return!0;if(t[0]===222)return!1;throw new Error("unknown endianness")}}});var Ca,sg=X(()=>{"use strict";zr();lt();Ca=class extends Zt{constructor(e){super(e)}getFunctions(){return{...this.setFragColor(),...this.getColorAsFloat()}}getCustomTypes(){return{}}setFragColor(){let e=xe(this.context.glContext.version);return{setFragColor:new ce(`
        void setFragColor(float value) {
            ${e.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new ce(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}});var Aa,ug=X(()=>{"use strict";zr();Aa=class n extends Zt{constructor(e){super(e)}getFunctions(){return{...this.bcastIndex(),...this.bcastMatmulIndex(),...this.offsetToIndices(),...this.indicesToOffset(),...this.incrementIndices()}}getCustomTypes(){return{}}bcastIndex(){let e=this.context.outputTextureLayout.shape.length,r={};return this.context.programInfo.inputNames.forEach((t,i)=>{let o=this.context.inputTextureLayouts[i].unpackedShape;if(o.length<=e){let s=o.length,a=e-s,u=`bcastIndices_${t}`,c="";for(let v=0;v<s;++v)c+=`
          realIndices[${v}] = int( mod(float(bcastedIndices[${a+v}]), ${o[v]}.0) );
          `;let g=`
        void ${u} (int bcastedIndices[${e}], out int realIndices[${s}]) {
          ${c}
        }
        `;r[u]=new ce(g)}}),r}bcastMatmulIndex(){let e=this.context.outputTextureLayout.shape.length,r={};return this.context.programInfo.inputNames.forEach((t,i)=>{let o=this.context.inputTextureLayouts[i].shape;if(!(o.length<2||o.length>e)){let s=o.length,a=e-s,u=`bcastMatmulIndices_${t}`,c="";for(let v=0;v<s-2;++v)c+=`
          realIndices[${v}] = int( mod(float(bcastedIndices[${a+v}]), ${o[v]}.0) );
          `;let g=`
        void ${u}(int bcastedIndices[${e}], out int realIndices[${s}]) {
          ${c}
          realIndices[${s-1}] = bcastedIndices[${e-1}];
          realIndices[${s-2}] = bcastedIndices[${e-2}];
        }
        `;r[u]=new ce(g)}}),r}indicesToOffset(){let e={};return this.context.programInfo.inputNames.forEach((r,t)=>{let i=this.context.inputTextureLayouts[t].shape,o=this.context.inputTextureLayouts[t].strides,s=i.length,a=`indicesToOffset_${r}`;e[a]=new ce(n.indexToOffsetSingle(a,s,o)),a=`indicesToOffset_${r}_T`,e[a]=new ce(n.indexToOffsetSingle(a,s,o.slice().reverse()))}),e}static indexToOffsetSingle(e,r,t){let i="";for(let o=r-1;o>=0;--o)i+=`
        offset += indices[${o}] * ${t[o]};
        `;return`
      int ${e}(int indices[${r}]) {
        int offset = 0;
        ${i}
        return offset;
      }
      `}offsetToIndices(){let e={};return this.context.programInfo.inputNames.forEach((r,t)=>{let i=this.context.inputTextureLayouts[t].shape,o=this.context.inputTextureLayouts[t].strides,s=i.length,a=`offsetToIndices_${r}`;e[a]=new ce(n.offsetToIndicesSingle(a,s,o)),a=`offsetToIndices_${r}_T`,e[a]=new ce(n.offsetToIndicesSingle(a,s,o.slice().reverse()))}),e}static offsetToIndicesSingle(e,r,t){let i=[];for(let o=0;o<r-1;++o)i.push(`
      indices[${o}] = offset / ${t[o]};`),i.push(`
        offset -= indices[${o}] * ${t[o]};`);return i.push(`
      indices[${r-1}] = offset;`),`
      void ${e}(int offset, out int indices[${r}]) {
        ${i.join("")}
      }
      `}incrementIndices(){let e={};return this.context.programInfo.inputNames.forEach((r,t)=>{let i=this.context.inputTextureLayouts[t].shape,o=i.length,s=`incrementIndices_${r}`,a="";for(let c=0;c<o;++c)a+=`
        shape[${c}] = ${i[c]};`;let u=`
        void ${s}(int axis, out int indices[${o}]) {
          int shape[${o}];
          ${a};
          for(int i = ${o} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;e[s]=new ce(u)}),e}}});var Oa,lg=X(()=>{"use strict";zr();Oa=class extends Zt{constructor(e){super(e)}getCustomTypes(){return{}}getFunctions(){return{...this.binaryVecFunctions(),...this.copyVec(),...this.setVecItem(),...this.getVecItem()}}binaryVecFunctions(){let r=this.context.outputTextureLayout.shape.length,t={add:"+=",sub:"-=",mul:"*=",div:"/="},i={};for(let o in t){let s=`${o}Vec`,a="";for(let c=0;c<r;++c)a+=`
          dest[${c}] ${t[o]} src[${c}];
          `;let u=`
        void ${s}(int src[${r}], out int dest[${r}]) {
          ${a}
        }
        `;i[s]=new ce(u)}return i}copyVec(){let r=this.context.outputTextureLayout.shape.length,t="";for(let o=0;o<r;++o)t+=`
        dest[${o}] = src[${o}];
        `;let i=`
      void copyVec(int src[${r}], out int dest[${r}]) {
        ${t}
      }
      `;return{copyVec:new ce(i)}}setVecItem(){let r=this.context.outputTextureLayout.shape.length,t=`
        if(index < 0)
            index =${r} + index;
        if (index == 0)
            m[0] = value;
        `;for(let o=1;o<r-1;++o)t+=`
        else if (index == ${o})
            m[${o}] = value;
            `;t+=`
        else
            m[${r-1}] = value;
        `;let i=`
      void setVecItem(out int m[${r}], int index, int value) {
        ${t}
      }
        `;return{setVecItem:new ce(i)}}getVecItem(){let r=this.context.outputTextureLayout.shape.length,t=`
        if(index < 0)
            index = ${r} + index;
        if (index == 0)
            return m[0];
      `;for(let o=1;o<r-1;++o)t+=`
        else if (index == ${o})
            return m[${o}];
      `;t+=`
        else
            return m[${r-1}];
        `;let i=`
      int getVecItem(int m[${r}], int index) {
        ${t}
      }
    `;return{getVecItem:new ce(i)}}}});var bu,cg=X(()=>{"use strict";og();ag();sg();ug();lg();bu={encoding:Ia,fragcolor:Ca,vec:Oa,shapeUtils:Aa,coordinates:Sa}});var Ea,fg=X(()=>{"use strict";zr();ng();cg();lt();Ea=class{constructor(e,r,t,i){this.libs={};this.glslLibRoutineDependencyGraph={};this.context=new ha(e,r,t,i),Object.keys(bu).forEach(s=>{let a=new bu[s](this.context);this.libs[s]=a});let o=this.glslLibRoutineDependencyGraph;for(let s in this.libs){let u=this.libs[s].getFunctions();for(let c in u){let g=s+"."+c,v;o[g]?(v=o[g],v.routineBody=u[c].routineBody):(v=new io(g,u[c].routineBody),o[g]=v);let T=u[c].dependencies;if(T)for(let S=0;S<T.length;++S)if(o[T[S]])v.addDependency(o[T[S]]);else{let O=new io(T[S]);o[T[S]]=O,v.addDependency(O)}}}}preprocess(){let e=this.context.programInfo,r=e.shaderSource;return this.context.programInfo.hasMain||(r=`${r}
      ${Ud(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),r=rg(r),`${Vd(this.context.glContext.version)}
    ${this.getUniforms(e.inputNames,e.variables)}
    ${this.getImports(r)}
    ${r}`}getImports(e){let r=this.selectGlslLibRoutinesToBeIncluded(e);if(r.length===0)return"";let t="";for(let i=0;i<r.length;++i)if(r[i].routineBody)t+=r[i].routineBody+`
`;else throw new Error(`Missing body for the Glsl Library routine: ${r[i].name}`);return t}selectGlslLibRoutinesToBeIncluded(e){let r=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(t=>{let i=t.split(".")[1];e.indexOf(i)!==-1&&r.push(this.glslLibRoutineDependencyGraph[t])}),ma.returnOrderedNodes(r)}getUniforms(e,r){let t=[];if(e)for(let i of e)t.push(`uniform sampler2D ${i};`);if(r)for(let i of r)t.push(`uniform ${i.type} ${i.name}${i.arrayLength?`[${i.arrayLength}]`:""};`);return t.join(`
`)}}});var Pa,dg=X(()=>{"use strict";lr();Kt();fg();lt();Pa=class{constructor(e,r,t){this.profiler=e;this.glContext=r;this.textureLayoutStrategy=t;this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,r){this.repo.set(e,r)}run(e,r,t){this.profiler.event("op",`ProgramManager.run ${e.programInfo.name??"unknown kernel"}`,()=>{let i=this.glContext.gl,o=e.program;i.useProgram(o);try{this.bindOutput(t),this.attributesBound||this.bindAttributes(e.attribLocations),this.bindUniforms(e.uniformLocations,e.programInfo.variables??[],r)}catch(s){throw Xe.error("ProgramManager",e.programInfo.shaderSource),s}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(e=>this.glContext.deleteProgram(e.program))}build(e,r,t){return this.profiler.event("backend","ProgramManager.build",()=>{let i=new Ea(this.glContext,e,r,t),o=i.preprocess(),s=this.compile(o);return{programInfo:e,program:s,uniformLocations:this.getUniformLocations(s,i.context.programInfo.inputNames,i.context.programInfo.variables),attribLocations:this.getAttribLocations(s)}})}compile(e){if(!this.vertexShader){Xe.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");let i=Wd(this.glContext.version);this.vertexShader=this.glContext.compileShader(i,this.glContext.gl.VERTEX_SHADER)}De.debug&&Xe.verbose("ProrgramManager",`FragShader:
${e}
`);let r=this.glContext.compileShader(e,this.glContext.gl.FRAGMENT_SHADER),t=this.glContext.createProgram(this.vertexShader,r);return this.glContext.deleteShader(r),t}bindOutput(e){let r=e.width,t=e.height;Xe.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${r}/${t}, shape=${e.shape}, type=${e.tensor.type}`),this.glContext.attachFramebuffer(e.texture,r,t)}bindAttributes(e){let r=e.position,t=e.textureCoord;this.glContext.setVertexAttributes(r,t),this.attributesBound=!0}bindUniforms(e,r,t){let i=this.glContext.gl,o=0;for(let{name:s,type:a,location:u,arrayLength:c}of e){let g=r.find(v=>v.name===s)?.data;if(a!=="sampler2D"&&!g)throw new Error(`variable '${s}' does not have data defined in program info`);switch(a){case"sampler2D":this.bindTexture(t[o],u,o),o++;break;case"float":c?i.uniform1fv(u,g):i.uniform1f(u,g);break;case"int":c?i.uniform1iv(u,g):i.uniform1i(u,g);break;default:throw new Error(`Uniform not implemented: ${a}`)}}}bindTexture(e,r,t){this.glContext.bindTextureToUniform(e.texture,t,r)}getAttribLocations(e){return{position:this.getAttribLocation(e,"position"),textureCoord:this.getAttribLocation(e,"textureCoord")}}getUniformLocations(e,r,t){let i=[];if(r)for(let o of r)i.push({name:o,type:"sampler2D",location:this.getUniformLocation(e,o)});if(t)for(let o of t)i.push({...o,location:this.getUniformLocation(e,o.name)});return i}getUniformLocation(e,r){let i=this.glContext.gl.getUniformLocation(e,r);if(i===null)throw new Error(`Uniform ${r} not found.`);return i}getAttribLocation(e,r){return this.glContext.gl.getAttribLocation(e,r)}}});var Da,pg=X(()=>{"use strict";Kt();ro();Da=class{constructor(e,r,t,i){this.glContext=e;this.layoutStrategy=r;this.profiler=t;this.config=i;this.pendingRead=new Map;i.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(e,r,t,i){let o=this.toEncoderType(e),s=this.glContext.getEncoder(o,r.channels||1,i);if(r.isPacked&&i===1)throw new Error("not implemented");let a=r.width,u=r.height,c,g;if(this.config.reuseTextures){c=`${a}x${u}_${s.format}_${s.internalFormat}_${s.textureType}`,g=this.inUseTextures.get(c),g||(g=[],this.inUseTextures.set(c,g));let T=this.idleTextures.get(c);if(T&&T.length>0){let S=T.pop();return g.push(S),i===1&&this.glContext.updateTexture(S,a,u,s,this.toTextureData(e,t)),S}}Xe.verbose("TextureManager",`Creating new texture of size ${r.width}x${r.height}`);let v=this.glContext.allocateTexture(a,u,s,this.toTextureData(e,t));return this.config.reuseTextures&&(g.push(v),this.textureLookup.set(v,c)),v}readTexture(e,r,t){return t||(t=1),this.profiler.event("backend","TextureManager.readTexture",()=>{let i=e.shape.reduce((s,a)=>s*a)*t,o=this.glContext.readTexture(e.texture,e.width,e.height,i,this.toEncoderType(r),t);return this.toTensorData(r,o)})}async readTextureAsync(e,r,t){let i=e.tensor.dataId;if(t||(t=1),this.pendingRead.has(i)){let o=this.pendingRead.get(i);return new Promise(s=>o?.push(s))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(i,[]);let o=e.shape.reduce((c,g)=>c*g)*t;await this.glContext.createAndWaitForFence();let s=this.glContext.readTexture(e.texture,e.width,e.height,o,this.toEncoderType(r),t),a=this.toTensorData(r,s),u=this.pendingRead.get(i);return this.pendingRead.delete(i),u?.forEach(c=>c(a)),a})}readUint8TextureAsFloat(e){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{let r=e.shape.reduce((i,o)=>i*o),t=this.glContext.readTexture(e.texture,e.width,e.height,r*4,"byte",4);return new Float32Array(t.buffer,t.byteOffset,r)})}releaseTexture(e,r){let t;if(this.config.reuseTextures&&(t=this.textureLookup.get(e.texture),t)){r&&this.textureLookup.delete(t);let i=this.inUseTextures.get(t);if(i){let o=i.indexOf(e.texture);if(o!==-1){i.splice(o,1);let s=this.idleTextures.get(t);s||(s=[],this.idleTextures.set(t,s)),s.push(e.texture)}}}(!t||r)&&(Xe.verbose("TextureManager",`Deleting texture of size ${e.width}x${e.height}`),this.glContext.deleteTexture(e.texture))}toTensorData(e,r){switch(e){case"int16":return r instanceof Int16Array?r:Int16Array.from(r);case"int32":return r instanceof Int32Array?r:Int32Array.from(r);case"int8":return r instanceof Int8Array?r:Int8Array.from(r);case"uint16":return r instanceof Uint16Array?r:Uint16Array.from(r);case"uint32":return r instanceof Uint32Array?r:Uint32Array.from(r);case"uint8":case"bool":return r instanceof Uint8Array?r:Uint8Array.from(r);case"float32":return r instanceof Float32Array?r:Float32Array.from(r);case"float64":return r instanceof Float64Array?r:Float64Array.from(r);default:throw new Error(`TensorData type ${e} is not supported`)}}toTextureData(e,r){if(r)return r instanceof Float32Array?r:new Float32Array(r)}toEncoderType(e){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}});var ka,hg=X(()=>{"use strict";Kt();Of();ap();eg();dg();yu();pg();ka=class{constructor(e,r){this.backend=e;this.context=r;this.layoutStrategy=new $a(e.glContext.maxTextureSize),this.programManager=new Pa(this.context.profiler,e.glContext,this.layoutStrategy),this.textureManager=new Da(e.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:e.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=e.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new pa(this)}onGraphInitialized(e){let r=e.getValues().filter(t=>t.from===-1&&t.tensor).map(t=>t.tensor.dataId);this.initializers=new Set(r)}isInitializer(e){return this.initializers?this.initializers.has(e):!1}addInitializer(e){this.initializers.add(e)}getTextureData(e,r){return r?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,r,t=!1){Xe.verbose("WebGLSessionHandler","Storing Texture data in cache"),t?this.packedTextureDataCache.set(e,r):this.unpackedTextureDataCache.set(e,r)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.textureManager.releaseTexture(e,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.textureManager.releaseTexture(e,!0)),this.unpackedTextureDataCache=new Map}resolve(e,r,t){let i=Af(e,r,Qm);return{impl:i.opImpl,context:i.opInit?i.opInit(e,t):e}}}});function V_(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}var so,mg=X(()=>{"use strict";lr();ro();ro();$r();so=class{constructor(e,r){this.frameBufferBound=!1;this.itemsToPoll=[];this.gl=e,this.version=r,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(e,r,t,i){let o=this.gl,s=o.createTexture();o.bindTexture(o.TEXTURE_2D,s),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MIN_FILTER,o.NEAREST),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MAG_FILTER,o.NEAREST),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_S,o.CLAMP_TO_EDGE),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_T,o.CLAMP_TO_EDGE);let a=i?t.encode(i,e*r):null;return o.texImage2D(o.TEXTURE_2D,0,t.internalFormat,e,r,0,t.format,t.textureType,a),this.checkError(),s}updateTexture(e,r,t,i,o){let s=this.gl;s.bindTexture(s.TEXTURE_2D,e);let a=i.encode(o,r*t);s.texSubImage2D(s.TEXTURE_2D,0,0,0,r,t,i.format,i.textureType,a),this.checkError()}attachFramebuffer(e,r,t){let i=this.gl;i.bindTexture(i.TEXTURE_2D,e),i.bindFramebuffer(i.FRAMEBUFFER,this.framebuffer),i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,e,0),this.checkError(),i.viewport(0,0,r,t),i.scissor(0,0,r,t)}readTexture(e,r,t,i,o,s){let a=this.gl;s||(s=1),this.frameBufferBound||this.attachFramebuffer(e,r,t);let u=this.getEncoder(o,s),c=u.allocate(r*t);return a.bindTexture(a.TEXTURE_2D,e),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e,0),a.readPixels(0,0,r,t,a.RGBA,u.textureType,c),this.checkError(),u.decode(c,i)}isFramebufferReady(){return!0}getActiveTexture(){let e=this.gl;return`TEXTURE${e.getParameter(this.gl.ACTIVE_TEXTURE)-e.TEXTURE0}`}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(e,r){let t=this.gl;t.vertexAttribPointer(e,3,t.FLOAT,!1,20,0),t.enableVertexAttribArray(e),r!==-1&&(t.vertexAttribPointer(r,2,t.FLOAT,!1,20,12),t.enableVertexAttribArray(r)),this.checkError()}createProgram(e,r){let t=this.gl,i=t.createProgram();return t.attachShader(i,e),t.attachShader(i,r),t.linkProgram(i),i}compileShader(e,r){let t=this.gl,i=t.createShader(r);if(!i)throw new Error(`createShader() returned null with type ${r}`);if(t.shaderSource(i,e),t.compileShader(i),t.getShaderParameter(i,t.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${t.getShaderInfoLog(i)}
Shader source:
${e}`);return i}deleteShader(e){this.gl.deleteShader(e)}bindTextureToUniform(e,r,t){let i=this.gl;i.activeTexture(i.TEXTURE0+r),this.checkError(),i.bindTexture(i.TEXTURE_2D,e),this.checkError(),i.uniform1i(t,r),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(De.debug){let e=this.gl,r=e.getError(),t="";switch(r){case e.NO_ERROR:return;case e.INVALID_ENUM:t="INVALID_ENUM";break;case e.INVALID_VALUE:t="INVALID_VALUE";break;case e.INVALID_OPERATION:t="INVALID_OPERATION";break;case e.INVALID_FRAMEBUFFER_OPERATION:t="INVALID_FRAMEBUFFER_OPERATION";break;case e.OUT_OF_MEMORY:t="OUT_OF_MEMORY";break;case e.CONTEXT_LOST_WEBGL:t="CONTEXT_LOST_WEBGL";break;default:t=`Unknown WebGL Error: ${r.toString(16)}`}throw new Error(t)}}deleteTexture(e){this.gl.deleteTexture(e)}deleteProgram(e){this.gl.deleteProgram(e)}getEncoder(e,r,t=0){if(this.version===2)return new fa(this.gl,r);switch(e){case"float":return t===1||this.isRenderFloat32Supported?new to(this.gl,r):new to(this.gl,r,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new da(this.gl,r);default:throw new Error(`Invalid dataType: ${e}`)}}clearActiveTextures(){let e=this.gl;for(let r=0;r<this.maxTextureImageUnits;++r)e.activeTexture(e.TEXTURE0+r),e.bindTexture(e.TEXTURE_2D,null)}dispose(){if(this.disposed)return;let e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(this.framebuffer),e.bindBuffer(e.ARRAY_BUFFER,null),e.deleteBuffer(this.vertexbuffer),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),e.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){let e=this.gl,r=e.createBuffer();if(!r)throw new Error("createBuffer() returned null");let t=this.createDefaultGeometry();return e.bindBuffer(e.ARRAY_BUFFER,r),e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW),this.checkError(),r}createFramebuffer(){let e=this.gl.createFramebuffer();if(!e)throw new Error("createFramebuffer returned null");return e}queryVitalParameters(){let e=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=e.getParameter(e.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){let e=this.gl,r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);let t=this.version===2?e.RGBA32F:e.RGBA;e.texImage2D(e.TEXTURE_2D,0,t,1,1,0,e.RGBA,e.FLOAT,null);let i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),o}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){let e=this.gl,r,t,i,o,s;try{r=e.createTexture(),t=e.createFramebuffer(),e.bindTexture(e.TEXTURE_2D,r);let a=this.version===2?e.RGBA32F:e.RGBA;return e.texImage2D(e.TEXTURE_2D,0,a,1,1,0,e.RGBA,e.FLOAT,null),e.bindFramebuffer(e.FRAMEBUFFER,t),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0),e.enable(e.BLEND),i=e.createShader(e.VERTEX_SHADER),!i||(e.shaderSource(i,"void main(){}"),e.compileShader(i),o=e.createShader(e.FRAGMENT_SHADER),!o)||(e.shaderSource(o,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),e.compileShader(o),s=e.createProgram(),!s)?!1:(e.attachShader(s,i),e.attachShader(s,o),e.linkProgram(s),e.useProgram(s),e.drawArrays(e.POINTS,0,1),e.getError()===e.NO_ERROR)}finally{e.disable(e.BLEND),s&&e.deleteProgram(s),i&&e.deleteShader(i),o&&e.deleteShader(o),t&&(e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(t)),r&&(e.bindTexture(e.TEXTURE_2D,null),e.deleteTexture(r))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let e=this.gl,r=this.disjointTimerQueryWebgl2Extension,t=e.createQuery();return e.beginQuery(r.TIME_ELAPSED_EXT,t),t}else throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let e=this.gl,r=this.disjointTimerQueryWebgl2Extension;e.endQuery(r.TIME_ELAPSED_EXT);return}else throw new Error("WebGL1 profiling currently not supported")}isTimerResultAvailable(e){let r=!1,t=!1;if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let i=this.gl,o=this.disjointTimerQueryWebgl2Extension;r=i.getQueryParameter(e,i.QUERY_RESULT_AVAILABLE),t=i.getParameter(o.GPU_DISJOINT_EXT)}else throw new Error("WebGL1 profiling currently not supported");return r&&!t}getTimerResult(e){let r=0;if(this.version===2){let t=this.gl;r=t.getQueryParameter(e,t.QUERY_RESULT),t.deleteQuery(e)}else throw new Error("WebGL1 profiling currently not supported");return r/1e6}async waitForQueryAndGetTime(e){return await Ws(()=>this.isTimerResultAvailable(e)),this.getTimerResult(e)}async createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let r,t=e,i=t.fenceSync(t.SYNC_GPU_COMMANDS_COMPLETE,0);return e.flush(),i===null?r=()=>!0:r=()=>{let o=t.clientWaitSync(i,0,0);return o===t.ALREADY_SIGNALED||o===t.CONDITION_SATISFIED},{query:i,isFencePassed:r}}async pollFence(e){return new Promise(r=>{this.addItemToPoll(()=>e.isFencePassed(),()=>r())})}pollItems(){let e=V_(this.itemsToPoll.map(r=>r.isDoneFn));for(let r=0;r<=e;++r){let{resolveFn:t}=this.itemsToPoll[r];t()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}async addItemToPoll(e,r){this.itemsToPoll.push({isDoneFn:e,resolveFn:r}),!(this.itemsToPoll.length>1)&&await Ws(()=>(this.pollItems(),this.itemsToPoll.length===0))}}});function vu(n){let e;if((!n||n==="webgl2")&&"webgl2"in ni?e=ni.webgl2:(!n||n==="webgl")&&"webgl"in ni&&(e=ni.webgl),!e)try{let t=H_();e=gg(t,n)}catch{let i=U_();e=gg(i,n)}n=n||e.version===1?"webgl":"webgl2";let r=e.gl;return ni[n]=e,r.isContextLost()?(delete ni[n],vu(n)):(r.disable(r.DEPTH_TEST),r.disable(r.STENCIL_TEST),r.disable(r.BLEND),r.disable(r.DITHER),r.disable(r.POLYGON_OFFSET_FILL),r.disable(r.SAMPLE_COVERAGE),r.enable(r.SCISSOR_TEST),r.enable(r.CULL_FACE),r.cullFace(r.BACK),e)}function gg(n,e){let r={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1},t,i=r;if((!e||e==="webgl2")&&(t=n.getContext("webgl2",i),t))try{return new so(t,2)}catch(o){Xe.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${o}`)}if((!e||e==="webgl")&&(t=n.getContext("webgl",i)||n.getContext("experimental-webgl",i),t))try{return new so(t,1)}catch(o){Xe.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${o}`)}throw new Error("WebGL is not supported")}function U_(){if(typeof document>"u")throw new TypeError("failed to create canvas: document is not supported");let n=document.createElement("canvas");return n.width=1,n.height=1,n}function H_(){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}var ni,yg=X(()=>{"use strict";Kt();mg();ni={}});var Ba,bg=X(()=>{"use strict";lr();Kt();hg();yg();Ba=class{get contextId(){return De.webgl.contextId}set contextId(e){De.webgl.contextId=e}get matmulMaxBatchSize(){return De.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(e){De.webgl.matmulMaxBatchSize=e}get textureCacheMode(){return De.webgl.textureCacheMode}set textureCacheMode(e){De.webgl.textureCacheMode=e}get pack(){return De.webgl.pack}set pack(e){De.webgl.pack=e}get async(){return De.webgl.async}set async(e){De.webgl.async=e}initialize(){try{return this.glContext=vu(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),Xe.setWithEnv(De),De.webgl.context||Object.defineProperty(De.webgl,"context",{value:this.glContext.gl}),Xe.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(e){return Xe.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${e}`),!1}}createSessionHandler(e){return new ka(this,e)}dispose(){this.glContext.dispose()}}});async function wu(n){if(n){let e=typeof n=="string"?[n]:n;for(let r of e){let t=vg.get(r);if(t)return t;let i=await K_(r);if(i)return i}}else return wu(["webgl"]);throw new Error("no available backend to use")}async function K_(n){let e=q_;if(typeof e[n]<"u"&&X_(e[n])){let r=e[n],t=r.initialize();if(typeof t=="object"&&"then"in t&&(t=await t),t)return vg.set(n,r),r}}function X_(n){let e=n;return"initialize"in e&&typeof e.initialize=="function"&&"createSessionHandler"in e&&typeof e.createSessionHandler=="function"&&"dispose"in e&&typeof e.dispose=="function"}var vg,q_,wg=X(()=>{"use strict";bg();vg=new Map,q_={webgl:new Ba}});var xu,Ra,xg=X(()=>{"use strict";Kt();xu=class{constructor(e,r){this.op=e;this.node=r}},Ra=class{constructor(e,r,t){this.graph=e;this.profiler=t;this.initialize(r)}initialize(e){this.profiler.event("session","ExecutionPlan.initialize",()=>{let r=this.graph.getNodes();if(r.length!==e.length)throw new Error("The size of nodes and OPs do not match.");this._ops=e.map((t,i)=>new xu(t,r[i])),this.reset(),this._starter=[],this._ops.forEach((t,i)=>{let o=!0;for(let s of t.node.inputs)if(!this._values[s]&&this.graph.getInputIndices().indexOf(s)===-1){o=!1;break}o&&this._starter.push(i)})})}reset(){this._values=this.graph.getValues().map(e=>e.tensor)}async execute(e,r){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();let t=e.createInferenceHandler(),i=this.graph.getInputIndices();if(r.length!==i.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${r.length} expected: ${i.length}`);r.forEach((g,v)=>{let T=i[v];this._values[T]=g});let o=this._starter.slice(0),s=this.graph.getValues(),a=this.graph.getNodes(),u=0;for(;u<o.length;){let g=o[u++],v=this._ops[g],T=v.node.inputs.map(k=>this._values[k]);if(T.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${v.node}`);let S=T;Xe.verbose("ExecPlan",`Runing op:${v.node.name} (${S.map((k,M)=>`'${v.node.inputs[M]}': ${k.type}[${k.dims.join(",")}]`).join(", ")})`);let O=await this.profiler.event("node",v.node.name,async()=>v.op.impl(t,S,v.op.context));if(O.length!==v.node.outputs.length)throw new Error("the size of output does not match model definition.");O.forEach((k,M)=>{let F=v.node.outputs[M];if(this._values[F])throw new Error(`output [${F}] already has value: op:${v.node.name}`);this._values[F]=k});let I=new Set;O.forEach((k,M)=>{let F=v.node.outputs[M];for(let j of s[F].to){let Y=a[j],Z=!0;for(let P of Y.inputs)if(!this._values[P]){Z=!1;break}Z&&I.add(j)}}),o.push(...I)}let c=[];for(let g=0;g<this.graph.getOutputIndices().length;g++){let v=this.graph.getOutputIndices()[g],T=this._values[v];if(T===void 0)throw new Error(`required output [${v}] does not have value`);v===0?await T.getData():T.data,c.push(T)}return Xe.verbose("ExecPlan","disposing of inferenceHandler"),t.dispose(),c})}}});var Le,tr,uo,Tg=X(()=>{"use strict";Xi();Le=Un(Xn());bn();Ke();tr=be.experimental.fbs,uo=class n{constructor(e){if(this._attributes=new Map,e!=null){for(let r of e)r instanceof Le.onnx.AttributeProto?this._attributes.set(r.name,[n.getValue(r),n.getType(r)]):r instanceof tr.Attribute&&this._attributes.set(r.name(),[n.getValue(r),n.getType(r)]);if(this._attributes.size<e.length)throw new Error("duplicated attribute names")}}set(e,r,t){this._attributes.set(e,[t,r])}delete(e){this._attributes.delete(e)}getFloat(e,r){return this.get(e,"float",r)}getInt(e,r){return this.get(e,"int",r)}getString(e,r){return this.get(e,"string",r)}getTensor(e,r){return this.get(e,"tensor",r)}getFloats(e,r){return this.get(e,"floats",r)}getInts(e,r){return this.get(e,"ints",r)}getStrings(e,r){return this.get(e,"strings",r)}getTensors(e,r){return this.get(e,"tensors",r)}get(e,r,t){let i=this._attributes.get(e);if(i===void 0){if(t!==void 0)return t;throw new Error(`required attribute not found: ${e}`)}if(i[1]!==r)throw new Error(`type mismatch: expected ${r} but got ${i[1]}`);return i[0]}static getType(e){let r=e instanceof Le.onnx.AttributeProto?e.type:e.type();switch(r){case Le.onnx.AttributeProto.AttributeType.FLOAT:return"float";case Le.onnx.AttributeProto.AttributeType.INT:return"int";case Le.onnx.AttributeProto.AttributeType.STRING:return"string";case Le.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case Le.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case Le.onnx.AttributeProto.AttributeType.INTS:return"ints";case Le.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case Le.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${Le.onnx.AttributeProto.AttributeType[r]}`)}}static getValue(e){let r=e instanceof Le.onnx.AttributeProto?e.type:e.type();if(r===Le.onnx.AttributeProto.AttributeType.GRAPH||r===Le.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");let t=this.getValueNoCheck(e);if(r===Le.onnx.AttributeProto.AttributeType.INT&&jt.isLong(t))return jt.longToNumber(t);if(r===Le.onnx.AttributeProto.AttributeType.INTS){let i=t,o=new Array(i.length);for(let s=0;s<i.length;s++){let a=i[s];o[s]=jt.longToNumber(a)}return o}if(r===Le.onnx.AttributeProto.AttributeType.TENSOR)return e instanceof Le.onnx.AttributeProto?vt.fromProto(t):vt.fromOrtTensor(t);if(r===Le.onnx.AttributeProto.AttributeType.TENSORS){if(e instanceof Le.onnx.AttributeProto)return t.map(o=>vt.fromProto(o));if(e instanceof tr.Attribute)return t.map(o=>vt.fromOrtTensor(o))}return r===Le.onnx.AttributeProto.AttributeType.STRING&&e instanceof Le.onnx.AttributeProto?eo(t):r===Le.onnx.AttributeProto.AttributeType.STRINGS&&e instanceof Le.onnx.AttributeProto?t.map(eo):t}static getValueNoCheck(e){return e instanceof Le.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(e):this.getValueNoCheckFromOrtFormat(e)}static getValueNoCheckFromOnnxFormat(e){switch(e.type){case Le.onnx.AttributeProto.AttributeType.FLOAT:return e.f;case Le.onnx.AttributeProto.AttributeType.INT:return e.i;case Le.onnx.AttributeProto.AttributeType.STRING:return e.s;case Le.onnx.AttributeProto.AttributeType.TENSOR:return e.t;case Le.onnx.AttributeProto.AttributeType.GRAPH:return e.g;case Le.onnx.AttributeProto.AttributeType.FLOATS:return e.floats;case Le.onnx.AttributeProto.AttributeType.INTS:return e.ints;case Le.onnx.AttributeProto.AttributeType.STRINGS:return e.strings;case Le.onnx.AttributeProto.AttributeType.TENSORS:return e.tensors;case Le.onnx.AttributeProto.AttributeType.GRAPHS:return e.graphs;default:throw new Error(`unsupported attribute type: ${Le.onnx.AttributeProto.AttributeType[e.type]}`)}}static getValueNoCheckFromOrtFormat(e){switch(e.type()){case tr.AttributeType.FLOAT:return e.f();case tr.AttributeType.INT:return e.i();case tr.AttributeType.STRING:return e.s();case tr.AttributeType.TENSOR:return e.t();case tr.AttributeType.GRAPH:return e.g();case tr.AttributeType.FLOATS:return e.floatsArray();case tr.AttributeType.INTS:{let r=[];for(let t=0;t<e.intsLength();t++)r.push(e.ints(t));return r}case tr.AttributeType.STRINGS:{let r=[];for(let t=0;t<e.stringsLength();t++)r.push(e.strings(t));return r}case tr.AttributeType.TENSORS:{let r=[];for(let t=0;t<e.tensorsLength();t++)r.push(e.tensors(t));return r}default:throw new Error(`unsupported attribute type: ${tr.AttributeType[e.type()]}`)}}}});var _u,Ma,$u,Cr,La,Tu,_g=X(()=>{"use strict";Tg();Xi();_u=Un(Xn());bn();Ke();Ma=be.experimental.fbs,$u={from:(n,e)=>new Tu(n,e)},Cr=class{constructor(e){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,e&&(this.type=Ot.tensorValueTypeFromProto(e.type.tensorType))}get from(){return this._from}get to(){return this._to}},La=class{constructor(e,r){e instanceof _u.onnx.NodeProto?(this.name=e.name,this.opType=e.opType,this.attributes=new uo(e.attribute)):e instanceof Ma.Node&&(this.name=r??e.name(),this.opType=e.opType(),this.attributes=new uo(Ot.tensorAttributesFromORTFormat(e))),this.inputs=[],this.outputs=[],this.executeNode=!0}},Tu=class{constructor(e,r){if(!e)throw new TypeError("graph is empty");this.buildGraph(e),this.transformGraph(r),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(e){if(e instanceof _u.onnx.GraphProto)this.buildGraphFromOnnxFormat(e);else if(e instanceof Ma.Graph)this.buildGraphFromOrtFormat(e);else throw new TypeError("Graph type is not supported.")}buildGraphFromOnnxFormat(e){let r=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let t=new Map;if(!e.input)throw new Error("missing information in graph: input");let i=[];for(let o of e.input){if(r.has(o.name))throw new Error(`duplicated input name: ${o.name}`);let s=this._allData.push(new Cr(o))-1;r.set(o.name,s),i.push(o.name)}if(!e.initializer)throw new Error("missing information in graph: initializer");for(let o of e.initializer){let s=r.get(o.name);if(s===void 0){let a=new Cr;a.type={shape:{dims:Ot.tensorDimsFromProto(o.dims)},tensorType:Ot.tensorDataTypeFromProto(o.dataType)},s=this._allData.push(a)-1,r.set(o.name,s)}this._allData[s]._from=-1,this._allData[s].tensor=vt.fromProto(o)}for(let o=0;o<this._allData.length;o++)this._allData[o].tensor||(this._allInputIndices.push(o),this._allInputNames.push(i[o]));if(!e.output)throw new Error("missing information in graph: output");for(let o of e.output){if(r.has(o.name))throw new Error(`duplicated output name: ${o.name}`);let s=this._allData.push(new Cr(o))-1;r.set(o.name,s),this._allOutputIndices.push(s),this._allOutputNames.push(o.name)}if(!e.node)throw new Error("missing information in graph: node");for(let o of e.node){if(!o.name)for(let a=0;;a++){let u=`unnamed_${o.opType}_${a}`;if(!t.has(u)){o.name=u;break}}if(t.has(o.name))throw new Error(`duplicated node name: ${o.name}`);let s=this._nodes.push(new La(o))-1;t.set(o.name,s)}for(let o=0;o<this._nodes.length;o++){let s=this._nodes[o],a=e.node[o];if(!a.output)throw new Error(`missing output for node: ${a.name}`);for(let u of a.output){let c=r.get(u);if(typeof c>"u"&&(c=this._allData.push(new Cr)-1,r.set(u,c)),s.outputs.push(c),this._allData[c]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${c}`);if(this._allData[c]._from=o,a.opType==="Constant"){if(!a.attribute||a.attribute.length!==1||!a.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!a.output||a.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");s.outputs.pop(),s.executeNode=!1,this._allData[c]._from=-1,this._allData[c].tensor=vt.fromProto(a.attribute[0].t)}}}for(let o=0;o<this._nodes.length;o++){let s=this._nodes[o],a=e.node[o];if(!a.input)throw new Error(`missing input for node: ${a.name}`);for(let u of a.input){let c=r.get(u);if(typeof c>"u"){if(u===""&&(a.input.length===3||a.input.length===4)&&a.opType==="Resize")continue;throw new Error(`unrecognized input '${u}' for node: ${a.name}`)}s.inputs.push(c),this._allData[c]._to.push(o)}}return!0}buildGraphFromOrtFormat(e){let r=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let t=new Map,i=[];for(let o=0;o<e.inputsLength();o++){let s=e.inputs(o);if(r.has(s))throw new Error(`duplicated input name: ${s}`);for(let a=0;a<e.nodeArgsLength();a++)if(e.nodeArgs(a)?.name()===s){let u=new Cr;if(e.nodeArgs(a)?.type()?.valueType()!==Ma.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");let g=e.nodeArgs(a).type().value(new Ma.TensorTypeAndShape),v=Ot.tensorDataTypeFromProto(g.elemType()),T=g.shape(),S=[];for(let I=0;I<T.dimLength();I++)S.push(jt.longToNumber(T.dim(I).value().dimValue()));u.type={shape:{dims:S},tensorType:v};let O=this._allData.push(u)-1;r.set(s,O),i.push(s)}}for(let o=0;o<e.initializersLength();o++){let s=e.initializers(o),a=r.get(s.name());if(a===void 0){let u=new Cr,c=Ot.tensorDimsFromORTFormat(s),g=Ot.tensorDataTypeFromProto(s.dataType());u.type={shape:{dims:c},tensorType:g},a=this._allData.push(u)-1,r.set(s.name(),a)}this._allData[a]._from=-1,this._allData[a].tensor=vt.fromOrtTensor(s)}for(let o=0;o<this._allData.length;o++)this._allData[o].tensor||(this._allInputIndices.push(o),this._allInputNames.push(i[o]));for(let o=0;o<e.outputsLength();o++){let s=e.outputs(o);if(r.has(s))throw new Error(`duplicated output name: ${s}`);let a=this._allData.push(new Cr)-1;r.set(s,a),this._allOutputIndices.push(a),this._allOutputNames.push(s)}if(!e.nodes)throw new Error("missing information in graph: node");for(let o=0;o<e.nodesLength();o++){let s=e.nodes(o),a=s.name();if(!a)for(let c=0;a=`unnamed_${s.opType()}_${c}`,!!t.has(a);c++);if(t.has(a))throw new Error(`duplicated node name: ${a}`);let u=this._nodes.push(new La(s,a))-1;t.set(a,u)}for(let o=0;o<this._nodes.length;o++){let s=this._nodes[o],a=e.nodes(o);if(a==null)throw new Error(`No node exists at index ${o}`);if(a?.outputsLength()===0)throw new Error(`missing output for node: ${a.name}`);for(let u=0;u<a?.outputsLength();u++){let c=a?.outputs(u),g=r.get(c);if(typeof g>"u"&&(g=this._allData.push(new Cr)-1,r.set(c,g)),s.outputs.push(g),this._allData[g]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${g}`);if(this._allData[g]._from=o,a.opType()==="Constant"){if(a.attributesLength()!==1||!a.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(a.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");s.outputs.pop(),s.executeNode=!1,this._allData[g]._from=-1,this._allData[g].tensor=vt.fromOrtTensor(a.attributes(0).t())}}}for(let o=0;o<this._nodes.length;o++){let s=this._nodes[o],a=e.nodes(o);if(a.inputsLength()===0)throw new Error(`missing input for node: ${a.name}`);for(let u=0;u<a.inputsLength();u++){let c=a.inputs(u),g=r.get(c);if(typeof g>"u")throw new Error(`unrecognized input '${c}' for node: ${a.name()}`);s.inputs.push(g),this._allData[g]._to.push(o)}}}checkIsAcyclic(){let e=new Set;this._allInputIndices.forEach(i=>{this._allData[i]._to.forEach(s=>{e.add(s)})});let r=Array.from(e),t=new Array(this._nodes.length).fill("white");for(;r.length>0;){let i=r.pop();t[i]==="gray"?t[i]="black":(r.push(i),t[i]="gray",this._nodes[i].outputs.forEach(o=>{let s=this._allData[o];if(typeof s.tensor<"u")throw new Error("node outputs should not be initialized");if(s._from!==i)throw new Error("from property of the Value object doesn't match index of Node being processed");s._to.forEach(a=>{if(t[a]==="gray")throw new Error("model graph is cyclic");t[a]==="white"&&r.push(a)})}))}}transformGraph(e){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),e&&e.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let e=0,r=new Array(this._nodes.length,0),t=0;for(let i=0;i<this._nodes.length;i++)r[i]=t,this._nodes[i].executeNode?(t!==i&&(this._nodes[t]=this._nodes[i]),t++):this._nodes[i].outputs.forEach(o=>{this._allData[o]._from=-2});this._nodes.splice(t,this._nodes.length-t);for(let i=0;i<this._allData.length;i++){let o=this._allData[i];o._from!==void 0&&o._from!==-1&&o._from!==-2&&(o._from=r[o._from]);for(let s=0;s<o._to.length;s++)if(o._to[s]>=0)o._to[s]=r[o._to[s]];else throw new Error("Trying to update a removed node")}e=0;for(let i=0;i<this._allData.length;i++){if(this._allData[i].from===-2&&this._allOutputIndices.indexOf(i+e)===-1){e++,this._allData.splice(i,1),i--;continue}if(e>0){let o=-1;this._allData[i].from!==void 0&&this._allData[i].from!==-1?(o=this._nodes[this._allData[i].from].outputs.indexOf(i+e),o!==-1&&(this._nodes[this._allData[i].from].outputs[o]=i)):(o=this._allInputIndices.indexOf(i+e),o!==-1&&(this._allInputIndices[o]=i)),this._allData[i].to.forEach(s=>{o=this._nodes[s].inputs.indexOf(i+e),o!==-1&&(this._nodes[s].inputs[o]=i)}),this._allData[i].to.length===0&&(o=this._allOutputIndices.indexOf(i+e),o!==-1&&(this._allOutputIndices[o]=i))}}}deleteNode(e){let r=this._nodes[e];if(r.outputs.length>1){for(let a=1;a<r.outputs.length;a++)if(this._allData[r.outputs[a]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}r.executeNode=!1;let t=r.inputs[0],i=r.outputs[0],o=this._allData[i].to;for(let a=0;a<r.inputs.length;a++){let u=this._allData[r.inputs[a]].to.indexOf(e);if(u===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[r.inputs[a]].to.splice(u,1)}this._allData[i]._to=[];let s=this._allOutputIndices.indexOf(i);if(s!==-1&&(this._allOutputIndices[s]=t),o&&o.length>0)for(let a of o){let u=this._nodes[a].inputs.indexOf(i);if(u===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[a].inputs[u]=t,this._allData[t].to.push(a)}}removeAllDropoutNodes(){let e=0;for(let r of this._nodes){if(r.opType==="Dropout"){if(r.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(r.outputs.length!==1&&r.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(r.outputs.length===2&&this._allData[r.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(e)}e++}}removeAllIdentityNodes(){let e=0;for(let r of this._nodes)r.opType==="Identity"&&this.deleteNode(e),e++}isActivation(e){switch(e.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(let e of this._nodes)if(e.opType==="Conv"){let r=this._allData[e.outputs[0]]._to;if(r.length===1&&this.isActivation(this._nodes[r[0]])){let t=this._nodes[r[0]];if(t.opType==="Clip")if(t.inputs.length===1)try{e.attributes.set("activation_params","floats",[t.attributes.getFloat("min"),t.attributes.getFloat("max")])}catch{e.attributes.set("activation_params","floats",[gn,yn])}else if(t.inputs.length>=3&&this._allData[t.inputs[1]].tensor!==void 0&&this._allData[t.inputs[2]].tensor!==void 0)e.attributes.set("activation_params","floats",[this._allData[t.inputs[1]].tensor.floatData[0],this._allData[t.inputs[2]].tensor.floatData[0]]);else continue;e.attributes.set("activation","string",t.opType),this.deleteNode(r[0])}}}}});var $g,Y_,Na,Sg=X(()=>{"use strict";ia();_g();Xi();$g=Un(Xn());Ke();Y_=be.experimental.fbs,Na=class{constructor(){}load(e,r,t){if(!t)try{this.loadFromOnnxFormat(e,r);return}catch(i){if(t!==void 0)throw i}this.loadFromOrtFormat(e,r)}loadFromOnnxFormat(e,r){let t=$g.onnx.ModelProto.decode(e);if(jt.longToNumber(t.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=t.opsetImport.map(o=>({domain:o.domain,version:jt.longToNumber(o.version)})),this._graph=$u.from(t.graph,r)}loadFromOrtFormat(e,r){let t=new G.ByteBuffer(e),i=Y_.InferenceSession.getRootAsInferenceSession(t).model();if(jt.longToNumber(i.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let s=0;s<i.opsetImportLength();s++){let a=i.opsetImport(s);this._opsets.push({domain:a?.domain(),version:jt.longToNumber(a.version())})}this._graph=$u.from(i.graph(),r)}get graph(){return this._graph}get opsets(){return this._opsets}}});var za,Ig=X(()=>{"use strict";wg();xg();Kt();Sg();za=class{constructor(e={}){this._initialized=!1,this.backendHint=e.backendHint,this.profiler=ra.create(e.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(e,r,t){await this.profiler.event("session","Session.loadModel",async()=>{let i=await wu(this.backendHint);if(this.sessionHandler=i.createSessionHandler(this.context),this._model=new Na,typeof e=="string"){let o=e.endsWith(".ort");if(typeof process<"u"&&process.versions&&process.versions.node){let s=await(void 0)(e);this.initialize(s,o)}else{let a=await(await fetch(e)).arrayBuffer();this.initialize(new Uint8Array(a),o)}}else if(ArrayBuffer.isView(e))this.initialize(e);else{let o=new Uint8Array(e,r||0,t||e.byteLength);this.initialize(o)}})}initialize(e,r){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{let t=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(e,t,r),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new Ra(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(e){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{let r=this.normalizeAndValidateInputs(e),t=await this._executionPlan.execute(this.sessionHandler,r);return this.createOutput(t)})}normalizeAndValidateInputs(e){let r=this._model.graph.getInputNames();if(Array.isArray(e)){if(e.length!==r.length)throw new Error(`incorrect input array length: expected ${r.length} but got ${e.length}`)}else{if(e.size!==r.length)throw new Error(`incorrect input map size: expected ${r.length} but got ${e.size}`);let t=new Array(e.size),i=0;for(let o=0;o<r.length;++o){let s=e.get(r[o]);if(!s)throw new Error(`missing input tensor for: '${name}'`);t[i++]=s}e=t}if(!this.context.graphInputTypes||this.context.graphInputTypes.length===0||!this.context.graphInputDims||this.context.graphInputDims.length===0){let t=this._model.graph.getInputIndices(),i=this._model.graph.getValues(),o=new Array(t.length);for(let s=0;s<t.length;++s){let a=i[t[s]];o[s]=a.type.shape.dims,this.context.graphInputTypes.push(a.type.tensorType),this.context.graphInputDims.push(e[s].dims)}this.validateInputTensorDims(o,e,!0)}else this.validateInputTensorDims(this.context.graphInputDims,e,!1);return this.validateInputTensorTypes(this.context.graphInputTypes,e),e}validateInputTensorTypes(e,r){for(let t=0;t<r.length;t++){let i=e[t],o=r[t].type;if(i!==o)throw new Error(`input tensor[${t}] check failed: expected type '${i}' but got ${o}`)}}validateInputTensorDims(e,r,t){for(let i=0;i<r.length;i++){let o=e[i],s=r[i].dims;if(!this.compareTensorDims(o,s,t))throw new Error(`input tensor[${i}] check failed: expected shape '[${o.join(",")}]' but got [${s.join(",")}]`)}}compareTensorDims(e,r,t){if(e.length!==r.length)return!1;for(let i=0;i<e.length;++i)if(e[i]!==r[i]&&(!t||e[i]!==0))return!1;return!0}createOutput(e){let r=this._model.graph.getOutputNames();if(e.length!==r.length)throw new Error("expected number of outputs do not match number of generated outputs");let t=new Map;for(let i=0;i<r.length;++i)t.set(r[i],e[i]);return t}initializeOps(e){let r=e.getNodes();this._ops=new Array(r.length);for(let t=0;t<r.length;t++)this._ops[t]=this.sessionHandler.resolve(r[t],this._model.opsets,e)}}});var Fa,Cg=X(()=>{"use strict";lr();bn();Fa=class{constructor(e){this.session=e;this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(e,r,t){let i=new Map;for(let a in e)if(Object.hasOwnProperty.call(e,a)){let u=e[a];i.set(a,new vt(u.dims,u.type,void 0,void 0,u.data))}let o=await this.session.run(i),s={};return o.forEach((a,u)=>{s[u]=new qt(a.type,a.data,a.dims)}),s}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}});var Ag={};ln(Ag,{onnxjsBackend:()=>Z_});var Su,Z_,Og=X(()=>{"use strict";Ig();Cg();Su=class{async init(){}async createInferenceSessionHandler(e,r){let t=new za(r);return typeof e=="string"?await t.loadModel(e):await t.loadModel(e),new Fa(t)}},Z_=new Su});var Iu={};ln(Iu,{readFile:()=>Q_});var Q_,Cu=X(()=>{Q_=void 0});var Au={};ln(Au,{join:()=>e$});var e$,Ou=X(()=>{e$=void 0});var Dg=et((Pg,Eu)=>{"use strict";var Eg=(()=>{var n=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(n=n||__filename),function(e={}){var r=e,t,i;r.ready=new Promise((l,f)=>{t=l,i=f}),r.jsepInit=(l,f,d,p,h,y,b,w)=>{r.zh=l,r.ph=f,r.rh=d,r.eh=p,r.qh=h,r.Cd=y,r.sh=b,r.th=w,f=(x,$,C)=>(...D)=>{let R=Gt,A=$?.();D=x(...D);let z=$?.();return A!==z&&(x=z,C(A),$=C=null),Gt!=R?So():D},d=x=>async(...$)=>{try{if(r.Xg)throw Error("Session already started");let C=r.Xg={uh:$[0],errors:[]},D=await x(...$);if(r.Xg!==C)throw Error("Session mismatch");l.flush();let R=C.errors;if(0<R.length){let A=await Promise.all(R);if(A=A.filter(z=>z),0<A.length)throw Error(A.join(`
`))}return D}finally{r.Xg=null}},r._OrtRun=d(f(r._OrtRun,()=>r._OrtRun,x=>r._OrtRun=x)),r._OrtRunWithBinding=d(f(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,x=>r._OrtRunWithBinding=x)),r._OrtBindInput=f(r._OrtBindInput,()=>r._OrtBindInput,x=>r._OrtBindInput=x),r.jsepRegisterBuffer=(x,$,C,D)=>l.registerBuffer(x,$,C,D),r.jsepUnregisterBuffers=x=>{l.unregisterBuffers(x)},r.jsepGetBuffer=x=>l.getBuffer(x),r.jsepCreateDownloader=(x,$,C)=>l.createDownloader(x,$,C)};var o=Object.assign({},r),s="./this.program",a=(l,f)=>{throw f},u=typeof window=="object",c=typeof importScripts=="function",g=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",v="",T,S,O;if(g){var I=(Cu(),Rr(Iu)),k=(Ou(),Rr(Au));v=c?k.dirname(v)+"/":__dirname+"/",T=(l,f)=>(l=l.startsWith("file://")?new URL(l):k.normalize(l),I.readFileSync(l,f?void 0:"utf8")),O=l=>(l=T(l,!0),l.buffer||(l=new Uint8Array(l)),l),S=(l,f,d,p=!0)=>{l=l.startsWith("file://")?new URL(l):k.normalize(l),I.readFile(l,p?void 0:"utf8",(h,y)=>{h?d(h):f(p?y.buffer:y)})},!r.thisProgram&&1<process.argv.length&&(s=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),a=(l,f)=>{throw process.exitCode=l,f},r.inspect=()=>"[Emscripten Module object]"}else(u||c)&&(c?v=self.location.href:typeof document<"u"&&document.currentScript&&(v=document.currentScript.src),n&&(v=n),v.indexOf("blob:")!==0?v=v.substr(0,v.replace(/[?#].*/,"").lastIndexOf("/")+1):v="",T=l=>{var f=new XMLHttpRequest;return f.open("GET",l,!1),f.send(null),f.responseText},c&&(O=l=>{var f=new XMLHttpRequest;return f.open("GET",l,!1),f.responseType="arraybuffer",f.send(null),new Uint8Array(f.response)}),S=(l,f,d)=>{var p=new XMLHttpRequest;p.open("GET",l,!0),p.responseType="arraybuffer",p.onload=()=>{p.status==200||p.status==0&&p.response?f(p.response):d()},p.onerror=d,p.send(null)});var M=r.print||console.log.bind(console),F=r.printErr||console.error.bind(console);Object.assign(r,o),o=null,r.thisProgram&&(s=r.thisProgram),r.quit&&(a=r.quit);var j;r.wasmBinary&&(j=r.wasmBinary);var Y=r.noExitRuntime||!0;typeof WebAssembly!="object"&&Et("no native wasm support detected");var Z,P,te=!1,ue,le,Ae,q,ge,it;function me(){var l=Z.buffer;r.HEAP8=le=new Int8Array(l),r.HEAP16=new Int16Array(l),r.HEAP32=q=new Int32Array(l),r.HEAPU8=Ae=new Uint8Array(l),r.HEAPU16=new Uint16Array(l),r.HEAPU32=ge=new Uint32Array(l),r.HEAPF32=new Float32Array(l),r.HEAPF64=it=new Float64Array(l)}var de=[],Dt=[],Ge=[];function wt(){var l=r.preRun.shift();de.unshift(l)}var Ye=0,$t=null,yr=null;function Et(l){throw r.onAbort&&r.onAbort(l),l="Aborted("+l+")",F(l),te=!0,ue=1,l=new WebAssembly.RuntimeError(l+". Build with -sASSERTIONS for more info."),i(l),l}function Dr(l){return l.startsWith("data:application/octet-stream;base64,")}var ie;if(ie="ort-wasm-simd.wasm",!Dr(ie)){var Be=ie;ie=r.locateFile?r.locateFile(Be,v):v+Be}function He(l){if(l==ie&&j)return new Uint8Array(j);if(O)return O(l);throw"both async and sync fetching of the wasm failed"}function kt(l){if(!j&&(u||c)){if(typeof fetch=="function"&&!l.startsWith("file://"))return fetch(l,{credentials:"same-origin"}).then(f=>{if(!f.ok)throw"failed to load wasm binary file at '"+l+"'";return f.arrayBuffer()}).catch(()=>He(l));if(S)return new Promise((f,d)=>{S(l,p=>f(new Uint8Array(p)),d)})}return Promise.resolve().then(()=>He(l))}function Lt(l,f,d){return kt(l).then(p=>WebAssembly.instantiate(p,f)).then(p=>p).then(d,p=>{F("failed to asynchronously prepare wasm: "+p),Et(p)})}function ft(l,f){var d=ie;return j||typeof WebAssembly.instantiateStreaming!="function"||Dr(d)||d.startsWith("file://")||g||typeof fetch!="function"?Lt(d,l,f):fetch(d,{credentials:"same-origin"}).then(p=>WebAssembly.instantiateStreaming(p,l).then(f,function(h){return F("wasm streaming compile failed: "+h),F("falling back to ArrayBuffer instantiation"),Lt(d,l,f)}))}var ot,Nt={1312944:l=>{r.Cd("Abs",l,void 0)},1312995:l=>{r.Cd("Neg",l,void 0)},1313046:l=>{r.Cd("Floor",l,void 0)},1313099:l=>{r.Cd("Ceil",l,void 0)},1313151:l=>{r.Cd("Reciprocal",l,void 0)},1313209:l=>{r.Cd("Sqrt",l,void 0)},1313261:l=>{r.Cd("Exp",l,void 0)},1313312:l=>{r.Cd("Erf",l,void 0)},1313363:l=>{r.Cd("Sigmoid",l,void 0)},1313418:l=>{r.Cd("Log",l,void 0)},1313469:l=>{r.Cd("Sin",l,void 0)},1313520:l=>{r.Cd("Cos",l,void 0)},1313571:l=>{r.Cd("Tan",l,void 0)},1313622:l=>{r.Cd("Asin",l,void 0)},1313674:l=>{r.Cd("Acos",l,void 0)},1313726:l=>{r.Cd("Atan",l,void 0)},1313778:l=>{r.Cd("Sinh",l,void 0)},1313830:l=>{r.Cd("Cosh",l,void 0)},1313882:l=>{r.Cd("Asinh",l,void 0)},1313935:l=>{r.Cd("Acosh",l,void 0)},1313988:l=>{r.Cd("Atanh",l,void 0)},1314041:l=>{r.Cd("Tanh",l,void 0)},1314093:l=>{r.Cd("Not",l,void 0)},1314144:(l,f,d)=>{r.Cd("ClipV10",l,{min:f,max:d})},1314216:l=>{r.Cd("Clip",l,void 0)},1314268:(l,f)=>{r.Cd("Elu",l,{alpha:f})},1314326:l=>{r.Cd("Relu",l,void 0)},1314378:(l,f)=>{r.Cd("LeakyRelu",l,{alpha:f})},1314442:(l,f)=>{r.Cd("ThresholdedRelu",l,{alpha:f})},1314512:(l,f)=>{r.Cd("Cast",l,{to:f})},1314570:l=>{r.Cd("Add",l,void 0)},1314621:l=>{r.Cd("Sub",l,void 0)},1314672:l=>{r.Cd("Mul",l,void 0)},1314723:l=>{r.Cd("Div",l,void 0)},1314774:l=>{r.Cd("Pow",l,void 0)},1314825:l=>{r.Cd("Equal",l,void 0)},1314878:l=>{r.Cd("Greater",l,void 0)},1314933:l=>{r.Cd("GreaterOrEqual",l,void 0)},1314995:l=>{r.Cd("Less",l,void 0)},1315047:l=>{r.Cd("LessOrEqual",l,void 0)},1315106:(l,f,d,p,h)=>{r.Cd("ReduceMean",l,{keepDims:!!f,noopWithEmptyAxes:!!d,axes:p?Array.from(q.subarray(h>>>0,h+p>>>0)):[]})},1315270:(l,f,d,p,h)=>{r.Cd("ReduceMax",l,{keepDims:!!f,noopWithEmptyAxes:!!d,axes:p?Array.from(q.subarray(h>>>0,h+p>>>0)):[]})},1315433:(l,f,d,p,h)=>{r.Cd("ReduceMin",l,{keepDims:!!f,noopWithEmptyAxes:!!d,axes:p?Array.from(q.subarray(h>>>0,h+p>>>0)):[]})},1315596:(l,f,d,p,h)=>{r.Cd("ReduceProd",l,{keepDims:!!f,noopWithEmptyAxes:!!d,axes:p?Array.from(q.subarray(h>>>0,h+p>>>0)):[]})},1315760:(l,f,d,p,h)=>{r.Cd("ReduceSum",l,{keepDims:!!f,noopWithEmptyAxes:!!d,axes:p?Array.from(q.subarray(h>>>0,h+p>>>0)):[]})},1315923:(l,f,d,p,h)=>{r.Cd("ReduceL1",l,{keepDims:!!f,noopWithEmptyAxes:!!d,axes:p?Array.from(q.subarray(h>>>0,h+p>>>0)):[]})},1316085:(l,f,d,p,h)=>{r.Cd("ReduceL2",l,{keepDims:!!f,noopWithEmptyAxes:!!d,axes:p?Array.from(q.subarray(h>>>0,h+p>>>0)):[]})},1316247:(l,f,d,p,h)=>{r.Cd("ReduceLogSum",l,{keepDims:!!f,noopWithEmptyAxes:!!d,axes:p?Array.from(q.subarray(h>>>0,h+p>>>0)):[]})},1316413:(l,f,d,p,h)=>{r.Cd("ReduceSumSquare",l,{keepDims:!!f,noopWithEmptyAxes:!!d,axes:p?Array.from(q.subarray(h>>>0,h+p>>>0)):[]})},1316582:(l,f,d,p,h)=>{r.Cd("ReduceLogSumExp",l,{keepDims:!!f,noopWithEmptyAxes:!!d,axes:p?Array.from(q.subarray(h>>>0,h+p>>>0)):[]})},1316751:l=>{r.Cd("Where",l,void 0)},1316804:(l,f,d)=>{r.Cd("Transpose",l,{perm:f?Array.from(q.subarray(d>>>0,d+f>>>0)):[]})},1316917:(l,f,d,p,h,y,b,w,x,$)=>{r.Cd("Conv",l,{format:x?"NHWC":"NCHW",auto_pad:f,dilations:[d],group:p,kernel_shape:[h],pads:[y,b],strides:[w],w_is_const:()=>!!le[$>>>0]})},1317145:(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z)=>{r.Cd("Conv",l,{format:A?"NHWC":"NCHW",auto_pad:f,dilations:[d,p],group:h,kernel_shape:[y,b],pads:[w,x,$,C],strides:[D,R],w_is_const:()=>!!le[z>>>0]})},1317404:(l,f,d,p,h,y,b,w,x,$)=>{r.Cd("Conv",l,{format:x?"NHWC":"NCHW",auto_pad:f,dilations:[d],group:p,kernel_shape:[h],pads:[y,b],strides:[w],w_is_const:()=>!!le[$>>>0]})},1317632:(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z)=>{r.Cd("Conv",l,{format:A?"NHWC":"NCHW",auto_pad:f,dilations:[d,p],group:h,kernel_shape:[y,b],pads:[w,x,$,C],strides:[D,R],w_is_const:()=>!!le[z>>>0]})},1317891:(l,f,d,p,h,y,b,w,x,$,C,D,R,A)=>{r.Cd("ConvTranspose",l,{format:x?"NHWC":"NCHW",autoPad:f,dilations:[d],group:p,kernel_shape:[h],pads:[y,b],strides:[w],wIsConst:()=>!!le[$>>>0],outputPadding:C?Array.from(q.subarray(D>>>0,D+C>>>0)):[],outputShape:R?Array.from(q.subarray(A>>>0,A+R>>>0)):[]})},1318271:(l,f,d,p,h,y,b,w,x,$,C,D,R)=>{r.Cd("ConvTranspose",l,{format:w?"NHWC":"NCHW",autoPad:f,dilations:Array.from(q.subarray(d>>>0,d+2>>>0)),group:p,kernelShape:Array.from(q.subarray(h>>>0,h+2>>>0)),pads:Array.from(q.subarray(y>>>0,y+4>>>0)),strides:Array.from(q.subarray(b>>>0,b+2>>>0)),wIsConst:()=>!!le[x>>>0],outputPadding:0<$?Array.from(q.subarray(C>>>0,C+$>>>0)):[],outputShape:0<D?Array.from(q.subarray(R>>>0,R+D>>>0)):[]})},1318794:(l,f,d,p,h,y,b,w,x,$,C,D,R,A)=>{r.Cd("ConvTranspose",l,{format:x?"NHWC":"NCHW",autoPad:f,dilations:[d],group:p,kernel_shape:[h],pads:[y,b],strides:[w],wIsConst:()=>!!le[$>>>0],outputPadding:C?Array.from(q.subarray(D>>>0,D+C>>>0)):[],outputShape:R?Array.from(q.subarray(A>>>0,A+R>>>0)):[]})},1319174:(l,f,d,p,h,y,b,w,x,$,C,D,R)=>{r.Cd("ConvTranspose",l,{format:w?"NHWC":"NCHW",autoPad:f,dilations:Array.from(q.subarray(d>>>0,d+2>>>0)),group:p,kernelShape:Array.from(q.subarray(h>>>0,h+2>>>0)),pads:Array.from(q.subarray(y>>>0,y+4>>>0)),strides:Array.from(q.subarray(b>>>0,b+2>>>0)),wIsConst:()=>!!le[x>>>0],outputPadding:0<$?Array.from(q.subarray(C>>>0,C+$>>>0)):[],outputShape:0<D?Array.from(q.subarray(R>>>0,R+D>>>0)):[]})},1319697:(l,f)=>{r.Cd("GlobalAveragePool",l,{format:f?"NHWC":"NCHW"})},1319788:(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H)=>{r.Cd("AveragePool",l,{format:H?"NHWC":"NCHW",auto_pad:f,ceil_mode:d,count_include_pad:p,storage_order:h,dilations:[y,b],kernel_shape:[w,x],pads:[$,C,D,R],strides:[A,z]})},1320072:(l,f)=>{r.Cd("GlobalAveragePool",l,{format:f?"NHWC":"NCHW"})},1320163:(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H)=>{r.Cd("AveragePool",l,{format:H?"NHWC":"NCHW",auto_pad:f,ceil_mode:d,count_include_pad:p,storage_order:h,dilations:[y,b],kernel_shape:[w,x],pads:[$,C,D,R],strides:[A,z]})},1320447:(l,f)=>{r.Cd("GlobalMaxPool",l,{format:f?"NHWC":"NCHW"})},1320534:(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H)=>{r.Cd("MaxPool",l,{format:H?"NHWC":"NCHW",auto_pad:f,ceil_mode:d,count_include_pad:p,storage_order:h,dilations:[y,b],kernel_shape:[w,x],pads:[$,C,D,R],strides:[A,z]})},1320814:(l,f)=>{r.Cd("GlobalMaxPool",l,{format:f?"NHWC":"NCHW"})},1320901:(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H)=>{r.Cd("MaxPool",l,{format:H?"NHWC":"NCHW",auto_pad:f,ceil_mode:d,count_include_pad:p,storage_order:h,dilations:[y,b],kernel_shape:[w,x],pads:[$,C,D,R],strides:[A,z]})},1321181:(l,f,d,p,h)=>{r.Cd("Gemm",l,{alpha:f,beta:d,transA:p,transB:h})},1321285:l=>{r.Cd("MatMul",l,void 0)},1321339:(l,f,d,p)=>{r.Cd("ArgMax",l,{keepDims:!!f,selectLastIndex:!!d,axis:p})},1321447:(l,f,d,p)=>{r.Cd("ArgMin",l,{keepDims:!!f,selectLastIndex:!!d,axis:p})},1321555:(l,f)=>{r.Cd("Softmax",l,{axis:f})},1321618:(l,f)=>{r.Cd("Concat",l,{axis:f})},1321678:(l,f,d,p,h)=>{r.Cd("Split",l,{axis:f,numOutputs:d,splitSizes:p?Array.from(q.subarray(h>>>0,h+p>>>0)):[]})},1321823:l=>{r.Cd("Expand",l,void 0)},1321877:(l,f)=>{r.Cd("Gather",l,{axis:Number(f)})},1321948:(l,f)=>{r.Cd("GatherElements",l,{axis:Number(f)})},1322027:(l,f,d,p,h,y,b,w,x,$,C)=>{r.Cd("Resize",l,{antialias:f,axes:d?Array.from(q.subarray(p>>>0,p+d>>>0)):[],coordinateTransformMode:or(h),cubicCoeffA:y,excludeOutside:b,extrapolationValue:w,keepAspectRatioPolicy:or(x),mode:or($),nearestMode:or(C)})},1322378:(l,f,d,p,h,y,b)=>{r.Cd("Slice",l,{starts:f?Array.from(q.subarray(d>>>0,d+f>>>0)):[],ends:p?Array.from(q.subarray(h>>>0,h+p>>>0)):[],axes:y?Array.from(q.subarray(b>>>0,b+y>>>0)):[]})},1322609:l=>{r.Cd("Tile",l,void 0)},1322661:(l,f,d)=>{r.Cd("LayerNormalization",l,{axis:Number(f),epsilon:Number(d)})},1322768:(l,f,d)=>{r.Cd("InstanceNormalization",l,{epsilon:f,format:d?"NHWC":"NCHW"})},1322882:(l,f,d)=>{r.Cd("InstanceNormalization",l,{epsilon:f,format:d?"NHWC":"NCHW"})},1322996:l=>{r.Cd("Range",l,void 0)},1323049:(l,f)=>{r.Cd("Einsum",l,{equation:or(f)})},1323130:(l,f,d,p,h)=>{r.Cd("Pad",l,{mode:f,value:d,pads:p?Array.from(q.subarray(h>>>0,h+p>>>0)):[]})},1323262:l=>{r.Cd("Gelu",l,void 0)},1323314:l=>{r.Cd("BiasAdd",l,void 0)},1323369:l=>{r.Cd("BiasSplitGelu",l,void 0)},1323430:(l,f)=>{r.Cd("SkipLayerNormalization",l,{epsilon:f})},1323511:l=>{r.sh(l)},1323545:(l,f)=>r.th(l,f,r.Xg.uh,r.Xg.errors),1323657:l=>r.ph(l),1323690:l=>r.rh(l),1323722:(l,f,d)=>{r.eh(l,f,d,!0)},1323761:(l,f,d)=>{r.eh(l,f,d)}};function br(l){this.name="ExitStatus",this.message=`Program terminated with exit(${l})`,this.status=l}var nr=l=>{for(;0<l.length;)l.shift()(r)},Kr=[],Xr=0,St=0;function Cn(l){this.Wg=l,this.Sg=l-24,this.mh=function(f){ge[this.Sg+4>>2>>>0]=f},this.bh=function(){return ge[this.Sg+4>>2>>>0]},this.lh=function(f){ge[this.Sg+8>>2>>>0]=f},this.fh=function(f){le[this.Sg+12>>0>>>0]=f?1:0},this.ih=function(){return le[this.Sg+12>>0>>>0]!=0},this.gh=function(f){le[this.Sg+13>>0>>>0]=f?1:0},this.oh=function(){return le[this.Sg+13>>0>>>0]!=0},this.kh=function(f,d){this.dh(0),this.mh(f),this.lh(d)},this.dh=function(f){ge[this.Sg+16>>2>>>0]=f},this.hh=function(){return ge[this.Sg+16>>2>>>0]},this.jh=function(){if(yi(this.bh()))return ge[this.Wg>>2>>>0];var f=this.hh();return f!==0?f:this.Wg}}var ir=l=>{var f=St;if(!f)return kr(0),0;var d=new Cn(f);d.dh(f);var p=d.bh();if(!p)return kr(0),f;for(var h in l){var y=l[h];if(y===0||y===p)break;if(gi(y,p,d.Sg+16))return kr(y),f}return kr(p),f},si=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,wo=(l,f,d)=>{f>>>=0;var p=f+d;for(d=f;l[d]&&!(d>=p);)++d;if(16<d-f&&l.buffer&&si)return si.decode(l.subarray(f,d));for(p="";f<d;){var h=l[f++];if(h&128){var y=l[f++]&63;if((h&224)==192)p+=String.fromCharCode((h&31)<<6|y);else{var b=l[f++]&63;h=(h&240)==224?(h&15)<<12|y<<6|b:(h&7)<<18|y<<12|b<<6|l[f++]&63,65536>h?p+=String.fromCharCode(h):(h-=65536,p+=String.fromCharCode(55296|h>>10,56320|h&1023))}}else p+=String.fromCharCode(h)}return p},or=(l,f)=>(l>>>=0)?wo(Ae,l,f):"",ui=l=>{for(var f=0,d=0;d<l.length;++d){var p=l.charCodeAt(d);127>=p?f++:2047>=p?f+=2:55296<=p&&57343>=p?(f+=4,++d):f+=3}return f},vr=(l,f,d,p)=>{if(d>>>=0,!(0<p))return 0;var h=d;p=d+p-1;for(var y=0;y<l.length;++y){var b=l.charCodeAt(y);if(55296<=b&&57343>=b){var w=l.charCodeAt(++y);b=65536+((b&1023)<<10)|w&1023}if(127>=b){if(d>=p)break;f[d++>>>0]=b}else{if(2047>=b){if(d+1>=p)break;f[d++>>>0]=192|b>>6}else{if(65535>=b){if(d+2>=p)break;f[d++>>>0]=224|b>>12}else{if(d+3>=p)break;f[d++>>>0]=240|b>>18,f[d++>>>0]=128|b>>12&63}f[d++>>>0]=128|b>>6&63}f[d++>>>0]=128|b&63}}return f[d>>>0]=0,d-h},wr=l=>l%4===0&&(l%100!==0||l%400===0),Yr=[0,31,60,91,121,152,182,213,244,274,305,335],An=[0,31,59,90,120,151,181,212,243,273,304,334],li=l=>{var f=ui(l)+1,d=Bn(f);return d&&vr(l,Ae,d,f),d},On=[],ci=(l,f)=>{On.length=0;var d;for(f>>=2;d=Ae[l++>>>0];)f+=d!=105&f,On.push(d==105?q[f>>>0]:it[f++>>>1]),++f;return On},En={},ar=()=>{if(!Pn){var l={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:s||"./this.program"},f;for(f in En)En[f]===void 0?delete l[f]:l[f]=En[f];var d=[];for(f in l)d.push(`${f}=${l[f]}`);Pn=d}return Pn},Pn,fi=[null,[],[]],Se=[31,29,31,30,31,30,31,31,30,31,30,31],Jr=[31,28,31,30,31,30,31,31,30,31,30,31];function xo(l){var f=Array(ui(l)+1);return vr(l,f,0,f.length),f}function To(l,f,d,p){function h(A,z,H){for(A=typeof A=="number"?A.toString():A||"";A.length<z;)A=H[0]+A;return A}function y(A,z){return h(A,z,"0")}function b(A,z){function H(ae){return 0>ae?-1:0<ae?1:0}var ee;return(ee=H(A.getFullYear()-z.getFullYear()))===0&&(ee=H(A.getMonth()-z.getMonth()))===0&&(ee=H(A.getDate()-z.getDate())),ee}function w(A){switch(A.getDay()){case 0:return new Date(A.getFullYear()-1,11,29);case 1:return A;case 2:return new Date(A.getFullYear(),0,3);case 3:return new Date(A.getFullYear(),0,2);case 4:return new Date(A.getFullYear(),0,1);case 5:return new Date(A.getFullYear()-1,11,31);case 6:return new Date(A.getFullYear()-1,11,30)}}function x(A){var z=A.Ug;for(A=new Date(new Date(A.Vg+1900,0,1).getTime());0<z;){var H=A.getMonth(),ee=(wr(A.getFullYear())?Se:Jr)[H];if(z>ee-A.getDate())z-=ee-A.getDate()+1,A.setDate(1),11>H?A.setMonth(H+1):(A.setMonth(0),A.setFullYear(A.getFullYear()+1));else{A.setDate(A.getDate()+z);break}}return H=new Date(A.getFullYear()+1,0,4),z=w(new Date(A.getFullYear(),0,4)),H=w(H),0>=b(z,A)?0>=b(H,A)?A.getFullYear()+1:A.getFullYear():A.getFullYear()-1}l>>>=0,f>>>=0,d>>>=0,p>>>=0;var $=q[p+40>>2>>>0];p={xh:q[p>>2>>>0],wh:q[p+4>>2>>>0],Yg:q[p+8>>2>>>0],ah:q[p+12>>2>>>0],Zg:q[p+16>>2>>>0],Vg:q[p+20>>2>>>0],Tg:q[p+24>>2>>>0],Ug:q[p+28>>2>>>0],Ah:q[p+32>>2>>>0],vh:q[p+36>>2>>>0],yh:$?or($):""},d=or(d),$={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var C in $)d=d.replace(new RegExp(C,"g"),$[C]);var D="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),R="January February March April May June July August September October November December".split(" ");$={"%a":A=>D[A.Tg].substring(0,3),"%A":A=>D[A.Tg],"%b":A=>R[A.Zg].substring(0,3),"%B":A=>R[A.Zg],"%C":A=>y((A.Vg+1900)/100|0,2),"%d":A=>y(A.ah,2),"%e":A=>h(A.ah,2," "),"%g":A=>x(A).toString().substring(2),"%G":A=>x(A),"%H":A=>y(A.Yg,2),"%I":A=>(A=A.Yg,A==0?A=12:12<A&&(A-=12),y(A,2)),"%j":A=>{for(var z=0,H=0;H<=A.Zg-1;z+=(wr(A.Vg+1900)?Se:Jr)[H++]);return y(A.ah+z,3)},"%m":A=>y(A.Zg+1,2),"%M":A=>y(A.wh,2),"%n":()=>`
`,"%p":A=>0<=A.Yg&&12>A.Yg?"AM":"PM","%S":A=>y(A.xh,2),"%t":()=>"	","%u":A=>A.Tg||7,"%U":A=>y(Math.floor((A.Ug+7-A.Tg)/7),2),"%V":A=>{var z=Math.floor((A.Ug+7-(A.Tg+6)%7)/7);if(2>=(A.Tg+371-A.Ug-2)%7&&z++,z)z==53&&(H=(A.Tg+371-A.Ug)%7,H==4||H==3&&wr(A.Vg)||(z=1));else{z=52;var H=(A.Tg+7-A.Ug-1)%7;(H==4||H==5&&wr(A.Vg%400-1))&&z++}return y(z,2)},"%w":A=>A.Tg,"%W":A=>y(Math.floor((A.Ug+7-(A.Tg+6)%7)/7),2),"%y":A=>(A.Vg+1900).toString().substring(2),"%Y":A=>A.Vg+1900,"%z":A=>{A=A.vh;var z=0<=A;return A=Math.abs(A)/60,(z?"+":"-")+("0000"+(A/60*100+A%60)).slice(-4)},"%Z":A=>A.yh,"%%":()=>"%"},d=d.replace(/%%/g,"\0\0");for(C in $)d.includes(C)&&(d=d.replace(new RegExp(C,"g"),$[C](p)));return d=d.replace(/\0\0/g,"%"),C=xo(d),C.length>f?0:(le.set(C,l>>>0),C.length-1)}function Zr(l){try{l()}catch(f){Et(f)}}function gs(l){var f={},d;for(d in l)(function(p){var h=l[p];f[p]=typeof h=="function"?function(){Qr.push(p);try{return h.apply(null,arguments)}finally{te||(Qr.pop()===p||Et(),Gt&&sr===1&&Qr.length===0&&(sr=0,Zr(qc),typeof Fibers<"u"&&Fibers.Bh()))}}:h})(d);return f}var sr=0,Gt=null,di=0,Qr=[],Dn={},pi={},_o=0,kn=null,$o=[];function So(){return new Promise((l,f)=>{kn={resolve:l,reject:f}})}function Io(){var l=Bn(65548),f=l+12;ge[l>>2>>>0]=f,ge[l+4>>2>>>0]=f+65536,f=Qr[0];var d=Dn[f];return d===void 0&&(d=_o++,Dn[f]=d,pi[d]=f),q[l+8>>2>>>0]=d,l}function Co(l){if(!te){if(sr===0){var f=!1,d=!1;l((p=0)=>{if(!te&&(di=p,f=!0,d)){sr=2,Zr(()=>Kc(Gt)),typeof Browser<"u"&&Browser.$g.nh&&Browser.$g.resume(),p=!1;try{var h=(0,P[pi[q[Gt+8>>2>>>0]]])()}catch(w){h=w,p=!0}var y=!1;if(!Gt){var b=kn;b&&(kn=null,(p?b.reject:b.resolve)(h),y=!0)}if(p&&!y)throw h}}),d=!0,f||(sr=1,Gt=Io(),typeof Browser<"u"&&Browser.$g.nh&&Browser.$g.pause(),Zr(()=>Hc(Gt)))}else sr===2?(sr=0,Zr(Xc),hi(Gt),Gt=null,$o.forEach(p=>{if(!te)try{if(p(),!Y)try{ue=ue=p=ue,Y||(r.onExit&&r.onExit(p),te=!0),a(p,new br(p))}catch(h){h instanceof br||h=="unwind"||a(1,h)}}catch(h){h instanceof br||h=="unwind"||a(1,h)}})):Et(`invalid state: ${sr}`);return di}}function Ao(l){return Co(f=>{l().then(f)})}var Oo={Ha:function(l,f,d){return Ao(async()=>{await r.qh(l,f,d)})},u:function(l){return l=new Cn(l>>>0),l.ih()||(l.fh(!0),Xr--),l.gh(!1),Kr.push(l),mi(l.Wg),l.jh()},B:function(){V(0,0);var l=Kr.pop();Br(l.Wg),St=0},a:function(){return ir([])},k:function(l){return ir([l>>>0])},w:function(l,f){return ir([l>>>0,f>>>0])},q:function(l,f,d){return ir([l>>>0,f>>>0,d>>>0])},pa:function(){var l=Kr.pop();l||Et("no exception to throw");var f=l.Wg;throw l.oh()||(Kr.push(l),l.gh(!0),l.fh(!1),Xr++),St=f,St},s:function(l,f,d){throw l>>>=0,new Cn(l).kh(f>>>0,d>>>0),St=l,Xr++,St},$:function(){return Xr},g:function(l){throw St||(St=l>>>0),St},qa:function(){return 0},oc:function(){},Pa:function(){},Ra:function(){},Ja:function(){return 0},Ub:function(){},Ta:function(){},Jb:function(){},Ca:function(){},Qa:function(){},Na:function(){},dc:function(){},Oa:function(){},Tc:()=>!0,Oc:function(l,f,d){l=f+2097152>>>0<4194305-!!l?(l>>>0)+4294967296*f:NaN,d>>>=0,l=new Date(1e3*l),q[d>>2>>>0]=l.getUTCSeconds(),q[d+4>>2>>>0]=l.getUTCMinutes(),q[d+8>>2>>>0]=l.getUTCHours(),q[d+12>>2>>>0]=l.getUTCDate(),q[d+16>>2>>>0]=l.getUTCMonth(),q[d+20>>2>>>0]=l.getUTCFullYear()-1900,q[d+24>>2>>>0]=l.getUTCDay(),q[d+28>>2>>>0]=(l.getTime()-Date.UTC(l.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Pc:function(l,f,d){l=f+2097152>>>0<4194305-!!l?(l>>>0)+4294967296*f:NaN,d>>>=0,l=new Date(1e3*l),q[d>>2>>>0]=l.getSeconds(),q[d+4>>2>>>0]=l.getMinutes(),q[d+8>>2>>>0]=l.getHours(),q[d+12>>2>>>0]=l.getDate(),q[d+16>>2>>>0]=l.getMonth(),q[d+20>>2>>>0]=l.getFullYear()-1900,q[d+24>>2>>>0]=l.getDay(),q[d+28>>2>>>0]=(wr(l.getFullYear())?Yr:An)[l.getMonth()]+l.getDate()-1|0,q[d+36>>2>>>0]=-(60*l.getTimezoneOffset()),f=new Date(l.getFullYear(),6,1).getTimezoneOffset();var p=new Date(l.getFullYear(),0,1).getTimezoneOffset();q[d+32>>2>>>0]=(f!=p&&l.getTimezoneOffset()==Math.min(p,f))|0},Qc:function(l){l>>>=0;var f=new Date(q[l+20>>2>>>0]+1900,q[l+16>>2>>>0],q[l+12>>2>>>0],q[l+8>>2>>>0],q[l+4>>2>>>0],q[l>>2>>>0],0),d=q[l+32>>2>>>0],p=f.getTimezoneOffset(),h=new Date(f.getFullYear(),6,1).getTimezoneOffset(),y=new Date(f.getFullYear(),0,1).getTimezoneOffset(),b=Math.min(y,h);return 0>d?q[l+32>>2>>>0]=+(h!=y&&b==p):0<d!=(b==p)&&(h=Math.max(y,h),f.setTime(f.getTime()+6e4*((0<d?b:h)-p))),q[l+24>>2>>>0]=f.getDay(),q[l+28>>2>>>0]=(wr(f.getFullYear())?Yr:An)[f.getMonth()]+f.getDate()-1|0,q[l>>2>>>0]=f.getSeconds(),q[l+4>>2>>>0]=f.getMinutes(),q[l+8>>2>>>0]=f.getHours(),q[l+12>>2>>>0]=f.getDate(),q[l+16>>2>>>0]=f.getMonth(),q[l+20>>2>>>0]=f.getYear(),l=f.getTime()/1e3,kr((ot=l,1<=+Math.abs(ot)?0<ot?+Math.floor(ot/4294967296)>>>0:~~+Math.ceil((ot-+(~~ot>>>0))/4294967296)>>>0:0)),l>>>0},Mc:function(){return-52},Nc:function(){},La:function(l,f,d){function p(x){return(x=x.toTimeString().match(/\(([A-Za-z ]+)\)$/))?x[1]:"GMT"}d>>>=0;var h=new Date().getFullYear(),y=new Date(h,0,1),b=new Date(h,6,1);h=y.getTimezoneOffset();var w=b.getTimezoneOffset();ge[l>>>0>>2>>>0]=60*Math.max(h,w),q[f>>>0>>2>>>0]=+(h!=w),l=p(y),f=p(b),l=li(l),f=li(f),w<h?(ge[d>>2>>>0]=l,ge[d+4>>2>>>0]=f):(ge[d>>2>>>0]=f,ge[d+4>>2>>>0]=l)},ja:()=>{Et("")},x:function(l,f,d){return l>>>=0,f=ci(f>>>0,d>>>0),Nt[l].apply(null,f)},wa:function(l,f,d){return l>>>=0,f=ci(f>>>0,d>>>0),Nt[l].apply(null,f)},Ea:function(){return Date.now()},Ma:function(){return 4294901760},I:()=>performance.now(),yb:function(l,f,d){return f>>>=0,Ae.copyWithin(l>>>0>>>0,f>>>0,f+(d>>>0)>>>0)},Ka:function(l){l>>>=0;var f=Ae.length;if(4294901760<l)return!1;for(var d=1;4>=d;d*=2){var p=f*(1+.2/d);p=Math.min(p,l+100663296);var h=Math;p=Math.max(l,p);e:{h=h.min.call(h,4294901760,p+(65536-p%65536)%65536)-Z.buffer.byteLength+65535>>>16;try{Z.grow(h),me();var y=1;break e}catch{}y=void 0}if(y)return!0}return!1},cb:function(l,f){l>>>=0,f>>>=0;var d=0;return ar().forEach(function(p,h){var y=f+d;for(h=ge[l+4*h>>2>>>0]=y,y=0;y<p.length;++y)le[h++>>0>>>0]=p.charCodeAt(y);le[h>>0>>>0]=0,d+=p.length+1}),0},nb:function(l,f){l>>>=0,f>>>=0;var d=ar();ge[l>>2>>>0]=d.length;var p=0;return d.forEach(function(h){p+=h.length+1}),ge[f>>2>>>0]=p,0},ma:()=>52,Ba:function(){return 52},Rc:function(){return 70},Aa:function(l,f,d,p){f>>>=0,d>>>=0,p>>>=0;for(var h=0,y=0;y<d;y++){var b=ge[f>>2>>>0],w=ge[f+4>>2>>>0];f+=8;for(var x=0;x<w;x++){var $=Ae[b+x>>>0],C=fi[l];$===0||$===10?((l===1?M:F)(wo(C,0)),C.length=0):C.push($)}h+=w}return ge[p>>2>>>0]=h,0},ia:Bv,Sc:kw,M:sw,K:kv,Uc:Dw,Wc:Ow,C:Kv,z:Ev,b:Tv,Da:Iw,ca:mw,f:wv,ra:Cw,h:vv,F:Sw,i:Cv,Vc:Ew,j:Iv,t:Sv,r:Dv,n:Rv,W:Nv,Y:ww,J:Gv,oa:ew,aa:rw,la:xw,vb:Ux,gb:o1,zc:Hw,bb:l1,eb:s1,Sa:v1,Sb:$x,Dc:Gw,jb:r1,Va:y1,Ob:Ax,fb:a1,gc:cx,Lc:Bw,pc:rx,hb:i1,db:u1,Bb:Fx,kc:ax,nc:nx,fc:fx,Kc:Rw,_a:d1,ab:c1,qb:Yx,mb:Qx,$a:f1,ic:ux,Kb:Dx,lb:e1,Ua:b1,Tb:_x,Ic:Lw,Ac:Uw,tc:Zw,pb:Jx,lc:ox,Ib:kx,Hb:Bx,c:$v,_:Yv,p:_v,P:Aw,Z:fw,ha:Vv,e:xv,za:jv,G:$w,da:Zv,O:uw,ub:Hx,fa:Uv,d:Av,xa:qv,Fa:Tw,l:Ov,va:Jv,m:Pv,ya:Hv,ua:Qv,Ga:gw,o:Mv,V:ow,ga:iw,U:aw,na:dw,y:Lv,A:zv,E:Fv,X:_w,ta:lw,ea:Xv,N:nw,L:pw,D:tw,ba:Wv,T:cw,ka:Pw,R:yw,sa:vw,Q:bw,S:hw,jc:sx,zb:Gx,rb:Xx,Eb:Lx,Ab:jx,Bc:Vw,Nb:Ox,xb:Wx,Fb:Mx,Pb:Cx,ec:dx,ob:Zx,Mb:Ex,sb:Kx,Ya:h1,rc:ex,Fc:Fw,Za:p1,Qb:Ix,xc:Kw,Cb:zx,kb:t1,vc:Yw,Hc:Nw,wc:Xw,Cc:Ww,Xa:m1,Ec:jw,wb:Vx,Lb:Px,yc:qw,Jc:Mw,ib:n1,Db:Nx,Yb:vx,tb:qx,Gc:zw,Zb:bx,Rb:Sx,hc:lx,qc:tx,Gb:Rx,Xb:wx,sc:Qw,mc:ix,Wa:g1,uc:Jw,Vb:Tx,Wb:xx,$b:gx,ac:mx,cc:px,_b:yx,bc:hx,v:function(l){return l>>>0},Ia:To,H:function(l,f,d,p){return To(l>>>0,f>>>0,d>>>0,p>>>0)}};(function(){function l(d){if(d=d.exports,d=gs(d),P=d=w1(d),Z=P.Xc,me(),Dt.unshift(P.Yc),Ye--,r.monitorRunDependencies&&r.monitorRunDependencies(Ye),Ye==0&&($t!==null&&(clearInterval($t),$t=null),yr)){var p=yr;yr=null,p()}return d}var f={a:Oo};if(Ye++,r.monitorRunDependencies&&r.monitorRunDependencies(Ye),r.instantiateWasm)try{return r.instantiateWasm(f,l)}catch(d){F("Module.instantiateWasm callback failed with error: "+d),i(d)}return ft(f,function(d){l(d.instance)}).catch(i),{}})(),r._OrtInit=(l,f)=>(r._OrtInit=P.Zc)(l,f),r._OrtGetLastError=(l,f)=>(r._OrtGetLastError=P._c)(l,f),r._OrtCreateSessionOptions=(l,f,d,p,h,y,b,w,x,$)=>(r._OrtCreateSessionOptions=P.$c)(l,f,d,p,h,y,b,w,x,$),r._OrtAppendExecutionProvider=(l,f)=>(r._OrtAppendExecutionProvider=P.ad)(l,f),r._OrtAddFreeDimensionOverride=(l,f,d)=>(r._OrtAddFreeDimensionOverride=P.bd)(l,f,d),r._OrtAddSessionConfigEntry=(l,f,d)=>(r._OrtAddSessionConfigEntry=P.cd)(l,f,d),r._OrtReleaseSessionOptions=l=>(r._OrtReleaseSessionOptions=P.dd)(l),r._OrtCreateSession=(l,f,d)=>(r._OrtCreateSession=P.ed)(l,f,d),r._OrtReleaseSession=l=>(r._OrtReleaseSession=P.fd)(l),r._OrtGetInputOutputCount=(l,f,d)=>(r._OrtGetInputOutputCount=P.gd)(l,f,d),r._OrtGetInputName=(l,f)=>(r._OrtGetInputName=P.hd)(l,f),r._OrtGetOutputName=(l,f)=>(r._OrtGetOutputName=P.id)(l,f),r._OrtFree=l=>(r._OrtFree=P.jd)(l),r._OrtCreateTensor=(l,f,d,p,h,y)=>(r._OrtCreateTensor=P.kd)(l,f,d,p,h,y),r._OrtGetTensorData=(l,f,d,p,h)=>(r._OrtGetTensorData=P.ld)(l,f,d,p,h),r._OrtReleaseTensor=l=>(r._OrtReleaseTensor=P.md)(l),r._OrtCreateRunOptions=(l,f,d,p)=>(r._OrtCreateRunOptions=P.nd)(l,f,d,p),r._OrtAddRunConfigEntry=(l,f,d)=>(r._OrtAddRunConfigEntry=P.od)(l,f,d),r._OrtReleaseRunOptions=l=>(r._OrtReleaseRunOptions=P.pd)(l),r._OrtCreateBinding=l=>(r._OrtCreateBinding=P.qd)(l),r._OrtBindInput=(l,f,d)=>(r._OrtBindInput=P.rd)(l,f,d),r._OrtBindOutput=(l,f,d,p)=>(r._OrtBindOutput=P.sd)(l,f,d,p),r._OrtClearBoundOutputs=l=>(r._OrtClearBoundOutputs=P.td)(l),r._OrtReleaseBinding=l=>(r._OrtReleaseBinding=P.ud)(l),r._OrtRunWithBinding=(l,f,d,p,h)=>(r._OrtRunWithBinding=P.vd)(l,f,d,p,h),r._OrtRun=(l,f,d,p,h,y,b,w)=>(r._OrtRun=P.wd)(l,f,d,p,h,y,b,w),r._OrtEndProfiling=l=>(r._OrtEndProfiling=P.xd)(l),r._JsepOutput=(l,f,d)=>(r._JsepOutput=P.yd)(l,f,d),r._JsepGetNodeName=l=>(r._JsepGetNodeName=P.zd)(l);var Bn=r._malloc=l=>(Bn=r._malloc=P.Ad)(l),hi=r._free=l=>(hi=r._free=P.Bd)(l),V=(l,f)=>(V=P.Dd)(l,f),kr=l=>(kr=P.Ed)(l),U=()=>(U=P.Fd)(),W=l=>(W=P.Gd)(l),en=l=>(en=P.Hd)(l),Br=l=>(Br=P.Id)(l),mi=l=>(mi=P.Jd)(l),gi=(l,f,d)=>(gi=P.Kd)(l,f,d),yi=l=>(yi=P.Ld)(l),bi=r.dynCall_vi=(l,f)=>(bi=r.dynCall_vi=P.Md)(l,f),vi=r.dynCall_vii=(l,f,d)=>(vi=r.dynCall_vii=P.Nd)(l,f,d),Rn=r.dynCall_iiii=(l,f,d,p)=>(Rn=r.dynCall_iiii=P.Od)(l,f,d,p),wi=r.dynCall_iii=(l,f,d)=>(wi=r.dynCall_iii=P.Pd)(l,f,d),Eo=r.dynCall_ii=(l,f)=>(Eo=r.dynCall_ii=P.Qd)(l,f),Qe=r.dynCall_iiiiiii=(l,f,d,p,h,y,b)=>(Qe=r.dynCall_iiiiiii=P.Rd)(l,f,d,p,h,y,b),Mn=r.dynCall_v=l=>(Mn=r.dynCall_v=P.Sd)(l),Ln=r.dynCall_iiiiii=(l,f,d,p,h,y)=>(Ln=r.dynCall_iiiiii=P.Td)(l,f,d,p,h,y),xi=r.dynCall_iiij=(l,f,d,p,h)=>(xi=r.dynCall_iiij=P.Ud)(l,f,d,p,h),Nn=r.dynCall_iiiii=(l,f,d,p,h)=>(Nn=r.dynCall_iiiii=P.Vd)(l,f,d,p,h),Ti=r.dynCall_viii=(l,f,d,p)=>(Ti=r.dynCall_viii=P.Wd)(l,f,d,p),_i=r.dynCall_j=l=>(_i=r.dynCall_j=P.Xd)(l),$i=r.dynCall_i=l=>($i=r.dynCall_i=P.Yd)(l),Si=r.dynCall_iij=(l,f,d,p)=>(Si=r.dynCall_iij=P.Zd)(l,f,d,p),Ii=r.dynCall_iiiiij=(l,f,d,p,h,y,b)=>(Ii=r.dynCall_iiiiij=P._d)(l,f,d,p,h,y,b),Po=r.dynCall_vij=(l,f,d,p)=>(Po=r.dynCall_vij=P.$d)(l,f,d,p),Ci=r.dynCall_viiiii=(l,f,d,p,h,y)=>(Ci=r.dynCall_viiiii=P.ae)(l,f,d,p,h,y),Ai=r.dynCall_viiii=(l,f,d,p,h)=>(Ai=r.dynCall_viiii=P.be)(l,f,d,p,h),Oi=r.dynCall_iiiiiiii=(l,f,d,p,h,y,b,w)=>(Oi=r.dynCall_iiiiiiii=P.ce)(l,f,d,p,h,y,b,w),Do=r.dynCall_fi=(l,f)=>(Do=r.dynCall_fi=P.de)(l,f),ko=r.dynCall_fii=(l,f,d)=>(ko=r.dynCall_fii=P.ee)(l,f,d),Ei=r.dynCall_ji=(l,f)=>(Ei=r.dynCall_ji=P.fe)(l,f),tn=r.dynCall_di=(l,f)=>(tn=r.dynCall_di=P.ge)(l,f),Bo=r.dynCall_jii=(l,f,d)=>(Bo=r.dynCall_jii=P.he)(l,f,d),ur=r.dynCall_dii=(l,f,d)=>(ur=r.dynCall_dii=P.ie)(l,f,d),Wt=r.dynCall_iiiiiiiii=(l,f,d,p,h,y,b,w,x)=>(Wt=r.dynCall_iiiiiiiii=P.je)(l,f,d,p,h,y,b,w,x),Pi=r.dynCall_viij=(l,f,d,p,h)=>(Pi=r.dynCall_viij=P.ke)(l,f,d,p,h),rn=r.dynCall_viiiiii=(l,f,d,p,h,y,b)=>(rn=r.dynCall_viiiiii=P.le)(l,f,d,p,h,y,b),Di=r.dynCall_vijj=(l,f,d,p,h,y)=>(Di=r.dynCall_vijj=P.me)(l,f,d,p,h,y),ki=r.dynCall_viiiiiii=(l,f,d,p,h,y,b,w)=>(ki=r.dynCall_viiiiiii=P.ne)(l,f,d,p,h,y,b,w),Ro=r.dynCall_iiiiiiiiii=(l,f,d,p,h,y,b,w,x,$)=>(Ro=r.dynCall_iiiiiiiiii=P.oe)(l,f,d,p,h,y,b,w,x,$),zn=r.dynCall_viiiiiiii=(l,f,d,p,h,y,b,w,x)=>(zn=r.dynCall_viiiiiiii=P.pe)(l,f,d,p,h,y,b,w,x),Mo=r.dynCall_iiiiijiiiii=(l,f,d,p,h,y,b,w,x,$,C,D)=>(Mo=r.dynCall_iiiiijiiiii=P.qe)(l,f,d,p,h,y,b,w,x,$,C,D),Lo=r.dynCall_viiji=(l,f,d,p,h,y)=>(Lo=r.dynCall_viiji=P.re)(l,f,d,p,h,y),No=r.dynCall_viijiii=(l,f,d,p,h,y,b,w)=>(No=r.dynCall_viijiii=P.se)(l,f,d,p,h,y,b,w),zo=r.dynCall_viiiiij=(l,f,d,p,h,y,b,w)=>(zo=r.dynCall_viiiiij=P.te)(l,f,d,p,h,y,b,w),Fo=r.dynCall_viiiiiiiii=(l,f,d,p,h,y,b,w,x,$)=>(Fo=r.dynCall_viiiiiiiii=P.ue)(l,f,d,p,h,y,b,w,x,$),jo=r.dynCall_viid=(l,f,d,p)=>(jo=r.dynCall_viid=P.ve)(l,f,d,p),Go=r.dynCall_iiiiiiiij=(l,f,d,p,h,y,b,w,x,$)=>(Go=r.dynCall_iiiiiiiij=P.we)(l,f,d,p,h,y,b,w,x,$),Wo=r.dynCall_iiiiiiiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D)=>(Wo=r.dynCall_iiiiiiiiiiii=P.xe)(l,f,d,p,h,y,b,w,x,$,C,D),nn=r.dynCall_viiiiiiiiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A)=>(nn=r.dynCall_viiiiiiiiiiiii=P.ye)(l,f,d,p,h,y,b,w,x,$,C,D,R,A),Fn=r.dynCall_viijjjiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z)=>(Fn=r.dynCall_viijjjiiiiii=P.ze)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z),Bi=r.dynCall_viiijiiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R)=>(Bi=r.dynCall_viiijiiiiiii=P.Ae)(l,f,d,p,h,y,b,w,x,$,C,D,R),Ri=r.dynCall_viffiii=(l,f,d,p,h,y,b)=>(Ri=r.dynCall_viffiii=P.Be)(l,f,d,p,h,y,b),Mi=r.dynCall_viiijjjii=(l,f,d,p,h,y,b,w,x,$,C,D)=>(Mi=r.dynCall_viiijjjii=P.Ce)(l,f,d,p,h,y,b,w,x,$,C,D),jn=r.dynCall_viifiii=(l,f,d,p,h,y,b)=>(jn=r.dynCall_viifiii=P.De)(l,f,d,p,h,y,b),Gn=r.dynCall_viiiiidiidi=(l,f,d,p,h,y,b,w,x,$,C)=>(Gn=r.dynCall_viiiiidiidi=P.Ee)(l,f,d,p,h,y,b,w,x,$,C),Li=r.dynCall_viiiiiiiiidi=(l,f,d,p,h,y,b,w,x,$,C,D)=>(Li=r.dynCall_viiiiiiiiidi=P.Fe)(l,f,d,p,h,y,b,w,x,$,C,D),Ni=r.dynCall_vjiiiiii=(l,f,d,p,h,y,b,w,x)=>(Ni=r.dynCall_vjiiiiii=P.Ge)(l,f,d,p,h,y,b,w,x),zi=r.dynCall_jiii=(l,f,d,p)=>(zi=r.dynCall_jiii=P.He)(l,f,d,p),Wn=r.dynCall_viiid=(l,f,d,p,h)=>(Wn=r.dynCall_viiid=P.Ie)(l,f,d,p,h),on=r.dynCall_viiiiiiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D)=>(on=r.dynCall_viiiiiiiiiii=P.Je)(l,f,d,p,h,y,b,w,x,$,C,D),Vn=r.dynCall_vijjjjjjjjjjjjji=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne,at,st,dt,xt,Vt,Ut)=>(Vn=r.dynCall_vijjjjjjjjjjjjji=P.Ke)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne,at,st,dt,xt,Vt,Ut),Fi=r.dynCall_viiiji=(l,f,d,p,h,y,b)=>(Fi=r.dynCall_viiiji=P.Le)(l,f,d,p,h,y,b),ji=r.dynCall_vijjjiiji=(l,f,d,p,h,y,b,w,x,$,C,D,R)=>(ji=r.dynCall_vijjjiiji=P.Me)(l,f,d,p,h,y,b,w,x,$,C,D,R),Gi=r.dynCall_iiiji=(l,f,d,p,h,y)=>(Gi=r.dynCall_iiiji=P.Ne)(l,f,d,p,h,y),Wi=r.dynCall_iiijiiiiiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z)=>(Wi=r.dynCall_iiijiiiiiiiiii=P.Oe)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z),Vi=r.dynCall_vj=(l,f,d)=>(Vi=r.dynCall_vj=P.Pe)(l,f,d),Vo=r.dynCall_jjj=(l,f,d,p,h)=>(Vo=r.dynCall_jjj=P.Qe)(l,f,d,p,h),an=r.dynCall_iiijiiiiii=(l,f,d,p,h,y,b,w,x,$,C)=>(an=r.dynCall_iiijiiiiii=P.Re)(l,f,d,p,h,y,b,w,x,$,C),Ui=r.dynCall_viiff=(l,f,d,p,h)=>(Ui=r.dynCall_viiff=P.Se)(l,f,d,p,h),m=r.dynCall_viiiiiff=(l,f,d,p,h,y,b,w)=>(m=r.dynCall_viiiiiff=P.Te)(l,f,d,p,h,y,b,w),_=r.dynCall_vfiii=(l,f,d,p,h)=>(_=r.dynCall_vfiii=P.Ue)(l,f,d,p,h),E=r.dynCall_viiiiff=(l,f,d,p,h,y,b)=>(E=r.dynCall_viiiiff=P.Ve)(l,f,d,p,h,y,b),L=r.dynCall_viiiiiiiiifiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A)=>(L=r.dynCall_viiiiiiiiifiii=P.We)(l,f,d,p,h,y,b,w,x,$,C,D,R,A),K=r.dynCall_viiiiiiiijj=(l,f,d,p,h,y,b,w,x,$,C,D,R)=>(K=r.dynCall_viiiiiiiijj=P.Xe)(l,f,d,p,h,y,b,w,x,$,C,D,R),Q=r.dynCall_iiiiiiiiiiiiiifii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee)=>(Q=r.dynCall_iiiiiiiiiiiiiifii=P.Ye)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee),ne=r.dynCall_viiiiiiiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R)=>(ne=r.dynCall_viiiiiiiiiiii=P.Ze)(l,f,d,p,h,y,b,w,x,$,C,D,R),_e=r.dynCall_ij=(l,f,d)=>(_e=r.dynCall_ij=P._e)(l,f,d),ve=r.dynCall_iiiiiiiiiiiiiiiiifii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie)=>(ve=r.dynCall_iiiiiiiiiiiiiiiiifii=P.$e)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie),ye=r.dynCall_vijjiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D)=>(ye=r.dynCall_vijjiiiiii=P.af)(l,f,d,p,h,y,b,w,x,$,C,D),$e=r.dynCall_iiiijjj=(l,f,d,p,h,y,b,w,x,$)=>($e=r.dynCall_iiiijjj=P.bf)(l,f,d,p,h,y,b,w,x,$),Me=r.dynCall_viiiiiiiiii=(l,f,d,p,h,y,b,w,x,$,C)=>(Me=r.dynCall_viiiiiiiiii=P.cf)(l,f,d,p,h,y,b,w,x,$,C),Fe=r.dynCall_iiijjj=(l,f,d,p,h,y,b,w,x)=>(Fe=r.dynCall_iiijjj=P.df)(l,f,d,p,h,y,b,w,x),J=r.dynCall_fffffff=(l,f,d,p,h,y,b)=>(J=r.dynCall_fffffff=P.ef)(l,f,d,p,h,y,b),Oe=r.dynCall_viiiij=(l,f,d,p,h,y,b)=>(Oe=r.dynCall_viiiij=P.ff)(l,f,d,p,h,y,b),We=r.dynCall_viijj=(l,f,d,p,h,y,b)=>(We=r.dynCall_viijj=P.gf)(l,f,d,p,h,y,b),xr=r.dynCall_vjjjjjjffiifiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne,at)=>(xr=r.dynCall_vjjjjjjffiifiiiiii=P.hf)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne,at),Hi=r.dynCall_viiiiiiffiifiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee)=>(Hi=r.dynCall_viiiiiiffiifiiiii=P.jf)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee),gl=r.dynCall_viiiiiiffifiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H)=>(gl=r.dynCall_viiiiiiffifiiiii=P.kf)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H),yl=r.dynCall_viiiiiiffiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z)=>(yl=r.dynCall_viiiiiiffiiiiii=P.lf)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z),bl=r.dynCall_vjjjjjjjjfffiifiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne,at,st,dt,xt,Vt,Ut)=>(bl=r.dynCall_vjjjjjjjjfffiifiiiiii=P.mf)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne,at,st,dt,xt,Vt,Ut),vl=r.dynCall_vjjjjjjfffifiiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne,at,st)=>(vl=r.dynCall_vjjjjjjfffifiiiiiii=P.nf)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne,at,st),wl=r.dynCall_vjjjjjjfffifiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne)=>(wl=r.dynCall_vjjjjjjfffifiiiii=P.of)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne),xl=r.dynCall_vjjjjjjjjfffiifiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne,at,st,dt,xt,Vt)=>(xl=r.dynCall_vjjjjjjjjfffiifiiiii=P.pf)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne,at,st,dt,xt,Vt),Tl=r.dynCall_vijjfffiii=(l,f,d,p,h,y,b,w,x,$,C,D)=>(Tl=r.dynCall_vijjfffiii=P.qf)(l,f,d,p,h,y,b,w,x,$,C,D),_l=r.dynCall_vijiiiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D)=>(_l=r.dynCall_vijiiiiiiii=P.rf)(l,f,d,p,h,y,b,w,x,$,C,D),$l=r.dynCall_vijjjjjjifiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee)=>($l=r.dynCall_vijjjjjjifiiiii=P.sf)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee),Sl=r.dynCall_vjjjjjiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z)=>(Sl=r.dynCall_vjjjjjiiii=P.tf)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z),Il=r.dynCall_vjjjjfiii=(l,f,d,p,h,y,b,w,x,$,C,D,R)=>(Il=r.dynCall_vjjjjfiii=P.uf)(l,f,d,p,h,y,b,w,x,$,C,D,R),Cl=r.dynCall_viifi=(l,f,d,p,h)=>(Cl=r.dynCall_viifi=P.vf)(l,f,d,p,h),Al=r.dynCall_iiiiiji=(l,f,d,p,h,y,b,w)=>(Al=r.dynCall_iiiiiji=P.wf)(l,f,d,p,h,y,b,w),Ol=r.dynCall_vijjii=(l,f,d,p,h,y,b,w)=>(Ol=r.dynCall_vijjii=P.xf)(l,f,d,p,h,y,b,w),El=r.dynCall_viiijiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D)=>(El=r.dynCall_viiijiiiiii=P.yf)(l,f,d,p,h,y,b,w,x,$,C,D),Pl=r.dynCall_viiiiijjiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z)=>(Pl=r.dynCall_viiiiijjiiiii=P.zf)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z),Dl=r.dynCall_iiiiji=(l,f,d,p,h,y,b)=>(Dl=r.dynCall_iiiiji=P.Af)(l,f,d,p,h,y,b),kl=r.dynCall_viiiiijiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A)=>(kl=r.dynCall_viiiiijiiiiii=P.Bf)(l,f,d,p,h,y,b,w,x,$,C,D,R,A),Bl=r.dynCall_viiiijii=(l,f,d,p,h,y,b,w,x)=>(Bl=r.dynCall_viiiijii=P.Cf)(l,f,d,p,h,y,b,w,x),Rl=r.dynCall_viijjiii=(l,f,d,p,h,y,b,w,x,$)=>(Rl=r.dynCall_viijjiii=P.Df)(l,f,d,p,h,y,b,w,x,$),Ml=r.dynCall_ijii=(l,f,d,p,h)=>(Ml=r.dynCall_ijii=P.Ef)(l,f,d,p,h),Ll=r.dynCall_jjjjjjj=(l,f,d,p,h,y,b,w,x,$,C,D,R)=>(Ll=r.dynCall_jjjjjjj=P.Ff)(l,f,d,p,h,y,b,w,x,$,C,D,R),Nl=r.dynCall_jjjjjj=(l,f,d,p,h,y,b,w,x,$,C)=>(Nl=r.dynCall_jjjjjj=P.Gf)(l,f,d,p,h,y,b,w,x,$,C),zl=r.dynCall_vijjjjiij=(l,f,d,p,h,y,b,w,x,$,C,D,R,A)=>(zl=r.dynCall_vijjjjiij=P.Hf)(l,f,d,p,h,y,b,w,x,$,C,D,R,A),Fl=r.dynCall_viiiiijij=(l,f,d,p,h,y,b,w,x,$,C)=>(Fl=r.dynCall_viiiiijij=P.If)(l,f,d,p,h,y,b,w,x,$,C),jl=r.dynCall_viiiiiijij=(l,f,d,p,h,y,b,w,x,$,C,D)=>(jl=r.dynCall_viiiiiijij=P.Jf)(l,f,d,p,h,y,b,w,x,$,C,D),Gl=r.dynCall_vijiii=(l,f,d,p,h,y,b)=>(Gl=r.dynCall_vijiii=P.Kf)(l,f,d,p,h,y,b),Wl=r.dynCall_viiiiiiiiifi=(l,f,d,p,h,y,b,w,x,$,C,D)=>(Wl=r.dynCall_viiiiiiiiifi=P.Lf)(l,f,d,p,h,y,b,w,x,$,C,D),Vl=r.dynCall_viiijiiiiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z)=>(Vl=r.dynCall_viiijiiiiiiiii=P.Mf)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z),Ul=r.dynCall_iiijiiii=(l,f,d,p,h,y,b,w,x)=>(Ul=r.dynCall_iiijiiii=P.Nf)(l,f,d,p,h,y,b,w,x),Hl=r.dynCall_viiiiiijjiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H)=>(Hl=r.dynCall_viiiiiijjiiiii=P.Of)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H),ql=r.dynCall_viiiiiiijiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H)=>(ql=r.dynCall_viiiiiiijiiiiii=P.Pf)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H),Kl=r.dynCall_vif=(l,f,d)=>(Kl=r.dynCall_vif=P.Qf)(l,f,d),Xl=r.dynCall_viif=(l,f,d,p)=>(Xl=r.dynCall_viif=P.Rf)(l,f,d,p),Yl=r.dynCall_viiiiiifii=(l,f,d,p,h,y,b,w,x,$)=>(Yl=r.dynCall_viiiiiifii=P.Sf)(l,f,d,p,h,y,b,w,x,$),Jl=r.dynCall_viiiiijiiiiiiiiiiiiiiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne,at,st,dt,xt)=>(Jl=r.dynCall_viiiiijiiiiiiiiiiiiiiiiiii=P.Tf)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne,at,st,dt,xt),Zl=r.dynCall_viijji=(l,f,d,p,h,y,b,w)=>(Zl=r.dynCall_viijji=P.Uf)(l,f,d,p,h,y,b,w),Ql=r.dynCall_iiiiiiiiiiiji=(l,f,d,p,h,y,b,w,x,$,C,D,R,A)=>(Ql=r.dynCall_iiiiiiiiiiiji=P.Vf)(l,f,d,p,h,y,b,w,x,$,C,D,R,A),ec=r.dynCall_viifiifijjjii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H)=>(ec=r.dynCall_viifiifijjjii=P.Wf)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H),tc=r.dynCall_viiiiiiiiiiiiiiiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee)=>(tc=r.dynCall_viiiiiiiiiiiiiiiiiiii=P.Xf)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee),rc=r.dynCall_iif=(l,f,d)=>(rc=r.dynCall_iif=P.Yf)(l,f,d),nc=r.dynCall_viiiiifiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R)=>(nc=r.dynCall_viiiiifiiiiii=P.Zf)(l,f,d,p,h,y,b,w,x,$,C,D,R),ic=r.dynCall_vijiiiiiiijjii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee)=>(ic=r.dynCall_vijiiiiiiijjii=P._f)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee),oc=r.dynCall_iiiiid=(l,f,d,p,h,y)=>(oc=r.dynCall_iiiiid=P.$f)(l,f,d,p,h,y),ac=r.dynCall_viiiijjj=(l,f,d,p,h,y,b,w,x,$,C)=>(ac=r.dynCall_viiiijjj=P.ag)(l,f,d,p,h,y,b,w,x,$,C),sc=r.dynCall_viiiiiiiiiiiiiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe)=>(sc=r.dynCall_viiiiiiiiiiiiiiiiii=P.bg)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe),uc=r.dynCall_viiiiiiiiiiiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee)=>(uc=r.dynCall_viiiiiiiiiiiiiiii=P.cg)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee),lc=r.dynCall_viiiiiiiiiiiiiiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie)=>(lc=r.dynCall_viiiiiiiiiiiiiiiiiii=P.dg)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie),cc=r.dynCall_viiiiiiiiiiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H)=>(cc=r.dynCall_viiiiiiiiiiiiiii=P.eg)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H),fc=r.dynCall_viiiiiiijjj=(l,f,d,p,h,y,b,w,x,$,C,D,R,A)=>(fc=r.dynCall_viiiiiiijjj=P.fg)(l,f,d,p,h,y,b,w,x,$,C,D,R,A),dc=r.dynCall_iiiiiiiiiii=(l,f,d,p,h,y,b,w,x,$,C)=>(dc=r.dynCall_iiiiiiiiiii=P.gg)(l,f,d,p,h,y,b,w,x,$,C),pc=r.dynCall_iiiiiiiiiiiiiiiiiifi=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie)=>(pc=r.dynCall_iiiiiiiiiiiiiiiiiifi=P.hg)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie),hc=r.dynCall_viiif=(l,f,d,p,h)=>(hc=r.dynCall_viiif=P.ig)(l,f,d,p,h),mc=r.dynCall_iijjj=(l,f,d,p,h,y,b,w)=>(mc=r.dynCall_iijjj=P.jg)(l,f,d,p,h,y,b,w),gc=r.dynCall_viiiiji=(l,f,d,p,h,y,b,w)=>(gc=r.dynCall_viiiiji=P.kg)(l,f,d,p,h,y,b,w),yc=r.dynCall_iijjji=(l,f,d,p,h,y,b,w,x)=>(yc=r.dynCall_iijjji=P.lg)(l,f,d,p,h,y,b,w,x),bc=r.dynCall_ijijji=(l,f,d,p,h,y,b,w,x)=>(bc=r.dynCall_ijijji=P.mg)(l,f,d,p,h,y,b,w,x),vc=r.dynCall_viiijjiii=(l,f,d,p,h,y,b,w,x,$,C)=>(vc=r.dynCall_viiijjiii=P.ng)(l,f,d,p,h,y,b,w,x,$,C),wc=r.dynCall_iiiiijji=(l,f,d,p,h,y,b,w,x,$)=>(wc=r.dynCall_iiiiijji=P.og)(l,f,d,p,h,y,b,w,x,$),xc=r.dynCall_viji=(l,f,d,p,h)=>(xc=r.dynCall_viji=P.pg)(l,f,d,p,h),Tc=r.dynCall_iiiifi=(l,f,d,p,h,y)=>(Tc=r.dynCall_iiiifi=P.qg)(l,f,d,p,h,y),_c=r.dynCall_iiijii=(l,f,d,p,h,y,b)=>(_c=r.dynCall_iiijii=P.rg)(l,f,d,p,h,y,b),$c=r.dynCall_iiiiiiiiijii=(l,f,d,p,h,y,b,w,x,$,C,D,R)=>($c=r.dynCall_iiiiiiiiijii=P.sg)(l,f,d,p,h,y,b,w,x,$,C,D,R),Sc=r.dynCall_iiiijjii=(l,f,d,p,h,y,b,w,x,$)=>(Sc=r.dynCall_iiiijjii=P.tg)(l,f,d,p,h,y,b,w,x,$),Ic=r.dynCall_iiiiiijjjii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A)=>(Ic=r.dynCall_iiiiiijjjii=P.ug)(l,f,d,p,h,y,b,w,x,$,C,D,R,A),Cc=r.dynCall_iiijiii=(l,f,d,p,h,y,b,w)=>(Cc=r.dynCall_iiijiii=P.vg)(l,f,d,p,h,y,b,w),Ac=r.dynCall_iiiiiiiijjjfi=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H)=>(Ac=r.dynCall_iiiiiiiijjjfi=P.wg)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H),Oc=r.dynCall_iijiiii=(l,f,d,p,h,y,b,w)=>(Oc=r.dynCall_iijiiii=P.xg)(l,f,d,p,h,y,b,w),Ec=r.dynCall_iijjjii=(l,f,d,p,h,y,b,w,x,$)=>(Ec=r.dynCall_iijjjii=P.yg)(l,f,d,p,h,y,b,w,x,$),Pc=r.dynCall_iiji=(l,f,d,p,h)=>(Pc=r.dynCall_iiji=P.zg)(l,f,d,p,h),Dc=r.dynCall_viiijiiiii=(l,f,d,p,h,y,b,w,x,$,C)=>(Dc=r.dynCall_viiijiiiii=P.Ag)(l,f,d,p,h,y,b,w,x,$,C),kc=r.dynCall_iid=(l,f,d)=>(kc=r.dynCall_iid=P.Bg)(l,f,d),Bc=r.dynCall_iiif=(l,f,d,p)=>(Bc=r.dynCall_iiif=P.Cg)(l,f,d,p),Rc=r.dynCall_vidi=(l,f,d,p)=>(Rc=r.dynCall_vidi=P.Dg)(l,f,d,p),Mc=r.dynCall_vjiii=(l,f,d,p,h,y)=>(Mc=r.dynCall_vjiii=P.Eg)(l,f,d,p,h,y),Lc=r.dynCall_iiiij=(l,f,d,p,h,y)=>(Lc=r.dynCall_iiiij=P.Fg)(l,f,d,p,h,y),Nc=r.dynCall_viiijii=(l,f,d,p,h,y,b,w)=>(Nc=r.dynCall_viiijii=P.Gg)(l,f,d,p,h,y,b,w),zc=r.dynCall_viijiiiiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A)=>(zc=r.dynCall_viijiiiiiiiii=P.Hg)(l,f,d,p,h,y,b,w,x,$,C,D,R,A),Fc=r.dynCall_viiij=(l,f,d,p,h,y)=>(Fc=r.dynCall_viiij=P.Ig)(l,f,d,p,h,y),jc=r.dynCall_fiiii=(l,f,d,p,h)=>(jc=r.dynCall_fiiii=P.Jg)(l,f,d,p,h),Gc=r.dynCall_jfi=(l,f,d)=>(Gc=r.dynCall_jfi=P.Kg)(l,f,d),Wc=r.dynCall_viiiiiiiiiiiiii=(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z)=>(Wc=r.dynCall_viiiiiiiiiiiiii=P.Lg)(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z),Vc=r.dynCall_jiij=(l,f,d,p,h)=>(Vc=r.dynCall_jiij=P.Mg)(l,f,d,p,h),Uc=r.dynCall_fiii=(l,f,d,p)=>(Uc=r.dynCall_fiii=P.Ng)(l,f,d,p),Hc=l=>(Hc=P.Og)(l),qc=()=>(qc=P.Pg)(),Kc=l=>(Kc=P.Qg)(l),Xc=()=>(Xc=P.Rg)();r.___start_em_js=1323794,r.___stop_em_js=1323955;function vv(l,f,d,p){var h=U();try{return Rn(l,f,d,p)}catch(y){if(W(h),y!==y+0)throw y;V(1,0)}}function wv(l,f,d){var p=U();try{return wi(l,f,d)}catch(h){if(W(p),h!==h+0)throw h;V(1,0)}}function xv(l,f,d){var p=U();try{vi(l,f,d)}catch(h){if(W(p),h!==h+0)throw h;V(1,0)}}function Tv(l,f){var d=U();try{return Eo(l,f)}catch(p){if(W(d),p!==p+0)throw p;V(1,0)}}function _v(l,f){var d=U();try{bi(l,f)}catch(p){if(W(d),p!==p+0)throw p;V(1,0)}}function $v(l){var f=U();try{Mn(l)}catch(d){if(W(f),d!==d+0)throw d;V(1,0)}}function Sv(l,f,d,p,h,y,b){var w=U();try{return Qe(l,f,d,p,h,y,b)}catch(x){if(W(w),x!==x+0)throw x;V(1,0)}}function Iv(l,f,d,p,h,y){var b=U();try{return Ln(l,f,d,p,h,y)}catch(w){if(W(b),w!==w+0)throw w;V(1,0)}}function Cv(l,f,d,p,h){var y=U();try{return Nn(l,f,d,p,h)}catch(b){if(W(y),b!==b+0)throw b;V(1,0)}}function Av(l,f,d,p){var h=U();try{Ti(l,f,d,p)}catch(y){if(W(h),y!==y+0)throw y;V(1,0)}}function Ov(l,f,d,p,h){var y=U();try{Ai(l,f,d,p,h)}catch(b){if(W(y),b!==b+0)throw b;V(1,0)}}function Ev(l){var f=U();try{return $i(l)}catch(d){if(W(f),d!==d+0)throw d;V(1,0)}}function Pv(l,f,d,p,h,y){var b=U();try{Ci(l,f,d,p,h,y)}catch(w){if(W(b),w!==w+0)throw w;V(1,0)}}function Dv(l,f,d,p,h,y,b,w){var x=U();try{return Oi(l,f,d,p,h,y,b,w)}catch($){if(W(x),$!==$+0)throw $;V(1,0)}}function kv(l,f){var d=U();try{return Do(l,f)}catch(p){if(W(d),p!==p+0)throw p;V(1,0)}}function Bv(l,f){var d=U();try{return tn(l,f)}catch(p){if(W(d),p!==p+0)throw p;V(1,0)}}function Rv(l,f,d,p,h,y,b,w,x){var $=U();try{return Wt(l,f,d,p,h,y,b,w,x)}catch(C){if(W($),C!==C+0)throw C;V(1,0)}}function Mv(l,f,d,p,h,y,b){var w=U();try{rn(l,f,d,p,h,y,b)}catch(x){if(W(w),x!==x+0)throw x;V(1,0)}}function Lv(l,f,d,p,h,y,b,w){var x=U();try{ki(l,f,d,p,h,y,b,w)}catch($){if(W(x),$!==$+0)throw $;V(1,0)}}function Nv(l,f,d,p,h,y,b,w,x,$){var C=U();try{return Ro(l,f,d,p,h,y,b,w,x,$)}catch(D){if(W(C),D!==D+0)throw D;V(1,0)}}function zv(l,f,d,p,h,y,b,w,x){var $=U();try{zn(l,f,d,p,h,y,b,w,x)}catch(C){if(W($),C!==C+0)throw C;V(1,0)}}function Fv(l,f,d,p,h,y,b,w,x,$){var C=U();try{Fo(l,f,d,p,h,y,b,w,x,$)}catch(D){if(W(C),D!==D+0)throw D;V(1,0)}}function jv(l,f,d,p){var h=U();try{jo(l,f,d,p)}catch(y){if(W(h),y!==y+0)throw y;V(1,0)}}function Gv(l,f,d,p,h,y,b,w,x,$,C,D){var R=U();try{return Wo(l,f,d,p,h,y,b,w,x,$,C,D)}catch(A){if(W(R),A!==A+0)throw A;V(1,0)}}function Wv(l,f,d,p,h,y,b,w,x,$,C,D,R,A){var z=U();try{nn(l,f,d,p,h,y,b,w,x,$,C,D,R,A)}catch(H){if(W(z),H!==H+0)throw H;V(1,0)}}function Vv(l,f,d,p,h,y,b){var w=U();try{Ri(l,f,d,p,h,y,b)}catch(x){if(W(w),x!==x+0)throw x;V(1,0)}}function Uv(l,f,d,p,h,y,b){var w=U();try{jn(l,f,d,p,h,y,b)}catch(x){if(W(w),x!==x+0)throw x;V(1,0)}}function Hv(l,f,d,p,h,y,b,w,x,$,C){var D=U();try{Gn(l,f,d,p,h,y,b,w,x,$,C)}catch(R){if(W(D),R!==R+0)throw R;V(1,0)}}function qv(l,f,d,p,h){var y=U();try{Wn(l,f,d,p,h)}catch(b){if(W(y),b!==b+0)throw b;V(1,0)}}function Kv(l,f,d,p,h){var y=U();try{return jc(l,f,d,p,h)}catch(b){if(W(y),b!==b+0)throw b;V(1,0)}}function Xv(l,f,d,p,h,y,b,w,x,$,C,D,R,A){var z=U();try{L(l,f,d,p,h,y,b,w,x,$,C,D,R,A)}catch(H){if(W(z),H!==H+0)throw H;V(1,0)}}function Yv(l,f,d,p,h){var y=U();try{_(l,f,d,p,h)}catch(b){if(W(y),b!==b+0)throw b;V(1,0)}}function Jv(l,f,d,p,h,y,b){var w=U();try{E(l,f,d,p,h,y,b)}catch(x){if(W(w),x!==x+0)throw x;V(1,0)}}function Zv(l,f,d,p,h){var y=U();try{Ui(l,f,d,p,h)}catch(b){if(W(y),b!==b+0)throw b;V(1,0)}}function Qv(l,f,d,p,h,y,b,w){var x=U();try{m(l,f,d,p,h,y,b,w)}catch($){if(W(x),$!==$+0)throw $;V(1,0)}}function ew(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee){var ae=U();try{return Q(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee)}catch(pe){if(W(ae),pe!==pe+0)throw pe;V(1,0)}}function tw(l,f,d,p,h,y,b,w,x,$,C,D,R){var A=U();try{ne(l,f,d,p,h,y,b,w,x,$,C,D,R)}catch(z){if(W(A),z!==z+0)throw z;V(1,0)}}function rw(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie){var Ee=U();try{return ve(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie)}catch(Pe){if(W(Ee),Pe!==Pe+0)throw Pe;V(1,0)}}function nw(l,f,d,p,h,y,b,w,x,$,C){var D=U();try{Me(l,f,d,p,h,y,b,w,x,$,C)}catch(R){if(W(D),R!==R+0)throw R;V(1,0)}}function iw(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee){var ae=U();try{Hi(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee)}catch(pe){if(W(ae),pe!==pe+0)throw pe;V(1,0)}}function ow(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H){var ee=U();try{gl(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H)}catch(ae){if(W(ee),ae!==ae+0)throw ae;V(1,0)}}function aw(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z){var H=U();try{yl(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z)}catch(ee){if(W(H),ee!==ee+0)throw ee;V(1,0)}}function sw(l,f,d,p,h,y,b){var w=U();try{return J(l,f,d,p,h,y,b)}catch(x){if(W(w),x!==x+0)throw x;V(1,0)}}function uw(l,f,d,p,h){var y=U();try{Cl(l,f,d,p,h)}catch(b){if(W(y),b!==b+0)throw b;V(1,0)}}function lw(l,f,d,p,h,y,b,w,x,$,C,D){var R=U();try{Wl(l,f,d,p,h,y,b,w,x,$,C,D)}catch(A){if(W(R),A!==A+0)throw A;V(1,0)}}function cw(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z){var H=U();try{Wc(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z)}catch(ee){if(W(H),ee!==ee+0)throw ee;V(1,0)}}function fw(l,f,d){var p=U();try{Kl(l,f,d)}catch(h){if(W(p),h!==h+0)throw h;V(1,0)}}function dw(l,f,d,p,h,y,b,w,x,$){var C=U();try{Yl(l,f,d,p,h,y,b,w,x,$)}catch(D){if(W(C),D!==D+0)throw D;V(1,0)}}function pw(l,f,d,p,h,y,b,w,x,$,C,D){var R=U();try{on(l,f,d,p,h,y,b,w,x,$,C,D)}catch(A){if(W(R),A!==A+0)throw A;V(1,0)}}function hw(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee){var Pe=U();try{tc(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee)}catch(Ne){if(W(Pe),Ne!==Ne+0)throw Ne;V(1,0)}}function mw(l,f,d){var p=U();try{return rc(l,f,d)}catch(h){if(W(p),h!==h+0)throw h;V(1,0)}}function gw(l,f,d,p,h,y,b,w,x,$,C,D,R){var A=U();try{nc(l,f,d,p,h,y,b,w,x,$,C,D,R)}catch(z){if(W(A),z!==z+0)throw z;V(1,0)}}function yw(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee){var ae=U();try{uc(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee)}catch(pe){if(W(ae),pe!==pe+0)throw pe;V(1,0)}}function bw(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie){var Ee=U();try{lc(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie)}catch(Pe){if(W(Ee),Pe!==Pe+0)throw Pe;V(1,0)}}function vw(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe){var Ie=U();try{sc(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe)}catch(Ee){if(W(Ie),Ee!==Ee+0)throw Ee;V(1,0)}}function ww(l,f,d,p,h,y,b,w,x,$,C){var D=U();try{return dc(l,f,d,p,h,y,b,w,x,$,C)}catch(R){if(W(D),R!==R+0)throw R;V(1,0)}}function xw(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie){var Ee=U();try{return pc(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie)}catch(Pe){if(W(Ee),Pe!==Pe+0)throw Pe;V(1,0)}}function Tw(l,f,d,p,h){var y=U();try{hc(l,f,d,p,h)}catch(b){if(W(y),b!==b+0)throw b;V(1,0)}}function _w(l,f,d,p,h,y,b,w,x,$,C,D){var R=U();try{Li(l,f,d,p,h,y,b,w,x,$,C,D)}catch(A){if(W(R),A!==A+0)throw A;V(1,0)}}function $w(l,f,d,p){var h=U();try{Xl(l,f,d,p)}catch(y){if(W(h),y!==y+0)throw y;V(1,0)}}function Sw(l,f,d,p,h,y){var b=U();try{return Tc(l,f,d,p,h,y)}catch(w){if(W(b),w!==w+0)throw w;V(1,0)}}function Iw(l,f,d){var p=U();try{return kc(l,f,d)}catch(h){if(W(p),h!==h+0)throw h;V(1,0)}}function Cw(l,f,d,p){var h=U();try{return Bc(l,f,d,p)}catch(y){if(W(h),y!==y+0)throw y;V(1,0)}}function Aw(l,f,d,p){var h=U();try{Rc(l,f,d,p)}catch(y){if(W(h),y!==y+0)throw y;V(1,0)}}function Ow(l,f,d,p){var h=U();try{return Uc(l,f,d,p)}catch(y){if(W(h),y!==y+0)throw y;V(1,0)}}function Ew(l,f,d,p,h,y){var b=U();try{return oc(l,f,d,p,h,y)}catch(w){if(W(b),w!==w+0)throw w;V(1,0)}}function Pw(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H){var ee=U();try{cc(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H)}catch(ae){if(W(ee),ae!==ae+0)throw ae;V(1,0)}}function Dw(l,f,d){var p=U();try{return ko(l,f,d)}catch(h){if(W(p),h!==h+0)throw h;V(1,0)}}function kw(l,f,d){var p=U();try{return ur(l,f,d)}catch(h){if(W(p),h!==h+0)throw h;V(1,0)}}function Bw(l,f,d,p,h){var y=U();try{return xi(l,f,d,p,h)}catch(b){if(W(y),b!==b+0)throw b;V(1,0)}}function Rw(l,f,d,p){var h=U();try{return Si(l,f,d,p)}catch(y){if(W(h),y!==y+0)throw y;V(1,0)}}function Mw(l,f,d,p){var h=U();try{Po(l,f,d,p)}catch(y){if(W(h),y!==y+0)throw y;V(1,0)}}function Lw(l,f){var d=U();try{return Ei(l,f)}catch(p){if(W(d),p!==p+0)throw p;V(1,0)}}function Nw(l,f,d,p,h){var y=U();try{Pi(l,f,d,p,h)}catch(b){if(W(y),b!==b+0)throw b;V(1,0)}}function zw(l,f,d,p,h,y){var b=U();try{Di(l,f,d,p,h,y)}catch(w){if(W(b),w!==w+0)throw w;V(1,0)}}function Fw(l,f,d,p,h,y,b,w){var x=U();try{Nc(l,f,d,p,h,y,b,w)}catch($){if(W(x),$!==$+0)throw $;V(1,0)}}function jw(l,f,d,p,h,y,b){var w=U();try{We(l,f,d,p,h,y,b)}catch(x){if(W(w),x!==x+0)throw x;V(1,0)}}function Gw(l,f,d,p,h,y,b,w,x,$,C,D){var R=U();try{return Mo(l,f,d,p,h,y,b,w,x,$,C,D)}catch(A){if(W(R),A!==A+0)throw A;V(1,0)}}function Ww(l,f,d,p,h,y,b,w){var x=U();try{No(l,f,d,p,h,y,b,w)}catch($){if(W(x),$!==$+0)throw $;V(1,0)}}function Vw(l,f,d,p,h,y,b,w){var x=U();try{zo(l,f,d,p,h,y,b,w)}catch($){if(W(x),$!==$+0)throw $;V(1,0)}}function Uw(l,f,d){var p=U();try{return Bo(l,f,d)}catch(h){if(W(p),h!==h+0)throw h;V(1,0)}}function Hw(l,f,d,p,h,y,b,w,x,$){var C=U();try{return Go(l,f,d,p,h,y,b,w,x,$)}catch(D){if(W(C),D!==D+0)throw D;V(1,0)}}function qw(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z){var H=U();try{Fn(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z)}catch(ee){if(W(H),ee!==ee+0)throw ee;V(1,0)}}function Kw(l,f,d,p,h,y,b,w,x,$,C,D,R){var A=U();try{Bi(l,f,d,p,h,y,b,w,x,$,C,D,R)}catch(z){if(W(A),z!==z+0)throw z;V(1,0)}}function Xw(l,f,d,p,h,y){var b=U();try{Lo(l,f,d,p,h,y)}catch(w){if(W(b),w!==w+0)throw w;V(1,0)}}function Yw(l,f,d,p,h,y,b,w,x,$,C,D){var R=U();try{Mi(l,f,d,p,h,y,b,w,x,$,C,D)}catch(A){if(W(R),A!==A+0)throw A;V(1,0)}}function Jw(l,f,d,p,h,y,b,w,x){var $=U();try{Ni(l,f,d,p,h,y,b,w,x)}catch(C){if(W($),C!==C+0)throw C;V(1,0)}}function Zw(l,f,d,p){var h=U();try{return zi(l,f,d,p)}catch(y){if(W(h),y!==y+0)throw y;V(1,0)}}function Qw(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne,at,st,dt,xt,Vt,Ut){var sn=U();try{Vn(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne,at,st,dt,xt,Vt,Ut)}catch(un){if(W(sn),un!==un+0)throw un;V(1,0)}}function ex(l,f,d,p,h,y,b){var w=U();try{Fi(l,f,d,p,h,y,b)}catch(x){if(W(w),x!==x+0)throw x;V(1,0)}}function tx(l,f,d,p,h,y,b,w,x,$,C,D,R){var A=U();try{ji(l,f,d,p,h,y,b,w,x,$,C,D,R)}catch(z){if(W(A),z!==z+0)throw z;V(1,0)}}function rx(l,f,d,p,h,y){var b=U();try{return Gi(l,f,d,p,h,y)}catch(w){if(W(b),w!==w+0)throw w;V(1,0)}}function nx(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z){var H=U();try{return Wi(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z)}catch(ee){if(W(H),ee!==ee+0)throw ee;V(1,0)}}function ix(l,f,d){var p=U();try{Vi(l,f,d)}catch(h){if(W(p),h!==h+0)throw h;V(1,0)}}function ox(l,f,d,p,h){var y=U();try{return Vo(l,f,d,p,h)}catch(b){if(W(y),b!==b+0)throw b;V(1,0)}}function ax(l,f,d,p,h,y,b,w,x,$,C){var D=U();try{return an(l,f,d,p,h,y,b,w,x,$,C)}catch(R){if(W(D),R!==R+0)throw R;V(1,0)}}function sx(l,f,d,p,h,y,b,w,x,$,C,D,R){var A=U();try{K(l,f,d,p,h,y,b,w,x,$,C,D,R)}catch(z){if(W(A),z!==z+0)throw z;V(1,0)}}function ux(l,f,d){var p=U();try{return _e(l,f,d)}catch(h){if(W(p),h!==h+0)throw h;V(1,0)}}function lx(l,f,d,p,h,y,b,w,x,$,C,D){var R=U();try{ye(l,f,d,p,h,y,b,w,x,$,C,D)}catch(A){if(W(R),A!==A+0)throw A;V(1,0)}}function cx(l,f,d,p,h,y,b,w,x,$){var C=U();try{return $e(l,f,d,p,h,y,b,w,x,$)}catch(D){if(W(C),D!==D+0)throw D;V(1,0)}}function fx(l,f,d,p,h,y,b,w,x){var $=U();try{return Fe(l,f,d,p,h,y,b,w,x)}catch(C){if(W($),C!==C+0)throw C;V(1,0)}}function dx(l,f,d,p,h,y,b){var w=U();try{Oe(l,f,d,p,h,y,b)}catch(x){if(W(w),x!==x+0)throw x;V(1,0)}}function px(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne,at){var st=U();try{xr(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne,at)}catch(dt){if(W(st),dt!==dt+0)throw dt;V(1,0)}}function hx(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne,at,st,dt,xt,Vt,Ut){var sn=U();try{bl(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne,at,st,dt,xt,Vt,Ut)}catch(un){if(W(sn),un!==un+0)throw un;V(1,0)}}function mx(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne,at,st){var dt=U();try{vl(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne,at,st)}catch(xt){if(W(dt),xt!==xt+0)throw xt;V(1,0)}}function gx(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne){var at=U();try{wl(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne)}catch(st){if(W(at),st!==st+0)throw st;V(1,0)}}function yx(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne,at,st,dt,xt,Vt){var Ut=U();try{xl(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne,at,st,dt,xt,Vt)}catch(sn){if(W(Ut),sn!==sn+0)throw sn;V(1,0)}}function bx(l,f,d,p,h,y,b,w,x,$,C,D){var R=U();try{Tl(l,f,d,p,h,y,b,w,x,$,C,D)}catch(A){if(W(R),A!==A+0)throw A;V(1,0)}}function vx(l,f,d,p,h,y,b,w,x,$,C,D){var R=U();try{_l(l,f,d,p,h,y,b,w,x,$,C,D)}catch(A){if(W(R),A!==A+0)throw A;V(1,0)}}function wx(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee){var Pe=U();try{$l(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee)}catch(Ne){if(W(Pe),Ne!==Ne+0)throw Ne;V(1,0)}}function xx(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z){var H=U();try{Sl(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z)}catch(ee){if(W(H),ee!==ee+0)throw ee;V(1,0)}}function Tx(l,f,d,p,h,y,b,w,x,$,C,D,R){var A=U();try{Il(l,f,d,p,h,y,b,w,x,$,C,D,R)}catch(z){if(W(A),z!==z+0)throw z;V(1,0)}}function _x(l,f,d){var p=U();try{return Gc(l,f,d)}catch(h){if(W(p),h!==h+0)throw h;V(1,0)}}function $x(l,f,d,p,h,y,b,w){var x=U();try{return Al(l,f,d,p,h,y,b,w)}catch($){if(W(x),$!==$+0)throw $;V(1,0)}}function Sx(l,f,d,p,h,y,b,w){var x=U();try{Ol(l,f,d,p,h,y,b,w)}catch($){if(W(x),$!==$+0)throw $;V(1,0)}}function Ix(l,f,d,p,h,y,b,w,x,$,C,D){var R=U();try{El(l,f,d,p,h,y,b,w,x,$,C,D)}catch(A){if(W(R),A!==A+0)throw A;V(1,0)}}function Cx(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z){var H=U();try{Pl(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z)}catch(ee){if(W(H),ee!==ee+0)throw ee;V(1,0)}}function Ax(l,f,d,p,h,y,b){var w=U();try{return Dl(l,f,d,p,h,y,b)}catch(x){if(W(w),x!==x+0)throw x;V(1,0)}}function Ox(l,f,d,p,h,y,b,w,x,$,C,D,R,A){var z=U();try{kl(l,f,d,p,h,y,b,w,x,$,C,D,R,A)}catch(H){if(W(z),H!==H+0)throw H;V(1,0)}}function Ex(l,f,d,p,h,y,b,w,x){var $=U();try{Bl(l,f,d,p,h,y,b,w,x)}catch(C){if(W($),C!==C+0)throw C;V(1,0)}}function Px(l,f,d,p,h,y,b,w,x,$){var C=U();try{Rl(l,f,d,p,h,y,b,w,x,$)}catch(D){if(W(C),D!==D+0)throw D;V(1,0)}}function Dx(l,f,d,p,h){var y=U();try{return Ml(l,f,d,p,h)}catch(b){if(W(y),b!==b+0)throw b;V(1,0)}}function kx(l,f,d,p,h,y,b,w,x,$,C){var D=U();try{return Nl(l,f,d,p,h,y,b,w,x,$,C)}catch(R){if(W(D),R!==R+0)throw R;V(1,0)}}function Bx(l,f,d,p,h,y,b,w,x,$,C,D,R){var A=U();try{return Ll(l,f,d,p,h,y,b,w,x,$,C,D,R)}catch(z){if(W(A),z!==z+0)throw z;V(1,0)}}function Rx(l,f,d,p,h,y,b,w,x,$,C,D,R,A){var z=U();try{zl(l,f,d,p,h,y,b,w,x,$,C,D,R,A)}catch(H){if(W(z),H!==H+0)throw H;V(1,0)}}function Mx(l,f,d,p,h,y,b,w,x,$,C){var D=U();try{Fl(l,f,d,p,h,y,b,w,x,$,C)}catch(R){if(W(D),R!==R+0)throw R;V(1,0)}}function Lx(l,f,d,p,h,y,b,w,x,$,C,D){var R=U();try{jl(l,f,d,p,h,y,b,w,x,$,C,D)}catch(A){if(W(R),A!==A+0)throw A;V(1,0)}}function Nx(l,f,d,p,h,y,b){var w=U();try{Gl(l,f,d,p,h,y,b)}catch(x){if(W(w),x!==x+0)throw x;V(1,0)}}function zx(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z){var H=U();try{Vl(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z)}catch(ee){if(W(H),ee!==ee+0)throw ee;V(1,0)}}function Fx(l,f,d,p,h,y,b,w,x){var $=U();try{return Ul(l,f,d,p,h,y,b,w,x)}catch(C){if(W($),C!==C+0)throw C;V(1,0)}}function jx(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H){var ee=U();try{Hl(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H)}catch(ae){if(W(ee),ae!==ae+0)throw ae;V(1,0)}}function Gx(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H){var ee=U();try{ql(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H)}catch(ae){if(W(ee),ae!==ae+0)throw ae;V(1,0)}}function Wx(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne,at,st,dt,xt){var Vt=U();try{Jl(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee,ae,pe,Ie,Ee,Pe,Ne,at,st,dt,xt)}catch(Ut){if(W(Vt),Ut!==Ut+0)throw Ut;V(1,0)}}function Vx(l,f,d,p,h,y,b,w){var x=U();try{Zl(l,f,d,p,h,y,b,w)}catch($){if(W(x),$!==$+0)throw $;V(1,0)}}function Ux(l,f,d,p,h,y,b,w,x,$,C,D,R,A){var z=U();try{return Ql(l,f,d,p,h,y,b,w,x,$,C,D,R,A)}catch(H){if(W(z),H!==H+0)throw H;V(1,0)}}function Hx(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H){var ee=U();try{ec(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H)}catch(ae){if(W(ee),ae!==ae+0)throw ae;V(1,0)}}function qx(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee){var ae=U();try{ic(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H,ee)}catch(pe){if(W(ae),pe!==pe+0)throw pe;V(1,0)}}function Kx(l,f,d,p,h,y,b,w,x,$,C){var D=U();try{ac(l,f,d,p,h,y,b,w,x,$,C)}catch(R){if(W(D),R!==R+0)throw R;V(1,0)}}function Xx(l,f,d,p,h,y,b,w,x,$,C,D,R,A){var z=U();try{fc(l,f,d,p,h,y,b,w,x,$,C,D,R,A)}catch(H){if(W(z),H!==H+0)throw H;V(1,0)}}function Yx(l,f,d,p,h,y,b,w){var x=U();try{return mc(l,f,d,p,h,y,b,w)}catch($){if(W(x),$!==$+0)throw $;V(1,0)}}function Jx(l,f,d,p,h){var y=U();try{return Vc(l,f,d,p,h)}catch(b){if(W(y),b!==b+0)throw b;V(1,0)}}function Zx(l,f,d,p,h,y,b,w){var x=U();try{gc(l,f,d,p,h,y,b,w)}catch($){if(W(x),$!==$+0)throw $;V(1,0)}}function Qx(l,f,d,p,h,y,b,w,x){var $=U();try{return yc(l,f,d,p,h,y,b,w,x)}catch(C){if(W($),C!==C+0)throw C;V(1,0)}}function e1(l,f,d,p,h,y,b,w,x){var $=U();try{return bc(l,f,d,p,h,y,b,w,x)}catch(C){if(W($),C!==C+0)throw C;V(1,0)}}function t1(l,f,d,p,h,y,b,w,x,$,C){var D=U();try{vc(l,f,d,p,h,y,b,w,x,$,C)}catch(R){if(W(D),R!==R+0)throw R;V(1,0)}}function r1(l,f,d,p,h,y,b,w,x,$){var C=U();try{return wc(l,f,d,p,h,y,b,w,x,$)}catch(D){if(W(C),D!==D+0)throw D;V(1,0)}}function n1(l,f,d,p,h){var y=U();try{xc(l,f,d,p,h)}catch(b){if(W(y),b!==b+0)throw b;V(1,0)}}function i1(l,f,d,p,h,y,b){var w=U();try{return _c(l,f,d,p,h,y,b)}catch(x){if(W(w),x!==x+0)throw x;V(1,0)}}function o1(l,f,d,p,h,y,b,w,x,$,C,D,R){var A=U();try{return $c(l,f,d,p,h,y,b,w,x,$,C,D,R)}catch(z){if(W(A),z!==z+0)throw z;V(1,0)}}function a1(l,f,d,p,h,y,b,w,x,$){var C=U();try{return Sc(l,f,d,p,h,y,b,w,x,$)}catch(D){if(W(C),D!==D+0)throw D;V(1,0)}}function s1(l,f,d,p,h,y,b,w,x,$,C,D,R,A){var z=U();try{return Ic(l,f,d,p,h,y,b,w,x,$,C,D,R,A)}catch(H){if(W(z),H!==H+0)throw H;V(1,0)}}function u1(l,f,d,p,h,y,b,w){var x=U();try{return Cc(l,f,d,p,h,y,b,w)}catch($){if(W(x),$!==$+0)throw $;V(1,0)}}function l1(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H){var ee=U();try{return Ac(l,f,d,p,h,y,b,w,x,$,C,D,R,A,z,H)}catch(ae){if(W(ee),ae!==ae+0)throw ae;V(1,0)}}function c1(l,f,d,p,h,y,b,w){var x=U();try{return Oc(l,f,d,p,h,y,b,w)}catch($){if(W(x),$!==$+0)throw $;V(1,0)}}function f1(l,f,d,p,h,y,b,w,x,$){var C=U();try{return Ec(l,f,d,p,h,y,b,w,x,$)}catch(D){if(W(C),D!==D+0)throw D;V(1,0)}}function d1(l,f,d,p,h){var y=U();try{return Pc(l,f,d,p,h)}catch(b){if(W(y),b!==b+0)throw b;V(1,0)}}function p1(l,f,d,p,h,y,b,w,x,$,C){var D=U();try{Dc(l,f,d,p,h,y,b,w,x,$,C)}catch(R){if(W(D),R!==R+0)throw R;V(1,0)}}function h1(l,f,d,p,h,y){var b=U();try{Fc(l,f,d,p,h,y)}catch(w){if(W(b),w!==w+0)throw w;V(1,0)}}function m1(l,f,d,p,h,y,b,w,x,$,C,D,R,A){var z=U();try{zc(l,f,d,p,h,y,b,w,x,$,C,D,R,A)}catch(H){if(W(z),H!==H+0)throw H;V(1,0)}}function g1(l,f,d,p,h,y){var b=U();try{Mc(l,f,d,p,h,y)}catch(w){if(W(b),w!==w+0)throw w;V(1,0)}}function y1(l,f,d,p,h,y){var b=U();try{return Lc(l,f,d,p,h,y)}catch(w){if(W(b),w!==w+0)throw w;V(1,0)}}function b1(l){var f=U();try{return _i(l)}catch(d){if(W(f),d!==d+0)throw d;V(1,0)}}function v1(l,f,d,p,h,y,b){var w=U();try{return Ii(l,f,d,p,h,y,b)}catch(x){if(W(w),x!==x+0)throw x;V(1,0)}}function w1(l){l=Object.assign({},l);var f=p=>()=>p()>>>0,d=p=>h=>p(h)>>>0;return l.__errno_location=f(l.__errno_location),l.malloc=d(l.malloc),l.stackSave=f(l.stackSave),l.stackAlloc=d(l.stackAlloc),l}r.stackAlloc=en,r.stackSave=U,r.stackRestore=W,r.UTF8ToString=or,r.stringToUTF8=(l,f,d)=>vr(l,Ae,f,d),r.lengthBytesUTF8=ui;var Uo;yr=function l(){Uo||Yc(),Uo||(yr=l)};function Yc(){function l(){if(!Uo&&(Uo=!0,r.calledRun=!0,!te)){if(nr(Dt),t(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),r.postRun)for(typeof r.postRun=="function"&&(r.postRun=[r.postRun]);r.postRun.length;){var f=r.postRun.shift();Ge.unshift(f)}nr(Ge)}}if(!(0<Ye)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;)wt();nr(de),0<Ye||(r.setStatus?(r.setStatus("Running..."),setTimeout(function(){setTimeout(function(){r.setStatus("")},1),l()},1)):l())}}if(r.preInit)for(typeof r.preInit=="function"&&(r.preInit=[r.preInit]);0<r.preInit.length;)r.preInit.pop()();return Yc(),e.ready}})();typeof Pg=="object"&&typeof Eu=="object"?Eu.exports=Eg:typeof define=="function"&&define.amd&&define([],()=>Eg)});var kg=et(()=>{});var Bg=et(()=>{});var Rg={};ln(Rg,{cpus:()=>t$});var t$,Mg=X(()=>{t$=void 0});var zg=et((Ng,Pu)=>{"use strict";var Lg=(()=>{var n=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(n=n||__filename),function(e={}){function r(){return me.buffer!=Ye.buffer&&ie(),Ye}function t(){return me.buffer!=Ye.buffer&&ie(),$t}function i(){return me.buffer!=Ye.buffer&&ie(),yr}function o(){return me.buffer!=Ye.buffer&&ie(),Et}function s(){return me.buffer!=Ye.buffer&&ie(),Dr}var a=e,u,c;a.ready=new Promise((m,_)=>{u=m,c=_}),a.jsepInit=(m,_,E,L,K,Q,ne,_e)=>{a.Qb=m,a.wb=_,a.yb=E,a.jb=L,a.xb=K,a.Ea=Q,a.zb=ne,a.Ab=_e,_=(ve,ye,$e)=>(...Me)=>{let Fe=Wt,J=ye?.();Me=ve(...Me);let Oe=ye?.();return J!==Oe&&(ve=Oe,$e(J),ye=$e=null),Wt!=Fe?Lo():Me},E=ve=>async(...ye)=>{try{if(a.bb)throw Error("Session already started");let $e=a.bb={Fb:ye[0],errors:[]},Me=await ve(...ye);if(a.bb!==$e)throw Error("Session mismatch");m.flush();let Fe=$e.errors;if(0<Fe.length){let J=await Promise.all(Fe);if(J=J.filter(Oe=>Oe),0<J.length)throw Error(J.join(`
`))}return Me}finally{a.bb=null}},a._OrtRun=E(_(a._OrtRun,()=>a._OrtRun,ve=>a._OrtRun=ve)),a._OrtRunWithBinding=E(_(a._OrtRunWithBinding,()=>a._OrtRunWithBinding,ve=>a._OrtRunWithBinding=ve)),a._OrtBindInput=_(a._OrtBindInput,()=>a._OrtBindInput,ve=>a._OrtBindInput=ve),a.jsepRegisterBuffer=(ve,ye,$e,Me)=>m.registerBuffer(ve,ye,$e,Me),a.jsepUnregisterBuffers=ve=>{m.unregisterBuffers(ve)},a.jsepGetBuffer=ve=>m.getBuffer(ve),a.jsepCreateDownloader=(ve,ye,$e)=>m.createDownloader(ve,ye,$e)};var g=Object.assign({},a),v="./this.program",T=(m,_)=>{throw _},S=typeof window=="object",O=typeof importScripts=="function",I=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",k=a.ENVIRONMENT_IS_PTHREAD||!1,M="";function F(m){return a.locateFile?a.locateFile(m,M):M+m}var j,Y,Z;if(I){var P=(Cu(),Rr(Iu)),te=(Ou(),Rr(Au));M=O?te.dirname(M)+"/":__dirname+"/",j=(_,E)=>(_=_.startsWith("file://")?new URL(_):te.normalize(_),P.readFileSync(_,E?void 0:"utf8")),Z=_=>(_=j(_,!0),_.buffer||(_=new Uint8Array(_)),_),Y=(_,E,L,K=!0)=>{_=_.startsWith("file://")?new URL(_):te.normalize(_),P.readFile(_,K?void 0:"utf8",(Q,ne)=>{Q?L(Q):E(K?ne.buffer:ne)})},!a.thisProgram&&1<process.argv.length&&(v=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),T=(_,E)=>{throw process.exitCode=_,E},a.inspect=()=>"[Emscripten Module object]";let m;try{m=kg()}catch(_){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),_}global.Worker=m.Worker}else(S||O)&&(O?M=self.location.href:typeof document<"u"&&document.currentScript&&(M=document.currentScript.src),typeof n<"u"&&n&&(M=n),M.indexOf("blob:")!==0?M=M.substr(0,M.replace(/[?#].*/,"").lastIndexOf("/")+1):M="",I||(j=m=>{var _=new XMLHttpRequest;return _.open("GET",m,!1),_.send(null),_.responseText},O&&(Z=m=>{var _=new XMLHttpRequest;return _.open("GET",m,!1),_.responseType="arraybuffer",_.send(null),new Uint8Array(_.response)}),Y=(m,_,E)=>{var L=new XMLHttpRequest;L.open("GET",m,!0),L.responseType="arraybuffer",L.onload=()=>{L.status==200||L.status==0&&L.response?_(L.response):E()},L.onerror=E,L.send(null)}));I&&typeof performance>"u"&&(global.performance=Bg().performance);var ue=console.log.bind(console),le=console.error.bind(console);I&&(ue=(...m)=>P.writeSync(1,m.join(" ")+`
`),le=(...m)=>P.writeSync(2,m.join(" ")+`
`));var Ae=a.print||ue,q=a.printErr||le;Object.assign(a,g),g=null,a.thisProgram&&(v=a.thisProgram),a.quit&&(T=a.quit);var ge;a.wasmBinary&&(ge=a.wasmBinary);var it=a.noExitRuntime||!0;typeof WebAssembly!="object"&&St("no native wasm support detected");var me,de,Dt,Ge=!1,wt,Ye,$t,yr,Et,Dr;function ie(){var m=me.buffer;a.HEAP8=Ye=new Int8Array(m),a.HEAP16=new Int16Array(m),a.HEAP32=yr=new Int32Array(m),a.HEAPU8=$t=new Uint8Array(m),a.HEAPU16=new Uint16Array(m),a.HEAPU32=Et=new Uint32Array(m),a.HEAPF32=new Float32Array(m),a.HEAPF64=Dr=new Float64Array(m)}var Be=a.INITIAL_MEMORY||16777216;if(5242880<=Be||St("INITIAL_MEMORY should be larger than STACK_SIZE, was "+Be+"! (STACK_SIZE=5242880)"),k)me=a.wasmMemory;else if(a.wasmMemory)me=a.wasmMemory;else if(me=new WebAssembly.Memory({initial:Be/65536,maximum:65536,shared:!0}),!(me.buffer instanceof SharedArrayBuffer))throw q("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),I&&q("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");ie(),Be=me.buffer.byteLength;var He=[],kt=[],Lt=[],ft=0;function ot(){return it||0<ft}var Nt=0,br=null,nr=null;function Kr(){Nt++,a.monitorRunDependencies&&a.monitorRunDependencies(Nt)}function Xr(){if(Nt--,a.monitorRunDependencies&&a.monitorRunDependencies(Nt),Nt==0&&(br!==null&&(clearInterval(br),br=null),nr)){var m=nr;nr=null,m()}}function St(m){throw a.onAbort&&a.onAbort(m),m="Aborted("+m+")",q(m),Ge=!0,wt=1,m=new WebAssembly.RuntimeError(m+". Build with -sASSERTIONS for more info."),c(m),m}function Cn(m){return m.startsWith("data:application/octet-stream;base64,")}var ir;ir="ort-wasm-simd-threaded.wasm",Cn(ir)||(ir=F(ir));function si(m){if(m==ir&&ge)return new Uint8Array(ge);if(Z)return Z(m);throw"both async and sync fetching of the wasm failed"}function wo(m){if(!ge&&(S||O)){if(typeof fetch=="function"&&!m.startsWith("file://"))return fetch(m,{credentials:"same-origin"}).then(_=>{if(!_.ok)throw"failed to load wasm binary file at '"+m+"'";return _.arrayBuffer()}).catch(()=>si(m));if(Y)return new Promise((_,E)=>{Y(m,L=>_(new Uint8Array(L)),E)})}return Promise.resolve().then(()=>si(m))}function or(m,_,E){return wo(m).then(L=>WebAssembly.instantiate(L,_)).then(L=>L).then(E,L=>{q("failed to asynchronously prepare wasm: "+L),St(L)})}function ui(m,_){var E=ir;return ge||typeof WebAssembly.instantiateStreaming!="function"||Cn(E)||E.startsWith("file://")||I||typeof fetch!="function"?or(E,m,_):fetch(E,{credentials:"same-origin"}).then(L=>WebAssembly.instantiateStreaming(L,m).then(_,function(K){return q("wasm streaming compile failed: "+K),q("falling back to ArrayBuffer instantiation"),or(E,m,_)}))}var vr,wr={911532:m=>{a.Ea("Abs",m,void 0)},911583:m=>{a.Ea("Neg",m,void 0)},911634:m=>{a.Ea("Floor",m,void 0)},911687:m=>{a.Ea("Ceil",m,void 0)},911739:m=>{a.Ea("Reciprocal",m,void 0)},911797:m=>{a.Ea("Sqrt",m,void 0)},911849:m=>{a.Ea("Exp",m,void 0)},911900:m=>{a.Ea("Erf",m,void 0)},911951:m=>{a.Ea("Sigmoid",m,void 0)},912006:m=>{a.Ea("Log",m,void 0)},912057:m=>{a.Ea("Sin",m,void 0)},912108:m=>{a.Ea("Cos",m,void 0)},912159:m=>{a.Ea("Tan",m,void 0)},912210:m=>{a.Ea("Asin",m,void 0)},912262:m=>{a.Ea("Acos",m,void 0)},912314:m=>{a.Ea("Atan",m,void 0)},912366:m=>{a.Ea("Sinh",m,void 0)},912418:m=>{a.Ea("Cosh",m,void 0)},912470:m=>{a.Ea("Asinh",m,void 0)},912523:m=>{a.Ea("Acosh",m,void 0)},912576:m=>{a.Ea("Atanh",m,void 0)},912629:m=>{a.Ea("Tanh",m,void 0)},912681:m=>{a.Ea("Not",m,void 0)},912732:(m,_,E)=>{a.Ea("ClipV10",m,{min:_,max:E})},912804:m=>{a.Ea("Clip",m,void 0)},912856:(m,_)=>{a.Ea("Elu",m,{alpha:_})},912914:m=>{a.Ea("Relu",m,void 0)},912966:(m,_)=>{a.Ea("LeakyRelu",m,{alpha:_})},913030:(m,_)=>{a.Ea("ThresholdedRelu",m,{alpha:_})},913100:(m,_)=>{a.Ea("Cast",m,{to:_})},913158:m=>{a.Ea("Add",m,void 0)},913209:m=>{a.Ea("Sub",m,void 0)},913260:m=>{a.Ea("Mul",m,void 0)},913311:m=>{a.Ea("Div",m,void 0)},913362:m=>{a.Ea("Pow",m,void 0)},913413:m=>{a.Ea("Equal",m,void 0)},913466:m=>{a.Ea("Greater",m,void 0)},913521:m=>{a.Ea("GreaterOrEqual",m,void 0)},913583:m=>{a.Ea("Less",m,void 0)},913635:m=>{a.Ea("LessOrEqual",m,void 0)},913694:(m,_,E,L,K)=>{a.Ea("ReduceMean",m,{keepDims:!!_,noopWithEmptyAxes:!!E,axes:L?Array.from(i().subarray(K>>>0,K+L>>>0)):[]})},913858:(m,_,E,L,K)=>{a.Ea("ReduceMax",m,{keepDims:!!_,noopWithEmptyAxes:!!E,axes:L?Array.from(i().subarray(K>>>0,K+L>>>0)):[]})},914021:(m,_,E,L,K)=>{a.Ea("ReduceMin",m,{keepDims:!!_,noopWithEmptyAxes:!!E,axes:L?Array.from(i().subarray(K>>>0,K+L>>>0)):[]})},914184:(m,_,E,L,K)=>{a.Ea("ReduceProd",m,{keepDims:!!_,noopWithEmptyAxes:!!E,axes:L?Array.from(i().subarray(K>>>0,K+L>>>0)):[]})},914348:(m,_,E,L,K)=>{a.Ea("ReduceSum",m,{keepDims:!!_,noopWithEmptyAxes:!!E,axes:L?Array.from(i().subarray(K>>>0,K+L>>>0)):[]})},914511:(m,_,E,L,K)=>{a.Ea("ReduceL1",m,{keepDims:!!_,noopWithEmptyAxes:!!E,axes:L?Array.from(i().subarray(K>>>0,K+L>>>0)):[]})},914673:(m,_,E,L,K)=>{a.Ea("ReduceL2",m,{keepDims:!!_,noopWithEmptyAxes:!!E,axes:L?Array.from(i().subarray(K>>>0,K+L>>>0)):[]})},914835:(m,_,E,L,K)=>{a.Ea("ReduceLogSum",m,{keepDims:!!_,noopWithEmptyAxes:!!E,axes:L?Array.from(i().subarray(K>>>0,K+L>>>0)):[]})},915001:(m,_,E,L,K)=>{a.Ea("ReduceSumSquare",m,{keepDims:!!_,noopWithEmptyAxes:!!E,axes:L?Array.from(i().subarray(K>>>0,K+L>>>0)):[]})},915170:(m,_,E,L,K)=>{a.Ea("ReduceLogSumExp",m,{keepDims:!!_,noopWithEmptyAxes:!!E,axes:L?Array.from(i().subarray(K>>>0,K+L>>>0)):[]})},915339:m=>{a.Ea("Where",m,void 0)},915392:(m,_,E)=>{a.Ea("Transpose",m,{perm:_?Array.from(i().subarray(E>>>0,E+_>>>0)):[]})},915505:(m,_,E,L,K,Q,ne,_e,ve,ye)=>{a.Ea("Conv",m,{format:ve?"NHWC":"NCHW",auto_pad:_,dilations:[E],group:L,kernel_shape:[K],pads:[Q,ne],strides:[_e],w_is_const:()=>!!r()[ye>>>0]})},915733:(m,_,E,L,K,Q,ne,_e,ve,ye,$e,Me,Fe,J,Oe)=>{a.Ea("Conv",m,{format:J?"NHWC":"NCHW",auto_pad:_,dilations:[E,L],group:K,kernel_shape:[Q,ne],pads:[_e,ve,ye,$e],strides:[Me,Fe],w_is_const:()=>!!r()[Oe>>>0]})},915992:(m,_,E,L,K,Q,ne,_e,ve,ye)=>{a.Ea("Conv",m,{format:ve?"NHWC":"NCHW",auto_pad:_,dilations:[E],group:L,kernel_shape:[K],pads:[Q,ne],strides:[_e],w_is_const:()=>!!r()[ye>>>0]})},916220:(m,_,E,L,K,Q,ne,_e,ve,ye,$e,Me,Fe,J,Oe)=>{a.Ea("Conv",m,{format:J?"NHWC":"NCHW",auto_pad:_,dilations:[E,L],group:K,kernel_shape:[Q,ne],pads:[_e,ve,ye,$e],strides:[Me,Fe],w_is_const:()=>!!r()[Oe>>>0]})},916479:(m,_,E,L,K,Q,ne,_e,ve,ye,$e,Me,Fe,J)=>{a.Ea("ConvTranspose",m,{format:ve?"NHWC":"NCHW",autoPad:_,dilations:[E],group:L,kernel_shape:[K],pads:[Q,ne],strides:[_e],wIsConst:()=>!!r()[ye>>>0],outputPadding:$e?Array.from(i().subarray(Me>>>0,Me+$e>>>0)):[],outputShape:Fe?Array.from(i().subarray(J>>>0,J+Fe>>>0)):[]})},916859:(m,_,E,L,K,Q,ne,_e,ve,ye,$e,Me,Fe)=>{a.Ea("ConvTranspose",m,{format:_e?"NHWC":"NCHW",autoPad:_,dilations:Array.from(i().subarray(E>>>0,E+2>>>0)),group:L,kernelShape:Array.from(i().subarray(K>>>0,K+2>>>0)),pads:Array.from(i().subarray(Q>>>0,Q+4>>>0)),strides:Array.from(i().subarray(ne>>>0,ne+2>>>0)),wIsConst:()=>!!r()[ve>>>0],outputPadding:0<ye?Array.from(i().subarray($e>>>0,$e+ye>>>0)):[],outputShape:0<Me?Array.from(i().subarray(Fe>>>0,Fe+Me>>>0)):[]})},917382:(m,_,E,L,K,Q,ne,_e,ve,ye,$e,Me,Fe,J)=>{a.Ea("ConvTranspose",m,{format:ve?"NHWC":"NCHW",autoPad:_,dilations:[E],group:L,kernel_shape:[K],pads:[Q,ne],strides:[_e],wIsConst:()=>!!r()[ye>>>0],outputPadding:$e?Array.from(i().subarray(Me>>>0,Me+$e>>>0)):[],outputShape:Fe?Array.from(i().subarray(J>>>0,J+Fe>>>0)):[]})},917762:(m,_,E,L,K,Q,ne,_e,ve,ye,$e,Me,Fe)=>{a.Ea("ConvTranspose",m,{format:_e?"NHWC":"NCHW",autoPad:_,dilations:Array.from(i().subarray(E>>>0,E+2>>>0)),group:L,kernelShape:Array.from(i().subarray(K>>>0,K+2>>>0)),pads:Array.from(i().subarray(Q>>>0,Q+4>>>0)),strides:Array.from(i().subarray(ne>>>0,ne+2>>>0)),wIsConst:()=>!!r()[ve>>>0],outputPadding:0<ye?Array.from(i().subarray($e>>>0,$e+ye>>>0)):[],outputShape:0<Me?Array.from(i().subarray(Fe>>>0,Fe+Me>>>0)):[]})},918285:(m,_)=>{a.Ea("GlobalAveragePool",m,{format:_?"NHWC":"NCHW"})},918376:(m,_,E,L,K,Q,ne,_e,ve,ye,$e,Me,Fe,J,Oe,We)=>{a.Ea("AveragePool",m,{format:We?"NHWC":"NCHW",auto_pad:_,ceil_mode:E,count_include_pad:L,storage_order:K,dilations:[Q,ne],kernel_shape:[_e,ve],pads:[ye,$e,Me,Fe],strides:[J,Oe]})},918660:(m,_)=>{a.Ea("GlobalAveragePool",m,{format:_?"NHWC":"NCHW"})},918751:(m,_,E,L,K,Q,ne,_e,ve,ye,$e,Me,Fe,J,Oe,We)=>{a.Ea("AveragePool",m,{format:We?"NHWC":"NCHW",auto_pad:_,ceil_mode:E,count_include_pad:L,storage_order:K,dilations:[Q,ne],kernel_shape:[_e,ve],pads:[ye,$e,Me,Fe],strides:[J,Oe]})},919035:(m,_)=>{a.Ea("GlobalMaxPool",m,{format:_?"NHWC":"NCHW"})},919122:(m,_,E,L,K,Q,ne,_e,ve,ye,$e,Me,Fe,J,Oe,We)=>{a.Ea("MaxPool",m,{format:We?"NHWC":"NCHW",auto_pad:_,ceil_mode:E,count_include_pad:L,storage_order:K,dilations:[Q,ne],kernel_shape:[_e,ve],pads:[ye,$e,Me,Fe],strides:[J,Oe]})},919402:(m,_)=>{a.Ea("GlobalMaxPool",m,{format:_?"NHWC":"NCHW"})},919489:(m,_,E,L,K,Q,ne,_e,ve,ye,$e,Me,Fe,J,Oe,We)=>{a.Ea("MaxPool",m,{format:We?"NHWC":"NCHW",auto_pad:_,ceil_mode:E,count_include_pad:L,storage_order:K,dilations:[Q,ne],kernel_shape:[_e,ve],pads:[ye,$e,Me,Fe],strides:[J,Oe]})},919769:(m,_,E,L,K)=>{a.Ea("Gemm",m,{alpha:_,beta:E,transA:L,transB:K})},919873:m=>{a.Ea("MatMul",m,void 0)},919927:(m,_,E,L)=>{a.Ea("ArgMax",m,{keepDims:!!_,selectLastIndex:!!E,axis:L})},920035:(m,_,E,L)=>{a.Ea("ArgMin",m,{keepDims:!!_,selectLastIndex:!!E,axis:L})},920143:(m,_)=>{a.Ea("Softmax",m,{axis:_})},920206:(m,_)=>{a.Ea("Concat",m,{axis:_})},920266:(m,_,E,L,K)=>{a.Ea("Split",m,{axis:_,numOutputs:E,splitSizes:L?Array.from(i().subarray(K>>>0,K+L>>>0)):[]})},920411:m=>{a.Ea("Expand",m,void 0)},920465:(m,_)=>{a.Ea("Gather",m,{axis:Number(_)})},920536:(m,_)=>{a.Ea("GatherElements",m,{axis:Number(_)})},920615:(m,_,E,L,K,Q,ne,_e,ve,ye,$e)=>{a.Ea("Resize",m,{antialias:_,axes:E?Array.from(i().subarray(L>>>0,L+E>>>0)):[],coordinateTransformMode:ar(K),cubicCoeffA:Q,excludeOutside:ne,extrapolationValue:_e,keepAspectRatioPolicy:ar(ve),mode:ar(ye),nearestMode:ar($e)})},920966:(m,_,E,L,K,Q,ne)=>{a.Ea("Slice",m,{starts:_?Array.from(i().subarray(E>>>0,E+_>>>0)):[],ends:L?Array.from(i().subarray(K>>>0,K+L>>>0)):[],axes:Q?Array.from(i().subarray(ne>>>0,ne+Q>>>0)):[]})},921197:m=>{a.Ea("Tile",m,void 0)},921249:(m,_,E)=>{a.Ea("LayerNormalization",m,{axis:Number(_),epsilon:Number(E)})},921356:(m,_,E)=>{a.Ea("InstanceNormalization",m,{epsilon:_,format:E?"NHWC":"NCHW"})},921470:(m,_,E)=>{a.Ea("InstanceNormalization",m,{epsilon:_,format:E?"NHWC":"NCHW"})},921584:m=>{a.Ea("Range",m,void 0)},921637:(m,_)=>{a.Ea("Einsum",m,{equation:ar(_)})},921718:(m,_,E,L,K)=>{a.Ea("Pad",m,{mode:_,value:E,pads:L?Array.from(i().subarray(K>>>0,K+L>>>0)):[]})},921850:m=>{a.Ea("Gelu",m,void 0)},921902:m=>{a.Ea("BiasAdd",m,void 0)},921957:m=>{a.Ea("BiasSplitGelu",m,void 0)},922018:(m,_)=>{a.Ea("SkipLayerNormalization",m,{epsilon:_})},922099:m=>{a.zb(m)},922133:(m,_)=>a.Ab(m,_,a.bb.Fb,a.bb.errors),922245:m=>a.wb(m),922278:m=>a.yb(m),922310:(m,_,E)=>{a.jb(m,_,E,!0)},922349:(m,_,E)=>{a.jb(m,_,E)}};function Yr(m){this.name="ExitStatus",this.message=`Program terminated with exit(${m})`,this.status=m}function An(m){m.terminate(),m.onmessage=()=>{}}function li(m){(m=Se.Qa[m])||St(),Se.Eb(m)}function On(m){var _=Se.tb();if(!_)return 6;Se.Ya.push(_),Se.Qa[m.Xa]=_,_.Xa=m.Xa;var E={cmd:"run",start_routine:m.Gb,arg:m.rb,pthread_ptr:m.Xa};return I&&_.unref(),_.postMessage(E,m.Mb),0}var ci=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,En=(m,_,E)=>{_>>>=0;var L=_+E;for(E=_;m[E]&&!(E>=L);)++E;if(16<E-_&&m.buffer&&ci)return ci.decode(m.buffer instanceof SharedArrayBuffer?m.slice(_,E):m.subarray(_,E));for(L="";_<E;){var K=m[_++];if(K&128){var Q=m[_++]&63;if((K&224)==192)L+=String.fromCharCode((K&31)<<6|Q);else{var ne=m[_++]&63;K=(K&240)==224?(K&15)<<12|Q<<6|ne:(K&7)<<18|Q<<12|ne<<6|m[_++]&63,65536>K?L+=String.fromCharCode(K):(K-=65536,L+=String.fromCharCode(55296|K>>10,56320|K&1023))}}else L+=String.fromCharCode(K)}return L},ar=(m,_)=>(m>>>=0)?En(t(),m,_):"";function Pn(m){if(k)return Qe(1,1,m);wt=m,ot()||(Se.Hb(),a.onExit&&a.onExit(m),Ge=!0),T(m,new Yr(m))}var fi=m=>{if(wt=m,k)throw xo(m),"unwind";Pn(m)},Se={ab:[],Ya:[],mb:[],Qa:{},gb:function(){k?Se.vb():Se.ub()},ub:function(){He.unshift(()=>{Kr(),Se.Bb(()=>Xr())})},vb:function(){Se.receiveObjectTransfer=Se.Db,Se.threadInitTLS=Se.lb,Se.setExitStatus=Se.kb,it=!1},kb:function(m){wt=m},Sb:["$terminateWorker"],Hb:function(){for(var m of Se.Ya)An(m);for(m of Se.ab)An(m);Se.ab=[],Se.Ya=[],Se.Qa=[]},Eb:function(m){var _=m.Xa;delete Se.Qa[_],Se.ab.push(m),Se.Ya.splice(Se.Ya.indexOf(m),1),m.Xa=0,jn(_)},Db:function(){},lb:function(){Se.mb.forEach(m=>m())},Cb:m=>new Promise(_=>{m.onmessage=Q=>{Q=Q.data;var ne=Q.cmd;if(Q.targetThread&&Q.targetThread!=nn()){var _e=Se.Qa[Q.Rb];_e?_e.postMessage(Q,Q.transferList):q('Internal error! Worker sent a message "'+ne+'" to target pthread '+Q.targetThread+", but that thread no longer exists!")}else ne==="checkMailbox"?en():ne==="spawnThread"?On(Q):ne==="cleanupThread"?li(Q.thread):ne==="killThread"?(Q=Q.thread,ne=Se.Qa[Q],delete Se.Qa[Q],An(ne),jn(Q),Se.Ya.splice(Se.Ya.indexOf(ne),1),ne.Xa=0):ne==="cancelThread"?Se.Qa[Q.thread].postMessage({cmd:"cancel"}):ne==="loaded"?(m.loaded=!0,_(m)):ne==="alert"?alert("Thread "+Q.threadId+": "+Q.text):Q.target==="setimmediate"?m.postMessage(Q):ne==="callHandler"?a[Q.handler](...Q.args):ne&&q("worker sent an unknown command "+ne)},m.onerror=Q=>{throw q("worker sent an error! "+Q.filename+":"+Q.lineno+": "+Q.message),Q},I&&(m.on("message",function(Q){m.onmessage({data:Q})}),m.on("error",function(Q){m.onerror(Q)}));var E=[],L=["onExit","onAbort","print","printErr"],K;for(K of L)a.hasOwnProperty(K)&&E.push(K);m.postMessage({cmd:"load",handlers:E,urlOrBlob:a.mainScriptUrlOrBlob||n,wasmMemory:me,wasmModule:Dt})}),Bb:function(m){m()},qb:function(){var m=F("ort-wasm-simd-threaded.worker.js");m=new Worker(m),Se.ab.push(m)},tb:function(){return Se.ab.length==0&&(Se.qb(),Se.Cb(Se.ab[0])),Se.ab.pop()}};a.PThread=Se;var Jr=m=>{for(;0<m.length;)m.shift()(a)};a.establishStackSpace=function(){var m=nn(),_=i()[m+52>>2>>>0];m=i()[m+56>>2>>>0],zi(_,_-m),on(_)};function xo(m){if(k)return Qe(2,0,m);fi(m)}a.invokeEntryPoint=function(m,_){m=Fi.apply(null,[m,_]),ot()?Se.kb(m):Gn(m)};function To(m){this.fb=m-24,this.pb=function(_){o()[this.fb+4>>2>>>0]=_},this.ob=function(_){o()[this.fb+8>>2>>>0]=_},this.gb=function(_,E){this.nb(),this.pb(_),this.ob(E)},this.nb=function(){o()[this.fb+16>>2>>>0]=0}}var Zr=0,gs=0;function sr(m,_,E,L){return k?Qe(3,1,m,_,E,L):Gt(m,_,E,L)}function Gt(m,_,E,L){if(m>>>=0,_>>>=0,E>>>=0,L>>>=0,typeof SharedArrayBuffer>"u")return q("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var K=[];return k&&K.length===0?sr(m,_,E,L):(m={Gb:E,Xa:m,rb:L,Mb:K},k?(m.Ob="spawnThread",postMessage(m,K),0):On(m))}function di(m,_,E){return k?Qe(4,1,m,_,E):0}function Qr(m,_){if(k)return Qe(5,1,m,_)}var Dn=m=>{for(var _=0,E=0;E<m.length;++E){var L=m.charCodeAt(E);127>=L?_++:2047>=L?_+=2:55296<=L&&57343>=L?(_+=4,++E):_+=3}return _},pi=(m,_,E,L)=>{if(E>>>=0,!(0<L))return 0;var K=E;L=E+L-1;for(var Q=0;Q<m.length;++Q){var ne=m.charCodeAt(Q);if(55296<=ne&&57343>=ne){var _e=m.charCodeAt(++Q);ne=65536+((ne&1023)<<10)|_e&1023}if(127>=ne){if(E>=L)break;_[E++>>>0]=ne}else{if(2047>=ne){if(E+1>=L)break;_[E++>>>0]=192|ne>>6}else{if(65535>=ne){if(E+2>=L)break;_[E++>>>0]=224|ne>>12}else{if(E+3>=L)break;_[E++>>>0]=240|ne>>18,_[E++>>>0]=128|ne>>12&63}_[E++>>>0]=128|ne>>6&63}_[E++>>>0]=128|ne&63}}return _[E>>>0]=0,E-K},_o=(m,_,E)=>pi(m,t(),_,E);function kn(m,_){if(k)return Qe(6,1,m,_)}function $o(m,_,E){if(k)return Qe(7,1,m,_,E)}function So(m,_,E){return k?Qe(8,1,m,_,E):0}function Io(m,_){if(k)return Qe(9,1,m,_)}function Co(m,_,E){if(k)return Qe(10,1,m,_,E)}function Ao(m,_,E,L){if(k)return Qe(11,1,m,_,E,L)}function Oo(m,_,E,L){if(k)return Qe(12,1,m,_,E,L)}function Bn(m,_,E,L){if(k)return Qe(13,1,m,_,E,L)}function hi(m){if(k)return Qe(14,1,m)}function V(m,_){if(k)return Qe(15,1,m,_)}function kr(m,_,E){if(k)return Qe(16,1,m,_,E)}var U=m=>{if(!Ge)try{if(m(),!ot())try{k?Gn(wt):fi(wt)}catch(_){_ instanceof Yr||_=="unwind"||T(1,_)}}catch(_){_ instanceof Yr||_=="unwind"||T(1,_)}};function W(m){m>>>=0,typeof Atomics.Nb=="function"&&(Atomics.Nb(i(),m>>2,m).value.then(en),m+=128,Atomics.store(i(),m>>2,1))}a.__emscripten_thread_mailbox_await=W;function en(){var m=nn();m&&(W(m),U(()=>Li()))}a.checkMailbox=en;var Br=m=>m%4===0&&(m%100!==0||m%400===0),mi=[0,31,60,91,121,152,182,213,244,274,305,335],gi=[0,31,59,90,120,151,181,212,243,273,304,334];function yi(m,_,E,L,K,Q,ne,_e){return k?Qe(17,1,m,_,E,L,K,Q,ne,_e):-52}function bi(m,_,E,L,K,Q,ne){if(k)return Qe(18,1,m,_,E,L,K,Q,ne)}var vi=m=>{var _=Dn(m)+1,E=Fn(_);return E&&_o(m,E,_),E},Rn=[],wi=(m,_)=>{Rn.length=0;var E;for(_>>=2;E=t()[m++>>>0];)_+=E!=105&_,Rn.push(E==105?i()[_>>>0]:s()[_++>>>1]),++_;return Rn},Eo=m=>{var _=Wn();return m=m(),on(_),m};function Qe(m,_){var E=arguments.length-2,L=arguments;return Eo(()=>{for(var K=Vn(8*E),Q=K>>3,ne=0;ne<E;ne++){var _e=L[2+ne];s()[Q+ne>>>0]=_e}return Mi(m,E,K,_)})}var Mn=[],Ln={},xi=()=>{if(!Nn){var m={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:v||"./this.program"},_;for(_ in Ln)Ln[_]===void 0?delete m[_]:m[_]=Ln[_];var E=[];for(_ in m)E.push(`${_}=${m[_]}`);Nn=E}return Nn},Nn;function Ti(m,_){if(k)return Qe(19,1,m,_);m>>>=0,_>>>=0;var E=0;return xi().forEach(function(L,K){var Q=_+E;for(K=o()[m+4*K>>2>>>0]=Q,Q=0;Q<L.length;++Q)r()[K++>>0>>>0]=L.charCodeAt(Q);r()[K>>0>>>0]=0,E+=L.length+1}),0}function _i(m,_){if(k)return Qe(20,1,m,_);m>>>=0,_>>>=0;var E=xi();o()[m>>2>>>0]=E.length;var L=0;return E.forEach(function(K){L+=K.length+1}),o()[_>>2>>>0]=L,0}function $i(m){return k?Qe(21,1,m):52}function Si(m,_,E,L){return k?Qe(22,1,m,_,E,L):52}function Ii(m,_,E,L,K){return k?Qe(23,1,m,_,E,L,K):70}var Po=[null,[],[]];function Ci(m,_,E,L){if(k)return Qe(24,1,m,_,E,L);_>>>=0,E>>>=0,L>>>=0;for(var K=0,Q=0;Q<E;Q++){var ne=o()[_>>2>>>0],_e=o()[_+4>>2>>>0];_+=8;for(var ve=0;ve<_e;ve++){var ye=t()[ne+ve>>>0],$e=Po[m];ye===0||ye===10?((m===1?Ae:q)(En($e,0)),$e.length=0):$e.push(ye)}K+=_e}return o()[L>>2>>>0]=K,0}var Ai=[31,29,31,30,31,30,31,31,30,31,30,31],Oi=[31,28,31,30,31,30,31,31,30,31,30,31];function Do(m){var _=Array(Dn(m)+1);return pi(m,_,0,_.length),_}var ko=(m,_)=>{r().set(m,_>>>0)};function Ei(m,_,E,L){function K(J,Oe,We){for(J=typeof J=="number"?J.toString():J||"";J.length<Oe;)J=We[0]+J;return J}function Q(J,Oe){return K(J,Oe,"0")}function ne(J,Oe){function We(Hi){return 0>Hi?-1:0<Hi?1:0}var xr;return(xr=We(J.getFullYear()-Oe.getFullYear()))===0&&(xr=We(J.getMonth()-Oe.getMonth()))===0&&(xr=We(J.getDate()-Oe.getDate())),xr}function _e(J){switch(J.getDay()){case 0:return new Date(J.getFullYear()-1,11,29);case 1:return J;case 2:return new Date(J.getFullYear(),0,3);case 3:return new Date(J.getFullYear(),0,2);case 4:return new Date(J.getFullYear(),0,1);case 5:return new Date(J.getFullYear()-1,11,31);case 6:return new Date(J.getFullYear()-1,11,30)}}function ve(J){var Oe=J.Za;for(J=new Date(new Date(J.$a+1900,0,1).getTime());0<Oe;){var We=J.getMonth(),xr=(Br(J.getFullYear())?Ai:Oi)[We];if(Oe>xr-J.getDate())Oe-=xr-J.getDate()+1,J.setDate(1),11>We?J.setMonth(We+1):(J.setMonth(0),J.setFullYear(J.getFullYear()+1));else{J.setDate(J.getDate()+Oe);break}}return We=new Date(J.getFullYear()+1,0,4),Oe=_e(new Date(J.getFullYear(),0,4)),We=_e(We),0>=ne(Oe,J)?0>=ne(We,J)?J.getFullYear()+1:J.getFullYear():J.getFullYear()-1}m>>>=0,_>>>=0,E>>>=0,L>>>=0;var ye=i()[L+40>>2>>>0];L={Kb:i()[L>>2>>>0],Jb:i()[L+4>>2>>>0],cb:i()[L+8>>2>>>0],ib:i()[L+12>>2>>>0],eb:i()[L+16>>2>>>0],$a:i()[L+20>>2>>>0],Wa:i()[L+24>>2>>>0],Za:i()[L+28>>2>>>0],Tb:i()[L+32>>2>>>0],Ib:i()[L+36>>2>>>0],Lb:ye?ar(ye):""},E=ar(E),ye={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var $e in ye)E=E.replace(new RegExp($e,"g"),ye[$e]);var Me="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Fe="January February March April May June July August September October November December".split(" ");ye={"%a":J=>Me[J.Wa].substring(0,3),"%A":J=>Me[J.Wa],"%b":J=>Fe[J.eb].substring(0,3),"%B":J=>Fe[J.eb],"%C":J=>Q((J.$a+1900)/100|0,2),"%d":J=>Q(J.ib,2),"%e":J=>K(J.ib,2," "),"%g":J=>ve(J).toString().substring(2),"%G":J=>ve(J),"%H":J=>Q(J.cb,2),"%I":J=>(J=J.cb,J==0?J=12:12<J&&(J-=12),Q(J,2)),"%j":J=>{for(var Oe=0,We=0;We<=J.eb-1;Oe+=(Br(J.$a+1900)?Ai:Oi)[We++]);return Q(J.ib+Oe,3)},"%m":J=>Q(J.eb+1,2),"%M":J=>Q(J.Jb,2),"%n":()=>`
`,"%p":J=>0<=J.cb&&12>J.cb?"AM":"PM","%S":J=>Q(J.Kb,2),"%t":()=>"	","%u":J=>J.Wa||7,"%U":J=>Q(Math.floor((J.Za+7-J.Wa)/7),2),"%V":J=>{var Oe=Math.floor((J.Za+7-(J.Wa+6)%7)/7);if(2>=(J.Wa+371-J.Za-2)%7&&Oe++,Oe)Oe==53&&(We=(J.Wa+371-J.Za)%7,We==4||We==3&&Br(J.$a)||(Oe=1));else{Oe=52;var We=(J.Wa+7-J.Za-1)%7;(We==4||We==5&&Br(J.$a%400-1))&&Oe++}return Q(Oe,2)},"%w":J=>J.Wa,"%W":J=>Q(Math.floor((J.Za+7-(J.Wa+6)%7)/7),2),"%y":J=>(J.$a+1900).toString().substring(2),"%Y":J=>J.$a+1900,"%z":J=>{J=J.Ib;var Oe=0<=J;return J=Math.abs(J)/60,(Oe?"+":"-")+("0000"+(J/60*100+J%60)).slice(-4)},"%Z":J=>J.Lb,"%%":()=>"%"},E=E.replace(/%%/g,"\0\0");for($e in ye)E.includes($e)&&(E=E.replace(new RegExp($e,"g"),ye[$e](L)));return E=E.replace(/\0\0/g,"%"),$e=Do(E),$e.length>_?0:(ko($e,m),$e.length-1)}function tn(m){try{m()}catch(_){St(_)}}function Bo(m){var _={},E;for(E in m)(function(L){var K=m[L];_[L]=typeof K=="function"?function(){rn.push(L);try{return K.apply(null,arguments)}finally{Ge||(rn.pop()===L||St(),Wt&&ur===1&&rn.length===0&&(ur=0,ft+=1,tn(Gi),typeof Fibers<"u"&&Fibers.Ub()))}}:K})(E);return _}var ur=0,Wt=null,Pi=0,rn=[],Di={},ki={},Ro=0,zn=null,Mo=[];function Lo(){return new Promise((m,_)=>{zn={resolve:m,reject:_}})}function No(){var m=Fn(65548),_=m+12;o()[m>>2>>>0]=_,o()[m+4>>2>>>0]=_+65536,_=rn[0];var E=Di[_];return E===void 0&&(E=Ro++,Di[_]=E,ki[E]=_),_=E,i()[m+8>>2>>>0]=_,m}function zo(){var m=i()[Wt+8>>2>>>0];return m=de[ki[m]],--ft,m()}function Fo(m){if(!Ge){if(ur===0){var _=!1,E=!1;m((L=0)=>{if(!Ge&&(Pi=L,_=!0,E)){ur=2,tn(()=>Wi(Wt)),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),L=!1;try{var K=zo()}catch(_e){K=_e,L=!0}var Q=!1;if(!Wt){var ne=zn;ne&&(zn=null,(L?ne.reject:ne.resolve)(K),Q=!0)}if(L&&!Q)throw K}}),E=!0,_||(ur=1,Wt=No(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),tn(()=>ji(Wt)))}else ur===2?(ur=0,tn(Vi),Bi(Wt),Wt=null,Mo.forEach(L=>U(L))):St(`invalid state: ${ur}`);return Pi}}function jo(m){return Fo(_=>{m().then(_)})}Se.gb();var Go=[null,Pn,xo,sr,di,Qr,kn,$o,So,Io,Co,Ao,Oo,Bn,hi,V,kr,yi,bi,Ti,_i,$i,Si,Ii,Ci],Wo={r:function(m,_,E){return jo(async()=>{await a.xb(m,_,E)})},b:function(m,_,E){throw m>>>=0,new To(m).gb(_>>>0,E>>>0),Zr=m,gs++,Zr},O:function(m){Ri(m>>>0,!O,1,!S,131072,!1),Se.lb()},l:function(m){m>>>=0,k?postMessage({cmd:"cleanupThread",thread:m}):li(m)},I:Gt,i:di,U:Qr,E:kn,G:$o,V:So,S:Io,K:Co,R:Ao,p:Oo,F:Bn,C:hi,T:V,D:kr,q:()=>!0,A:function(m,_){m>>>=0,m==_>>>0?setTimeout(()=>en()):k?postMessage({targetThread:m,cmd:"checkMailbox"}):(m=Se.Qa[m])&&m.postMessage({cmd:"checkMailbox"})},M:function(){return-1},N:W,X:function(m){I&&Se.Qa[m>>>0].ref()},u:function(m,_,E){m=_+2097152>>>0<4194305-!!m?(m>>>0)+4294967296*_:NaN,E>>>=0,m=new Date(1e3*m),i()[E>>2>>>0]=m.getUTCSeconds(),i()[E+4>>2>>>0]=m.getUTCMinutes(),i()[E+8>>2>>>0]=m.getUTCHours(),i()[E+12>>2>>>0]=m.getUTCDate(),i()[E+16>>2>>>0]=m.getUTCMonth(),i()[E+20>>2>>>0]=m.getUTCFullYear()-1900,i()[E+24>>2>>>0]=m.getUTCDay(),m=(m.getTime()-Date.UTC(m.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,i()[E+28>>2>>>0]=m},v:function(m,_,E){m=_+2097152>>>0<4194305-!!m?(m>>>0)+4294967296*_:NaN,E>>>=0,m=new Date(1e3*m),i()[E>>2>>>0]=m.getSeconds(),i()[E+4>>2>>>0]=m.getMinutes(),i()[E+8>>2>>>0]=m.getHours(),i()[E+12>>2>>>0]=m.getDate(),i()[E+16>>2>>>0]=m.getMonth(),i()[E+20>>2>>>0]=m.getFullYear()-1900,i()[E+24>>2>>>0]=m.getDay(),_=(Br(m.getFullYear())?mi:gi)[m.getMonth()]+m.getDate()-1|0,i()[E+28>>2>>>0]=_,i()[E+36>>2>>>0]=-(60*m.getTimezoneOffset()),_=new Date(m.getFullYear(),6,1).getTimezoneOffset();var L=new Date(m.getFullYear(),0,1).getTimezoneOffset();m=(_!=L&&m.getTimezoneOffset()==Math.min(L,_))|0,i()[E+32>>2>>>0]=m},w:function(m){m>>>=0;var _=new Date(i()[m+20>>2>>>0]+1900,i()[m+16>>2>>>0],i()[m+12>>2>>>0],i()[m+8>>2>>>0],i()[m+4>>2>>>0],i()[m>>2>>>0],0),E=i()[m+32>>2>>>0],L=_.getTimezoneOffset(),K=new Date(_.getFullYear(),6,1).getTimezoneOffset(),Q=new Date(_.getFullYear(),0,1).getTimezoneOffset(),ne=Math.min(Q,K);return 0>E?i()[m+32>>2>>>0]=+(K!=Q&&ne==L):0<E!=(ne==L)&&(K=Math.max(Q,K),_.setTime(_.getTime()+6e4*((0<E?ne:K)-L))),i()[m+24>>2>>>0]=_.getDay(),E=(Br(_.getFullYear())?mi:gi)[_.getMonth()]+_.getDate()-1|0,i()[m+28>>2>>>0]=E,i()[m>>2>>>0]=_.getSeconds(),i()[m+4>>2>>>0]=_.getMinutes(),i()[m+8>>2>>>0]=_.getHours(),i()[m+12>>2>>>0]=_.getDate(),i()[m+16>>2>>>0]=_.getMonth(),i()[m+20>>2>>>0]=_.getYear(),m=_.getTime()/1e3,Ni((vr=m,1<=+Math.abs(vr)?0<vr?+Math.floor(vr/4294967296)>>>0:~~+Math.ceil((vr-+(~~vr>>>0))/4294967296)>>>0:0)),m>>>0},s:yi,t:bi,z:function(m,_,E){function L(ye){return(ye=ye.toTimeString().match(/\(([A-Za-z ]+)\)$/))?ye[1]:"GMT"}m>>>=0,_>>>=0,E>>>=0;var K=new Date().getFullYear(),Q=new Date(K,0,1),ne=new Date(K,6,1);K=Q.getTimezoneOffset();var _e=ne.getTimezoneOffset(),ve=Math.max(K,_e);o()[m>>2>>>0]=60*ve,i()[_>>2>>>0]=+(K!=_e),m=L(Q),_=L(ne),m=vi(m),_=vi(_),_e<K?(o()[E>>2>>>0]=m,o()[E+4>>2>>>0]=_):(o()[E>>2>>>0]=_,o()[E+4>>2>>>0]=m)},d:()=>{St("")},c:function(m,_,E){return m>>>=0,_=wi(_>>>0,E>>>0),wr[m].apply(null,_)},k:function(m,_,E){return m>>>=0,_=wi(_>>>0,E>>>0),wr[m].apply(null,_)},m:function(){},j:function(){return Date.now()},W:()=>{throw ft+=1,"unwind"},B:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:function(){return I?(Mg(),Rr(Rg)).cpus().length:navigator.hardwareConcurrency},L:function(m,_,E,L){for(Se.Pb=_>>>0,Mn.length=E,_=L>>>0>>3,L=0;L<E;L++)Mn[L]=s()[_+L>>>0];return(0>m?wr[-m-1]:Go[m]).apply(null,Mn)},y:function(m){m>>>=0;var _=t().length;if(m<=_||4294901760<m)return!1;for(var E=1;4>=E;E*=2){var L=_*(1+.2/E);L=Math.min(L,m+100663296);var K=Math;L=Math.max(m,L);e:{K=K.min.call(K,4294901760,L+(65536-L%65536)%65536)-me.buffer.byteLength+65535>>>16;try{me.grow(K),ie();var Q=1;break e}catch{}Q=void 0}if(Q)return!0}return!1},P:Ti,Q:_i,H:fi,h:$i,o:Si,x:Ii,n:Ci,a:me||a.wasmMemory,J:Ei,e:function(m,_,E,L){return Ei(m>>>0,_>>>0,E>>>0,L>>>0)}};(function(){function m(E,L){return E=E.exports,E=Bo(E),de=E=Vo(E),Se.mb.push(de.Da),kt.unshift(de.Y),Dt=L,Xr(),E}var _={a:Wo};if(Kr(),a.instantiateWasm)try{return a.instantiateWasm(_,m)}catch(E){q("Module.instantiateWasm callback failed with error: "+E),c(E)}return ui(_,function(E){m(E.instance,E.module)}).catch(c),{}})(),a._OrtInit=(m,_)=>(a._OrtInit=de.Z)(m,_),a._OrtGetLastError=(m,_)=>(a._OrtGetLastError=de._)(m,_),a._OrtCreateSessionOptions=(m,_,E,L,K,Q,ne,_e,ve,ye)=>(a._OrtCreateSessionOptions=de.$)(m,_,E,L,K,Q,ne,_e,ve,ye),a._OrtAppendExecutionProvider=(m,_)=>(a._OrtAppendExecutionProvider=de.aa)(m,_),a._OrtAddFreeDimensionOverride=(m,_,E)=>(a._OrtAddFreeDimensionOverride=de.ba)(m,_,E),a._OrtAddSessionConfigEntry=(m,_,E)=>(a._OrtAddSessionConfigEntry=de.ca)(m,_,E),a._OrtReleaseSessionOptions=m=>(a._OrtReleaseSessionOptions=de.da)(m),a._OrtCreateSession=(m,_,E)=>(a._OrtCreateSession=de.ea)(m,_,E),a._OrtReleaseSession=m=>(a._OrtReleaseSession=de.fa)(m),a._OrtGetInputOutputCount=(m,_,E)=>(a._OrtGetInputOutputCount=de.ga)(m,_,E),a._OrtGetInputName=(m,_)=>(a._OrtGetInputName=de.ha)(m,_),a._OrtGetOutputName=(m,_)=>(a._OrtGetOutputName=de.ia)(m,_),a._OrtFree=m=>(a._OrtFree=de.ja)(m),a._OrtCreateTensor=(m,_,E,L,K,Q)=>(a._OrtCreateTensor=de.ka)(m,_,E,L,K,Q),a._OrtGetTensorData=(m,_,E,L,K)=>(a._OrtGetTensorData=de.la)(m,_,E,L,K),a._OrtReleaseTensor=m=>(a._OrtReleaseTensor=de.ma)(m),a._OrtCreateRunOptions=(m,_,E,L)=>(a._OrtCreateRunOptions=de.na)(m,_,E,L),a._OrtAddRunConfigEntry=(m,_,E)=>(a._OrtAddRunConfigEntry=de.oa)(m,_,E),a._OrtReleaseRunOptions=m=>(a._OrtReleaseRunOptions=de.pa)(m),a._OrtCreateBinding=m=>(a._OrtCreateBinding=de.qa)(m),a._OrtBindInput=(m,_,E)=>(a._OrtBindInput=de.ra)(m,_,E),a._OrtBindOutput=(m,_,E,L)=>(a._OrtBindOutput=de.sa)(m,_,E,L),a._OrtClearBoundOutputs=m=>(a._OrtClearBoundOutputs=de.ta)(m),a._OrtReleaseBinding=m=>(a._OrtReleaseBinding=de.ua)(m),a._OrtRunWithBinding=(m,_,E,L,K)=>(a._OrtRunWithBinding=de.va)(m,_,E,L,K),a._OrtRun=(m,_,E,L,K,Q,ne,_e)=>(a._OrtRun=de.wa)(m,_,E,L,K,Q,ne,_e),a._OrtEndProfiling=m=>(a._OrtEndProfiling=de.xa)(m),a._JsepOutput=(m,_,E)=>(a._JsepOutput=de.ya)(m,_,E),a._JsepGetNodeName=m=>(a._JsepGetNodeName=de.za)(m);var nn=a._pthread_self=()=>(nn=a._pthread_self=de.Aa)(),Fn=a._malloc=m=>(Fn=a._malloc=de.Ba)(m),Bi=a._free=m=>(Bi=a._free=de.Ca)(m);a.__emscripten_tls_init=()=>(a.__emscripten_tls_init=de.Da)();var Ri=a.__emscripten_thread_init=(m,_,E,L,K,Q)=>(Ri=a.__emscripten_thread_init=de.Fa)(m,_,E,L,K,Q);a.__emscripten_thread_crashed=()=>(a.__emscripten_thread_crashed=de.Ga)();var Mi=(m,_,E,L)=>(Mi=de.Ha)(m,_,E,L),jn=m=>(jn=de.Ia)(m),Gn=a.__emscripten_thread_exit=m=>(Gn=a.__emscripten_thread_exit=de.Ja)(m),Li=a.__emscripten_check_mailbox=()=>(Li=a.__emscripten_check_mailbox=de.Ka)(),Ni=m=>(Ni=de.La)(m),zi=(m,_)=>(zi=de.Ma)(m,_),Wn=()=>(Wn=de.Na)(),on=m=>(on=de.Oa)(m),Vn=m=>(Vn=de.Pa)(m),Fi=a.dynCall_ii=(m,_)=>(Fi=a.dynCall_ii=de.Ra)(m,_),ji=m=>(ji=de.Sa)(m),Gi=()=>(Gi=de.Ta)(),Wi=m=>(Wi=de.Ua)(m),Vi=()=>(Vi=de.Va)();a.___start_em_js=922382,a.___stop_em_js=922543;function Vo(m){m=Object.assign({},m);var _=L=>()=>L()>>>0,E=L=>K=>L(K)>>>0;return m.__errno_location=_(m.__errno_location),m.pthread_self=_(m.pthread_self),m.malloc=E(m.malloc),m.stackSave=_(m.stackSave),m.stackAlloc=E(m.stackAlloc),m}a.keepRuntimeAlive=ot,a.wasmMemory=me,a.stackAlloc=Vn,a.stackSave=Wn,a.stackRestore=on,a.UTF8ToString=ar,a.stringToUTF8=_o,a.lengthBytesUTF8=Dn,a.ExitStatus=Yr,a.PThread=Se;var an;nr=function m(){an||Ui(),an||(nr=m)};function Ui(){function m(){if(!an&&(an=!0,a.calledRun=!0,!Ge)&&(k||Jr(kt),u(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),!k)){if(a.postRun)for(typeof a.postRun=="function"&&(a.postRun=[a.postRun]);a.postRun.length;){var _=a.postRun.shift();Lt.unshift(_)}Jr(Lt)}}if(!(0<Nt))if(k)u(a),k||Jr(kt),startWorker(a);else{if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;)He.unshift(a.preRun.shift());Jr(He),0<Nt||(a.setStatus?(a.setStatus("Running..."),setTimeout(function(){setTimeout(function(){a.setStatus("")},1),m()},1)):m())}}if(a.preInit)for(typeof a.preInit=="function"&&(a.preInit=[a.preInit]);0<a.preInit.length;)a.preInit.pop()();return Ui(),e.ready}})();typeof Ng=="object"&&typeof Pu=="object"?Pu.exports=Lg:typeof define=="function"&&define.amd&&define([],()=>Lg)});var Fg=et((YB,r$)=>{r$.exports='"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\n'});var Gg,n$,Du,ku,ja,jg,i$,o$,a$,Wg,gt,ii=X(()=>{"use strict";Gg=Dg();n$=zg(),ku=!1,ja=!1,jg=!1,i$=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},o$=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},a$=(n,e)=>n?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":e?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Wg=async n=>{if(ku)return Promise.resolve();if(ja)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(jg)throw new Error("previous call to 'initializeWebAssembly()' failed.");ja=!0;let e=n.initTimeout,r=n.numThreads,t=n.simd,i=r>1&&i$(),o=t&&o$(),s=n.wasmPaths,a=typeof s=="string"?s:void 0,u=a$(o,i),c=typeof s=="object"?s[u]:void 0,g=!1,v=[];if(e>0&&v.push(new Promise(T=>{setTimeout(()=>{g=!0,T()},e)})),v.push(new Promise((T,S)=>{let O=i?n$:Gg,I={locateFile:(k,M)=>{if(i&&k.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Fg()],{type:"text/javascript"}));if(k.endsWith(".wasm")){if(c)return c;let F=a??M;return u==="ort-wasm-simd.wasm"?F+"ort-wasm-simd.jsep.wasm":u==="ort-wasm-simd-threaded.wasm"?F+"ort-wasm-simd-threaded.jsep.wasm":F+u}return M+k}};if(i)if(typeof Blob>"u")I.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let k=`var ortWasmThreaded=${O.toString()};`;I.mainScriptUrlOrBlob=new Blob([k],{type:"text/javascript"})}O(I).then(k=>{ja=!1,ku=!0,Du=k,T()},k=>{ja=!1,jg=!0,S(k)})})),await Promise.race(v),g)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},gt=()=>{if(ku&&Du)return Du;throw new Error("WebAssembly is not initialized yet.")}});var Tt,lo,ut,Ga=X(()=>{"use strict";ii();Tt=(n,e)=>{let r=gt(),t=r.lengthBytesUTF8(n)+1,i=r._malloc(t);return r.stringToUTF8(n,i,t),e.push(i),i},lo=(n,e,r,t)=>{if(typeof n=="object"&&n!==null){if(r.has(n))throw new Error("Circular reference in options");r.add(n)}Object.entries(n).forEach(([i,o])=>{let s=e?e+i:i;if(typeof o=="object")lo(o,s+".",r,t);else if(typeof o=="string"||typeof o=="number")t(s,o.toString());else if(typeof o=="boolean")t(s,o?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof o}`)})},ut=n=>{let e=gt(),r=e.stackSave();try{let t=e.stackAlloc(8);e._OrtGetLastError(t,t+4);let i=e.HEAP32[t/4],o=e.HEAPU32[t/4+1],s=o?e.UTF8ToString(o):"";throw new Error(`${n} ERROR_CODE: ${i}, ERROR_MESSAGE: ${s}`)}finally{e.stackRestore(r)}}});var Vg,Ug=X(()=>{"use strict";ii();Ga();Vg=n=>{let e=gt(),r=0,t=[],i=n||{};try{if(n?.logSeverityLevel===void 0)i.logSeverityLevel=2;else if(typeof n.logSeverityLevel!="number"||!Number.isInteger(n.logSeverityLevel)||n.logSeverityLevel<0||n.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${n.logSeverityLevel}`);if(n?.logVerbosityLevel===void 0)i.logVerbosityLevel=0;else if(typeof n.logVerbosityLevel!="number"||!Number.isInteger(n.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${n.logVerbosityLevel}`);n?.terminate===void 0&&(i.terminate=!1);let o=0;return n?.tag!==void 0&&(o=Tt(n.tag,t)),r=e._OrtCreateRunOptions(i.logSeverityLevel,i.logVerbosityLevel,!!i.terminate,o),r===0&&ut("Can't create run options."),n?.extra!==void 0&&lo(n.extra,"",new WeakSet,(s,a)=>{let u=Tt(s,t),c=Tt(a,t);e._OrtAddRunConfigEntry(r,u,c)!==0&&ut(`Can't set a run config entry: ${s} - ${a}.`)}),[r,t]}catch(o){throw r!==0&&e._OrtReleaseRunOptions(r),t.forEach(s=>e._free(s)),o}}});var s$,u$,l$,c$,Hg,qg=X(()=>{"use strict";ii();Ga();s$=n=>{switch(n){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${n}`)}},u$=n=>{switch(n){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${n}`)}},l$=n=>{n.extra||(n.extra={}),n.extra.session||(n.extra.session={});let e=n.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1"),n.executionProviders&&n.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(n.enableMemPattern=!1)},c$=(n,e,r)=>{for(let t of e){let i=typeof t=="string"?t:t.name;switch(i){case"xnnpack":i="XNNPACK";break;case"webnn":if(i="WEBNN",typeof t!="string"){let s=t;if(s?.deviceType){let a=Tt("deviceType",r),u=Tt(s.deviceType,r);gt()._OrtAddSessionConfigEntry(n,a,u)!==0&&ut(`Can't set a session config entry: 'deviceType' - ${s.deviceType}.`)}if(s?.powerPreference){let a=Tt("powerPreference",r),u=Tt(s.powerPreference,r);gt()._OrtAddSessionConfigEntry(n,a,u)!==0&&ut(`Can't set a session config entry: 'powerPreference' - ${s.powerPreference}.`)}}break;case"webgpu":if(i="JS",typeof t!="string"){let s=t;if(s?.preferredLayout){if(s.preferredLayout!=="NCHW"&&s.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${s.preferredLayout}`);let a=Tt("preferredLayout",r),u=Tt(s.preferredLayout,r);gt()._OrtAddSessionConfigEntry(n,a,u)!==0&&ut(`Can't set a session config entry: 'preferredLayout' - ${s.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${i}`)}let o=Tt(i,r);gt()._OrtAppendExecutionProvider(n,o)!==0&&ut(`Can't append execution provider: ${i}.`)}},Hg=n=>{let e=gt(),r=0,t=[],i=n||{};l$(i);try{let o=s$(i.graphOptimizationLevel??"all"),s=u$(i.executionMode??"sequential"),a=typeof i.logId=="string"?Tt(i.logId,t):0,u=i.logSeverityLevel??2;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log serverity level is not valid: ${u}`);let c=i.logVerbosityLevel??0;if(!Number.isInteger(c)||c<0||c>4)throw new Error(`log verbosity level is not valid: ${c}`);let g=typeof i.optimizedModelFilePath=="string"?Tt(i.optimizedModelFilePath,t):0;if(r=e._OrtCreateSessionOptions(o,!!i.enableCpuMemArena,!!i.enableMemPattern,s,!!i.enableProfiling,0,a,u,c,g),r===0&&ut("Can't create session options."),i.executionProviders&&c$(r,i.executionProviders,t),i.freeDimensionOverrides)for(let[v,T]of Object.entries(i.freeDimensionOverrides)){if(typeof v!="string")throw new Error(`free dimension override name must be a string: ${v}`);if(typeof T!="number"||!Number.isInteger(T)||T<0)throw new Error(`free dimension override value must be a non-negative integer: ${T}`);let S=Tt(v,t);e._OrtAddFreeDimensionOverride(r,S,T)!==0&&ut(`Can't set a free dimension override: ${v} - ${T}.`)}return i.extra!==void 0&&lo(i.extra,"",new WeakSet,(v,T)=>{let S=Tt(v,t),O=Tt(T,t);e._OrtAddSessionConfigEntry(r,S,O)!==0&&ut(`Can't set a session config entry: ${v} - ${T}.`)}),[r,t]}catch(o){throw r!==0&&e._OrtReleaseSessionOptions(r),t.forEach(s=>e._free(s)),o}}});var Bu,co,fo,Wa,po,Va,Ru,_t=X(()=>{"use strict";Bu=n=>{switch(n){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${n}`)}},co=n=>{switch(n){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${n}`)}},fo=n=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][n],Wa=n=>{switch(n){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${n}`)}},po=n=>{switch(n){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${n}`)}},Va=n=>n==="float32"||n==="int32"||n==="int64"||n==="bool"||n==="float16"||n==="uint32",Ru=n=>{switch(n){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${n}`)}}});var f$,d$,Kg,Xg,Yg,p$,ct,Hr=X(()=>{"use strict";_t();f$=["V","I","W","E","F"],d$=(n,e)=>{console.log(`[${f$[n]},${new Date().toISOString()}]${e}`)},Yg=(n,e)=>{Kg=n,Xg=e},p$=(n,e)=>{let r=po(n),t=po(Kg);r>=t&&d$(r,typeof e=="function"?e():e)},ct=(...n)=>{Xg&&p$(...n)}});var Jg,Zg=X(()=>{"use strict";_t();Jg=(n,e)=>new(Wa(e))(n)});var Qg=X(()=>{"use strict"});var Ua,h$,ey,Lu,Mu,ty,ry=X(()=>{"use strict";Hr();Qg();Ua=n=>Math.ceil(n/16)*16,h$=1,ey=()=>h$++,Lu=async(n,e,r,t)=>{let i=Ua(r),o=n.device.createBuffer({size:i,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let s=n.getCommandEncoder();n.endComputePass(),s.copyBufferToBuffer(e,0,o,0,i),n.flush(),await o.mapAsync(GPUMapMode.READ);let a=o.getMappedRange();if(t){let u=t();return u.set(new Uint8Array(a,0,r)),u}else return new Uint8Array(a.slice(0,r))}finally{o.destroy()}},Mu=class{constructor(e){this.backend=e;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(e,r){let t=r.buffer,i=r.byteOffset,o=r.byteLength,s=Ua(o),a=this.storageCache.get(e);if(!a)throw new Error("gpu data for uploading does not exist");if(a.originalSize!==o)throw new Error(`inconsistent data size. gpu data size=${a.originalSize}, data size=${o}`);let u=this.backend.device.createBuffer({mappedAtCreation:!0,size:s,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),c=u.getMappedRange();new Uint8Array(c).set(new Uint8Array(t,i,o)),u.unmap();let g=this.backend.getCommandEncoder();this.backend.endComputePass(),g.copyBufferToBuffer(u,0,a.gpuData.buffer,0,s),ct("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${e})`),this.buffersForUploadingPending.push(u)}memcpy(e,r){let t=this.storageCache.get(e);if(!t)throw new Error("source gpu data for memcpy does not exist");let i=this.storageCache.get(r);if(!i)throw new Error("destination gpu data for memcpy does not exist");if(t.originalSize!==i.originalSize)throw new Error("inconsistent source and destination gpu data size");let o=Ua(t.originalSize),s=this.backend.getCommandEncoder();this.backend.endComputePass(),s.copyBufferToBuffer(t.gpuData.buffer,0,i.gpuData.buffer,0,o)}registerExternalBuffer(e,r,t){let i;if(t){if(i=this.externalBuffers.get(t),i===void 0)throw new Error("previous buffer is not registered");if(e===t)return ct("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${i}, buffer is the same, skip.`),i;this.externalBuffers.delete(t)}else i=ey();return this.storageCache.set(i,{gpuData:{id:i,type:0,buffer:e},originalSize:r}),this.externalBuffers.set(e,i),ct("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${i}, registered.`),i}unregisterExternalBuffer(e){let r=this.externalBuffers.get(e);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(e),ct("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(e,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let t=Ua(e),i,o=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,s=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(o||s){let u=o?this.freeBuffers:this.freeUniformBuffers,c=u.get(t);c||(c=[],u.set(t,c)),c.length>0?i=c.pop():i=this.backend.device.createBuffer({size:t,usage:r})}else i=this.backend.device.createBuffer({size:t,usage:r});let a={id:ey(),type:0,buffer:i};return this.storageCache.set(a.id,{gpuData:a,originalSize:e}),ct("verbose",()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${a.id}`),a}get(e){return this.storageCache.get(e)?.gpuData}release(e){let r=this.storageCache.get(e);if(!r)throw new Error("releasing data does not exist");return ct("verbose",()=>`[WebGPU] GpuDataManager.release(id=${e}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(e),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(e,r){let t=this.storageCache.get(e);if(!t)throw new Error("data does not exist");await Lu(this.backend,t.gpuData.buffer,t.originalSize,r)}refreshPendingBuffers(){for(let e of this.buffersForUploadingPending)e.destroy();this.buffersForUploadingPending=[];for(let e of this.buffersPending)(e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(e.size).push(e):(e.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(e.size).push(e):e.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(e=>{e.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(e=>{e.forEach(r=>{r.destroy()})}),this.storageCache.forEach(e=>{e.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},ty=(...n)=>new Mu(...n)});var Nu,Ce,yt=X(()=>{"use strict";Nu=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this._cacheKey}},Ce=n=>new Nu(n)});var zu,Ar,re,_n,Ha,qa,Ka,je=X(()=>{"use strict";zu=class{static calcMatMulShape(e,r){return e[1]!==r[0]?void 0:[e[0],r[1]]}},Ar=class{static calcShape(e,r,t=!1){let i=e.length,o=r.length;if(i===0)return r;if(o===0)return e;let s=Math.max(e.length,r.length),a=new Array(s);if(t){if(i<2||o<2)return;let u=zu.calcMatMulShape([e[i-2],e[i-1]],[r[o-2],r[o-1]]);if(u===void 0)return;[a[s-2],a[s-1]]=u}for(let u=t?3:1;u<=s;u++){let c=i-u<0?1:e[i-u],g=o-u<0?1:r[o-u];if(c!==g&&c>1&&g>1)return;a[s-u]=Math.max(c,g)}return a}static isValidBroadcast(e,r){let t=e.length,i=r.length;if(t>i)return!1;for(let o=1;o<=t;o++)if(e[t-o]!==1&&e[t-o]!==r[i-o])return!1;return!0}},re=class n{static size(e){return n.getSizeFromDimensionRange(e,0,e.length)}static sizeFromDimension(e,r){if(r<0||r>e.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return n.getSizeFromDimensionRange(e,r,e.length)}static sizeToDimension(e,r){if(r<0||r>e.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${e.length} dimensions.`);return n.getSizeFromDimensionRange(e,0,r)}static getSizeFromDimensionRange(e,r,t){let i=1;for(let o=r;o<t;o++){if(e[o]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");i*=e[o]}return i}static computeStrides(e){let r=e.length;if(r===0)return[];if(r===1)return[1];let t=new Array(r);t[r-1]=1,t[r-2]=e[r-1];for(let i=r-3;i>=0;--i)t[i]=t[i+1]*e[i+1];return t}static normalizeAxis(e,r){if(e<-r&&e>=r)throw new Error("unsupported axis for this operation.");return e<0?e+r:e}static normalizeAxes(e,r){return e.map(t=>this.normalizeAxis(t,r??e.length))}static sortBasedOnPerm(e,r){return r?r.map(t=>e[t]):e.slice().reverse()}static padShape(e,r){let t=e.length;return e.map((i,o)=>i+r[o]+r[o+t])}static areEqual(e,r){return e.length!==r.length?!1:e.every((t,i)=>t===r[i])}},_n=class n{static adjustPoolAttributes(e,r,t,i,o,s){if(!e&&t.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let a=0;a<r.length-2;a++)a>=t.length?t.push(r[a+2]):t[a]=r[a+2];for(let a=0;a<t.length;a++)if(a<i.length){if(i[a]<0)throw new Error("strides should be greater than or equal to 1")}else i.push(1);for(let a=0;a<t.length;a++)if(a<o.length){if(o[a]<0)throw new Error("dilations should be greater than or equal to 1")}else o.push(1);for(let a=0;a<t.length*2;a++)if(a<s.length){if(s[a]<0)throw new Error("pad should be greater than or equal to 1")}else s.push(0);for(let a=0;a<t.length;a++){if(t[a]<=0)throw new Error("kernel shapes need to be greater than 0");if(s[a]>=t[a]||s[a+t.length]>=t[a])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,r,t,i,o,s,a){if(a){if(o.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(i.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let u=0;u<e.length-2;u++)n.adjustPadAndReturnShape(e[u+(s?1:2)],r[u],t[u],i[u],o,u,u+e.length-2,a)}}static computePoolOutputShape(e,r,t,i,o,s,a){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let u=[r[0],r[1]];return n.computeShapeHelper(e,r,u,t,i,o,s,a),u}static computeConvOutputShape(e,r,t,i,o,s,a){if(e.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let u=[e[0],r[0]];return n.computeShapeHelper(!1,e,u,t,i,o,s,a),u}static computeShapeHelper(e,r,t,i,o,s,a,u){if(e)for(let c=0;c<r.length-2;c++)t.push(1);else for(let c=0;c<r.length-2;c++)t.push(n.adjustPadAndReturnShape(r[c+2],i[c],o[c],s[c],a,c,c+r.length-2,u))}static adjustPadAndReturnShape(e,r,t,i,o,s,a,u){let c=t*(i-1)+1;if(u&&u!=="NOTSET")switch(u){case"VALID":return o[s]=0,o[a]=0,Math.floor((e-c)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(t!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let v=((e+r-1)/r-1)*r+i-e;return o[s]=Math.floor(u==="SAME_LOWER"?(v+1)/2:v/2),o[a]=v-o[s],Math.floor((e+v-i)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((e+o[s]+o[a]-c)/r+1)}},Ha=class{static getShapeOfGemmResult(e,r,t,i,o){if(e.length!==2||t.length!==2)throw new Error("shape need to be of size 2");let s,a,u;r?(s=e[1],a=e[0]):(s=e[0],a=e[1]);let c=-1;if(i?(u=t[0],c=1):(u=t[1],c=0),t[c]!==a)throw new Error("dimension mismatch");if(s<=0||u<=0||a<=0)throw new Error("invalid shape specified");if(o&&!Ar.isValidBroadcast(o,[s,u]))throw new Error("gemm: invalid bias shape for broadcast");return[s,u,a]}},qa=-34028234663852886e22,Ka=34028234663852886e22});var m$,ny,bt,ju,$n,mr,Sn,oi,iy,fe,Te,Fu,oy,Gu,Je=X(()=>{"use strict";_t();je();m$=64,ny=(n,e)=>{if(e===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(n){case 10:return e>1?`vec${e}<f16>`:"f16";case 1:return e>1?`vec${e}<f32>`:"f32";case 6:return e>1?`vec${e}<i32>`:"i32";case 12:return e>1?`vec${e}<u32>`:"u32";case 7:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(e!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${n}`)}},bt=(n,e=1)=>{let r=ny(n,e);return typeof r=="string"?r:r[0]},ju=n=>[{type:"uint32",data:n},{type:"uint32",data:re.computeStrides(n)}],$n=n=>n%4===0?4:n%2===0?2:1,mr=(n="f32",e,r="0")=>!e||e===1?`${n}(${r})`:`vec${e}<${n}>(${r})`,Sn=(n,e,r)=>n==="f32"?r:e===1?`f32(${r})`:`vec${e}f(${r})`,oi=(n,e)=>e===4?`(${n}.x + ${n}.y + ${n}.z + ${n}.w)`:e===2?`(${n}.x + ${n}.y)`:e===3?`(${n}.x + ${n}.y + ${n}.z)`:n,iy=(n,e,r,t,i)=>{let o=typeof r=="number",s=o?r:r.length,a=[...new Array(s).keys()],u=s<2?"u32":s<=4?`vec${s}<u32>`:`array<u32, ${s}>`,c=ny(e,i),g=typeof c=="string"?c:c[1],v=typeof c=="string"?c:c[0],T={indices:u,value:g,storage:v,tensor:e},S=ie=>typeof ie=="string"?ie:`${ie}u`,O={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},I=o?"uniforms.":"",k=`${I}${n}_shape`,M=`${I}${n}_strides`,F="";for(let ie=0;ie<s-1;ie++)F+=`
    let dim${ie} = current / ${M}[${ie}];
    let rest${ie} = current % ${M}[${ie}];
    indices[${ie}] = dim${ie};
    current = rest${ie};
    `;F+=`indices[${s-1}] = current;`;let j=s<2?"":`
  fn o2i_${n}(offset: u32) -> ${T.indices} {
    var indices: ${T.indices};
    var current = offset;
    ${F}
    return indices;
  }`,Y=ie=>(O.offsetToIndices=!0,s<2?ie:`o2i_${n}(${ie})`),Z=[];if(s>=2)for(let ie=s-1;ie>=0;ie--)Z.push(`${M}[${ie}] * (indices[${ie}])`);let P=s<2?"":`
  fn i2o_${n}(indices: ${T.indices}) -> u32 {
    return ${Z.join("+")};
  }`,te=ie=>(O.indicesToOffset=!0,s<2?ie:`i2o_${n}(${ie})`),ue=(...ie)=>s===0?"0u":`${T.indices}(${ie.map(S).join(",")})`,le=(ie,Be)=>s<2?`${ie}`:`${ie}[${Be}]`,Ae=(ie,Be,He)=>s<2?`${ie}=${He};`:`${ie}[${Be}]=${He};`,q={},ge=(ie,Be)=>{O.broadcastedIndicesToOffset=!0;let He=`${Be.name}broadcastedIndicesTo${n}Offset`;if(He in q)return`${He}(${ie})`;let kt=[];for(let Lt=s-1;Lt>=0;Lt--){let ft=Be.indicesGet("outputIndices",Lt+Be.rank-s);kt.push(`${le(M,Lt)} * (${ft} % ${le(k,Lt)})`)}return q[He]=`fn ${He}(outputIndices: ${Be.type.indices}) -> u32 {
             return ${kt.length>0?kt.join("+"):"0u"};
           }`,`${He}(${ie})`},it=(ie,Be)=>(()=>{if(T.storage===T.value)return`${n}[${ie}]=${Be};`;if(T.storage==="vec2<u32>"&&T.value==="i32")return`${n}[${ie}]=vec2<u32>(u32(${Be}), select(0u, 0xFFFFFFFFu, ${Be} < 0));`;if(T.storage==="vec2<u32>"&&T.value==="u32")return`${n}[${ie}]=vec2<u32>(u32(${Be}), 0u);`;if(T.storage==="u32"&&T.value==="vec4<bool>")return`${n}[${ie}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${Be}));`;throw new Error(`not supported combination of storage type ${T.storage} and value type ${T.value} yet`)})(),me=ie=>(()=>{if(T.storage===T.value)return`${n}[${ie}]`;if(T.storage==="vec2<u32>"&&T.value==="i32")return`i32(${n}[${ie}].x)`;if(T.storage==="vec2<u32>"&&T.value==="u32")return`u32(${n}[${ie}].x)`;if(T.storage==="u32"&&T.value==="vec4<bool>")return`vec4<bool>(bool(${n}[${ie}] & 0xFFu), bool(${n}[${ie}] & 0xFF00u), bool(${n}[${ie}] & 0xFF0000u), bool(${n}[${ie}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${T.storage} and value type ${T.value} yet`)})(),de=s<2?"":`
  fn get_${n}ByIndices(indices: ${T.indices}) -> ${g} {
    return ${me(`i2o_${n}(indices)`)};
  }`,Dt=s<2?"":(()=>{let ie=a.map(He=>`d${He}: u32`).join(", "),Be=a.map(He=>`d${He}`).join(", ");return`
  fn get_${n}(${ie}) -> ${g} {
    return get_${n}ByIndices(${ue(Be)});
  }`})(),Ge=(...ie)=>{if(ie.length!==s)throw new Error(`indices length must be ${s}`);let Be=ie.map(S).join(",");return s===0?me("0u"):s===1?me(Be[0]):(O.get=!0,O.getByIndices=!0,O.indicesToOffset=!0,`get_${n}(${Be})`)},wt=ie=>s<2?me(ie):(O.getByIndices=!0,O.indicesToOffset=!0,`get_${n}ByIndices(${ie})`),Ye=s<2?"":`
  fn set_${n}ByIndices(indices: ${T.indices}, value: ${g}) {
    ${it(`i2o_${n}(indices)`,"value")}
  }`,$t=s<2?"":(()=>{let ie=a.map(He=>`d${He}: u32`).join(", "),Be=a.map(He=>`d${He}`).join(", ");return`
  fn set_${n}(${ie}, value: ${g}) {
    set_${n}ByIndices(${ue(Be)}, value);
  }`})();return{impl:()=>{let ie=[];return o||(ie.push(`const ${k} = ${T.indices}(${r.join(",")});`),ie.push(`const ${M} = ${T.indices}(${re.computeStrides(r).join(",")});`)),O.offsetToIndices&&ie.push(j),O.indicesToOffset&&ie.push(P),O.broadcastedIndicesToOffset&&Object.values(q).forEach(Be=>ie.push(Be)),O.set&&ie.push($t),O.setByIndices&&ie.push(Ye),O.get&&ie.push(Dt),O.getByIndices&&ie.push(de),ie.join(`
`)},type:T,offsetToIndices:Y,indicesToOffset:te,broadcastedIndicesToOffset:ge,indices:ue,indicesGet:le,indicesSet:Ae,set:(...ie)=>{if(ie.length!==s+1)throw new Error(`indices length must be ${s}`);let Be=ie[s];if(typeof Be!="string")throw new Error("value must be string");let He=ie.slice(0,s).map(S).join(",");return s===0?it("0u",Be):s===1?it(He[0],Be):(O.set=!0,O.setByIndices=!0,O.indicesToOffset=!0,`set_${n}(${He}, ${Be})`)},setByOffset:it,setByIndices:(ie,Be)=>s<2?it(ie,Be):(O.setByIndices=!0,O.indicesToOffset=!0,`set_${n}ByIndices(${ie}, ${Be});`),get:Ge,getByOffset:me,getByIndices:wt,usage:t?"input":"output",name:n,strides:M,shape:k,rank:s}},fe=(n,e,r,t=1)=>iy(n,e,r,!0,t),Te=(n,e,r,t=1)=>iy(n,e,r,!1,t),Fu=class{constructor(e){this.normalizedDispatchGroup=e;this.indicesHelpers=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${typeof e=="number"?`${e}u`:e}) { return; }`}mainStart(e=m$){let r=typeof e=="number"?e:e[0],t=typeof e=="number"?1:e[1],i=typeof e=="number"?1:e[2],o=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,s=o?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>`,a=o?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +
          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${r*t*i}u + local_index;`;return`@compute @workgroup_size(${r}, ${t}, ${i})
  fn main(${s}) {
    ${a}
  `}declareVariable(e,r){this.indicesHelpers.push(e),e.shape.startsWith("uniforms.")&&this.uniforms.push({name:e.shape.replace("uniforms.",""),type:e.type.indices}),e.strides.startsWith("uniforms.")&&this.uniforms.push({name:e.strides.replace("uniforms.",""),type:e.type.indices});let t=e.usage==="input"?"read":"read_write",i=e.type.storage;return`@group(0) @binding(${r}) var<storage, ${t}> ${e.name}: array<${i}>;`}declareVariables(...e){return e.map(r=>this.declareVariable(r,this.variableIndex++)).join(`
`)}registerUniform(e,r){return this.uniforms.push({name:e,type:r}),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let e=[];for(let{name:r,type:t}of this.uniforms)e.push(`${r}:${t}`);return`
      struct Uniforms { ${e.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.indicesHelpers.map(e=>e.impl()).join(`
`)}},oy=n=>new Fu(n),Gu=(n,e)=>{let r=n.length,t=[];for(let i=0;i<r;i++){let o=r-1-i,s=n[o]||1;(e[e.length-1-i]||1)>1&&s===1&&t.unshift(o)}return t}});var Or,g$,Xa,y$,Er,ay,sy,uy,ly,cy,fy,dy,py,hy,my,gr,Wu=X(()=>{"use strict";je();yt();Je();Or=n=>{if(!n||n.length===0||n.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(n.length===2&&n[1].dims.length!==1)throw new Error("Invalid axes input dims.")},g$=n=>["","",`var value = ${n.getByOffset("inputOffset")};`,""],Xa=(n,e,r,t,i,o,s=!1,a=!1)=>{let u=[],c=r[0].dims,g=re.normalizeAxes(i,r[0].dims.length),v=!a&&g.length===0;c.forEach((te,ue)=>{v||g.indexOf(ue)>=0?s&&u.push(1):u.push(te)});let T=[],S=fe("_A",r[0].dataType,c),O=Te("output",o,u),I=t(S,O,g),k=`inputOffset = ${S.indicesToOffset("inputIndices")};`,M=`let ${k};`,F=`var ${k};`,j=I[1]===""?"":F,Y=(I[1]===""?M:k)+`
`+I[2];for(let te=0,ue=0;te<r[0].dims.length;te++)v||g.indexOf(te)>=0?(s&&ue++,Y=`for(var j${te}: u32 = 0; j${te} < ${r[0].dims[te]}; j${te}++) {
                ${I[2].includes("lastIndex")?`let lastIndex = j${te};`:""}
                ${S.indicesSet("inputIndices",te,`j${te}`)}
                ${Y}
              }`):(T.push(`${S.indicesSet("inputIndices",te,O.indicesGet("outputIndices",ue))};`),ue++);let Z=re.size(u);return{name:n,shaderCache:e,getShaderSource:te=>`
        ${te.declareVariables(S,O)}

        ${te.mainStart()}
          ${te.guardAgainstOutOfBoundsWorkgroupSizes(Z)}
          var inputIndices: ${S.type.indices};
          let outputIndices = ${O.offsetToIndices("global_idx")};

          ${T.join(`
`)}
          ${I[0]}       // init ops for reduce max/min
          ${j}
          ${I[1]}
          ${Y}
          ${I[3]}
          ${I.length===4?O.setByOffset("global_idx","value"):I.slice(4).join(`
`)}
        }`,getRunData:()=>({outputs:[{dims:u,dataType:o}],dispatchGroup:{x:Math.ceil(Z/64)}})}},y$=(n,e)=>{let r=[];return n[1].dims[0]>0&&n[1].getBigInt64Array().forEach(t=>r.push(Number(t))),Ce({axes:r,keepDims:e.keepDims,noopWithEmptyAxes:e.noopWithEmptyAxes})},Er=(n,e,r,t)=>{let i=n.inputs,o=i.length===1?r:y$(i,r);n.compute(Xa(e,{hint:o.cacheKey},[i[0]],o.noopWithEmptyAxes&&o.axes.length===0?g$:t,o.axes,i[0].dataType,o.keepDims,o.noopWithEmptyAxes),{inputs:[0]})},ay=(n,e)=>{Or(n.inputs),Er(n,"ReduceLogSum",e,(t,i)=>[`var value = ${i.type.storage}(0);`,"",`value += ${t.getByOffset("inputOffset")};`,"value = log(value);"])},sy=(n,e)=>{Or(n.inputs),Er(n,"ReduceL1",e,(t,i)=>[`var value = ${i.type.storage}(0);`,"",`value += abs(${t.getByOffset("inputOffset")});`,""])},uy=(n,e)=>{Or(n.inputs),Er(n,"ReduceL2",e,(t,i)=>[`var t = ${i.type.value}(0); var value = ${i.type.value}(0);`,"",`t = ${t.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])},ly=(n,e)=>{Or(n.inputs),Er(n,"ReduceLogSumExp",e,(t,i)=>[`var value = ${i.type.storage}(0);`,"",`value += exp(${t.getByOffset("inputOffset")});`,"value = log(value);"])},cy=(n,e)=>{Or(n.inputs),Er(n,"ReduceMax",e,(t,i,o)=>{let s=[];for(let a=0;a<t.rank;a++)(o.indexOf(a)>=0||o.length===0)&&s.push(t.indicesSet("inputIndices",a,0));return[`${s.join(`
`)}`,`var value = ${t.getByOffset("inputOffset")};`,`value = max(value, ${t.getByOffset("inputOffset")});`,""]})},fy=(n,e)=>{Or(n.inputs),Er(n,"ReduceMean",e,(t,i,o)=>{let s=1;for(let a=0;a<t.rank;a++)(o.indexOf(a)>=0||o.length===0)&&(s*=n.inputs[0].dims[a]);return["var sum = f32(0);","",`sum += f32(${t.getByOffset("inputOffset")});`,`let value = ${i.type.value}(sum / ${s});`]})},dy=(n,e)=>{Or(n.inputs),Er(n,"ReduceMin",e,(t,i,o)=>{let s=[];for(let a=0;a<t.rank;a++)(o.indexOf(a)>=0||o.length===0)&&s.push(`inputIndices[${a}] = 0;`);return[`${s.join(`
`)}`,`var value = ${t.getByOffset("inputOffset")};`,`value = min(value, ${t.getByOffset("inputOffset")});`,""]})},py=(n,e)=>{Or(n.inputs),Er(n,"ReduceProd",e,(t,i)=>[`var value = ${i.type.storage}(1);`,"",`value *= ${t.getByOffset("inputOffset")};`,""])},hy=(n,e)=>{Or(n.inputs),Er(n,"ReduceSum",e,(t,i)=>[`var value = ${i.type.storage}(0);`,"",`value += ${t.getByOffset("inputOffset")};`,""])},my=(n,e)=>{Or(n.inputs),Er(n,"ReduceSumSquare",e,(t,i)=>[`var t = ${i.type.value}(0); var value = ${i.type.value}(0);`,"",`t = ${t.getByOffset("inputOffset")}; value += t * t;`,""])},gr=n=>Ce(n)});var gy,yy,by,vy,Vu,wy=X(()=>{"use strict";_t();yt();Wu();gy=n=>{if(!n||n.length===0||n.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(n[0].dataType!==1)throw new Error("Invalid input type.")},yy=(n,e)=>Ce({axis:e.axis,keepDims:e.keepDims,selectLastIndex:e.selectLastIndex}),by=(n,e)=>{gy(n.inputs);let r=(i,o,s)=>{let a=[];for(let u=0;u<i.rank;u++)(s.indexOf(u)>=0||s.length===0)&&a.push(`inputIndices[${u}] = 0;`);return[`${a.join(`
`)}`,`var value = ${i.getByOffset("inputOffset")};
var bestIndex : i32 = 0;`,`if (${i.getByOffset("inputOffset")} ${e.selectLastIndex>0?"<=":"<"} value) {
         value = ${i.getByOffset("inputOffset")};
         bestIndex = i32(lastIndex);
       }`,"",o.setByOffset("global_idx","bestIndex")]},t=n.inputs.length===1?e:yy(n.inputs,e);n.compute(Xa("ArgMin",{hint:t.cacheKey},[n.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},vy=(n,e)=>{gy(n.inputs);let r=(i,o,s)=>{let a=[];for(let u=0;u<i.rank;u++)(s.indexOf(u)>=0||s.length===0)&&a.push(`inputIndices[${u}] = 0;`);return[`${a.join(`
`)}`,`var value = ${i.getByOffset("inputOffset")};
var bestIndex : i32 = 0;`,`if (${i.getByOffset("inputOffset")} ${e.selectLastIndex>0?">=":">"} value) {
         value = ${i.getByOffset("inputOffset")};
         bestIndex = i32(lastIndex);
       }`,"",o.setByOffset("global_idx","bestIndex")]},t=n.inputs.length===1?e:yy(n.inputs,e);n.compute(Xa("argMax",{hint:t.cacheKey},[n.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},Vu=n=>Ce(n)});var b$,v$,xy,Ty=X(()=>{"use strict";je();Je();b$=n=>{if(n[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(n[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(n[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(n[0].dims[2]!==n[1].dims[0])throw new Error("last dimension of input and bias are not the same")},v$=n=>{let e=n[0].dims,r=n[0].dims[2],t=re.size(e)/4,i=n[0].dataType,o=fe("input",i,e,4),s=fe("bias",i,[r],4),a=fe("residual",i,e,4),u=Te("output",i,e,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:e,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(t/64)}}),getShaderSource:g=>`
  const channels = ${r}u / 4;
  ${g.declareVariables(o,s,a,u)}

  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes(t)}
    let value = ${o.getByOffset("global_idx")}
      + ${s.getByOffset("global_idx % channels")} + ${a.getByOffset("global_idx")};
    ${u.setByOffset("global_idx","value")}
  }`}},xy=n=>{b$(n.inputs),n.compute(v$(n.inputs))}});var w$,Ze,_y,$y,Sy,Iy,Cy,Ay,Oy,Ey,Py,Uu,x$,Dy,ky,By,Ry,Ya,My,Ja,Ly,Ny,zy,Fy,jy,Gy,Wy,Vy,Uy,Hy,qy,Ky,Xy,Yy,Jy,Zy,Qy,Hu=X(()=>{"use strict";_t();je();yt();Je();w$=(n,e,r,t,i,o)=>{let s=Math.ceil(e/4),a="";typeof i=="string"?a=`${i}(a)`:a=i("a");let u=fe("inputData",r,[s],4),c=Te("outputData",t,[s],4);return`
  ${n.declareVariables(u,c)}

  ${o??""}

  ${n.mainStart()}
    ${n.guardAgainstOutOfBoundsWorkgroupSizes(s)}

    let a = ${u.getByOffset("global_idx")};
    ${c.setByOffset("global_idx",a)}
  }`},Ze=(n,e,r,t,i,o=n.dataType)=>({name:e,shaderCache:{hint:i},getShaderSource:s=>w$(s,re.size(n.dims),n.dataType,o,r,t),getRunData:s=>({outputs:[{dims:n.dims,dataType:o}],dispatchGroup:{x:Math.ceil(re.size(s[0].dims)/64/4)}})}),_y=n=>{n.compute(Ze(n.inputs[0],"Abs","abs"))},$y=n=>{n.compute(Ze(n.inputs[0],"Acos","acos"))},Sy=n=>{n.compute(Ze(n.inputs[0],"Acosh","acosh"))},Iy=n=>{n.compute(Ze(n.inputs[0],"Asin","asin"))},Cy=n=>{n.compute(Ze(n.inputs[0],"Asinh","asinh"))},Ay=n=>{n.compute(Ze(n.inputs[0],"Atan","atan"))},Oy=n=>{n.compute(Ze(n.inputs[0],"Atanh","atanh"))},Ey=n=>Ce(n),Py=(n,e)=>{let r;switch(e.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${e.to}`)}n.compute(Ze(n.inputs[0],"Cast",r,void 0,e.cacheKey,e.to))},Uu=(n,e)=>{let r=bt(n.inputs[0].dataType);n.compute(Ze(n.inputs[0],"Clip",t=>`clamp(${t}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<${r}> = vec4(${r}(${e.min}));
    const clip_max_: vec4<${r}> = vec4(${r}(${e.max}));
`,e.cacheKey),{inputs:[0]})},x$=n=>{let e=n.length>=2?n[1].getFloat32Array()[0]:qa,r=n.length>=3?n[2].getFloat32Array()[0]:Ka;return Ce({min:e,max:r})},Dy=n=>{let e=x$(n.inputs);Uu(n,e)},ky=n=>{n.compute(Ze(n.inputs[0],"Ceil","ceil"))},By=n=>{n.compute(Ze(n.inputs[0],"Cos","cos"))},Ry=n=>{n.compute(Ze(n.inputs[0],"Cosh","cosh"))},Ya=n=>Ce(n),My=(n,e)=>{n.compute(Ze(n.inputs[0],"Elu",r=>`elu_vf32(${r})`,`
  const elu_alpha_: f32 = f32(${e.alpha});

  fn elu_f32(a: f32) -> f32 {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,e.cacheKey))},Ja=(n,e="f32")=>`
const r0: ${e} = 0.3275911;
const r1: ${e} = 0.254829592;
const r2: ${e} = -0.284496736;
const r3: ${e} = 1.421413741;
const r4: ${e} = -1.453152027;
const r5: ${e} = 1.061405429;

fn erf_vf32(v: ${n}) -> ${n} {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,Ly=n=>{let e=bt(n.inputs[0].dataType);n.compute(Ze(n.inputs[0],"Erf",r=>`erf_vf32(${r})`,Ja(`vec4<${e}>`,e)))},Ny=n=>{n.compute(Ze(n.inputs[0],"Exp","exp"))},zy=n=>{n.compute(Ze(n.inputs[0],"Floor","floor"))},Fy=n=>{let e=bt(n.inputs[0].dataType);n.compute(Ze(n.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,Ja(`vec4<${e}>`,e)))},jy=(n,e)=>{n.compute(Ze(n.inputs[0],"LeakyRelu",r=>`select(leaky_relu_alpha_ * ${r}, ${r}, ${r} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${e.alpha});`,e.cacheKey))},Gy=n=>{n.compute(Ze(n.inputs[0],"Not",e=>`!${e}`))},Wy=n=>{n.compute(Ze(n.inputs[0],"Neg",e=>`-${e}`))},Vy=n=>{n.compute(Ze(n.inputs[0],"Reciprocal",e=>`1.0/${e}`))},Uy=n=>{n.compute(Ze(n.inputs[0],"Relu",e=>`select(vec4<f32>(0.0), ${e}, ${e} > vec4<f32>(0.0))`))},Hy=n=>{n.compute(Ze(n.inputs[0],"Sigmoid",e=>`(1.0 / (1.0 + exp(-${e})))`))},qy=n=>{n.compute(Ze(n.inputs[0],"Sin","sin"))},Ky=n=>{n.compute(Ze(n.inputs[0],"Sinh","sinh"))},Xy=n=>{n.compute(Ze(n.inputs[0],"Sqrt","sqrt"))},Yy=n=>{n.compute(Ze(n.inputs[0],"Tan","tan"))},Jy=n=>{n.compute(Ze(n.inputs[0],"Tanh","tanh"))},Zy=(n,e)=>(n.compute(Ze(n.inputs[0],"ThresholdedRelu",r=>`select(vec4<f32>(0.0), ${r}, ${r} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${e.alpha});`,e.cacheKey)),0),Qy=n=>{n.compute(Ze(n.inputs[0],"Log","log"))}});var _$,$$,eb,tb=X(()=>{"use strict";je();Je();Hu();_$=n=>{if(n[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(n[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(n[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(n[0].dims[2]!==n[1].dims[0])throw new Error("last dimension of input and bias are not the same")},$$=n=>{let e=n[0].dims.slice();e[2]=e[2]/2;let r=fe("input",n[0].dataType,n[0].dims,4),t=fe("bias",n[0].dataType,[n[0].dims[2]],4),i=Te("output",n[0].dataType,e,4),o=re.size(e)/4;return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:e,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:a=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${n[0].dims[2]/4/2}u;

  ${a.declareVariables(r,t,i)}

  ${Ja("vec4f")}

  ${a.mainStart()}
    ${a.guardAgainstOutOfBoundsWorkgroupSizes(o)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${i.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},eb=n=>{_$(n.inputs),n.compute($$(n.inputs))}});var S$,I$,Pr,rb,nb,ib,ob,ab,sb,ub,lb,cb,fb,db=X(()=>{"use strict";_t();je();Je();S$=(n,e,r,t,i,o,s,a,u,c,g)=>{let v=re.size(t),T=Math.ceil(v/4),S,O;typeof s=="string"?S=O=(Y,Z)=>`${s}((${Y}),(${Z}))`:typeof s=="function"?S=O=s:(S=s.scalar,O=s.vector);let I="",k=Te("outputData",c,t,4),M=fe("aData",a,e,4),F=fe("bData",u,r,4);if(o){let Y=Z=>{let P=re.computeStrides(Z),te=[];for(let ue=Z.length-1;ue>=0;ue--){let le=k.indicesGet("outputIndices",ue+t.length-Z.length);te.push(`${P[ue]}u * (${le} % ${Z[ue]}u)`)}return te.length>0?te.join("+"):"0u"};I=`
          fn calcOffsetA(outputIndices: ${k.type.indices}) -> u32 {
            return ${Y(e)};
          }

          fn calcOffsetB(outputIndices: ${k.type.indices}) -> u32 {
            return ${Y(r)};
          }
        `}let j;if(i)if(o){let Y=re.size(e)===1,Z=re.size(r)===1;Y||Z?j=k.setByOffset("global_idx",O(Y?`${M.type.value}(${M.getByOffset("0")}.x)`:M.getByOffset("global_idx"),Z?`${F.type.value}(${F.getByOffset("0")}.x)`:F.getByOffset("global_idx"))):j=`
            let outputIndices = ${k.offsetToIndices("global_idx * 4u")};
            let offsetA = calcOffsetA(outputIndices);
            let offsetB = calcOffsetB(outputIndices);
            ${k.setByOffset("global_idx",O(M.getByOffset("offsetA / 4u"),F.getByOffset("offsetB / 4u")))}
          `}else j=k.setByOffset("global_idx",O(M.getByOffset("global_idx"),F.getByOffset("global_idx")));else{if(!o)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let Y=(Z,P,te="")=>{let ue=`aData[indexA${P}][componentA${P}]`,le=`bData[indexB${P}][componentB${P}]`;return`
            let outputIndices${P} = ${k.offsetToIndices(`global_idx * 4u + ${P}u`)};
            let offsetA${P} = calcOffsetA(outputIndices${P});
            let offsetB${P} = calcOffsetB(outputIndices${P});
            let indexA${P} = offsetA${P} / 4u;
            let indexB${P} = offsetB${P} / 4u;
            let componentA${P} = offsetA${P} % 4u;
            let componentB${P} = offsetB${P} % 4u;
            ${Z}[${P}] = ${te}(${S(ue,le)});
          `};c===9?j=`
            var data = vec4<u32>(0);
            ${Y("data",0,"u32")}
            ${Y("data",1,"u32")}
            ${Y("data",2,"u32")}
            ${Y("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:j=`
            ${Y("outputData[global_idx]",0)}
            ${Y("outputData[global_idx]",1)}
            ${Y("outputData[global_idx]",2)}
            ${Y("outputData[global_idx]",3)}
          `}return`
        ${n.declareVariables(M,F,k)}

        ${g??""}
        ${I}

        ${n.mainStart()}
        ${n.guardAgainstOutOfBoundsWorkgroupSizes(T)}
        ${j}
      }`},I$=(n,e,r,t,i,o,s=r.dataType)=>{let a=!re.areEqual(r.dims,t.dims),u=r.dims,c=re.size(r.dims),g=!1;if(a){let v=Ar.calcShape(r.dims,t.dims,!1);if(!v)throw new Error("Can't perform binary op on the given tensors");u=v,c=re.size(u);let T=re.size(r.dims)===1,S=re.size(t.dims)===1,O=1;for(let I=1;I<u.length;I++){let k=r.dims[r.dims.length-I]??1,M=t.dims[t.dims.length-I]??1;if(k===M)O*=k;else break}(O%4===0||T||S)&&(g=!0)}else g=!0;return{name:n,shaderCache:{hint:e},getShaderSource:v=>S$(v,r.dims,t.dims,u,g,a,i,r.dataType,t.dataType,s,o),getRunData:()=>({outputs:[{dims:u,dataType:s}],dispatchGroup:{x:Math.ceil(c/64/4)}})}},Pr=(n,e,r,t,i,o)=>{n.compute(I$(e,i??"",n.inputs[0],n.inputs[1],r,t,o))},rb=n=>{Pr(n,"Add",(e,r)=>`${e}+${r}`)},nb=n=>{Pr(n,"Div",(e,r)=>`${e}/${r}`)},ib=n=>{Pr(n,"Equal",{scalar:(e,r)=>`u32(${e}==${r})`,vector:(e,r)=>`vec4<u32>(${e}==${r})`},void 0,void 0,9)},ob=n=>{Pr(n,"Mul",(e,r)=>`${e}*${r}`)},ab=n=>{let e=fe("input",n.inputs[0].dataType,n.inputs[0].dims).type.value;Pr(n,"Pow",{scalar:(t,i)=>`pow_custom(${t},${i})`,vector:(t,i)=>`pow_vector_custom(${t},${i})`},`
    fn pow_custom(a : ${e}, b : ${e}) -> ${e} {
      if (b == ${e}(0.0)) {
        return ${e}(1.0);
      } else if (a < ${e}(0.0) && f32(b) != floor(f32(b))) {
        return ${e}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${e}(1.0), round(f32(abs(b) % ${e}(2.0))) != 1.0) * ${e}(${e==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${e}>, b : vec4<${e}>) -> vec4<${e}> {
      // TODO: implement vectorized pow
      return vec4<${e}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},sb=n=>{Pr(n,"Sub",(e,r)=>`${e}-${r}`)},ub=n=>{Pr(n,"Greater",{scalar:(e,r)=>`u32(${e}>${r})`,vector:(e,r)=>`vec4<u32>(${e}>${r})`},void 0,void 0,9)},lb=n=>{Pr(n,"Less",{scalar:(e,r)=>`u32(${e}<${r})`,vector:(e,r)=>`vec4<u32>(${e}<${r})`},void 0,void 0,9)},cb=n=>{Pr(n,"GreaterOrEqual",{scalar:(e,r)=>`u32(${e}>=${r})`,vector:(e,r)=>`vec4<u32>(${e}>=${r})`},void 0,void 0,9)},fb=n=>{Pr(n,"LessOrEqual",{scalar:(e,r)=>`u32(${e}<=${r})`,vector:(e,r)=>`vec4<u32>(${e}<=${r})`},void 0,void 0,9)}});var A$,O$,E$,P$,pb,hb,mb=X(()=>{"use strict";je();yt();Je();A$=n=>{if(!n||n.length<1)throw new Error("too few inputs");let e=n[0].dataType,r=n[0].dims.length;for(let t of n){if(t.dataType!==e)throw new Error("input tensors should be one type");if(t.dims.length!==r)throw new Error("input tensors should have the same shape")}},O$=n=>`
  fn calculateInputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${n}u; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${n}u;
  }`,E$=(n,e)=>{let r=n.length,t=[];for(let i=0;i<r;++i){let o=e.setByOffset("global_idx",n[i].getByIndices("indices"));r===1?t.push(o):i===0?t.push(`if (inputIndex == ${i}u) { ${o} }`):i===r-1?t.push(`else { ${o} }`):t.push(`else if (inputIndex == ${i}) { ${o} }`)}return t.join(`
`)},P$=(n,e)=>{let r=n[0].dims.slice();if(e>=r.length||e<-1*r.length)throw new Error("axis specified for concat doesn't match input dimensionality");let t=e<0?r.length+e:e,i=r.slice(0);for(let S=1;S<n.length;S++){let O=n[S].dims.slice();for(let I=0;I<r.length;I++)if(I===t)i[t]+=O[I];else if(r[I]!==O[I])throw new Error("non concat dimensions must match")}let o=re.size(i),s=new Array(n.length),a=new Array(n.length),u=n[0].dataType,c=0;for(let S=0;S<n.length;++S)c+=n[S].dims[t],s[S]=c,a[S]=fe(`input${S}`,u,n[S].dims);let g=Te("output",u,i),v=g.indicesGet("indices",t),T=S=>`
  ${S.declareVariables(...a,g)}

  const sizeInConcatAxis = array<u32, ${s.length}>(${s.map(O=>`${O}u`).join(",")});
  ${O$(s.length)}

  ${S.mainStart()}
    ${S.guardAgainstOutOfBoundsWorkgroupSizes(o)}

    var indices = ${g.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${v});
    if (inputIndex != 0u) {
      ${v} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${E$(a,g)}
  }`;return{name:"Concat",shaderCache:{hint:`${e}`},getRunData:()=>({outputs:[{dims:i,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:T}},pb=(n,e)=>{A$(n.inputs),n.compute(P$(n.inputs,e.axis))},hb=n=>Ce({axis:n.axis})});var At,Za,Qa,es=X(()=>{"use strict";At=(n,e)=>{switch(n){case 1:return e;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${n}-component is not supported.`)}},Za=(n,e=!1,r=!1,t=3)=>"",Qa=(n,e)=>`
      ${n?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `});var ts,qu=X(()=>{"use strict";ts=`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));
}
`});var rs,ns,ho=X(()=>{"use strict";je();rs=n=>{switch(n.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${n.clipMin});const clip_max_=f32(${n.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},ns=n=>{let e=n?.activation||"";if(e==="Clip"){let[r,t]=n?.activation_params||[qa,Ka];return{activation:e,clipMax:t,clipMin:r,activationCacheKey:`${e}:${r},${t}`}}return{activation:e,activationCacheKey:e}}});var D$,k$,mo,gb,B$,go,R$,is,yo=X(()=>{"use strict";je();Je();ho();es();D$=(n,e)=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${e?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${e?", batchIndices":""});
        `,k$=(n,e)=>n?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${e===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,mo=(n,e,r="f32",t,i=!1,o=32,s=!1,a=32)=>{let u=e[1]*n[1],c=e[0]*n[0],g=i?u:o,v=i?o:u,T=g/e[0],S=o/e[1];if(!((i&&T===4&&n[1]===4||!i&&(T===3||T===4))&&g%e[0]===0&&o%e[1]===0&&n[0]===4))throw new Error(`If transposeA ${i} is true, innerElementSize ${T} and workPerThread[1] ${n[1]} must be 4.
      Otherwise, innerElementSize ${T} must be 3 or 4.
  tileAWidth ${g} must be divisible by workgroupSize[0]${e[0]}. tileInner ${o} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${n[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${T}<${r}>, ${g/T}>, ${v}>;
var<workgroup> mm_Bsub: array<array<vec4<${r}>, ${c/n[0]}>, ${o}>;

const rowPerThread = ${n[1]};
const colPerThread = ${n[0]};
const innerElementSize = ${T};
const tileInner = ${o};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${s?"0":"i32(globalId.z)"};
  ${t?`let batchIndices = ${t.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${u};

  let numTiles = ${s?`${Math.ceil(a/o)}`:"(dimInner - 1) / tileInner + 1"};
  var kStart = ${s?`i32(globalId.z) * ${a}`:"0"};

  var acc: array<vec4<${r}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${S};
  for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${D$(i,t)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${S}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${t?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${T===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${k$(i,T)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},gb=(n,e)=>n?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${e?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${e?", batchIndices":""});
            `,B$=n=>n?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",go=(n,e,r="f32",t,i=!1,o=32,s=!1,a=32,u=!1)=>{let c=n[1]*e[1],g=n[0]*e[0],v=i?c:o,T=i?o:c;if(!(T%e[1]===0&&v%e[0]===0&&o%e[1]===0))throw new Error(`tileAHight ${T} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${v} must be divisible by workgroupSize[0]${e[0]}, tileInner ${o} must be divisible by workgroupSize[1]${e[1]}`);let S=T/e[1],O=v/e[0],I=o/e[1],k=u?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${c};
    let globalColStart = i32(workgroupId.x) * ${g};

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${T}; inputRow = inputRow + ${e[1]}) {
        for (var inputCol = localCol; inputCol < ${v}; inputCol = inputCol + ${e[0]}) {
          ${gb(i,t)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${o}; inputRow = inputRow + ${e[1]}) {
            for (var inputCol = localCol; inputCol < ${g}; inputCol = inputCol + ${e[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${t?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${r}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${i?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${e[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${e[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${c};

let tileRowA = i32(localId.y) * ${S};
let tileColA = i32(localId.x) * ${O};
let tileRowB = i32(localId.y) * ${I};
// Loop over shared dimension.
for (var t = 0; t < numTiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${S}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${O}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${gb(i,t)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${I}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${t?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${r}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${B$(i)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${r}, ${v}>, ${T}>;
  var<workgroup> mm_Bsub : array<array<${r}, ${g}>, ${o}>;
  const rowPerThread = ${n[1]};
  const colPerThread = ${n[0]};
  const tileInner = ${o};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${s?"0":"i32(globalId.z)"};
    ${t?`let batchIndices = ${t.offsetToIndices("u32(batch)")};`:""}
    let numTiles = ${s?`${Math.ceil(a/o)}`:"(dimInner - 1) / tileInner + 1"};
    var kStart = ${s?`i32(globalId.z) * ${a}`:"0"};

    var acc : array<array<${r}, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${k}
  }
`},R$=(n,e,r,t,i,o=!1)=>{let s=i[0],a=i[1],u=i[2],c=t[0],g=t[1],v=t[2],T=t[3],S=Gu(s,u),O=Gu(a,u),I=bt(t[0].type.tensor),k=()=>{let j=g.rank,Y=c.rank,Z=`var aIndices: ${g.type.indices};`;for(let P=j-2-1,te=Y-1;P>=0;P--,te--)Z+=`
aIndices[${P}] = ${Y>1?`batchIndices[${te}]`:"batchIndices"};`;return S.forEach(P=>{Z+=`
aIndices[${P}] = 0;`}),Z+=`
aIndices[${j-2}] = u32(row);
                   aIndices[${j-1}] = u32(colIn);`,Z},M=()=>{let j=v.rank,Y=c.rank,Z=`var bIndices: ${v.type.indices};`;for(let P=j-2-1,te=Y-1;P>=0;P--,te--)Z+=`
bIndices[${P}] = ${Y>1?`batchIndices[${te}]`:"batchIndices"};`;return O.forEach(P=>{Z+=`
bIndices[${P}] = 0;`}),Z+=`
bIndices[${j-2}] = u32(row);
                   bIndices[${j-1}] = u32(colIn);`,Z};return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${c.type.indices}) -> ${At(n,I)} {
      var value = ${At(n,I)}(0.0);
      let col = colIn * ${n};
      if(row < dimAOuter && col < dimInner)
      {
        ${k()}
        value = ${g.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${c.type.indices}) -> ${At(n,I)} {
      var value = ${At(n,I)}(0.0);
      let col = colIn * ${n};
      if(row < dimInner && col < dimBOuter)
      {
        ${M()}
        value = ${v.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${At(n,I)}) {
      let col = colIn * ${n};
      if (row < dimAOuter && col < dimBOuter) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${e?`value = value + ${o?"bias[colIn]":`${At(n,I)}(bias[row])`};`:""}
        ${r}
        ${T.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},is=(n,e,r,t,i=!1)=>{let o=n[0].dims,s=n[1].dims,a=o.slice(0,-2),u=s.slice(0,-2),c=t?t.slice(0,-2):r.slice(0,-2),g=fe("batchDims",n[0].dataType,c),v=[g],T=[a,u,c],S=re.size(c),O=o[o.length-2],I=o[o.length-1],k=s[s.length-1],M=I%4===0&&k%4===0,{activationFunction:F,applyActivation:j}=rs(e),Y=O<=8?[4,1,1]:[4,4,1],Z=[8,8,1],P=[Math.ceil(k/Z[0]/Y[0]),Math.ceil(O/Z[1]/Y[1]),Math.ceil(S/Z[2]/Y[2])],te=bt(n[0].dataType),ue=M?4:1,le=fe("a",n[0].dataType,[...a,O,I/ue],ue),Ae=fe("b",n[1].dataType,[...u,I,k/ue],ue),q=Te("result",n[0].dataType,[S,O,k/ue],ue);v.push(le),v.push(Ae),v.push(q);let ge=[le,Ae],it=n.length>2,me=R$(ue,it,j,v,T,i);if(it){let Dt=i?ue:1;ge.push(fe("bias",n[2].dataType,n[2].dims,Dt))}let de=Dt=>`
  const dimAOuter: i32 = ${O};
  const dimBOuter: i32 = ${k};
  const dimInner: i32 = ${I};
  ${Dt.declareVariables(...ge,q)}
  ${me}
  ${F}
  ${M?mo(Y,Z,te,g):go(Y,Z,te,g)}
                   ${g.impl()}`;return{name:"MatMul",shaderCache:{hint:e.activationCacheKey},getRunData:()=>({outputs:[{dims:r,dataType:n[0].dataType}],dispatchGroup:{x:P[0],y:P[1],z:P[2]}}),getShaderSource:de}}});var M$,yb,bb=X(()=>{"use strict";Hr();je();Je();es();qu();yo();M$=(n,e,r,t,i=!1,o,s=!1,a=4,u=4,c=4,g="f32")=>{let v=Ae=>{switch(Ae){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${g}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${Ae} is not supported.`)}},T=Ae=>{switch(Ae){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${Ae} is not supported.`)}},S=n?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,O=n?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,I=n?"xShape[1]":"xShape[2]",k=n?"xShape[2]":"xShape[3]",M=n?"row":"col",F=n?"col":"row",j=`
    let inChannels = wShape[2];
    let outWidth = ${n?"outShape[2]":"outShape[3]"};
    let outRow = ${M} / outWidth;
    let outCol = ${M} % outWidth;

    let WRow = ${F} / (filterDims[1] * inChannels);
    let WCol = ${F} / inChannels % filterDims[1];
    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];
    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];
    let xCh = ${F} % inChannels;
    var resData = ${At(a,g)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${I} && xCol >= 0 && xCol < ${k}) {
      ${S}
      let xIndex = getIndexFromCoords4D(coord, xShape);
      ${v(a)}
    }
    return resData;`,Y=n?e&&t?`
    let col = colIn * ${a};
    ${j}`:`
    let col = colIn * ${a};
    if (row < dimAOuter && col < dimInner) {
      ${j}
    }
    return ${At(a,g)}(0.0);`:t&&r?`
    let col = colIn * ${a};
    ${j}`:`
    let col = colIn * ${a};
    if (row < dimInner && col < dimBOuter) {
      ${j}
    }
    return ${At(a,g)}(0.0);`,Z=`${T(u)}`,P=At(c,g),te=n?At(a,g):At(u,g),ue=n?At(u,g):At(a,g);return`
    ${Za(o,s,c===4,4)}
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${te} {
      ${n?Y:Z}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${ue} {
      ${n?Z:Y}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${P}) {
      let col = colIn * ${c};
      if (row < dimAOuter && col < dimBOuter)
      {
      var value = valueIn;
      let outWidth = ${n?"outShape[2]":"outShape[3]"};
      ${O}
      ${Qa(i,o)}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},yb=(n,e,r,t,i,o,s,a)=>{let u=e.format==="NHWC",c=u?n[0].dims[3]:n[0].dims[1],g=r[0],v=u?r[2]:r[3],T=u?r[1]:r[2],S=u?r[3]:r[1],O=u&&(c%4===0||c%3===0)&&S%4===0,I=u?S:v*T,k=u?v*T:S,M=[8,8,1],F=t<=8?[4,1,1]:[4,4,1],j=[Math.ceil(I/M[0]/F[0]),Math.ceil(k/M[1]/F[1]),Math.ceil(g/M[2]/F[2])];ct("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${j}`);let Y=O?u&&c%4!==0?3:4:F[0],Z=M[1]*F[1],P=M[0]*F[0],te=Math.max(M[0]*Y,M[1]),ue=t%Z===0,le=i%P===0,Ae=o%te===0,q=O?[Y,4,4]:[1,1,1],ge=bt(n[0].dataType),it=[`@group(0) @binding(0) var<storage, read> x: array<${O&&Y===4?`vec4<${ge}>`:ge}>;`,`@group(0) @binding(1) var<storage, read> w: array<${O?`vec4<${ge}>`:ge}>;`],me=`
      fn setOutputAtIndex(flatIndex : i32, value : ${O?`vec4<${ge}>`:ge}) {
        result[flatIndex] = ${O?`vec4<${ge}>`:ge}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${O?`vec4<${ge}>`:ge}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${O?"/ 4":""}, value);
      }`;return s&&(it.push(`@group(0) @binding(2) var<storage, read> bias: array<${O?`vec4<${ge}>`:ge}>;`),me+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${O?`vec4<${ge}>`:ge} {
          return bias[coords.${u?"w":"y"}${O?"/ 4":""}];
        }`),{name:"Conv2DMatMul",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:n[0].dataType}],dispatchGroup:{x:j[0],y:j[1],z:j[2]}}),getShaderSource:()=>`
        ${ts}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${it.join("")}
        @group(0) @binding(${it.length}) var<storage, read_write> result: array<${O?`vec4<${ge}>`:ge}>;
        //@group(0) @binding(${it.length+1}) var<uniform> uniforms: Uniforms;

        const xShape : vec4<i32> = vec4<i32>(${n[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${n[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${re.computeStrides(r).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${e.kernelShape[0]}, ${e.kernelShape[1]});
        const pad : vec2<i32> = vec2<i32>(${e.pads[0]}, ${e.pads[1]});
        const stride : vec2<i32> = vec2<i32>(${e.strides[0]}, ${e.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${e.dilations[0]}, ${e.dilations[1]});
        const dimAOuter : i32 = ${t};
        const dimBOuter : i32 = ${i};
        const dimInner : i32 = ${o};
        ${me}
        ${M$(u,ue,le,Ae,s,void 0,!1,q[0],q[1],q[2],ge)}
            ${O?mo(F,M,ge,void 0,!u,te):go(F,M,ge,void 0,!u,te,!1,void 0,a)}`}}});var Ku,vb=X(()=>{"use strict";je();Je();Yu();ho();Ku=(n,e,r)=>{let t=n.length>2,i=t?"value += b[output_channel];":"",o=n[0].dims,s=n[1].dims,a=s[0]/e.group,{activationFunction:u,applyActivation:c}=rs(e),g=e.format==="NHWC",v=Xu(o,s,e.dilations,e.pads,e.strides,g),T=re.size(v),S=Te("output",n[0].dataType,v),O=fe("x",n[0].dataType,o),I=fe("w",n[1].dataType,s),k=[O,I];t&&k.push(fe("b",n[2].dataType,n[2].dims));let M=F=>`
  const strides: vec2<u32> = vec2(${e.strides[0]}u, ${e.strides[1]}u);
  const pads: vec2<u32> = vec2(${e.pads[0]}u, ${e.pads[1]}u);

  ${F.declareVariables(...k,S)}

  ${u}

  ${F.mainStart()}
    ${F.guardAgainstOutOfBoundsWorkgroupSizes(T)}

    let outputIndices = ${S.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${g?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${g?1:2}], outputIndices[${g?2:3}]) * strides - pads;
    let group_id: u32 = output_channel / ${a}u;

    var value: ${S.type.value} = ${S.type.value}(0);
    for (var wInChannel: u32 = 0u; wInChannel < ${s[1]}u; wInChannel++) {
      let input_channel = group_id * ${s[1]}u + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < ${s[2]}u; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * ${e.dilations[0]}u;

        if (xHeight < 0u || xHeight >= ${o[g?1:2]}u) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < ${s[3]}u; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * ${e.dilations[1]}u;
          if (xWidth < 0u || xWidth >= ${o[g?2:3]}u) {
            continue;
          }

          let xVal = ${g?O.get("batch","xHeight","xWidth","input_channel"):O.get("batch","input_channel","xHeight","xWidth")};
          let wVal = ${I.get("output_channel","wInChannel","wHeight","wWidth")};
          value += xVal*wVal;
        }
      }
    }
    ${i}
    ${c}
    ${S.setByOffset("global_idx","value")}
  }`;return{name:"GroupedConv",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:r?r(v):v,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(T/64)}}),getShaderSource:M}}});var L$,wb,N$,z$,ai,xb,Tb,os=X(()=>{"use strict";je();yt();Je();L$=n=>{if(!n||n.length!==1)throw new Error("Transpose requires 1 input.")},wb=(n,e)=>e&&e.length!==n?[...new Array(n).keys()].reverse():e,N$=(n,e)=>re.sortBasedOnPerm(n,wb(n.length,e)),z$=(n,e,r,t)=>{let i=[];i.push(`fn perm(i: ${t.type.indices}) -> ${r.type.indices} {
    var a: ${r.type.indices};`);for(let o=0;o<e;++o)i.push(r.indicesSet("a",n[o],`i[${o}]`));return i.push("return a;}"),i.join(`
`)},ai=(n,e,r)=>{let t=wb(e,r),i=Te("output",n,r&&r.length||e),o=fe("a",n,e),s=a=>`
  ${a.registerUniform("output_size","u32").declareVariables(o,i)}

  ${z$(t,e,o,i)}

  ${a.mainStart()}
    ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${i.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${i.setByOffset("global_idx",o.getByIndices("aIndices"))}
  }`;return{name:"Transpose",shaderCache:{hint:`${r}`,inputDependencies:["rank"]},getRunData:a=>{let u=N$(a[0].dims,t),c=re.size(u);return{outputs:[{dims:u,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:[{type:"uint32",data:c},...ju(a[0].dims),...ju(u)]}},getShaderSource:s}},xb=(n,e)=>{L$(n.inputs),n.compute(ai(n.inputs[0].dataType,n.inputs[0].dims.length,e.perm))},Tb=n=>Ce({perm:n.perm})});var Xu,_b,F$,$b,Sb,j$,G$,Ib,Yu=X(()=>{"use strict";je();yt();bb();yo();vb();ho();os();Xu=(n,e,r,t,i,o)=>{let s=n[0],a=n.slice(o?1:2,o?3:4),u=a.length,c=e[0],v=e.slice(2).map((O,I)=>O+(O-1)*(r[I]-1)),S=a.map((O,I)=>O+t[I]+t[I+u]).map((O,I)=>Math.floor((O-v[I]+i[I])/i[I]));return S.splice(0,0,s),S.splice(o?3:1,0,c),S},_b=[2,3,1,0],F$=(n,e)=>{if(!n||n.length!==2&&n.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(n[0].dims.length!==4&&n[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(n[0].dims.length!==n[1].dims.length)throw new Error("filter does not have same dimension as input");let r=n[0].dims[e.format==="NHWC"?n[0].dims.length-1:1],t=n[1].dims[1]*e.group;if(r!==t)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(n.length===3&&(n[2].dims.length!==1||n[1].dims[0]!==n[2].dims[0]))throw new Error("invalid bias");let i=n[0].dims.length-2;if(e.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(e.strides.length!==i)throw new Error(`strides should be ${i}D`);if(e.pads.length!==i*2)throw new Error(`pads should be ${i*2}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==n[1].dims.length-2)throw new Error("invalid kernel shape")},$b=(n,e)=>{let r=n.kernelShape.slice();for(let o=2;o<e[1].dims.length;++o)r[o-2]===0&&(r[o-2]=e[1].dims[o]);let t=n.pads.slice();_n.adjustPadsBasedOnAutoPad(e[0].dims,n.strides,n.dilations,r,t,n.format==="NHWC",n.autoPad);let i=Object.assign({},n);return Object.assign(i,{kernelShape:r,pads:t,cacheKey:n.cacheKey}),i},Sb=n=>{let e=ns(n),r=n.format,t=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][n.auto_pad],i=n.dilations,o=n.group,s=n.kernel_shape,a=n.pads,u=n.strides,c=n.w_is_const();return Ce({autoPad:t,format:r,dilations:i,group:o,kernelShape:s,pads:a,strides:u,wIsConst:c,...e})},j$=(n,e,r)=>{let t=$b(r,e);if(r.group!==1){n.compute(Ku(e,t));return}let i=r.format==="NHWC",o=e.length===3,s=e[0].dims[i?1:2],a=e[0].dims[i?2:3],u=e[0].dims[i?3:1],c=e[1].dims[2],g=e[1].dims[3],v=Xu(e[0].dims,e[1].dims,r.dilations,t.pads,r.strides,i),T=v[i?1:2],S=v[i?2:3],O=v[i?3:1],I=i&&c===s&&g===a&&r.pads[0]===0&&r.pads[1]===0;if(I||c===1&&g===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let P=v[0],te,ue,le,Ae=[];if(i){let q=n.kernelCustomData.wT??n.compute(ai(e[1].dataType,e[1].dims.length,_b),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!n.kernelCustomData.wT&&(n.kernelCustomData.wT=q),I){let ge=s*a*u;te=e[0].reshape([1,P,ge]),ue=q.reshape([1,ge,O]),le=[1,P,O]}else te=e[0].reshape([P,s*a,u]),ue=q.reshape([1,u,O]),le=[P,T*S,O];Ae.push(te),Ae.push(ue)}else te=e[0].reshape([P,u,s*a]),ue=e[1].reshape([1,O,u]),le=[P,O,T*S],Ae.push(ue),Ae.push(te);o&&Ae.push(e[2]),n.compute(is(Ae,t,v,le,i),{inputs:Ae});return}let k=!0,M=n.kernelCustomData.wT??n.compute(ai(e[1].dataType,e[1].dims.length,_b),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!n.kernelCustomData.wT&&(n.kernelCustomData.wT=M);let F=[e[0],M];o&&F.push(e[2]);let j=i?T*S:O,Y=i?O:T*S,Z=c*g*u;n.compute(yb(F,t,v,j,Y,Z,o,k),{inputs:F})},G$=(n,e)=>{let r=e.format==="NHWC",t=[n.inputs[0].reshape(r?[n.inputs[0].dims[0],1,n.inputs[0].dims[1],n.inputs[0].dims[2]]:[n.inputs[0].dims[0],n.inputs[0].dims[1],1,n.inputs[0].dims[2]]),n.inputs[1].reshape([n.inputs[1].dims[0],n.inputs[1].dims[1],1,n.inputs[1].dims[2]])];n.inputs.length===3&&t.push(n.inputs[2]);let i=[0,e.pads[0],0,e.pads[1]],o=[1].concat(e.strides),s=[1].concat(e.dilations),a=[1].concat(e.kernelShape),u=$b({...e,pads:i,strides:o,dilations:s,kernelShape:a},t);n.compute(Ku(t,u,c=>r?[c[0],c[2],c[3]]:[]))},Ib=(n,e)=>{F$(n.inputs,e),n.inputs[0].dims.length===3?G$(n,e):j$(n,n.inputs,e)}});var W$,Cb,Ab=X(()=>{"use strict";Hr();je();es();qu();yo();W$=(n,e=!1,r,t=!1,i=4)=>{let o=At(i,"f32"),s=M=>{switch(M){case 1:return"return W[getIndexFromCoords4D(coord, wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${M} is not supported.`)}},a=n?`
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `,u=n?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,c=n?"outBackprop[1]":"outBackprop[2]",g=n?"outBackprop[2]":"outBackprop[3]",v=n?"row":"col",T=n?"col":"row",S=`
      let inChannels = ${n?"outBackprop[3]":"outBackprop[1]"};
      let outWidth = ${n?"outShape[2]":"outShape[3]"};
      let outRow = ${v} / outWidth;
      let outCol = ${v} % outWidth;

      let WRow = ${T} / (filterDims[1] * inChannels);
      let WCol = ${T} / inChannels % filterDims[1];
      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);
      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);
      if (xR < 0.0 || xR >= f32(${c}) || fract(xR) > 0.0) {
        return ${o}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${g}) || fract(xC) > 0.0) {
        return ${o}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${T} % inChannels;
      ${a}
      return x[getIndexFromCoords4D(coord, xShape)/${i}];`,O=n?`
      let col = colIn * ${i};
      if (row < dimAOuter && col < dimInner) {
        ${S}
      }
      return ${o}(0.0);`:`
      let col = colIn * ${i};
      if (row < dimInner && col < dimBOuter) {
        ${S}
      }
      return ${o}(0.0);`,I=`
      let col = colIn * ${i};
      let inChannels = ${n?"outBackprop[3]":"outBackprop[1]"};
      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);
      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];
      if (${n?"row < dimInner && col < dimBOuter":"row < dimInner && col < dimAOuter"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${s(i)}
      }
      return ${o}(0.0);
      `;return`
  ${Za(r,t,i===4,4)}
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${o} {
    ${n?O:I}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${o} {
    ${n?I:O}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${o}) {
    let col = colIn * ${i};
    if (row < dimAOuter && col < dimBOuter) {
      var value = valueInput;
      let outWidth = ${n?"outShape[2]":"outShape[3]"};
      ${u}
      ${Qa(e,r)}
      result[getIndexFromCoords4D(coords, outShape)/${i}] = value;
    }
  }`},Cb=(n,e,r,t,i,o,s,a)=>{let u=e.format==="NHWC",c=u?n[0].dims[3]:n[0].dims[1],g=r[0],v=u?r[2]:r[3],T=u?r[1]:r[2],S=u?r[3]:r[1],O=u?c%4===0&&S%4===0:v%4===0&&S%4===0,I=u?S:v*T,k=u?v*T:S,M=O?[8,8,1]:[I<=4||k<=4?4:16,I>4&&k<=4?4:16,1],F=O?[4,4,1]:[I<=4?1:4,I>4&&k<=4?1:4,1],j=[Math.ceil(I/M[0]/F[0]),Math.ceil(k/M[1]/F[1]),Math.ceil(g/M[2]/F[2])];ct("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${j}`);let Y=O?4:1,Z=Math.max(M[0]*Y,M[1]),P=[`@group(0) @binding(0) var<storage, read> x: array<${O?"vec4<f32>":"f32"}>;`,"@group(0) @binding(1) var<storage, read> W: array<f32>;"],te="";return s&&(P.push(`@group(0) @binding(2) var<storage, read> bias: array<${O?"vec4<f32>":"f32"}>;`),te+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${O?"vec4<f32>":"f32"} {
          return bias[coords.${u?"w":"y"}${O?"/ 4":""}];
        }`),{name:"Conv2DTransposeMatMul",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:n[0].dataType}],dispatchGroup:{x:j[0],y:j[1],z:j[2]}}),getShaderSource:()=>`
        ${ts}
        ${P.join(`
`)}
        @group(0) @binding(${P.length}) var<storage, read_write> result: array<${O?"vec4<f32>":"f32"}>;
        const outBackprop : vec4<i32> = vec4<i32>(${n[0].dims.join(",")});
        const xShape : vec4<i32> = vec4<i32>(${n[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${n[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${re.computeStrides(r).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${e.kernelShape[u?1:2]}, ${e.kernelShape[u?2:3]});
        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(
              ${e.dilations[0]<=1?0:(e.kernelShape[u?1:2]-1)*(e.dilations[0]-1)},
              ${e.dilations[1]<=1?0:(e.kernelShape[u?2:3]-1)*(e.dilations[1]-1)});
        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${e.pads[0]+e.pads[2]})/2,
                                         i32(effectiveFilterDims[1]) - 1 - (${e.pads[1]+e.pads[3]})/2);
        const strides : vec2<i32> = vec2<i32>(${e.strides[0]}, ${e.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${e.dilations[0]}, ${e.dilations[1]});
        const dimAOuter : i32 = ${t};
        const dimBOuter : i32 = ${i};
        const dimInner : i32 = ${o};
        ${te}
        ${W$(u,s,void 0,!1,Y)}
        ${O?mo(F,M,"f32",void 0,!u,Z):go(F,M,"f32",void 0,!u,Z,!1,void 0,a)}`}}});var V$,Ju,Ob=X(()=>{"use strict";Hr();je();Je();V$=(n,e,r,t,i,o,s=!1,a)=>{let u=r.format==="NHWC",c=u?1:2,g=u?2:3,v=u?3:1,T=re.size(t),S=s?2:1,O=r.group,I=e[1].dims,k=I[0]/O,M=I[1],F=`
  fn setOutputAtIndex(flatIndex : u32, value : ${s?`vec4<${a}>`:a}) {
    result[flatIndex] = ${s?`vec4<${a}>`:a}(value);
  }`;i&&(F+=`
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${s?`vec4<${a}>`:a} {
      return bias[coords.${u?"w":"y"}${s?"/ 4":""}];
    }`);let j=s?4:1,Y=fe("W",e[1].dataType,e[1].dims,j),Z=fe("Dy",e[0].dataType,e[0].dims,j),P=[Z,Y];i&&P.push(fe("bias",e[2].dataType,[t[v]],j));let te=Te("result",e[0].dataType,t,j),ue=`{
        let batch: u32 = ${o?"global_id.z":"workgroup_id.z"} / outShape[1];
        let r = ${o?"global_id.z":"workgroup_id.z"} % outShape[1];
        let c = ${o?"global_id.y":"workgroup_id.y"} * ${S};
        let d1: u32 = ${o?"global_id.x":"workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${a}>, ${S}>;
        for (var i = 0; i < ${S}; i++) {
          dotProd[i] = vec4<${a}>(0.0);
        }
        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {
          var dyR = (${a}(dyCorner.x) + ${a}(wR)) / ${a}(strides.x);
          let wRPerm = filterDims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${a}(outBackprop[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {
            let dyC = (${a}(dyCorner.y) + ${a}(wC)) / ${a}(strides.y);
            let dyC2 = (${a}(dyCorner.y) + 1.0 + ${a}(wC)) / ${a}(strides.y);
            let wCPerm = filterDims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${a}(outBackprop[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${a}(outBackprop[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${Y.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${Y.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${Y.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${Y.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Z.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${a}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${Z.get("batch","idyR","idyC2","d2")};

                dotProd[1] = dotProd[1] + vec4<${a}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = outBackprop[${v}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${Y.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${Y.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${Y.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${Y.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Z.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${a}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${Y.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${Y.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${Y.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${Y.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Z.get("batch","idyR","idyC2","d2")};
                let tmpval = vec4<${a}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${S}; i = i + 1) {
          let value = dotProd[i] + ${i?"bias[c+i]":"0.0"};
          ${te.set("batch","r","c + i","d1","value")};
        }
      }`,le=`
          let outputIndices = ${te.offsetToIndices("global_idx")};
          let batch = ${te.indicesGet("outputIndices",0)};
          let d1 = ${te.indicesGet("outputIndices",v)};
          let r = ${te.indicesGet("outputIndices",c)};
          let c = ${te.indicesGet("outputIndices",g)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / ${M};
          let wOutChannel = d1 - groupId * ${M};
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = 0.0;
          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {
            if (wR % dilations.x != 0) {
              continue;
            }
            let dyR = (${a}(dyRCorner) + ${a}(wR)) / ${a}(strides[0]);
            let wRPerm = filterDims.x - 1 - wR / dilations.x;
            if (dyR < 0.0 || dyR >= ${a}(outBackprop[${c}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {
              if (wC % dilations.y != 0) {
                continue;
              }
              let dyC = (${a}(dyCCorner) + ${a}(wC)) / ${a}(strides.y);
              let wCPerm = filterDims.y - 1 - wC / dilations.y;
              if (dyC < 0.0 || dyC >= ${a}(outBackprop[${g}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * ${k};
              for (var d2: u32 = 0; d2 < ${k}; d2 = d2 + 1) {
                let xValue = ${u?Z.get("batch","idyR","idyC","inputChannel"):Z.get("batch","inputChannel","idyR","idyC")};
                let wValue = ${Y.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${i?"bias[d1]":"0.0"};
          ${te.setByOffset("global_idx","value")};
        `;return`
  ${n.declareVariables(...P,te)}
  ${F}
  const outShape : vec4<u32> = vec4<u32>(${t.join(",")});
  const outBackprop : vec4<u32> = vec4<u32>(${e[0].dims.join(",")});
  const strides : vec2<u32> = vec2<u32>(${r.strides[0]}, ${r.strides[1]});
  const filterDims : vec2<u32> = vec2<u32>(${r.kernelShape[u?1:2]}, ${r.kernelShape[u?2:3]});
  const dilations : vec2<u32> = vec2<u32>(${r.dilations[0]}, ${r.dilations[1]});
  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(
          ${r.dilations[0]<=1?0:(r.kernelShape[u?1:2]-1)*(r.dilations[0]-1)},
          ${r.dilations[1]<=1?0:(r.kernelShape[u?2:3]-1)*(r.dilations[1]-1)});
  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,
                                     i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);
    ${n.mainStart()}
    ${n.guardAgainstOutOfBoundsWorkgroupSizes(T)};
  ${s?ue:le}}`},Ju=(n,e,r)=>{let t=n.length>2,i=e.outputShape,o=re.size(i),s=[Math.ceil(o/64),1,1];ct("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${s}`);let a=bt(n[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:e.cacheKey},getRunData:()=>({dispatchGroup:{x:s[0],y:s[1],z:s[2]},outputs:[{dims:r?r(i):i,dataType:n[0].dataType}]}),getShaderSource:u=>V$(u,n,e,i,t,s[1]===1&&s[2]===1,!1,a)}}});var U$,H$,q$,Eb,Pb,K$,X$,Y$,J$,Db,kb=X(()=>{"use strict";yt();Ab();Ob();ho();os();U$=(n,e,r,t,i,o)=>(n-1)*e+r+(t-1)*i+1-o,H$=(n,e,r,t,i)=>{let o=Math.floor(n/2);e==="SAME_UPPER"?(r[t]=o,r[i]=n-o):e==="SAME_LOWER"&&(r[t]=n-o,r[i]=o)},q$=(n,e,r,t,i,o,s,a,u,c)=>{let g=n.length-2,v=c.length===0;if(u.length===0)for(let O=0;O<g;++O)u.push(0);let T=n[0],S=e[a?3:1]*i;for(let O=0,I=n.length-g-(a?1:0);O<g;++O,++I){let k=n[I],M=v?k*s[O]:c[O],F=U$(k,s[O],o[O],e[I],r[O],M);H$(F,t,o,O,O+g),v&&c.push(s[O]*(k-1)+u[O]+(e[I]-1)*r[O]+1-o[O]-o[O+g])}c.splice(0,0,T),c.splice(a?3:1,0,S)},Eb=(n,e)=>{let r=n.kernelShape.slice();if(n.kernelShape.length===0||n.kernelShape.reduce((T,S)=>T*S,1)===0){r.length=0;for(let T=2;T<e[1].dims.length;++T)r.push(e[1].dims[T])}let t=n.format==="NHWC";r.splice(0,0,e[1].dims[0]),r.splice(t?3:1,0,e[1].dims[1]);let i=n.pads.slice(),o=n.outputShape.slice(),s=n.outputPadding.slice(),a=e[0].dims,u=n.dilations.slice();if(u.reduce((T,S)=>T+S,0)===0){let T=e[0].dims.length-2;u=new Array(T).fill(1)}let c=n.strides.slice();if(c.reduce((T,S)=>T+S,0)===0){let T=e[0].dims.length-2;c=new Array(T).fill(1)}q$(a,r,u,n.autoPad,n.group,i,c,t,s,o);let g=Object.assign({},n),v=n.cacheKey+[r.join("n,"),i.join(","),c.join(","),s.join(","),o.join(","),u.join(",")].join("_");return Object.assign(g,{kernelShape:r,pads:i,outputPadding:s,outputShape:o,dilations:u,strides:c,cacheKey:v}),g},Pb=n=>{let e=ns(n),r=n.format,t=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof n.autoPad>"u"?0:n.autoPad],i=n.dilations,o=n.group,s=n.kernelShape,a=n.pads,u=n.strides,c=n.wIsConst(),g=n.outputPadding,v=n.outputShape;return Ce({autoPad:t,format:r,dilations:i,group:o,kernelShape:s,outputPadding:g,outputShape:v,pads:a,strides:u,wIsConst:c,...e})},K$=(n,e)=>{if(!n||n.length!==2&&n.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(n[0].dims.length!==4&&n[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(n[0].dims.length!==n[1].dims.length)throw new Error("filter does not have same dimension as input");let r=n[0].dims[e.format==="NHWC"?n[0].dims.length-1:1],t=n[1].dims[0];if(r!==t)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let i=n[1].dims[1]*e.group;if(n.length===3&&(n[2].dims.length!==1||n[2].dims[0]!==i))throw new Error("invalid bias");let o=n[0].dims.length-2;if(e.dilations.reduce((g,v)=>g+v,0)>0&&e.dilations.length!==o)throw new Error(`dilations should be ${o}D`);if(e.strides.reduce((g,v)=>g+v,0)>0&&e.strides.length!==o)throw new Error(`strides should be ${o}D`);if(e.pads.reduce((g,v)=>g+v,0)>0&&e.pads.length!==o*2)throw new Error(`pads should be ${o*2}D`);if(e.outputPadding.length!==o&&e.outputPadding.length!==0)throw new Error(`output_padding should be ${o}D`);if(e.kernelShape.reduce((g,v)=>g+v,0)>0&&e.kernelShape.length!==0&&e.kernelShape.length!==n[1].dims.length-2)throw new Error("invalid kernel shape");if(e.outputShape.length!==0&&e.outputShape.length!==n[0].dims.length-2)throw new Error("invalid output shape")},X$=[2,3,1,0],Y$=(n,e,r)=>{let t=Eb(r,e),i=r.format==="NHWC",o=e.length===3;if(t.group!==1){n.compute(Ju(e,t));return}let s=t.outputShape,a=s[i?1:2],u=s[i?2:3],c=s[i?3:1],g=e[1].dims[2],v=e[1].dims[3],T=e[0].dims[i?3:1],S=i?a*u:c,O=i?c:a*u,I=g*v*T,k=!0,M=n.kernelCustomData.wT??n.compute(ai(e[1].dataType,e[1].dims.length,X$),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!n.kernelCustomData.wT&&(n.kernelCustomData.wT=M);let F=[e[0],M];o&&(!i&&e[2].dims.length===1?F.push(e[2].reshape([e[2].dims[0],1,1])):F.push(e[2])),n.compute(Cb(F,t,s,S,O,I,o,k),{inputs:F})},J$=(n,e)=>{let r=e.format==="NHWC",t=[n.inputs[0].reshape(r?[n.inputs[0].dims[0],1,n.inputs[0].dims[1],n.inputs[0].dims[2]]:[n.inputs[0].dims[0],n.inputs[0].dims[1],1,n.inputs[0].dims[2]]),n.inputs[1].reshape([n.inputs[1].dims[0],n.inputs[1].dims[1],1,n.inputs[1].dims[2]])];t.length===3&&t.push(n.inputs[2]);let i=e.kernelShape;(i.length===0||i[0]===0)&&(i=[n.inputs[1].dims[2]]);let o=e.dilations;(o.length===0||o[0]===0)&&(o=[1]);let s=e.strides;(s.length===0||s[0]===0)&&(s=[1]);let a=e.pads;a.length===0&&(a=[0,0]),a=[0,a[0],0,a[1]],s=[1].concat(s),o=[1].concat(o),i=[1].concat(i);let u=Eb({...e,pads:a,strides:s,dilations:o,kernelShape:i},t);n.compute(Ju(t,u,c=>r?[c[0],c[2],c[3]]:[c[0],c[1],c[3]]))},Db=(n,e)=>{K$(n.inputs,e),n.inputs[0].dims.length===3?J$(n,e):Y$(n,n.inputs,e)}});var Zu,as,Bb,Z$,Q$,Qu,el,eS,Rb,Mb,Lb=X(()=>{"use strict";je();yt();Je();Zu="[a-zA-Z]|\\.\\.\\.",as="("+Zu+")+",Bb="^"+as+"$",Z$="("+as+",)*"+as,Q$="^"+Z$+"$",Qu=class{constructor(e=-1){this.symbolToIndices=new Map,this.inputIndex=e}addSymbol(e,r){let t=this.symbolToIndices.get(e);t===void 0?t=[r]:t.push(r),this.symbolToIndices.set(e,t)}},el=class{constructor(e,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[t,i]=r.includes("->")?r.split("->",2):[r,""];if(!t.match(RegExp(Q$)))throw new Error("Invalid LHS term");if(t.split(",").forEach((a,u)=>{let c=e[u].dims.slice();if(!a.match(RegExp(Bb)))throw new Error("Invalid LHS term");let g=this.processTerm(a,!0,c,u);this.lhs.push(g)}),i==="")i+=[...this.symbolToInfo.entries()].filter(([a,u])=>u.count===1||a==="...").map(([a])=>a).join("");else if(!i.match(RegExp(as)))throw new Error("Invalid RHS");i.match(RegExp(Zu,"g"))?.forEach(a=>{if(a==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let u=this.symbolToInfo.get(a);if(u===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(u.dimValue)}}),this.rhs=this.processTerm(i,!0,this.outputDims)}addSymbol(e,r,t){let i=this.symbolToInfo.get(e);if(i!==void 0){if(i.dimValue!==r&&i.count!==1)throw new Error("Dimension mismatch");i.count++,i.inputIndices.push(t)}else i={count:1,dimValue:r,inputIndices:[t]};this.symbolToInfo.set(e,i)}processTerm(e,r,t,i=-1){let o=t.length,s=!1,a=[],u=0;if(!e.match(RegExp(Bb))&&!r&&e!=="")throw new Error("Invalid LHS term");let c=e.match(RegExp(Zu,"g")),g=new Qu(i);return c?.forEach((v,T)=>{if(v==="..."){if(s)throw new Error("Only one ellipsis is allowed per input term");s=!0;let S=o-c.length+1;if(S<0)throw new Error("Ellipsis out of bounds");if(a=t.slice(u,u+S),this.hasEllipsis){if(this.ellipsisDims.length!==a.length||this.ellipsisDims.toString()!==a.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=a;else throw new Error("Ellipsis must be specified in the LHS");for(let O=0;O<a.length;O++){let I=String.fromCharCode("0".charCodeAt(0)+T);g.addSymbol(I,T+O),this.addSymbol(I,t[u++],i)}}else g.addSymbol(v,T),this.addSymbol(v,t[u++],i)}),g}},eS=(n,e)=>{let r=n[0].dataType,t=new Array(n.length);for(let j=0;j<n.length;++j)t[j]=fe(`input${j}`,r,n[j].dims);let i=e.outputDims,o=re.size(i),s=Te("output",r,i),a=[],u=Array.from(e.rhs.symbolToIndices.keys()),c="var prod = 1.0;",g="var sum = 0.0;",v="sum += prod;",T=[],S=[],O=[],I=[],k=e.symbolToInfo.size===u.length;e.symbolToInfo.forEach((j,Y)=>{if(u.includes(Y)){let Z=u.indexOf(Y);e.lhs.forEach((P,te)=>{if(j.inputIndices.includes(te)){let ue=P.symbolToIndices.get(Y);if(ue===void 0)throw new Error("Invalid symbol error");ue.forEach(le=>{a.push(`${t[te].indicesSet(`input${te}Indices`,le,s.indicesGet("outputIndices",Z))}`)})}})}else e.lhs.forEach((Z,P)=>{let te=e.symbolToInfo.get(Y);if(te===void 0)throw new Error("Invalid symbol error");if(te.inputIndices.includes(P)){let ue=Z.symbolToIndices.get(Y);if(ue===void 0)throw new Error("Invalid symbol error");ue.forEach(le=>{T.push(`${t[P].indicesSet(`input${P}Indices`,le,`${Y}`)}`)}),I.push(`prod *= ${t[P].getByIndices(`input${P}Indices`)};`)}}),S.push(`for(var ${Y}: u32 = 0; ${Y} < ${e.symbolToInfo.get(Y)?.dimValue}; ${Y}++) {`),O.push("}")});let M=k?[...a,`let sum = ${t.map((j,Y)=>j.getByIndices(`input${Y}Indices`)).join(" * ")};`]:[...a,g,...S,...T,c,...I,v,...O],F=j=>`
      ${j.declareVariables(...t,s)}

      ${j.mainStart()}
        ${j.guardAgainstOutOfBoundsWorkgroupSizes(o)}
        var outputIndices = ${s.offsetToIndices("global_idx")};
        ${t.map((Y,Z)=>`var input${Z}Indices: ${t[Z].type.indices};`).join(`
`)}
        ${M.join(`
`)};
        ${s.setByOffset("global_idx","sum")};
      }`;return{name:"Einsum",shaderCache:{hint:e.equation},getRunData:()=>({outputs:[{dims:i,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:F}},Rb=(n,e)=>{let r=new el(n.inputs,e.equation);n.compute(eS(n.inputs,r))},Mb=n=>{let e=n.equation.replace(/\s+/g,"");return Ce({equation:e})}});var tS,Nb,rS,nS,zb,Fb=X(()=>{"use strict";je();Je();tS=n=>{if(!n||n.length!==2)throw new Error("Expand requires 2 input.");let e=n[0].dims,r=Array.from(n[1].getBigInt64Array(),Number),t=r.length<e.length?0:r.length-e.length,i=e.length<r.length?0:e.length-r.length;for(;t<r.length&&i<e.length;++t,++i)if(r[t]!==e[i]&&r[t]!==1&&e[i]!==1)throw new Error("Expand requires shape to be broadcastable to input")},Nb=(n,e)=>{let r=n.length-e.length,t=[];for(let i=0;i<r;++i)t.push(n[i]);for(let i=0;i<e.length;++i)t.push(e[i]===1?n[i+r]:e[i]);return t},rS=(n,e)=>n.length>e.length?Nb(n,e):Nb(e,n),nS=n=>{let e=n[0].dims,r=Array.from(n[1].getBigInt64Array(),Number),t=rS(e,r),i=re.size(t),o=n[0].dataType,s=fe("input",o,e),a=Te("output",o,t),u=c=>`
  const inputShape = ${s.indices(...e)};
  ${c.declareVariables(s,a)}
  ${c.mainStart()}
  ${c.guardAgainstOutOfBoundsWorkgroupSizes(i)}
    let outputIndices = ${a.offsetToIndices("global_idx")};
    var inputIndices: ${s.type.indices};
    for (var i = 0; i < ${e.length}; i++) {
      if (${s.indicesGet("inputShape","i")} == 1) {
        ${s.indicesSet("inputIndices","i",0)}
      } else {
        ${s.indicesSet("inputIndices","i",a.indicesGet("outputIndices",`i + ${t.length-e.length}`))}
      }
    }
    ${a.setByOffset("global_idx",s.getByIndices("inputIndices"))}
  }`;return{name:"Expand",shaderCache:{hint:`${t}`},getShaderSource:u,getRunData:()=>({outputs:[{dims:t,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}})}},zb=n=>{tS(n.inputs),n.compute(nS(n.inputs),{inputs:[0]})}});var iS,oS,jb,Gb,Wb=X(()=>{"use strict";je();yt();Je();iS=n=>{if(!n||n.length!==2)throw new Error("Gather requires 2 inputs.")},oS=(n,e)=>{let r=n[0].dims,t=n[1].dims,i=r.length,o=re.normalizeAxis(e.axis,i),s=r.slice(0);s.splice(o,1,...t);let a=r[o],u=re.size(s),c=fe("data",n[0].dataType,n[0].dims),g=fe("inputIndices",n[1].dataType,n[1].dims),v=Te("output",n[0].dataType,s),T=()=>{let O=t.length,I=`var indicesIndices  = ${g.type.indices}(0);`;for(let k=0;k<O;k++)I+=`${O>1?`indicesIndices[${k}]`:"indicesIndices"} = ${s.length>1?`outputIndices[${o+k}]`:"outputIndices"};`;I+=`
        var idx = ${g.getByIndices("indicesIndices")};
        if (idx < 0) {
          idx = idx + ${a};
        }
        var dataIndices = ${c.type.indices}(0);
      `;for(let k=0,M=0;k<i;k++)k===o?(I+=`${i>1?`dataIndices[${k}]`:"dataIndices"} = u32(idx);`,M+=O):(I+=`${i>1?`dataIndices[${k}]`:"dataIndices"} = ${s.length>1?`outputIndices[${M}]`:"outputIndices"};`,M++);return I},S=O=>`
      ${O.declareVariables(c,g,v)}
      ${O.mainStart()}
        ${O.guardAgainstOutOfBoundsWorkgroupSizes(u)}
        let outputIndices = ${v.offsetToIndices("global_idx")};
        ${T()};
        let value = ${c.getByIndices("dataIndices")};
        ${v.setByOffset("global_idx","value")};
      }`;return{name:"Gather",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:S}},jb=n=>Ce({axis:n.axis}),Gb=(n,e)=>{let r=n.inputs;iS(r),n.compute(oS(n.inputs,e))}});var aS,sS,Vb,Ub,Hb=X(()=>{"use strict";je();yt();Je();aS=n=>{if(!n||n.length!==2)throw new Error("GatherElements requires 2 inputs.");if(n[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(n[0].dims.length!==n[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},sS=(n,e)=>{let r=n[0].dims,t=n[0].dataType,i=r.length,o=re.computeStrides(r),s=re.size(r),a=n[1].dims,u=n[1].dataType,c=re.size(a),g=re.normalizeAxis(e.axis,i),v=r[g],T=a.slice(0),S=re.size(T),O=fe("input",t,r),I=fe("indices",u,[c]),k=Te("output",t,T),M=F=>`
      const inputStrides = array<u32, ${o.length}>(${o.map(j=>`${j}u`).join(",")});
      ${F.declareVariables(O,I,k)}
      ${F.mainStart()}
      ${F.guardAgainstOutOfBoundsWorkgroupSizes(S)}

      let outputIndices = ${k.offsetToIndices("global_idx")};

      var idx = ${I.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + ${v};
      }

      var srcOffset = u32(0);

      for (var i = 0; i < ${r.length}; i++) {
        if (i == ${g}) {
          srcOffset +=  u32(idx) * inputStrides[i];
        } else {
          srcOffset += ${k.indicesGet("outputIndices","i")} * inputStrides[i];
        }
      }

      // Should never hit this with valid values in indices
      // This is a guard against malicious data in the indices input
      if (srcOffset < 0 || srcOffset >= ${s}) {
        return;
      }

      output[global_idx] = input[srcOffset];
  }`;return{name:"GatherElements",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:T,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(S/64)}}),getShaderSource:M}},Vb=n=>Ce({axis:n.axis}),Ub=(n,e)=>{let r=n.inputs;aS(r),n.compute(sS(n.inputs,e))}});var uS,lS,cS,qb,Kb,Xb=X(()=>{"use strict";je();yt();Je();uS=n=>{if(!n)throw new Error("Input is missing");if(n.length<2||n.length>3)throw new Error("Invaid input number.");if(n.length===3&&n[2].dims.length>2)throw new Error("Invalid input shape of C");if(n[0].dataType!==n[1].dataType||n.length===3&&n[0].dataType!==n[2].dataType)throw new Error("Input types are mismatched")},lS=(n,e,r)=>{if(r.length===0)return"0u";let t=r.length===1&&n!==1||r.length===2&&r[0]!==n,i=r[r.length-1]!==e,o="0u";return t||(o+=`+ m * ${r[r.length-1]}u`),i||(o+="+n"),o},cS=(n,e)=>{let r=n[0].dims.slice(),t=n[1].dims.slice(),[i,o,s]=Ha.getShapeOfGemmResult(r,e.transA,t,e.transB,n.length===3?n[2].dims:void 0),a=[i,o];if(!a)throw new Error("Can't use gemm on the given tensors");let u=re.size(a),c="";e.transA&&e.transB?c="value += a[k * M + m] * b[n * K + k];":e.transA&&!e.transB?c="value += a[k * M + m] * b[k * N + n];":!e.transA&&e.transB?c="value += a[m * K + k] * b[n * K + k];":!e.transA&&!e.transB&&(c="value += a[m * K + k] * b[k * N + n];");let g=bt(n[0].dataType),v=e.alpha===1?"":"value *= alpha;",T=n.length===3?`value += beta * c[${lS(i,o,n[2].dims)}];`:"",S=[`@group(0) @binding(0) var<storage, read> a : array<${g}>;`,`@group(0) @binding(1) var<storage, read> b : array<${g}>;`];n.length===3&&S.push(`@group(0) @binding(2) var<storage, read> c : array<${g}>;`);let O=I=>`
  const M: u32 = ${i}u;
  const N: u32 = ${o}u;
  const K: u32 = ${s}u;
  const alpha = ${g}(${e.alpha});
  const beta = ${g}(${e.beta});

  ${S.join(`
`)}
  @group(0) @binding(${n.length}) var<storage, read_write> output : array<${g}>;

  ${I.mainStart()}
    ${I.guardAgainstOutOfBoundsWorkgroupSizes(u)}

    let m = global_id.x / N;
    let n = global_id.x % N;

    var value = ${g}(0);
    for (var k: u32 = 0u; k<${s}u; k++) {
      ${c}
    }

    ${v}
    ${T}
    output[global_id.x] = value;

  }`;return{name:"Gemm",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:a,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:O}},qb=(n,e)=>{uS(n.inputs),n.compute(cS(n.inputs,e))},Kb=n=>Ce(n)});var fS,dS,pS,hS,Yb,Jb,Zb=X(()=>{"use strict";_t();je();yt();Je();fS={name:"InstanceNormalization"},dS=(n,e)=>{let r=n[0].dims,t=r,i=2,o=re.sizeToDimension(r,i),s=re.sizeFromDimension(r,i),a=r[1],u=fe("x",n[0].dataType,[r[0],r[1],s]),c=fe("scale",n[1].dataType,n[1].dims),g=fe("bias",n[2].dataType,n[2].dims),v=Te("output",n[0].dataType,[r[0],r[1],s]),T=[u,c,g,v],S=u.type.value,O=64,I=k=>`

  const C: u32 = ${a};
  const normSize: u32 = ${s};
  const epsilon: f32 = ${e.epsilon};
  var<workgroup> meanShared : ${S};
  var<workgroup> squaredNormShared : ${S};
  var<workgroup> workgroupShared : array<${S}, ${O}>;
  const workgroupSize = ${O}u;
  ${k.declareVariables(...T)}
  ${k.mainStart(O)}
    let norm = global_idx / workgroupSize;
    let batch = norm / C;
    let channel = norm % C;
    let localIndex = local_id.x;

    // initialize workgroup memory
    var initial: ${S} = 0;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      initial = initial + ${u.get("batch","channel","h")};
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the mean of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      meanShared = workgroupShared[0] / ${S}(normSize);
    }
    workgroupBarrier();

    // reinitialize workgroup memory.
    initial = 0;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      let deviation =  ${u.get("batch","channel","h")} - meanShared;
      initial = initial + deviation * deviation;
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the sum of square of deviation of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      squaredNormShared = workgroupShared[0];
    }
    workgroupBarrier();

    let invStdDev = 1 / sqrt(squaredNormShared / ${S}(normSize) + epsilon);
    let channelScale = invStdDev * ${c.getByOffset("channel")};
    let channelShift = ${g.getByOffset("channel")} - meanShared * channelScale;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      let value = ${u.get("batch","channel","h")} * channelScale + channelShift;
      ${v.set("batch","channel","h","value")};
    }
  }`;return{...fS,shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:t,dataType:n[0].dataType}],dispatchGroup:{x:o}}),getShaderSource:I}},pS=(n,e,r,t,i,o,s,a)=>{let u=$n(s),c=fe("input",e.dataType,e.dims,u),g=fe("scale",r.dataType,r.dims,u),v=fe("bias",t.dataType,t.dims,u),T=64,S=u===1?"vec2f":`mat2x${u}f`,O=u===1?"f32":`vec${u}f`,I=(Z,P)=>`${S}(${Z}, ${P})`,k=i*s/u,M=Math.ceil(o/T),F=Z=>`
  const H: u32 = ${o};
  const C: u32 = ${s/u};
  const imageSize: u32 = ${o*s/u};

  ${Z.declareVariables(c)}
  @group(0) @binding(1) var<storage, read_write> output : array<${S}>;

  ${Z.mainStart(T)}
    let currentImageNumber = global_idx / ${T} / C;
    let currentChannelNumber = (global_idx / ${T}) % C;
    let wgId = global_idx % ${T};
    let wgOffset = wgId * ${M};
    if (wgOffset >= H) {
        return;
    }
    let wgMax = min(wgOffset + ${M}, H);

    let offset = currentImageNumber * imageSize + currentChannelNumber;
    var sum = ${mr("f32",u)};
    var squaredSum = ${mr("f32",u)};
    for (var i: u32 = wgOffset; i < wgMax; i++) {
        let value = ${O}(input[offset + i * C]);
        sum += value;
        squaredSum += value * value;
    }
    output[global_idx] = ${I("sum","squaredSum")};
  }`,j=n.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:u,n:i,h:o,c:s})},getRunData:()=>({outputs:[{dims:[i,s,T,2],dataType:1}],dispatchGroup:{x:i*s/u}}),getShaderSource:F},{inputs:[e],outputs:[-1]})[0],Y=Z=>`
  const H: u32 = ${o};
  const C: u32 = ${s/u};
  const imageSize: u32 = ${T*s/u};
  const epsilon: f32 = ${a};

  @group(0) @binding(0) var<storage, read> input : array<${S}>;
  @group(0) @binding(1) var<storage, read> scale : array<${g.type.storage}>;
  @group(0) @binding(2) var<storage, read> bias : array<${v.type.storage}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${S}>;

  ${Z.mainStart()}
    ${Z.guardAgainstOutOfBoundsWorkgroupSizes(k)}
    let currentImageNumber = global_idx / C;
    let currentChannelNumber = global_idx % C;

    let offset = currentImageNumber * imageSize;
    var sum = ${mr("f32",u)};
    var squaredSum = ${mr("f32",u)};
    for (var i: u32 = 0; i < ${T}; i++) {
        let value = input[offset + i + currentChannelNumber * ${T}];
        sum += value[0];
        squaredSum += value[1];
    }
    sum = sum / f32(H);
    squaredSum = squaredSum / f32(H);
    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);
    let channelScale = invStdDev * ${O}(scale[currentChannelNumber]);
    let channelShift = ${O}(bias[currentChannelNumber]) - sum * channelScale;

    output[global_idx] = ${I("channelScale","channelShift")};
  }`;return n.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:u,n:i,h:o,c:s,epsilon:a})},getRunData:()=>({outputs:[{dims:[i,s,2],dataType:1}],dispatchGroup:{x:Math.ceil(k/64)}}),getShaderSource:Y},{inputs:[j,r,t],outputs:[-1]})[0]},hS=(n,e,r)=>{let t=e[0].dims,i=t,o=t[0],s=t[t.length-1],a=re.sizeFromDimension(t,1)/s,u=$n(s),c=re.size(i)/u,g=fe("input",e[0].dataType,e[0].dims,u),v=Te("output",e[0].dataType,i,u),T=bt(e[0].dataType),S=u===1?"vec2f":`mat2x${u}f`,O=u===1?T:`vec${u}<${T}>`,I=pS(n,e[0],e[1],e[2],o,a,s,r.epsilon),k=M=>`
  const H: u32 = ${a};
  const C: u32 = ${s/u};

  @group(0) @binding(0) var<storage, read> input : array<${g.type.storage}>;
  @group(0) @binding(1) var<storage, read> scaleInput : array<${S}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${v.type.storage}>;

  ${M.mainStart()}
    let currentImageNumber = global_idx / (C * H);
    let currentChannelNumber = global_idx % C;

    let scaleOffset = currentImageNumber * C + currentChannelNumber;
    let scale = scaleInput[scaleOffset];
    output[global_idx] = fma(input[global_idx], ${O}(scale[0]), ${O}(scale[1]));
  }`;n.compute({name:"InstanceNormalization",shaderCache:{hint:`${r.cacheKey}`},getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)}}),getShaderSource:k},{inputs:[e[0],I]})},Yb=n=>Ce({epsilon:n.epsilon,format:n.format}),Jb=(n,e)=>{e.format==="NHWC"?hS(n,n.inputs,e):n.compute(dS(n.inputs,e))}});var mS,gS,Qb,e0,t0=X(()=>{"use strict";_t();je();yt();Je();mS=n=>{if(!n||n.length<2)throw new Error("layerNorm requires at least 2 inputs.")},gS=(n,e,r)=>{let t=n[0].dims,i=n[1],o=n[2],s=t,a=re.normalizeAxis(e.axis,t.length),u=re.sizeToDimension(t,a),c=re.sizeFromDimension(t,a),g=re.size(i.dims),v=o?re.size(o.dims):0;if(g!==c||o&&v!==c)throw new Error(`Size of X.shape()[axis:] == ${c}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${g} and bias size of ${v}`);let T=[];for(let Y=0;Y<t.length;++Y)Y<a?T.push(t[Y]):T.push(1);let S=$n(c),O=bt(n[0].dataType),I=[fe("x",n[0].dataType,n[0].dims,S),fe("scale",i.dataType,i.dims,S)];o&&I.push(fe("bias",o.dataType,o.dims,S)),I.push(Te("output",n[0].dataType,s,S));let k=r>1,M=r>2;k&&I.push(Te("meanDataOutput",1,T)),M&&I.push(Te("invStdOutput",1,T));let F=Y=>`
  const normSize: f32 = ${c};
  const normSizeVectorized: u32 = ${c/S};
  const epsilon: f32 = ${e.epsilon};

  ${Y.declareVariables(...I)}
  ${Y.mainStart()}
    ${Y.guardAgainstOutOfBoundsWorkgroupSizes(u)}
    let offset = global_idx * normSizeVectorized;
    var meanVector = ${mr("f32",S)};
    var meanSquareVector = ${mr("f32",S)};

    for (var h: u32 = 0u; h < normSizeVectorized; h++) {
      let value = ${Sn(O,S,"x[h + offset]")};
      meanVector += value;
      meanSquareVector += value * value;
    }
    let mean = ${oi("meanVector",S)} / normSize;
    let meanSquare = sqrt(${oi("meanSquareVector",S)} 
      / normSize - mean * mean + epsilon);

    for (var j: u32 = 0; j < normSizeVectorized; j++) {
      let f32input = ${Sn(O,S,"x[j + offset]")};
      let f32scale = ${Sn(O,S,"scale[j]")};
      output[j + offset] = ${I[0].type.value}((f32input - mean) / meanSquare * f32scale
        ${o?`+ ${Sn(O,S,"bias[j]")}`:""}
      );
    }

    ${k?"meanDataOutput[global_idx] = mean":""};
    ${M?"invStdOutput[global_idx] = 1 / meanSquare":""};
  }`,j=[{dims:s,dataType:n[0].dataType}];return k&&j.push({dims:T,dataType:1}),M&&j.push({dims:T,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${e.cacheKey}|${r}|${n.length}`},getRunData:()=>({outputs:j,dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:F}},Qb=n=>Ce({axis:n.axis,epsilon:n.epsilon}),e0=(n,e)=>{mS(n.inputs),n.compute(gS(n.inputs,e,n.outputCount))}});var yS,r0,n0=X(()=>{"use strict";je();yo();yS=n=>{if(!n||n.length!==2)throw new Error("MatMul requires 2 inputs.");if(n[0].dims[n[0].dims.length-1]!==n[1].dims[n[1].dims.length-2])throw new Error("shared dimension does not match.")},r0=n=>{yS(n.inputs);let e=Ar.calcShape(n.inputs[0].dims,n.inputs[1].dims,!0);if(!e)throw new Error("Can't use matmul on the given tensors");n.compute(is(n.inputs,{activation:"",activationCacheKey:""},e))}});var bS,vS,wS,xS,TS,_S,$S,SS,IS,i0,o0,a0=X(()=>{"use strict";_t();je();yt();Je();bS=n=>{if(!n||n.length<1)throw new Error("Too few inputs");if(n[0].dataType!==1)throw new Error("Input type must be float.");if(n.length>=2){let e=n[0].dims.length*2===n[1].dims[0];if(n.length===4&&(e=n[3].dims[0]*2===n[1].dims[0]),!e)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},vS=(n,e,r,t,i,o,s)=>{let a=r.length,u="";for(let c=a-1;c>=0;--c)u+=`
            k = i32(${n.indicesGet("indices",c)}) - ${i[c]};
            if (k < 0) {
              break;
            }
            if (k >= ${r[c]}) {
              break;
            }
            offset += k * ${t[c]};
        `;return`
          value = ${o}(${s});
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${u}
            value = x[offset];
          }
      `},wS=(n,e,r,t,i)=>{let o=r.length,s="";for(let a=o-1;a>=0;--a)s+=`
                k = i32(${n.indicesGet("indices",a)}) - ${i[a]};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = ${2*(r[a]-1)};
                  k = k % _2n_1;
                  if(k >= ${r[a]}) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * ${t[a]};
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},xS=(n,e,r,t,i)=>{let o=r.length,s="";for(let a=o-1;a>=0;--a)s+=`
                k = i32(${n.indicesGet("indices",a)}) - ${i[a]};
                if (k < 0) {
                  k = 0;
                }
                if (k >= ${r[a]}) {
                  k = ${r[a]-1};
                }
                offset += k * ${t[a]};
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},TS=(n,e,r,t,i)=>{let o=r.length,s="";for(let a=o-1;a>=0;--a)s+=`
                k = i32(${n.indicesGet("indices",a)}) - ${i[a]};
                if (k < 0)  {
                  k += ${r[a]};
                }
                if (k >= ${r[a]}) {
                  k -= ${r[a]};
                }
                offset += k * ${t[a]};
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},_S=(n,e,r,t,i,o)=>{switch(i.mode){case 0:return vS(n,e,r,t,i.pads,o,i.value);case 1:return wS(n,e,r,t,i.pads);case 2:return xS(n,e,r,t,i.pads);case 3:return TS(n,e,r,t,i.pads);default:throw new Error("Invalid mode")}},$S=(n,e,r,t)=>{let i=e[0].dims,o=re.padShape(i.slice(),r.pads),s=re.size(o),a=re.computeStrides(i),u=Te("output",e[0].dataType,o),c=fe("x",e[0].dataType,i),g=_S(u,o,i,a,r,t);return`
              ${n.declareVariables(c,u)}
              ${n.mainStart()}
              ${n.guardAgainstOutOfBoundsWorkgroupSizes(s)}

              let indices = ${u.offsetToIndices("global_idx")};

              var value = ${t}(0);
              ${g}
              output[global_idx] = value;
          }`},SS=(n,e)=>{let r=re.padShape(n[0].dims.slice(),e.pads);return{name:"Pad",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(re.size(r)/64)}}),getShaderSource:t=>$S(t,n,e,"f32")}},IS=(n,e)=>{if(n.length>1){let r=n[1].getBigInt64Array(),t=n.length>=3&&n[2].data?n[2].getFloat32Array()[0]:0,i=n[0].dims.length,o=new Int32Array(2*i).fill(0);if(n.length>=4){let a=n[3].getBigInt64Array();for(let u=0;u<a.length;u++)o[Number(a[u])]=Number(r[u]),o[Number(a[u])+i]=Number(r[u+a.length])}else r.forEach((a,u)=>o[Number(u)]=Number(a));let s=[];return o.forEach(a=>s.push(a)),Ce({mode:e.mode,value:t,pads:s})}else return e},i0=(n,e)=>{bS(n.inputs);let r=IS(n.inputs,e);n.compute(SS(n.inputs,r),{inputs:[0]})},o0=n=>{let e=n.mode,r=n.value,t=n.pads;return Ce({mode:e,value:r,pads:t})}});var ss,s0,u0,l0,c0,f0,d0,p0,h0,m0,g0,y0,b0,v0,w0,x0=X(()=>{"use strict";je();yt();Je();ss=n=>{if(!n||n.length!==1)throw new Error("Pool ops requires 1 input.");if(n[0].dims.length!==4)throw new Error("Pool ops supports 2-D inputs only for now.")},s0=(n,e,r)=>{let t=e.format==="NHWC",i=t?[n.dims[0],n.dims[3],n.dims[1],n.dims[2]]:n.dims.slice(),o=Object.hasOwnProperty.call(e,"dilations"),s=e.kernelShape.slice(),a=e.strides.slice(),u=o?e.dilations.slice():[],c=e.pads.slice();_n.adjustPoolAttributes(r,i,s,a,u,c);let g=_n.computePoolOutputShape(r,i,a,u,s,c,e.autoPad),v=Object.assign({},e);return o?Object.assign(v,{kernelShape:s,strides:a,pads:c,dilations:u,cacheKey:e.cacheKey}):Object.assign(v,{kernelShape:s,strides:a,pads:c,cacheKey:e.cacheKey}),[v,t?[g[0],g[2],g[3],g[1]]:g]},u0=(n,e,r,t,i,o,s,a)=>{let u=i.format==="NHWC",c=r,g=e.type.value,v=c.length,T=re.size(t),S=Te("output",e.type.tensor,t);if(i.kernelShape.length<=2){let O=i.kernelShape[i.kernelShape.length-1],I=i.strides[i.strides.length-1],k=i.pads[i.pads.length/2-1],M=i.pads[i.pads.length-1],F=v-(u?2:1),j="",Y="",Z="";if(k+M!==0?j=`
              for (var i: u32 = 0u; i < ${O}u; i++) {
                xIndices[${F}] = indices[${F}] * ${I} - ${k} + i;
                if (xIndices[${F}] < 0 || xIndices[${F}] >= ${c[F]}) {
                  pad++;
                  continue;
                }
                let x_val = x[${e.indicesToOffset("xIndices")}];
                ${o}
              }`:j=`
              for (var i: u32 = 0u; i < ${O}u; i++) {
                xIndices[${F}] = indices[${F}] * ${I} - ${k} + i;
                let x_val = x[${e.indicesToOffset("xIndices")}];
                ${o}
              }`,i.kernelShape.length===2){let te=i.kernelShape[i.kernelShape.length-2],ue=i.strides[i.strides.length-2],le=i.pads[i.pads.length/2-2],Ae=i.pads[i.pads.length-2],q=v-(u?3:2),ge=c[q];le+Ae!==0?Y=`
                for (var j: u32 = 0u; j < ${te}u; j++) {
                  xIndices[${q}] = indices[${q}] * ${ue} - ${le} + j;
                  if (xIndices[${q}] < 0 || xIndices[${q}] >= ${ge}) {
                    pad+= ${O};
                    continue;
                  }
              `:Y=`
                for (var j: u32 = 0u; j < ${te}u; j++) {
                  xIndices[${q}] = indices[${q}] * ${ue} - ${le} + j;
                `,Z=`
              }
            `}return`
            ${n.declareVariables(e,S)}

            ${n.mainStart()}
              ${n.guardAgainstOutOfBoundsWorkgroupSizes(T)}

              let indices = ${S.offsetToIndices("global_idx")};
              var xIndices = ${S.offsetToIndices("global_idx")};

              var value: ${g} = ${g}(${a});
              var pad = 0;
              ${Y}
              ${j}
              ${Z}
              ${s}

              output[global_idx] = value;
            }`}else{if(u)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let O=re.size(i.kernelShape),I=re.computeStrides(i.kernelShape),k=I.length,M=i.pads.length,F=i.pads.reduce((Z,P)=>Z+P),j="";return F?j=`
                if (xIndices[j] >= inputDims[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${e.indicesToOffset("xIndices")}];
                ${o}
              }`:j=`
              }
              let x_val = x[${e.indicesToOffset("xIndices")}];
              ${o}
            `,`
            ${n.declareVariables(e,S)}

            const pads = array<u32, ${M}>(${i.pads.map(Z=>`${Z}u`).join(",")});
            const inputDims = array<u32, ${v}>(${c.map(Z=>`${Z}u`).join(",")});
            const kernelStrides = array<u32, ${k}>(${I.map(Z=>`${Z}u`).join(",")});
            const strides = array<u32, ${k}>(${i.strides.map(Z=>`${Z}u`).join(",")});

            ${n.mainStart()}
              ${n.guardAgainstOutOfBoundsWorkgroupSizes(T)}

              let indices = ${S.offsetToIndices("global_idx")};
              let xIndices = ${S.offsetToIndices("global_idx")};

              var offsets: array<u32, ${k}>;

              var value = ${S.type.value}(${a});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < ${O}u; i++) {
                var offset = i;
                for (var j = 0u; j < ${k-1}u; j++) {
                  offsets[j] = offset / kernelStrides[j];
                  offset -= offsets[j] * kernelStrides[j];
                }
                offsets[${k-1}] = offset;

                isPad = false;
                for (var j = ${v-k}u; j < ${v}u; j++) {
                  xIndices[j] = indices[j] * strides[j - ${v-k}u]
                    + offsets[j - ${v-k}u] - pads[j - 2u];
                  ${j}
              }
              ${s}

              output[global_idx] = value;
            }`}},l0=n=>({format:n.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][n.auto_pad],ceilMode:n.ceil_mode,kernelShape:n.kernel_shape,strides:n.strides,pads:n.pads}),c0=(n,e,r,t)=>{let[i,o]=s0(e,t,r),s=re.size(i.kernelShape),a=fe("x",e.dataType,e.dims),u=a.type.value,c="value += x_val;",g="";return i.countIncludePad?g+=`value /= ${u}(${s});`:g+=`value /= ${u}(${s} - pad);`,{name:n,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:o,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(re.size(o)/64)}}),getShaderSource:v=>u0(v,a,e.dims,o,i,c,g,"0.0")}},f0=n=>{let e=n.count_include_pad!==0,r=l0(n);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return Ce({countIncludePad:e,...r})},d0=(n,e)=>{ss(n.inputs),n.compute(c0("AveragePool",n.inputs[0],!1,e))},p0={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},h0=n=>{let e=n.format;return{format:e,...p0,cacheKey:e}},m0=(n,e)=>{ss(n.inputs),n.compute(c0("GlobalAveragePool",n.inputs[0],!0,e))},g0=(n,e,r,t)=>{let[i,o]=s0(e,t,r),s=`
      value = max(x_val, value);
    `,a="",u=fe("x",e.dataType,e.dims);return{name:n,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:o,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(re.size(o)/64)}}),getShaderSource:c=>u0(c,u,e.dims,o,i,s,a,"-1e5")}},y0=(n,e)=>{ss(n.inputs),n.compute(g0("MaxPool",n.inputs[0],!1,e))},b0=n=>{let e=n.storage_order,r=n.dilations,t=l0(n);if(e!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(t.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return Ce({storageOrder:e,dilations:r,...t})},v0=n=>{let e=n.format;return{format:e,...p0,cacheKey:e}},w0=(n,e)=>{ss(n.inputs),n.compute(g0("GlobalMaxPool",n.inputs[0],!0,e))}});var AS,OS,T0,_0=X(()=>{"use strict";lr();_t();Je();AS=(n,e,r)=>{let t=n===e,i=n<e&&r<0,o=n>e&&r>0;if(t||i||o)throw new Error("Range these inputs' contents are invalid.")},OS=(n,e,r,t)=>{let i=Math.abs(Math.ceil((e-n)/r)),o=[i],s=i,a=Te("output",t,o),u=a.type.storage,c=g=>`
        ${g.declareVariables(a)}
        ${g.mainStart()}
        ${g.guardAgainstOutOfBoundsWorkgroupSizes(s)}
        output[global_idx] = ${u}(${n}) + ${u}(global_idx) * ${u}(${r});
      }`;return{name:"Range",shaderCache:{hint:[n,e,r].map(g=>g.toString()).join("_")},getShaderSource:c,getRunData:()=>({outputs:[{dims:o,dataType:t}],dispatchGroup:{x:Math.ceil(s/64)}})}},T0=n=>{let e=0,r=0,t=0;n.inputs[0].dataType===6?(e=n.inputs[0].getInt32Array()[0],r=n.inputs[1].getInt32Array()[0],t=n.inputs[2].getInt32Array()[0]):n.inputs[0].dataType===1&&(e=n.inputs[0].getFloat32Array()[0],r=n.inputs[1].getFloat32Array()[0],t=n.inputs[2].getFloat32Array()[0]),De.webgpu.validateInputContent&&AS(e,r,t),n.compute(OS(e,r,t,n.inputs[0].dataType),{inputs:[]})}});var ES,PS,DS,kS,BS,RS,MS,LS,NS,zS,FS,jS,GS,WS,VS,$0,S0,I0=X(()=>{"use strict";je();yt();Je();ES=(n,e)=>{if(n.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),n.length>0){if(e.mode==="linear"){if(!(n.length===2||n.length===4&&n[0]===1&&n[1]===1||n.length===4&&n[0]===1&&n[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(e.mode==="cubic"&&!(n.length===2||n.length===4&&n[0]===1&&n[1]===1||n.length===4&&n[0]===1&&n[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},PS=(n,e,r)=>{e.every(i=>i>=0&&i<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let t=new Array(r).fill(1);return e.forEach((i,o)=>t[i]=n[o]),t},DS=(n,e,r,t,i,o)=>{let[s,a,u]=r>10?[1,2,3]:[-1,n.length>1?1:-1,-1],c=n[0].dims.length;if(s>0&&n.length>s&&n[s].dims.length>0)n[s].getFloat32Array().forEach(g=>o.push(g));else if(e.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(a>0&&n.length>a&&n[a].dims.length>0){if(n[a].getFloat32Array().forEach(g=>t.push(g)),t.length!==0&&t.length!==c&&r>=18&&t.length!==e.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");ES(t,e),e.axes.length>0&&PS(t,e.axes,c).forEach((g,v)=>t[v]=g)}if(u>0&&n.length>u&&(n[u].getBigInt64Array().forEach(g=>i.push(Number(g))),i.length!==c||r>=18&&i.length===e.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(e.axes.length>0){if(t.length!==e.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(i.length!==e.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof t<"u"&&typeof i<"u"&&t.length>0&&i.length>c)throw new Error("Resize requires only of scales or sizes to be specified")},kS=n=>"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(n){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`
`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${n} is not supported`)}})()+"}",BS=(n,e)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(n){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(e<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${n} is not supported`)}})()+"}",RS=(n,e,r)=>{let t=new Array(r).fill(0).concat(new Array(r).fill(1)),i=n.length===0?t:n.slice();return e.length>0?(e.forEach((o,s)=>{t[o]=i[s],t[s+r]=i[e.length+s]}),t):i},MS=(n,e,r,t)=>{let i=[];if(r.length>0)if(t.length>0){if(n.forEach(o=>i.push(o)),Math.max(...t)>n.length)throw new Error("axes is out of bound");t.forEach((o,s)=>i[o]=r[s])}else r.forEach(o=>i.push(o));else{if(e.length===0)throw new Error("Resize requires either scales or sizes.");i=n.map((o,s)=>Math.round(o*e[s]))}return i},LS=(n,e,r,t)=>{let i=(()=>{switch(t.keepAspectRatioPolicy){case"not_larger":return t.axes.length>0?Math.min(...t.axes.map(s=>r[s]),Number.MAX_VALUE):Math.min(...r,Number.MAX_VALUE);case"not_smaller":return t.axes.length>0?Math.max(...t.axes.map(s=>r[s]),Number.MIN_VALUE):Math.max(...r,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${t.keepAspectRatioPolicy} is not supported`)}})();r.fill(1,0,r.length);let o=n.slice();return t.axes.length>0?(t.axes.forEach(s=>r[s]=i),t.axes.forEach(s=>o[s]=Math.round(n[s]*r[s]))):(r.fill(i,0,r.length),o.forEach((s,a)=>o[a]=Math.round(s*r[a]))),o},NS=(n,e,r,t,i)=>`
    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${n.type.indices}) -> array<f32, ${r.length}> {
      const inputShape = array<u32, ${e.length}>(${e.map(o=>`${o}u`).join(",")});
      const outputShape = array<u32, ${r.length}>(${r.map(o=>`${o}u`).join(",")});
      const scales = array<f32, ${t.length}>(${t.map(o=>`${o}f`).join(",")});
      const roi = array<f32, ${i.length}>(${i.map(o=>`${o}f`).join(",")});
      var originalIndices: array<f32, ${r.length}>;
      for (var i:u32 = 0; i < ${r.length}; i++) {
        var outputIndex = ${r.length===1?"outputIndices":"outputIndices[i]"};
        if (scales[i] == 1.0) {
          originalIndices[i] = f32(outputIndex);
        } else {
          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],
                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${e.length}]);
        }
      }
      return originalIndices;
    }`,zS=(n,e,r,t,i,o,s)=>`
    fn calculateInputIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> ${n.type.indices} {
        const inputShape = array<u32, ${r.length}>(${r.map(a=>`${a}u`).join(",")});
        const outputShape = array<u32, ${t.length}>(${t.map(a=>`${a}u`).join(",")});
        const scales = array<f32, ${i.length}>(${i.map(a=>`${a}f`).join(",")});
        const roi = array<f32, ${o.length}>(${o.map(a=>`${a}f`).join(",")});
        var inputIndices: ${n.type.indices};
        for (var i:u32 = 0; i < ${t.length}; i++) {
          var outputIndex = ${t.length===1?"outputIndices":"outputIndices[i]"};
          var inputIndex: u32;
          if (scales[i] == 1.0) {
            inputIndex = outputIndex;
          } else {
            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],
                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${r.length}]);
            if (!${s} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {
              if (original_idx < 0) {
                inputIndex = 0;
              } else if (original_idx > (f32(inputShape[i]) - 1)) {
                inputIndex = inputShape[i] - 1;
              } else {
                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));
              }
            } else {
              inputIndex = u32(original_idx);
            }
          }
          ${n.indicesSet("inputIndices","i","inputIndex")}
        }
        return inputIndices;
    }`,FS=(n,e)=>`
    fn checkInputIndices(inputIndices: ${n.type.indices}) -> bool {
      const inputShape = array<u32, ${e.length}>(${e.map(r=>`${r}u`).join(",")});
      for (var i:u32 = 0; i < ${e.length}; i++) {
        var inputIndex = ${e.length===1?"inputIndices":"inputIndices[i]"};
        if (inputIndex < 0 || inputIndex >= inputShape[i]) {
          return false;
        }
      }
      return true;
    }`,jS=(n,e,r,t,i,o,s)=>{let[a,u,c,g]=r.length===2?[-1,0,1,-1]:i[1]===1?[0,2,3,1]:[0,1,2,3];return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {
      var inputIndices: ${n.type.indices};
      inputIndices[${u}] = max(0, min(row, ${r[u]} - 1));
      inputIndices[${c}] = max(0, min(col, ${r[c]} - 1));
      if (${r.length} > 2) {
        inputIndices[${g}] = channel;
        inputIndices[${a}] = batch;
      };
      return input[${n.indicesToOffset("inputIndices")}];
    }

    fn bilinearInterpolation(outputIndices: ${e.type.indices}) -> f32 {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);
      var row:f32 = originalIndices[${u}];
      var col:f32 = originalIndices[${c}];
      if (${o} && (row < 0 || row > (${r[u]} - 1) || col < 0 || col > ${r[c]} - 1)) {
        return ${s};
      }
      row = max(0, min(row, ${r[u]} - 1));
      col = max(0, min(col, ${r[c]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = 0;
      var batch: u32 = 0;
      if (${r.length>2}) {
        channel = u32(originalIndices[${g}]);
        batch = u32(originalIndices[${a}]);
      }
      var x11: f32 = getInputValue(batch, channel, row1, col1);
      var x12: f32 = getInputValue(batch, channel, row1, col2);
      var x21: f32 = getInputValue(batch, channel, row2, col1);
      var x22: f32 = getInputValue(batch, channel, row2, col2);
      var dx1: f32 = row - f32(row1);
      var dx2: f32 = f32(row2 ) - row;
      var dy1 = col - f32(col1);
      var dy2 = f32(col2) - col;
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},GS=(n,e,r,t,i,o,s,a,u,c)=>{let[g,v]=r.length===2?[0,1]:i[1]===1?[2,3]:[1,2],T=S=>{let O=S===g?"row":"col";return`
      fn ${O}CubicInterpolation(inputIndices: ${n.type.indices}, outputIndices: ${e.type.indices}) -> f32 {
        var outputIndex = ${t.length===1?"outputIndices":`outputIndices[${S}]`};
        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${i[S]},
        f32(${t[S]}), f32(${r[S]}), ${o[S]}, ${o[S]} + ${r.length});
        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${a} && (originalIdx < 0 || originalIdx > (${r[S]} - 1))) {
          return ${u};
        }
        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${O}: f32 = originalIdx + f32(i);
          if (${O} < 0 || ${O} >= ${r[S]}) {
            if (${c}) {
              coefs[i + 1] = 0.0;
              continue;
            } else if (${a}) {
              return ${u};
            } else {
              ${O} = max(0, min(${O}, ${r[S]} - 1));
            }
          }
          var inputIndicesCopy: ${n.type.indices} = inputIndices;
          inputIndicesCopy[${S}] = u32(${O});
          data[i + 1] = ${S===g?`input[${n.indicesToOffset("inputIndicesCopy")}];`:`
                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);`}
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${T(g)};
    ${T(v)};
  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {
    var absS = abs(s);
    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: f32 = 1.0 - absS;
    var twoMinusAbsS: f32 = 2.0 - absS;
    var onePlusAbsS: f32 = 1.0 + absS;
    coeffs[0] = ((${s} * onePlusAbsS - 5 * ${s}) * onePlusAbsS + 8 * ${s}) * onePlusAbsS - 4 * ${s};
    coeffs[1] = ((${s} + 2) * absS - (${s} + 3)) * absS * absS + 1;
    coeffs[2] = ((${s} + 2) * oneMinusAbsS - (${s} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${s} * twoMinusAbsS - 5 * ${s}) * twoMinusAbsS + 8 * ${s}) * twoMinusAbsS - 4 * ${s};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {
    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(outputIndices: ${e.type.indices}) -> f32 {
    var inputIndices: ${n.type.indices} = outputIndices;
    return colCubicInterpolation(inputIndices, outputIndices);
  }
    `},WS=(n,e,r,t,i,o)=>{let s=n.dims,a=RS(o,e.axes,s.length),u=MS(s,t,i,e.axes),c=t.slice();t.length===0&&(c=s.map((k,M)=>k===0?1:u[M]/k),e.keepAspectRatioPolicy!=="stretch"&&(u=LS(s,u,c,e)));let g=Te("output",n.dataType,u),v=fe("input",n.dataType,s),T=re.size(u),S=s.length===u.length&&s.every((k,M)=>k===u[M]),O=e.coordinateTransformMode==="tf_crop_and_resize",I=k=>`
      ${kS(e.coordinateTransformMode)};
      ${(()=>{switch(e.mode){case"nearest":return`
              ${FS(v,s)};
              ${BS(e.nearestMode,r)};
              ${zS(v,g,s,u,c,a,O)};
              `;case"linear":return`
              ${NS(g,s,u,c,a)};
              ${jS(v,g,s,u,c,O,e.extrapolationValue)};
              `;case"cubic":return`
            ${GS(v,g,s,u,c,a,e.cubicCoeffA,O,e.extrapolationValue,e.excludeOutside)};
            `;default:throw Error("Invalid resize mode")}})()};
      ${k.declareVariables(v,g)}
      ${k.mainStart()}
        ${k.guardAgainstOutOfBoundsWorkgroupSizes(T)}
        if (${S}) {
          output[global_idx] = input[global_idx];
        } else {
          let outputIndices = ${g.offsetToIndices("global_idx")};
          var inputIndices: ${v.type.indices};
          ${(()=>{switch(e.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);
                  if (checkInputIndices(inputIndices)) {
                    output[global_idx] = input[${v.indicesToOffset("inputIndices")}];
                  } else {
                    output[global_idx] = ${e.extrapolationValue};
                  }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${e.mode}`)}})()};
        }
      }`;return{name:"Resize",shaderCache:{hint:`${e.cacheKey}|${r}|${c.length>0?c:""}|${i.length>0?i:""}`},getShaderSource:I,getRunData:()=>({outputs:[{dims:u,dataType:n.dataType}],dispatchGroup:{x:Math.ceil(T/64)}})}},VS=n=>{let e=n.customDataBuffer;return new Uint32Array(e,e.byteOffset,1)[0]},$0=(n,e)=>{let r=[],t=[],i=[],o=VS(n);DS(n.inputs,e,o,r,t,i),n.compute(WS(n.inputs[0],e,o,r,t,i),{inputs:[0]})},S0=n=>{let e=n.antialias,r=n.axes,t=n.coordinateTransformMode,i=n.cubicCoeffA,o=n.excludeOutside!==0,s=n.extrapolationValue,a=n.keepAspectRatioPolicy,u=n.mode,c=n.nearestMode===""?"simple":n.nearestMode;return Ce({antialias:e,axes:r,coordinateTransformMode:t,cubicCoeffA:i,excludeOutside:o,extrapolationValue:s,keepAspectRatioPolicy:a,mode:u,nearestMode:c})}});var US,HS,C0,A0,O0=X(()=>{"use strict";_t();je();yt();Je();US=n=>{if(!n||n.length<3)throw new Error("layerNorm requires at least 3 inputs.");let e=n[0],r=n[1],t=n[2];if(e.dataType!==r.dataType||e.dataType!==t.dataType)throw new Error("All inputs must have the same data type");if(e.dims.length!==3&&e.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let i=e.dims[e.dims.length-1],o=e.dims[e.dims.length-2];if(r.dims[r.dims.length-1]!==i)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==o)throw new Error("Skip must have the same sequence length as input");if(t.dims.length!==1)throw new Error("Gamma must be 1D");if(t.dims[t.dims.length-1]!==i)throw new Error("Gamma must have the same hidden size as input");if(n.length>3){let s=n[3];if(s.dims.length!==1)throw new Error("Beta must be 1D");if(s.dims[s.dims.length-1]!==i)throw new Error("Beta must have the same hidden size as input")}if(n.length>4){let s=n[4];if(s.dims.length!==1)throw new Error("Bias must be 1D");if(s.dims[s.dims.length-1]!==i)throw new Error("Bias must have the same hidden size as input")}},HS=(n,e,r,t)=>{let i=n[0].dims,o=re.size(i),s=i,a=o,u=i.slice(-1)[0],c=t?i.slice(0,-1).concat(1):[],g=n.length>3,v=n.length>4,T=t&&r>1,S=t&&r>2,O=r>3,I=$n(u),k=[fe("x",n[0].dataType,n[0].dims,I),fe("skip",n[1].dataType,n[1].dims,I),fe("gamma",n[2].dataType,n[2].dims,I)];g&&k.push(fe("beta",n[3].dataType,n[3].dims,I)),v&&k.push(fe("bias",n[4].dataType,n[4].dims,I)),k.push(Te("output",n[0].dataType,s,I)),T&&k.push(Te("meanOutput",1,c)),S&&k.push(Te("invStdOutput",1,c)),O&&k.push(Te("inputSkipBiasSum",n[0].dataType,s,I));let M=bt(n[0].dataType),F=Y=>`
      const hiddenSize: f32 = ${u};
      const hiddenSizeVectorized: u32 = ${u/I};
      const epsilon: f32 = ${e.epsilon};

      ${Y.declareVariables(...k)}

      ${Y.mainStart()}
        ${Y.guardAgainstOutOfBoundsWorkgroupSizes(a/u)}
        let offset = global_idx * hiddenSizeVectorized;
        var sum = ${mr("f32",I)};
        var squareSum = ${mr("f32",I)};
        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {
          let skipValue = skip[offset + i];
          let biasValue = ${v?"bias[i]":"0.0"};
          let inputValue = x[offset + i];
          let value = inputValue + skipValue + biasValue;
          ${O?"inputSkipBiasSum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32Value = ${Sn(M,I,"value")};
          sum += f32Value;
          squareSum += f32Value * f32Value;
        }
        let mean = ${oi("sum",I)} / hiddenSize;
        let variance = sqrt(${oi("squareSum",I)} / hiddenSize - mean * mean + epsilon);
        ${T?"meanOutput[global_idx] = mean;":""}
        ${S?"invStdOutput[global_idx] = 1.0 / variance;":""}
        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {
          output[offset + i] = (output[offset + i] - ${M}(mean)) / ${M}(variance) * gamma[i]
           + ${g?"beta[i]":"0.0"};
        }
      }`,j=[{dims:s,dataType:n[0].dataType}];return r>1&&j.push({dims:c,dataType:1}),r>2&&j.push({dims:c,dataType:1}),r>3&&j.push({dims:i,dataType:n[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:e.cacheKey},getShaderSource:F,getRunData:()=>({outputs:j,dispatchGroup:{x:Math.ceil(a/u/64)}})}},C0=(n,e)=>{US(n.inputs);let t=[0];n.outputCount>1&&t.push(-3),n.outputCount>2&&t.push(-3),n.outputCount>3&&t.push(3),n.compute(HS(n.inputs,e,n.outputCount,!1),{outputs:t})},A0=n=>{let e=n.epsilon;return Ce({epsilon:e})}});var qS,us,KS,E0,XS,YS,P0,D0,k0=X(()=>{"use strict";_t();je();yt();Je();qS=(n,e)=>{if(!n||n.length<1)throw new Error("too few inputs");if(e.axes.length!==0){if(e.axes.length!==e.starts.length||e.axes.length!==e.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(e.starts.length!==e.ends.length)throw new Error("starts and ends must have the same length");n.slice(1).forEach((r,t)=>{if(n[t+1].dataType!==6&&n[t+1].dataType!==7)throw new Error(`Input ${t} must be an array of int32 or int64`)})},us=(n,e)=>{let r=[];if(n.length>e)if(n[e].dataType===7)n[e].getBigInt64Array().forEach(t=>r.push(Number(t)));else if(n[e].dataType===6)n[e].getInt32Array().forEach(t=>r.push(Number(t)));else throw new Error(`Input ${e} must be an array of int32 or int64`);return r},KS=(n,e)=>{if(n.length>1){let r=us(n,1),t=us(n,2),i=us(n,3);return i.length===0&&(i=[...Array(n[0].dims.length).keys()]),Ce({starts:r,ends:t,axes:i})}else return e},E0=(n,e,r,t,i)=>{let o=n;return n<0&&(o+=r[t[e]]),i[e]<0?Math.max(0,Math.min(o,r[t[e]]-1)):Math.max(0,Math.min(o,r[t[e]]))},XS=(n,e,r,t)=>`fn calculateInputIndices(outputIndices: ${e.type.indices}) -> ${n.type.indices} {
          var inputIndices: ${n.type.indices};
          var carry = 0u;
          for (var i = ${r.length}; i >= 0; i--) {
            var outputIndex = ${t.length===1?"outputIndices":"outputIndices[i]"};
            var inputIndex = outputIndex * steps[i] + starts[i] + carry;
            carry = inputIndex / inputShape[i];
            inputIndex = inputIndex % inputShape[i];
            if (signs[i] < 0) {
              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];
            }
            ${r.length===1?"inputIndices":"inputIndices[i]"} = inputIndex;
          }
          return inputIndices;
      }`,YS=(n,e)=>{let r=n[0].dims,t=re.size(r),i=e.axes.length>0?re.normalizeAxes(e.axes,r.length):[...Array(r.length).keys()],o=us(n,4);o.forEach(I=>I!==0||(()=>{throw new Error("step cannot be 0")})),o.length===0&&(o=Array(i.length).fill(1));let s=e.starts.map((I,k)=>E0(I,k,r,i,o)),a=e.ends.map((I,k)=>E0(I,k,r,i,o));if(i.length!==r.length)for(let I=0;I<r.length;++I)i.includes(I)||(s.splice(I,0,0),a.splice(I,0,r[I]),o.splice(I,0,1));let u=o.map(I=>Math.sign(I));o.forEach((I,k,M)=>{if(I<0){let F=(a[k]-s[k])/I,j=s[k],Y=j+F*o[k];s[k]=Y,a[k]=j,M[k]=-I}});let c=r.slice(0);i.forEach((I,k)=>{c[I]=Math.ceil((a[I]-s[I])/o[I])});let g={dims:c,dataType:n[0].dataType},v=Te("output",n[0].dataType,c),T=fe("input",n[0].dataType,r),S=re.size(c),O=I=>`
      ${I.declareVariables(T,v)}
        const signs = array<i32, ${u.length}>(${u.map(k=>`${k}i`).join(",")});
        const starts = array<u32, ${s.length}>(${s.map(k=>`${k}u`).join(",")});
        const ends = array<u32, ${a.length}>(${a.map(k=>`${k}u`).join(",")});
        const steps = array<u32, ${o.length}>(${o.map(k=>`${k}u`).join(",")});
        const inputShape = array<u32, ${r.length}>(${r.map(k=>`${k}u`).join(",")});

        ${XS(T,v,r,c)}
        ${I.mainStart()}
          ${I.guardAgainstOutOfBoundsWorkgroupSizes(S)}
          let outputIndices = ${v.offsetToIndices("global_idx")};
          let inputIndices = calculateInputIndices(outputIndices);
          ${v.setByOffset("global_idx",T.getByIndices("inputIndices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${e.cacheKey}|${n[4]?.dims??""}`},getShaderSource:O,getRunData:()=>({outputs:[g],dispatchGroup:{x:Math.ceil(t/64)}})}},P0=(n,e)=>{qS(n.inputs,e);let r=KS(n.inputs,e);n.compute(YS(n.inputs,r),{inputs:[0]})},D0=n=>{let e=n.starts,r=n.ends,t=n.axes;return Ce({starts:e,ends:r,axes:t})}});var JS,ZS,B0,R0,M0=X(()=>{"use strict";je();yt();Je();JS=n=>{if(!n||n.length!==1)throw new Error("Softmax op requires 1 input.")},ZS=(n,e)=>{let r=bt(n.dataType),t=n.dims,i=re.size(t),o=64,s=e.axis;if(s<0&&(s=t.length+s),s<t.length-1)throw new Error("softmax only supports last axis for now.");let a=t[s],u=i/a,c=r==="f32"?"var threadMax: f32 = -3.402823e+38f;":"var threadMax: f16 = -65504.0h;";return{name:"Softmax",getRunData:()=>({outputs:[{dims:t,dataType:n.dataType}],dispatchGroup:{x:u}}),getShaderSource:v=>`
      var<workgroup> rowMaxShared : ${r};
      var<workgroup> rowSumShared : ${r};
      var<workgroup> threadShared : array<${r}, ${o}>;

      @group(0) @binding(0) var<storage, read> x : array<${r}>;
      @group(0) @binding(1) var<storage, read_write> result : array<${r}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${r} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${r}) {
        let index = row * row_stride + col;
        result[index] = value;
      }

      @compute @workgroup_size(${o}, 1, 1)
      fn main(@builtin(local_invocation_id) local_id : vec3<u32>, @builtin(global_invocation_id) global_id : vec3u) {
        let gindex = i32(global_id.x);
        let lindex = i32(local_id.x);
        const wg = ${o};
        let row = gindex / wg;
        let cols = ${a};
        let row_stride : i32 = ${a};

        // find the rows max
        ${c}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = threadShared[0];
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum: ${r} = 0.0;
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = threadShared[0];
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`}},B0=(n,e)=>{JS(n.inputs),n.compute(ZS(n.inputs[0],e))},R0=n=>Ce({axis:n.axis})});var QS,eI,tI,rI,nI,L0,N0,z0=X(()=>{"use strict";je();yt();Je();QS=n=>{if(!n||n.length<1)throw new Error("too few inputs")},eI=(n,e)=>{let r=[],t=e.numOutputs;return n[1].dims[0]>0&&(n[1].getBigInt64Array().forEach(i=>r.push(Number(i))),t=r.length),Ce({numOutputs:t,axis:e.axis,splitSizes:r})},tI=n=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${n}u; i += 1u ) {
    if (index < sizeInConcatAxis[i]) {
        return i;
    }
    }
    return ${n}u;
}`,rI=n=>{let e=n.length,r=[];for(let t=0;t<e;++t){let i=n[t].setByIndices("indices","input[global_idx]");e===1?r.push(i):t===0?r.push(`if (outputNumber == ${t}u) { ${i} }`):t===e-1?r.push(`else { ${i} }`):r.push(`else if (outputNumber == ${t}) { ${i} }`)}return`
      fn writeBufferData(outputNumber: u32, indices: ${n[0].type.indices}, global_idx: u32) {
        ${r.join(`
`)}
      }`},nI=(n,e)=>{let r=n[0].dims,t=re.size(r),i=n[0].dataType,o=r.length,s=e.axis,a=s<0?r.length+s:s,u=new Array(e.numOutputs),c=fe("input",i,r),g=new Array(e.numOutputs),v=[],T=[],S=0;for(let k=0;k<e.numOutputs;k++){S+=e.splitSizes[k],g[k]=S;let M=r.slice();M[e.axis]=e.splitSizes[k],T.push(M),u[k]=Te(`output${k}`,i,T[k]),v.push({dims:T[k],dataType:n[0].dataType})}let O=o<2?"indices":`indices[${a}]`,I=k=>`
  ${k.declareVariables(c,...u)}
  const sizeInConcatAxis = array<u32, ${g.length}>(${g.map(M=>`${M}u`).join(",")});
  ${tI(g.length)}
  ${rI(u)}

  ${k.mainStart()}
    ${k.guardAgainstOutOfBoundsWorkgroupSizes(t)}

    var indices = ${c.offsetToIndices("global_idx")};
    let outputNumber = calculateOutputIndex(${O});
    if (outputNumber != 0) {
        ${O} -= sizeInConcatAxis[outputNumber - 1u];
    }
    writeBufferData(outputNumber, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:e.cacheKey},getShaderSource:I,getRunData:()=>({outputs:v,dispatchGroup:{x:Math.ceil(t/64)}})}},L0=(n,e)=>{QS(n.inputs);let r=n.inputs.length===1?e:eI(n.inputs,e);n.compute(nI(n.inputs,r),{inputs:[0]})},N0=n=>{let e=n.axis,r=n.splitSizes,t=n.numOutputs<0?r.length:n.numOutputs;if(t!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return Ce({axis:e,numOutputs:t,splitSizes:r})}});var F0,iI,oI,aI,j0,G0=X(()=>{"use strict";_t();je();Je();F0=n=>Array.from(n.getBigInt64Array(),Number),iI=n=>{if(!n||n.length!==2)throw new Error("Tile requires 2 inputs.");if(n[0].dataType!==1&&n[0].dataType!==6&&n[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(n[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(n[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(F0(n[1]).length!==n[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},oI=(n,e)=>{let r=[];for(let t=0;t<n.length;++t)r.push(n[t]*e[t]);return r},aI=n=>{let e=n[0].dims,r=F0(n[1]),t=oI(e,r),i=re.size(t),o=n[0].dataType,s=fe("input",o,e),a=Te("output",o,t),u=c=>`
      const inputShape = ${s.indices(...e)};
      ${c.declareVariables(s,a)}
      ${c.mainStart()}
      ${c.guardAgainstOutOfBoundsWorkgroupSizes(i)}
      let outputIndices = ${a.offsetToIndices("global_idx")};
      var inputIndices: ${s.type.indices};
      for (var i = 0; i < ${e.length}; i++) {
        let inputDimValue = ${a.indicesGet("outputIndices","i")}  % ${s.indicesGet("inputShape","i")};

        ${s.indicesSet("inputIndices","i","inputDimValue")}
      }
      ${a.setByOffset("global_idx",s.getByIndices("inputIndices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${r}`},getRunData:()=>({outputs:[{dims:t,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:u}},j0=n=>{iI(n.inputs),n.compute(aI(n.inputs),{inputs:[0]})}});var sI,uI,W0,V0=X(()=>{"use strict";_t();je();Je();sI=(n,e,r,t,i)=>{let o=re.size(r),s=Math.ceil(o/4),a=Te("outputData",i,r,4),u=fe("aData",e[1].dataType,e[1].dims,4),c=fe("bData",e[2].dataType,e[2].dims,4),g=fe("cData",e[0].dataType,e[0].dims,4),v,T=(S,O,I)=>`select(${O}, ${S}, ${I})`;if(!t)v=a.setByOffset("global_idx",T(u.getByOffset("global_idx"),c.getByOffset("global_idx"),g.getByOffset("global_idx")));else{let S=(O,I,k="")=>{let M=`aData[indexA${I}][componentA${I}]`,F=`bData[indexB${I}][componentB${I}]`,j=`bool(cData[indexC${I}] & ${4278190080>>>(3-I)*8}u)`;return`
            let outputIndices${I} = ${a.offsetToIndices(`global_idx * 4u + ${I}u`)};
            let offsetA${I} = ${u.broadcastedIndicesToOffset(`outputIndices${I}`,a)};
            let offsetB${I} = ${c.broadcastedIndicesToOffset(`outputIndices${I}`,a)};
            let offsetC${I} = ${g.broadcastedIndicesToOffset(`outputIndices${I}`,a)};
            let indexA${I} = offsetA${I} / 4u;
            let indexB${I} = offsetB${I} / 4u;
            let indexC${I} = offsetC${I} / 4u;
            let componentA${I} = offsetA${I} % 4u;
            let componentB${I} = offsetB${I} % 4u;
            ${O}[${I}] = ${k}(${T(M,F,j)});
          `};i===9?v=`
            var data = vec4<u32>(0);
            ${S("data",0,"u32")}
            ${S("data",1,"u32")}
            ${S("data",2,"u32")}
            ${S("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:v=`
            ${S("outputData[global_idx]",0)}
            ${S("outputData[global_idx]",1)}
            ${S("outputData[global_idx]",2)}
            ${S("outputData[global_idx]",3)}
          `}return`
        ${n.declareVariables(g,u,c,a)}
        ${n.mainStart()}
        ${n.guardAgainstOutOfBoundsWorkgroupSizes(s)}
        ${v}
      }`},uI=n=>{let e=n[1].dims,r=n[2].dims,t=n[0].dims,i=n[1].dataType,o=!(re.areEqual(e,r)&&re.areEqual(r,t)),s=e,a=re.size(e);if(o){let u=Ar.calcShape(Ar.calcShape(e,r,!1),t,!1);if(!u)throw new Error("Can't perform where op on the given tensors");s=u,a=re.size(s)}return{name:"Where",getShaderSource:u=>sI(u,n,s,o,i),getRunData:()=>({outputs:[{dims:s,dataType:i}],dispatchGroup:{x:Math.ceil(a/64/4)}})}},W0=n=>{n.compute(uI(n.inputs))}});var U0,H0=X(()=>{"use strict";wy();Ty();tb();db();mb();Yu();kb();Lb();Fb();Wb();Hb();Xb();Zb();t0();n0();a0();x0();_0();Wu();I0();O0();k0();M0();z0();G0();os();Hu();V0();U0=new Map([["Abs",[_y]],["Acos",[$y]],["Acosh",[Sy]],["Add",[rb]],["ArgMax",[vy,Vu]],["ArgMin",[by,Vu]],["Asin",[Iy]],["Asinh",[Cy]],["Atan",[Ay]],["Atanh",[Oy]],["AveragePool",[d0,f0]],["BiasAdd",[xy]],["BiasSplitGelu",[eb]],["Cast",[Py,Ey]],["Ceil",[ky]],["ClipV10",[Uu]],["Clip",[Dy]],["Concat",[pb,hb]],["Conv",[Ib,Sb]],["ConvTranspose",[Db,Pb]],["Cos",[By]],["Cosh",[Ry]],["Div",[nb]],["Einsum",[Rb,Mb]],["Elu",[My,Ya]],["Equal",[ib]],["Erf",[Ly]],["Exp",[Ny]],["Expand",[zb]],["Floor",[zy]],["Gather",[Gb,jb]],["GatherElements",[Ub,Vb]],["Gelu",[Fy]],["Gemm",[qb,Kb]],["GlobalAveragePool",[m0,h0]],["GlobalMaxPool",[w0,v0]],["Greater",[ub]],["GreaterOrEqual",[cb]],["InstanceNormalization",[Jb,Yb]],["LayerNormalization",[e0,Qb]],["LeakyRelu",[jy,Ya]],["Less",[lb]],["LessOrEqual",[fb]],["Log",[Qy]],["MatMul",[r0]],["MaxPool",[y0,b0]],["Mul",[ob]],["Neg",[Wy]],["Not",[Gy]],["Pad",[i0,o0]],["Pow",[ab]],["Range",[T0]],["Reciprocal",[Vy]],["ReduceMin",[dy,gr]],["ReduceMean",[fy,gr]],["ReduceMax",[cy,gr]],["ReduceSum",[hy,gr]],["ReduceProd",[py,gr]],["ReduceL1",[sy,gr]],["ReduceL2",[uy,gr]],["ReduceLogSum",[ay,gr]],["ReduceLogSumExp",[ly,gr]],["ReduceSumSquare",[my,gr]],["Relu",[Uy]],["Resize",[$0,S0]],["Sigmoid",[Hy]],["Sin",[qy]],["Sinh",[Ky]],["Slice",[P0,D0]],["SkipLayerNormalization",[C0,A0]],["Split",[L0,N0]],["Sqrt",[Xy]],["Softmax",[B0,R0]],["Sub",[sb]],["Tan",[Yy]],["Tanh",[Jy]],["ThresholdedRelu",[Zy,Ya]],["Tile",[j0]],["Transpose",[xb,Tb]],["Where",[W0]]])});var ls,q0=X(()=>{"use strict";_t();Hr();Je();ls=class{constructor(e){this.backend=e;this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,r){this.repo.set(e,r)}run(e,r,t,i,o,s,a){let u=this.backend.device,c=this.backend.getComputePassEncoder(),g=this.backend.supportTimestampQuery&&this.backend.env.webgpu.profilingMode==="default";g&&c.writeTimestamp(this.backend.profilingQuerySet,0),c.setPipeline(e.computePipeline);let v=[];for(let S of i)v.push({binding:v.length,resource:{buffer:S.buffer}});for(let S of o)v.push({binding:v.length,resource:{buffer:S.buffer}});a&&v.push({binding:v.length,resource:a});let T=u.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:v,label:e.programInfo.name});if(c.setBindGroup(0,T),c.dispatchWorkgroups(...s),this.backend.pendingDispatchNumber++,g){c.writeTimestamp(this.backend.profilingQuerySet,1),this.backend.profilingQueryData==null&&(this.backend.profilingQueryData=this.backend.gpuDataManager.create(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let S=this.backend.gpuDataManager.create(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.profilingQuerySet,0,2,this.backend.profilingQueryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.profilingQueryData.buffer,0,S.buffer,0,16),this.backend.flush();let O=this.backend.currentKernelId,I=this.backend.kernels.get(O),k=`[${I[0]}] ${I[1]}`;S.buffer.mapAsync(GPUMapMode.READ).then(()=>{let M=new BigUint64Array(S.buffer.getMappedRange()),F=M[0],j=M[1];S.buffer.unmap(),typeof this.backend.profilingTimeBase>"u"&&(this.backend.profilingTimeBase=F);let Y=Number(F-this.backend.profilingTimeBase),Z=Number(j-this.backend.profilingTimeBase);if(!Number.isSafeInteger(Y)||!Number.isSafeInteger(Z))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(S.id);let P="";r.forEach((ue,le)=>{P+=`input[${le}]: [${ue.dims}] | ${co(ue.dataType)}, `});let te="";t.forEach((ue,le)=>{te+=`output[${le}]: [${ue.dims}] | ${co(ue.dataType)}, `}),console.log(`[profiling] kernel "${O}|${k}" ${P}${te}execution time: ${Z-Y} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(e,r){let t=this.backend.device,i=[];t.features.has("shader-f16")&&i.push("enable f16;");let o=oy(r),s=e.getShaderSource(o),a=`${i.join(`
`)}
${o.additionalImplementations}
${s}`,u=t.createShaderModule({code:a,label:e.name});ct("verbose",()=>`[WebGPU] shader code: ${a}`);let c=t.createComputePipeline({compute:{module:u,entryPoint:"main"},layout:"auto",label:e.name});return{programInfo:e,computePipeline:c}}normalizeDispatchGroupSize(e){let r=typeof e=="number"?e:e.x,t=typeof e=="number"?1:e.y||1,i=typeof e=="number"?1:e.z||1,o=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=o&&t<=o&&i<=o)return[r,t,i];let s=r*t*i,a=Math.ceil(Math.sqrt(s));if(a>o){if(a=Math.ceil(Math.cbrt(s)),a>o)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[a,a,a]}else return[a,a,1]}}});var lI,cI,cs,K0=X(()=>{"use strict";Hr();Zg();ry();H0();q0();lI=(n,e)=>{if(e.length!==n.length)throw new Error(`inputDependencies length ${e.length} is not equal to inputTensors length ${n.length}.`);let r=[];for(let t=0;t<n.length;++t){let i=n[t].dataType;switch(e[t]){case"none":{r.push("");break}case"type":{r.push(`${i}`);break}case"rank":{let o=n[t].dims.length;r.push(`${i};${o}`);break}case"dims":{let o=n[t].dims.join(",");r.push(`${i};${o}`);break}default:throw new Error(`unsupported input dependency: ${e[t]}`)}}return r.join("|")},cI=(n,e)=>{let r=n.name;return n.shaderCache?.hint&&(r+="["+n.shaderCache.hint+"]"),r+=`:${lI(e,n.shaderCache?.inputDependencies??new Array(e.length).fill("dims"))}`,r},cs=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.supportTimestampQuery=!1;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let r=await navigator.gpu.requestAdapter();if(!r)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=e;let t=[],i={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:t};r.features.has("timestamp-query-inside-passes")&&(this.supportTimestampQuery=!0,t.push("timestamp-query-inside-passes")),r.features.has("shader-f16")&&t.push("shader-f16"),this.device=await r.requestDevice(i),this.gpuDataManager=ty(this),this.programManager=new ls(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Yg(e.logLevel,!!e.debug),this.device.onuncapturederror=o=>{o.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${o.error.message}`)},this.supportTimestampQuery&&(this.profilingQuerySet=this.device.createQuerySet({type:"timestamp",count:2})),Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){return this.computePassEncoder||(this.computePassEncoder=this.getCommandEncoder().beginComputePass()),this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}run(e,r,t,i,o){let s=[];for(let M=0;M<r.length;++M){let F=this.gpuDataManager.get(r[M].data);if(!F)throw new Error(`no GPU data for input: ${r[M].data}`);s[M]=F}let a=cI(e,r),u=this.programManager.getArtifact(a),{outputs:c,dispatchGroup:g,programUniforms:v}=e.getRunData(r),T=t.length===0?c.map((M,F)=>F):t;if(T.length!==c.length)throw new Error(`Output size ${T.length} must be equal to ${c.length}.`);let S=[],O=[];for(let M=0;M<c.length;++M){if(!Number.isInteger(T[M])||T[M]<-3||T[M]>=c.length)throw new Error(`Invalid output index: ${T[M]}`);if(T[M]===-3)continue;let F=T[M]===-1,j=T[M]===-2,Y=F||j?o(c[M].dataType,c[M].dims):i(T[M],c[M].dataType,c[M].dims),Z=this.gpuDataManager.get(Y.data);if(!Z)throw new Error(`no GPU data for output: ${Y.data}`);if(F&&this.temporaryData.push(Z),j){let P=this.kernelPersistentData.get(this.currentKernelId);P||(P=[],this.kernelPersistentData.set(this.currentKernelId,P)),P.push(Z)}S.push(Y),O.push(Z)}let I;if(v){let M=0,F=0,j=[],Y=1;v.forEach(te=>{let ue=typeof te.data=="number"?[te.data]:te.data,le;switch(ue.length){case 1:le=4;break;case 2:le=8;break;case 3:le=16;break;case 4:le=16;break;case 5:le=16;break;case 6:le=16;break;default:throw new Error(`unsupported data length: ${ue.length}`)}(F===5||F===6)&&(le=16),le>Y&&(Y=le),M=Math.ceil(M/le)*le,F=ue.length,j.push(M),M+=ue.length*4}),M=Math.ceil(M/Y)*Y;let Z=new ArrayBuffer(M);v.forEach((te,ue)=>{let le=j[ue],Ae=typeof te.data=="number"?[te.data]:te.data;te.type==="int32"?new Int32Array(Z,le,Ae.length).set(Ae):te.type==="uint32"?new Uint32Array(Z,le,Ae.length).set(Ae):new Float32Array(Z,le,Ae.length).set(Ae)});let P=this.gpuDataManager.create(M,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(P.buffer,0,Z,0,M),this.gpuDataManager.release(P.id),I={offset:0,size:M,buffer:P.buffer}}let k=this.programManager.normalizeDispatchGroupSize(g);return u||(u=this.programManager.build(e,k),this.programManager.setArtifact(a,u)),ct("info",()=>`[ProgramManager] run "${e.name}" (key=${a}) with ${k[0]}x${k[1]}x${k[2]}`),this.programManager.run(u,r,S,s,O,k,I),S}upload(e,r){this.gpuDataManager.upload(e,r)}memcpy(e,r){this.gpuDataManager.memcpy(e,r)}async download(e,r){await this.gpuDataManager.download(e,r)}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,r,t,i){let o=U0.get(e);if(!o)throw new Error(`kernel not implemented: ${e}`);this.kernels.set(r,[e,i,o[0],[o[1],t]])}releaseKernel(e){let r=this.kernelPersistentData.get(e);if(r){for(let t of r)this.gpuDataManager.release(t.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,r,t){let i=this.kernels.get(e);if(!i)throw new Error(`kernel not created: ${e}`);let[o,s,a,u]=i;if(this.currentKernelId!==null)throw new Error(`kernel "[${o}] ${s}" is not allowed to be called recursively`);this.currentKernelId=e,u[0]&&(u[1]=u[0](u[1]),u[0]=void 0),ct("info",()=>`[WebGPU] Start to run kernel "[${o}] ${s}"...`);let c=this.env.debug;this.temporaryData=[];try{return c&&this.device.pushErrorScope("validation"),a(r,u[1]),0}catch(g){return t.push(Promise.resolve(`[WebGPU] Kernel "[${o}] ${s}" failed. ${g}`)),1}finally{c&&t.push(this.device.popErrorScope().then(g=>g?`GPU validation error for kernel "[${o}] ${s}": ${g.message}`:null));for(let g of this.temporaryData)this.gpuDataManager.release(g.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(e,r,t,i){let o=this.sessionExternalDataMapping.get(e);o||(o=new Map,this.sessionExternalDataMapping.set(e,o));let s=o.get(r),a=this.gpuDataManager.registerExternalBuffer(t,i,s?.[1]);return o.set(r,[a,t]),a}unregisterBuffers(e){let r=this.sessionExternalDataMapping.get(e);r&&(r.forEach(t=>this.gpuDataManager.unregisterExternalBuffer(t[1])),this.sessionExternalDataMapping.delete(e))}getBuffer(e){let r=this.gpuDataManager.get(e);if(!r)throw new Error(`no GPU data for buffer: ${e}`);return r.buffer}createDownloader(e,r,t){return async()=>{let i=await Lu(this,e,r);return Jg(i.buffer,t)}}}});var X0={};ln(X0,{init:()=>fI});var bo,tl,fI,Y0=X(()=>{"use strict";_t();K0();Hr();je();bo=class n{constructor(e,r,t,i){this.module=e;this.dataType=r;this.data=t;this.dims=i}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let e=re.size(this.dims);return e===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let e=re.size(this.dims);return e===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let e=re.size(this.dims);return e===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}reshape(e){if(re.size(e)!==re.size(this.dims))throw new Error("Invalid new shape");return new n(this.module,this.dataType,this.data,e)}},tl=class{constructor(e,r,t){this.module=e;this.backend=r;this.customDataOffset=0;this.customDataSize=0;let i=e.HEAPU32,o=t>>2;this.opKernelContext=i[o++];let s=i[o++];this.outputCount=i[o++],this.customDataOffset=i[o++],this.customDataSize=i[o++];let a=[];for(let u=0;u<s;u++){let c=i[o++],g=i[o++],v=i[o++],T=[];for(let S=0;S<v;S++)T.push(i[o++]);a.push(new bo(e,c,g,T))}this.inputs=a}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(e,r){let t=r?.inputs?.map(a=>typeof a=="number"?this.inputs[a]:a)??this.inputs,i=r?.outputs??[],o=(a,u,c)=>new bo(this.module,u,this.output(a,c),c),s=(a,u)=>{let c=fo(a);if(!c)throw new Error(`Unsupported data type: ${a}`);let g=c*re.size(u);return new bo(this.module,a,this.backend.gpuDataManager.create(g).id,u)};return this.backend.run(e,t,i,o,s)}output(e,r){let t=this.module.stackSave();try{let i=this.module.stackAlloc((1+r.length)*4),o=i>>2;this.module.HEAPU32[o++]=r.length;for(let s=0;s<r.length;s++)this.module.HEAPU32[o++]=r[s];return this.module._JsepOutput(this.opKernelContext,e,i)}catch(i){throw new Error(`Failed to generate kernel's output[${e}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${i}`)}finally{this.module.stackRestore(t)}}},fI=async(n,e)=>{let r=n.jsepInit;if(r&&navigator.gpu){if(!e.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let t=new cs;await t.initialize(e),r(t,i=>t.alloc(i),i=>t.free(i),(i,o,s,a=!1)=>{if(a)ct("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${i}, dst=${o}, size=${s}`),t.memcpy(i,o);else{ct("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${i}, gpuDataId=${o}, size=${s}`);let u=n.HEAPU8.subarray(i,i+s);t.upload(o,u)}},async(i,o,s)=>{ct("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${i}, dataOffset=${o}, size=${s}`),await t.download(i,()=>n.HEAPU8.subarray(o,o+s))},(i,o,s)=>t.createKernel(i,o,s,e.debug||e.webgpu.profilingMode==="default"?n.UTF8ToString(n._JsepGetNodeName(o)):`${o}`),i=>t.releaseKernel(i),(i,o,s,a)=>{ct("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${s}, kernel=${i}, contextDataOffset=${o}`);let u=new tl(n,t,o);return t.computeKernel(i,u,a)})}}});var dI,pI,Z0,vo,rl,nl,Q0,ev,J0,tv,rv,nv,iv=X(()=>{"use strict";Ug();qg();_t();ii();Ga();dI=n=>{let e=gt(),r=e.stackSave();try{let t=e.stackAlloc(8);return e._OrtGetInputOutputCount(n,t,t+4)!==0&&ut("Can't get session input/output count."),[e.HEAP32[t/4],e.HEAP32[t/4+1]]}finally{e.stackRestore(r)}},pI=(n,e)=>{gt()._OrtInit(n,e)!==0&&ut("Can't initialize onnxruntime.")},Z0=async n=>{pI(n.wasm.numThreads,po(n.logLevel));{let e=(Y0(),Rr(X0)).init;await e(gt(),n)}},vo=new Map,rl=n=>{let e=gt(),r=e._malloc(n.byteLength);if(r===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${n.byteLength}.`);return e.HEAPU8.set(n,r),[r,n.byteLength]},nl=(n,e)=>{let r=gt(),t=0,i=0,o=0,s=[],a=[],u=[];try{[i,s]=Hg(e),t=r._OrtCreateSession(n[0],n[1],i),t===0&&ut("Can't create a session.");let[c,g]=dI(t),v=[],T=[],S=[];for(let I=0;I<c;I++){let k=r._OrtGetInputName(t,I);k===0&&ut("Can't get an input name."),a.push(k),v.push(r.UTF8ToString(k))}for(let I=0;I<g;I++){let k=r._OrtGetOutputName(t,I);k===0&&ut("Can't get an output name."),u.push(k);let M=r.UTF8ToString(k);T.push(M);{let F=typeof e?.preferredOutputLocation=="string"?e.preferredOutputLocation:e?.preferredOutputLocation?.[M]??"cpu";if(F!=="cpu"&&F!=="cpu-pinned"&&F!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${F}.`);S.push(F)}}let O=null;return S.some(I=>I==="gpu-buffer")&&(o=r._OrtCreateBinding(t),o===0&&ut("Can't create IO binding."),O={handle:o,outputPreferredLocations:S,outputPreferredLocationsEncoded:S.map(I=>Ru(I))}),vo.set(t,[t,a,u,O]),[t,v,T]}catch(c){throw a.forEach(g=>r._OrtFree(g)),u.forEach(g=>r._OrtFree(g)),o!==0&&r._OrtReleaseBinding(o),t!==0&&r._OrtReleaseSession(t),c}finally{r._free(n[0]),i!==0&&r._OrtReleaseSessionOptions(i),s.forEach(c=>r._free(c))}},Q0=(n,e)=>{let r=rl(n);return nl(r,e)},ev=n=>{let e=gt(),r=vo.get(n);if(!r)throw new Error(`cannot release session. invalid session id: ${n}`);let[t,i,o,s]=r;s&&e._OrtReleaseBinding(s.handle),e.jsepUnregisterBuffers?.(n),i.forEach(a=>e._OrtFree(a)),o.forEach(a=>e._OrtFree(a)),e._OrtReleaseSession(t),vo.delete(n)},J0=(n,e,r,t,i)=>{if(!n){e.push(0);return}let o=gt(),s=n[0],a=n[1],u=n[3],c,g;if(s==="string"&&u==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(u==="gpu-buffer"){let S=n[2].gpuBuffer,O=fo(Bu(s));g=a.reduce((I,k)=>I*k,1)*O,c=o.jsepRegisterBuffer(t,i,S,g)}else{let S=n[2];if(Array.isArray(S)){g=4*S.length,c=o._malloc(g),r.push(c);let O=c/4;for(let I=0;I<S.length;I++){if(typeof S[I]!="string")throw new TypeError(`tensor data at index ${I} is not a string`);o.HEAPU32[O++]=Tt(S[I],r)}}else g=S.byteLength,c=o._malloc(g),r.push(c),o.HEAPU8.set(new Uint8Array(S.buffer,S.byteOffset,g),c)}let v=o.stackSave(),T=o.stackAlloc(4*a.length);try{let S=T/4;a.forEach(I=>o.HEAP32[S++]=I);let O=o._OrtCreateTensor(Bu(s),c,g,T,a.length,Ru(u));O===0&&ut(`Can't create tensor for input/output. session=${t}, index=${i}.`),e.push(O)}finally{o.stackRestore(v)}},tv=async(n,e,r,t,i,o)=>{let s=gt(),a=vo.get(n);if(!a)throw new Error(`cannot run inference. invalid session id: ${n}`);let[u,c,g,v]=a,T=e.length,S=t.length,O=0,I=[],k=[],M=[],F=[],j=s.stackSave(),Y=s.stackAlloc(T*4),Z=s.stackAlloc(T*4),P=s.stackAlloc(S*4),te=s.stackAlloc(S*4);try{[O,I]=Vg(o);for(let me=0;me<T;me++)J0(r[me],k,F,n,e[me]);for(let me=0;me<S;me++)J0(i[me],M,F,n,T+t[me]);let ue=Y/4,le=Z/4,Ae=P/4,q=te/4;for(let me=0;me<T;me++)s.HEAPU32[ue++]=k[me],s.HEAPU32[le++]=c[e[me]];for(let me=0;me<S;me++)s.HEAPU32[Ae++]=M[me],s.HEAPU32[q++]=g[t[me]];if(v){let{handle:me,outputPreferredLocations:de,outputPreferredLocationsEncoded:Dt}=v;if(c.length!==T)throw new Error(`input count from feeds (${T}) is expected to be always equal to model's input count (${c.length}).`);for(let Ge=0;Ge<T;Ge++){let wt=e[Ge];await s._OrtBindInput(me,c[wt],k[Ge])!==0&&ut(`Can't bind input[${Ge}] for session=${n}.`)}for(let Ge=0;Ge<S;Ge++){let wt=t[Ge];i[Ge]?.[3]?s._OrtBindOutput(me,g[wt],M[Ge],0)!==0&&ut(`Can't bind pre-allocated output[${Ge}] for session=${n}.`):s._OrtBindOutput(me,g[wt],0,Dt[wt])!==0&&ut(`Can't bind output[${Ge}] to ${de[Ge]} for session=${n}.`)}}let ge;v?ge=await s._OrtRunWithBinding(u,v.handle,S,P,O):ge=await s._OrtRun(u,Z,Y,T,te,S,P,O),ge!==0&&ut("failed to call OrtRun().");let it=[];for(let me=0;me<S;me++){let de=s.HEAPU32[P/4+me];if(de===M[me]){it.push(i[me]);continue}let Dt=s.stackSave(),Ge=s.stackAlloc(4*4),wt=!1,Ye,$t=0;try{s._OrtGetTensorData(de,Ge,Ge+4,Ge+8,Ge+12)!==0&&ut(`Can't access output tensor data on index ${me}.`);let Et=Ge/4,Dr=s.HEAPU32[Et++];$t=s.HEAPU32[Et++];let ie=s.HEAPU32[Et++],Be=s.HEAPU32[Et++],He=[];for(let ft=0;ft<Be;ft++)He.push(s.HEAPU32[ie/4+ft]);s._OrtFree(ie);let kt=He.reduce((ft,ot)=>ft*ot,1);Ye=co(Dr);let Lt=v?.outputPreferredLocations[t[me]];if(Ye==="string"){if(Lt==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let ft=[],ot=$t/4;for(let Nt=0;Nt<kt;Nt++){let br=s.HEAPU32[ot++],nr=Nt===kt-1?void 0:s.HEAPU32[ot]-br;ft.push(s.UTF8ToString(br,nr))}it.push([Ye,He,ft,"cpu"])}else if(Lt==="gpu-buffer"&&kt>0){let ft=s.jsepGetBuffer($t),ot=fo(Dr);if(ot===void 0||!Va(Ye))throw new Error(`Unsupported data type: ${Ye}`);wt=!0,it.push([Ye,He,{gpuBuffer:ft,download:s.jsepCreateDownloader(ft,kt*ot,Ye),dispose:()=>{s._OrtReleaseTensor(de)}},"gpu-buffer"])}else{let ft=Wa(Ye),ot=new ft(kt);new Uint8Array(ot.buffer,ot.byteOffset,ot.byteLength).set(s.HEAPU8.subarray($t,$t+ot.byteLength)),it.push([Ye,He,ot,"cpu"])}}finally{s.stackRestore(Dt),Ye==="string"&&$t&&s._free($t),wt||s._OrtReleaseTensor(de)}}return v&&s._OrtClearBoundOutputs(v.handle),it}finally{s.stackRestore(j),k.forEach(ue=>s._OrtReleaseTensor(ue)),M.forEach(ue=>s._OrtReleaseTensor(ue)),F.forEach(ue=>s._free(ue)),O!==0&&s._OrtReleaseRunOptions(O),I.forEach(ue=>s._free(ue))}},rv=n=>{let e=gt(),r=vo.get(n);if(!r)throw new Error("invalid session id");let t=r[0],i=e._OrtEndProfiling(t);i===0&&ut("Can't get an profile file name."),e._OrtFree(i)},nv=n=>{let e=[];for(let r of n){let t=r[2];!Array.isArray(t)&&"buffer"in t&&e.push(t.buffer)}return e}});var ov=et((pz,mI)=>{mI.exports='/*!\n * ONNX Runtime Web v1.17.0\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var ui=Object.defineProperty;var wp=Object.getOwnPropertyDescriptor;var Cp=Object.getOwnPropertyNames;var $p=Object.prototype.hasOwnProperty;var oe=(t,r)=>()=>(t&&(r=t(t=0)),r);var Zr=(t,r)=>()=>(r||t((r={exports:{}}).exports,r),r.exports),Dn=(t,r)=>{for(var e in r)ui(t,e,{get:r[e],enumerable:!0})},xp=(t,r,e,d)=>{if(r&&typeof r=="object"||typeof r=="function")for(let l of Cp(r))!$p.call(t,l)&&l!==e&&ui(t,l,{get:()=>r[l],enumerable:!(d=wp(r,l))||d.enumerable});return t};var cr=t=>xp(ui({},"__esModule",{value:!0}),t);var li={};Dn(li,{readFile:()=>Sp});var Sp,ci=oe(()=>{Sp=void 0});var di={};Dn(di,{join:()=>_p});var _p,fi=oe(()=>{_p=void 0});var Ta=Zr((Ia,pi)=>{"use strict";var Aa=(()=>{var t=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(t=t||__filename),function(r={}){var e=r,d,l;e.ready=new Promise((n,i)=>{d=n,l=i}),e.jsepInit=(n,i,o,a,s,f,p,g)=>{e.zh=n,e.ph=i,e.rh=o,e.eh=a,e.qh=s,e.Cd=f,e.sh=p,e.th=g,i=(y,v,C)=>(...S)=>{let I=nt,$=v?.();S=y(...S);let M=v?.();return $!==M&&(y=M,C($),v=C=null),nt!=I?gn():S},o=y=>async(...v)=>{try{if(e.Xg)throw Error("Session already started");let C=e.Xg={uh:v[0],errors:[]},S=await y(...v);if(e.Xg!==C)throw Error("Session mismatch");n.flush();let I=C.errors;if(0<I.length){let $=await Promise.all(I);if($=$.filter(M=>M),0<$.length)throw Error($.join(`\n`))}return S}finally{e.Xg=null}},e._OrtRun=o(i(e._OrtRun,()=>e._OrtRun,y=>e._OrtRun=y)),e._OrtRunWithBinding=o(i(e._OrtRunWithBinding,()=>e._OrtRunWithBinding,y=>e._OrtRunWithBinding=y)),e._OrtBindInput=i(e._OrtBindInput,()=>e._OrtBindInput,y=>e._OrtBindInput=y),e.jsepRegisterBuffer=(y,v,C,S)=>n.registerBuffer(y,v,C,S),e.jsepUnregisterBuffers=y=>{n.unregisterBuffers(y)},e.jsepGetBuffer=y=>n.getBuffer(y),e.jsepCreateDownloader=(y,v,C)=>n.createDownloader(y,v,C)};var m=Object.assign({},e),h="./this.program",u=(n,i)=>{throw i},w=typeof window=="object",_=typeof importScripts=="function",O=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",j="",B,P,R;if(O){var T=(ci(),cr(li)),k=(fi(),cr(di));j=_?k.dirname(j)+"/":__dirname+"/",B=(n,i)=>(n=n.startsWith("file://")?new URL(n):k.normalize(n),T.readFileSync(n,i?void 0:"utf8")),R=n=>(n=B(n,!0),n.buffer||(n=new Uint8Array(n)),n),P=(n,i,o,a=!0)=>{n=n.startsWith("file://")?new URL(n):k.normalize(n),T.readFile(n,a?void 0:"utf8",(s,f)=>{s?o(s):i(a?f.buffer:f)})},!e.thisProgram&&1<process.argv.length&&(h=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),u=(n,i)=>{throw process.exitCode=n,i},e.inspect=()=>"[Emscripten Module object]"}else(w||_)&&(_?j=self.location.href:typeof document<"u"&&document.currentScript&&(j=document.currentScript.src),t&&(j=t),j.indexOf("blob:")!==0?j=j.substr(0,j.replace(/[?#].*/,"").lastIndexOf("/")+1):j="",B=n=>{var i=new XMLHttpRequest;return i.open("GET",n,!1),i.send(null),i.responseText},_&&(R=n=>{var i=new XMLHttpRequest;return i.open("GET",n,!1),i.responseType="arraybuffer",i.send(null),new Uint8Array(i.response)}),P=(n,i,o)=>{var a=new XMLHttpRequest;a.open("GET",n,!0),a.responseType="arraybuffer",a.onload=()=>{a.status==200||a.status==0&&a.response?i(a.response):o()},a.onerror=o,a.send(null)});var U=e.print||console.log.bind(console),K=e.printErr||console.error.bind(console);Object.assign(e,m),m=null,e.thisProgram&&(h=e.thisProgram),e.quit&&(u=e.quit);var Q;e.wasmBinary&&(Q=e.wasmBinary);var L=e.noExitRuntime||!0;typeof WebAssembly!="object"&&Je("no native wasm support detected");var X,A,Z=!1,re,ie,Ce,H,le,Be;function ue(){var n=X.buffer;e.HEAP8=ie=new Int8Array(n),e.HEAP16=new Int16Array(n),e.HEAP32=H=new Int32Array(n),e.HEAPU8=Ce=new Uint8Array(n),e.HEAPU16=new Uint16Array(n),e.HEAPU32=le=new Uint32Array(n),e.HEAPF32=new Float32Array(n),e.HEAPF64=Be=new Float64Array(n)}var ae=[],Ze=[],Ie=[];function He(){var n=e.preRun.shift();ae.unshift(n)}var Ee=0,qe=null,gt=null;function Je(n){throw e.onAbort&&e.onAbort(n),n="Aborted("+n+")",K(n),Z=!0,re=1,n=new WebAssembly.RuntimeError(n+". Build with -sASSERTIONS for more info."),l(n),n}function _t(n){return n.startsWith("data:application/octet-stream;base64,")}var ee;if(ee="ort-wasm-simd.wasm",!_t(ee)){var $e=ee;ee=e.locateFile?e.locateFile($e,j):j+$e}function Oe(n){if(n==ee&&Q)return new Uint8Array(Q);if(R)return R(n);throw"both async and sync fetching of the wasm failed"}function et(n){if(!Q&&(w||_)){if(typeof fetch=="function"&&!n.startsWith("file://"))return fetch(n,{credentials:"same-origin"}).then(i=>{if(!i.ok)throw"failed to load wasm binary file at \'"+n+"\'";return i.arrayBuffer()}).catch(()=>Oe(n));if(P)return new Promise((i,o)=>{P(n,a=>i(new Uint8Array(a)),o)})}return Promise.resolve().then(()=>Oe(n))}function tt(n,i,o){return et(n).then(a=>WebAssembly.instantiate(a,i)).then(a=>a).then(o,a=>{K("failed to asynchronously prepare wasm: "+a),Je(a)})}function Ge(n,i){var o=ee;return Q||typeof WebAssembly.instantiateStreaming!="function"||_t(o)||o.startsWith("file://")||O||typeof fetch!="function"?tt(o,n,i):fetch(o,{credentials:"same-origin"}).then(a=>WebAssembly.instantiateStreaming(a,n).then(i,function(s){return K("wasm streaming compile failed: "+s),K("falling back to ArrayBuffer instantiation"),tt(o,n,i)}))}var Me,rt={1312944:n=>{e.Cd("Abs",n,void 0)},1312995:n=>{e.Cd("Neg",n,void 0)},1313046:n=>{e.Cd("Floor",n,void 0)},1313099:n=>{e.Cd("Ceil",n,void 0)},1313151:n=>{e.Cd("Reciprocal",n,void 0)},1313209:n=>{e.Cd("Sqrt",n,void 0)},1313261:n=>{e.Cd("Exp",n,void 0)},1313312:n=>{e.Cd("Erf",n,void 0)},1313363:n=>{e.Cd("Sigmoid",n,void 0)},1313418:n=>{e.Cd("Log",n,void 0)},1313469:n=>{e.Cd("Sin",n,void 0)},1313520:n=>{e.Cd("Cos",n,void 0)},1313571:n=>{e.Cd("Tan",n,void 0)},1313622:n=>{e.Cd("Asin",n,void 0)},1313674:n=>{e.Cd("Acos",n,void 0)},1313726:n=>{e.Cd("Atan",n,void 0)},1313778:n=>{e.Cd("Sinh",n,void 0)},1313830:n=>{e.Cd("Cosh",n,void 0)},1313882:n=>{e.Cd("Asinh",n,void 0)},1313935:n=>{e.Cd("Acosh",n,void 0)},1313988:n=>{e.Cd("Atanh",n,void 0)},1314041:n=>{e.Cd("Tanh",n,void 0)},1314093:n=>{e.Cd("Not",n,void 0)},1314144:(n,i,o)=>{e.Cd("ClipV10",n,{min:i,max:o})},1314216:n=>{e.Cd("Clip",n,void 0)},1314268:(n,i)=>{e.Cd("Elu",n,{alpha:i})},1314326:n=>{e.Cd("Relu",n,void 0)},1314378:(n,i)=>{e.Cd("LeakyRelu",n,{alpha:i})},1314442:(n,i)=>{e.Cd("ThresholdedRelu",n,{alpha:i})},1314512:(n,i)=>{e.Cd("Cast",n,{to:i})},1314570:n=>{e.Cd("Add",n,void 0)},1314621:n=>{e.Cd("Sub",n,void 0)},1314672:n=>{e.Cd("Mul",n,void 0)},1314723:n=>{e.Cd("Div",n,void 0)},1314774:n=>{e.Cd("Pow",n,void 0)},1314825:n=>{e.Cd("Equal",n,void 0)},1314878:n=>{e.Cd("Greater",n,void 0)},1314933:n=>{e.Cd("GreaterOrEqual",n,void 0)},1314995:n=>{e.Cd("Less",n,void 0)},1315047:n=>{e.Cd("LessOrEqual",n,void 0)},1315106:(n,i,o,a,s)=>{e.Cd("ReduceMean",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[]})},1315270:(n,i,o,a,s)=>{e.Cd("ReduceMax",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[]})},1315433:(n,i,o,a,s)=>{e.Cd("ReduceMin",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[]})},1315596:(n,i,o,a,s)=>{e.Cd("ReduceProd",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[]})},1315760:(n,i,o,a,s)=>{e.Cd("ReduceSum",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[]})},1315923:(n,i,o,a,s)=>{e.Cd("ReduceL1",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[]})},1316085:(n,i,o,a,s)=>{e.Cd("ReduceL2",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[]})},1316247:(n,i,o,a,s)=>{e.Cd("ReduceLogSum",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[]})},1316413:(n,i,o,a,s)=>{e.Cd("ReduceSumSquare",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[]})},1316582:(n,i,o,a,s)=>{e.Cd("ReduceLogSumExp",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[]})},1316751:n=>{e.Cd("Where",n,void 0)},1316804:(n,i,o)=>{e.Cd("Transpose",n,{perm:i?Array.from(H.subarray(o>>>0,o+i>>>0)):[]})},1316917:(n,i,o,a,s,f,p,g,y,v)=>{e.Cd("Conv",n,{format:y?"NHWC":"NCHW",auto_pad:i,dilations:[o],group:a,kernel_shape:[s],pads:[f,p],strides:[g],w_is_const:()=>!!ie[v>>>0]})},1317145:(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)=>{e.Cd("Conv",n,{format:$?"NHWC":"NCHW",auto_pad:i,dilations:[o,a],group:s,kernel_shape:[f,p],pads:[g,y,v,C],strides:[S,I],w_is_const:()=>!!ie[M>>>0]})},1317404:(n,i,o,a,s,f,p,g,y,v)=>{e.Cd("Conv",n,{format:y?"NHWC":"NCHW",auto_pad:i,dilations:[o],group:a,kernel_shape:[s],pads:[f,p],strides:[g],w_is_const:()=>!!ie[v>>>0]})},1317632:(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)=>{e.Cd("Conv",n,{format:$?"NHWC":"NCHW",auto_pad:i,dilations:[o,a],group:s,kernel_shape:[f,p],pads:[g,y,v,C],strides:[S,I],w_is_const:()=>!!ie[M>>>0]})},1317891:(n,i,o,a,s,f,p,g,y,v,C,S,I,$)=>{e.Cd("ConvTranspose",n,{format:y?"NHWC":"NCHW",autoPad:i,dilations:[o],group:a,kernel_shape:[s],pads:[f,p],strides:[g],wIsConst:()=>!!ie[v>>>0],outputPadding:C?Array.from(H.subarray(S>>>0,S+C>>>0)):[],outputShape:I?Array.from(H.subarray($>>>0,$+I>>>0)):[]})},1318271:(n,i,o,a,s,f,p,g,y,v,C,S,I)=>{e.Cd("ConvTranspose",n,{format:g?"NHWC":"NCHW",autoPad:i,dilations:Array.from(H.subarray(o>>>0,o+2>>>0)),group:a,kernelShape:Array.from(H.subarray(s>>>0,s+2>>>0)),pads:Array.from(H.subarray(f>>>0,f+4>>>0)),strides:Array.from(H.subarray(p>>>0,p+2>>>0)),wIsConst:()=>!!ie[y>>>0],outputPadding:0<v?Array.from(H.subarray(C>>>0,C+v>>>0)):[],outputShape:0<S?Array.from(H.subarray(I>>>0,I+S>>>0)):[]})},1318794:(n,i,o,a,s,f,p,g,y,v,C,S,I,$)=>{e.Cd("ConvTranspose",n,{format:y?"NHWC":"NCHW",autoPad:i,dilations:[o],group:a,kernel_shape:[s],pads:[f,p],strides:[g],wIsConst:()=>!!ie[v>>>0],outputPadding:C?Array.from(H.subarray(S>>>0,S+C>>>0)):[],outputShape:I?Array.from(H.subarray($>>>0,$+I>>>0)):[]})},1319174:(n,i,o,a,s,f,p,g,y,v,C,S,I)=>{e.Cd("ConvTranspose",n,{format:g?"NHWC":"NCHW",autoPad:i,dilations:Array.from(H.subarray(o>>>0,o+2>>>0)),group:a,kernelShape:Array.from(H.subarray(s>>>0,s+2>>>0)),pads:Array.from(H.subarray(f>>>0,f+4>>>0)),strides:Array.from(H.subarray(p>>>0,p+2>>>0)),wIsConst:()=>!!ie[y>>>0],outputPadding:0<v?Array.from(H.subarray(C>>>0,C+v>>>0)):[],outputShape:0<S?Array.from(H.subarray(I>>>0,I+S>>>0)):[]})},1319697:(n,i)=>{e.Cd("GlobalAveragePool",n,{format:i?"NHWC":"NCHW"})},1319788:(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)=>{e.Cd("AveragePool",n,{format:G?"NHWC":"NCHW",auto_pad:i,ceil_mode:o,count_include_pad:a,storage_order:s,dilations:[f,p],kernel_shape:[g,y],pads:[v,C,S,I],strides:[$,M]})},1320072:(n,i)=>{e.Cd("GlobalAveragePool",n,{format:i?"NHWC":"NCHW"})},1320163:(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)=>{e.Cd("AveragePool",n,{format:G?"NHWC":"NCHW",auto_pad:i,ceil_mode:o,count_include_pad:a,storage_order:s,dilations:[f,p],kernel_shape:[g,y],pads:[v,C,S,I],strides:[$,M]})},1320447:(n,i)=>{e.Cd("GlobalMaxPool",n,{format:i?"NHWC":"NCHW"})},1320534:(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)=>{e.Cd("MaxPool",n,{format:G?"NHWC":"NCHW",auto_pad:i,ceil_mode:o,count_include_pad:a,storage_order:s,dilations:[f,p],kernel_shape:[g,y],pads:[v,C,S,I],strides:[$,M]})},1320814:(n,i)=>{e.Cd("GlobalMaxPool",n,{format:i?"NHWC":"NCHW"})},1320901:(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)=>{e.Cd("MaxPool",n,{format:G?"NHWC":"NCHW",auto_pad:i,ceil_mode:o,count_include_pad:a,storage_order:s,dilations:[f,p],kernel_shape:[g,y],pads:[v,C,S,I],strides:[$,M]})},1321181:(n,i,o,a,s)=>{e.Cd("Gemm",n,{alpha:i,beta:o,transA:a,transB:s})},1321285:n=>{e.Cd("MatMul",n,void 0)},1321339:(n,i,o,a)=>{e.Cd("ArgMax",n,{keepDims:!!i,selectLastIndex:!!o,axis:a})},1321447:(n,i,o,a)=>{e.Cd("ArgMin",n,{keepDims:!!i,selectLastIndex:!!o,axis:a})},1321555:(n,i)=>{e.Cd("Softmax",n,{axis:i})},1321618:(n,i)=>{e.Cd("Concat",n,{axis:i})},1321678:(n,i,o,a,s)=>{e.Cd("Split",n,{axis:i,numOutputs:o,splitSizes:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[]})},1321823:n=>{e.Cd("Expand",n,void 0)},1321877:(n,i)=>{e.Cd("Gather",n,{axis:Number(i)})},1321948:(n,i)=>{e.Cd("GatherElements",n,{axis:Number(i)})},1322027:(n,i,o,a,s,f,p,g,y,v,C)=>{e.Cd("Resize",n,{antialias:i,axes:o?Array.from(H.subarray(a>>>0,a+o>>>0)):[],coordinateTransformMode:ct(s),cubicCoeffA:f,excludeOutside:p,extrapolationValue:g,keepAspectRatioPolicy:ct(y),mode:ct(v),nearestMode:ct(C)})},1322378:(n,i,o,a,s,f,p)=>{e.Cd("Slice",n,{starts:i?Array.from(H.subarray(o>>>0,o+i>>>0)):[],ends:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[],axes:f?Array.from(H.subarray(p>>>0,p+f>>>0)):[]})},1322609:n=>{e.Cd("Tile",n,void 0)},1322661:(n,i,o)=>{e.Cd("LayerNormalization",n,{axis:Number(i),epsilon:Number(o)})},1322768:(n,i,o)=>{e.Cd("InstanceNormalization",n,{epsilon:i,format:o?"NHWC":"NCHW"})},1322882:(n,i,o)=>{e.Cd("InstanceNormalization",n,{epsilon:i,format:o?"NHWC":"NCHW"})},1322996:n=>{e.Cd("Range",n,void 0)},1323049:(n,i)=>{e.Cd("Einsum",n,{equation:ct(i)})},1323130:(n,i,o,a,s)=>{e.Cd("Pad",n,{mode:i,value:o,pads:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[]})},1323262:n=>{e.Cd("Gelu",n,void 0)},1323314:n=>{e.Cd("BiasAdd",n,void 0)},1323369:n=>{e.Cd("BiasSplitGelu",n,void 0)},1323430:(n,i)=>{e.Cd("SkipLayerNormalization",n,{epsilon:i})},1323511:n=>{e.sh(n)},1323545:(n,i)=>e.th(n,i,e.Xg.uh,e.Xg.errors),1323657:n=>e.ph(n),1323690:n=>e.rh(n),1323722:(n,i,o)=>{e.eh(n,i,o,!0)},1323761:(n,i,o)=>{e.eh(n,i,o)}};function yt(n){this.name="ExitStatus",this.message=`Program terminated with exit(${n})`,this.status=n}var ut=n=>{for(;0<n.length;)n.shift()(e)},Ot=[],Et=0,Ye=0;function Lt(n){this.Wg=n,this.Sg=n-24,this.mh=function(i){le[this.Sg+4>>2>>>0]=i},this.bh=function(){return le[this.Sg+4>>2>>>0]},this.lh=function(i){le[this.Sg+8>>2>>>0]=i},this.fh=function(i){ie[this.Sg+12>>0>>>0]=i?1:0},this.ih=function(){return ie[this.Sg+12>>0>>>0]!=0},this.gh=function(i){ie[this.Sg+13>>0>>>0]=i?1:0},this.oh=function(){return ie[this.Sg+13>>0>>>0]!=0},this.kh=function(i,o){this.dh(0),this.mh(i),this.lh(o)},this.dh=function(i){le[this.Sg+16>>2>>>0]=i},this.hh=function(){return le[this.Sg+16>>2>>>0]},this.jh=function(){if(xr(this.bh()))return le[this.Wg>>2>>>0];var i=this.hh();return i!==0?i:this.Wg}}var lt=n=>{var i=Ye;if(!i)return At(0),0;var o=new Lt(i);o.dh(i);var a=o.bh();if(!a)return At(0),i;for(var s in n){var f=n[s];if(f===0||f===a)break;if($r(f,a,o.Sg+16))return At(f),i}return At(a),i},pr=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,dn=(n,i,o)=>{i>>>=0;var a=i+o;for(o=i;n[o]&&!(o>=a);)++o;if(16<o-i&&n.buffer&&pr)return pr.decode(n.subarray(i,o));for(a="";i<o;){var s=n[i++];if(s&128){var f=n[i++]&63;if((s&224)==192)a+=String.fromCharCode((s&31)<<6|f);else{var p=n[i++]&63;s=(s&240)==224?(s&15)<<12|f<<6|p:(s&7)<<18|f<<12|p<<6|n[i++]&63,65536>s?a+=String.fromCharCode(s):(s-=65536,a+=String.fromCharCode(55296|s>>10,56320|s&1023))}}else a+=String.fromCharCode(s)}return a},ct=(n,i)=>(n>>>=0)?dn(Ce,n,i):"",mr=n=>{for(var i=0,o=0;o<n.length;++o){var a=n.charCodeAt(o);127>=a?i++:2047>=a?i+=2:55296<=a&&57343>=a?(i+=4,++o):i+=3}return i},bt=(n,i,o,a)=>{if(o>>>=0,!(0<a))return 0;var s=o;a=o+a-1;for(var f=0;f<n.length;++f){var p=n.charCodeAt(f);if(55296<=p&&57343>=p){var g=n.charCodeAt(++f);p=65536+((p&1023)<<10)|g&1023}if(127>=p){if(o>=a)break;i[o++>>>0]=p}else{if(2047>=p){if(o+1>=a)break;i[o++>>>0]=192|p>>6}else{if(65535>=p){if(o+2>=a)break;i[o++>>>0]=224|p>>12}else{if(o+3>=a)break;i[o++>>>0]=240|p>>18,i[o++>>>0]=128|p>>12&63}i[o++>>>0]=128|p>>6&63}i[o++>>>0]=128|p&63}}return i[o>>>0]=0,o-s},vt=n=>n%4===0&&(n%100!==0||n%400===0),Pt=[0,31,60,91,121,152,182,213,244,274,305,335],Kt=[0,31,59,90,120,151,181,212,243,273,304,334],hr=n=>{var i=mr(n)+1,o=Zt(i);return o&&bt(n,Ce,o,i),o},qt=[],gr=(n,i)=>{qt.length=0;var o;for(i>>=2;o=Ce[n++>>>0];)i+=o!=105&i,qt.push(o==105?H[i>>>0]:Be[i++>>>1]),++i;return qt},Yt={},dt=()=>{if(!Xt){var n={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:h||"./this.program"},i;for(i in Yt)Yt[i]===void 0?delete n[i]:n[i]=Yt[i];var o=[];for(i in n)o.push(`${i}=${n[i]}`);Xt=o}return Xt},Xt,yr=[null,[],[]],he=[31,29,31,30,31,30,31,31,30,31,30,31],Rt=[31,28,31,30,31,30,31,31,30,31,30,31];function fn(n){var i=Array(mr(n)+1);return bt(n,i,0,i.length),i}function pn(n,i,o,a){function s($,M,G){for($=typeof $=="number"?$.toString():$||"";$.length<M;)$=G[0]+$;return $}function f($,M){return s($,M,"0")}function p($,M){function G(te){return 0>te?-1:0<te?1:0}var q;return(q=G($.getFullYear()-M.getFullYear()))===0&&(q=G($.getMonth()-M.getMonth()))===0&&(q=G($.getDate()-M.getDate())),q}function g($){switch($.getDay()){case 0:return new Date($.getFullYear()-1,11,29);case 1:return $;case 2:return new Date($.getFullYear(),0,3);case 3:return new Date($.getFullYear(),0,2);case 4:return new Date($.getFullYear(),0,1);case 5:return new Date($.getFullYear()-1,11,31);case 6:return new Date($.getFullYear()-1,11,30)}}function y($){var M=$.Ug;for($=new Date(new Date($.Vg+1900,0,1).getTime());0<M;){var G=$.getMonth(),q=(vt($.getFullYear())?he:Rt)[G];if(M>q-$.getDate())M-=q-$.getDate()+1,$.setDate(1),11>G?$.setMonth(G+1):($.setMonth(0),$.setFullYear($.getFullYear()+1));else{$.setDate($.getDate()+M);break}}return G=new Date($.getFullYear()+1,0,4),M=g(new Date($.getFullYear(),0,4)),G=g(G),0>=p(M,$)?0>=p(G,$)?$.getFullYear()+1:$.getFullYear():$.getFullYear()-1}n>>>=0,i>>>=0,o>>>=0,a>>>=0;var v=H[a+40>>2>>>0];a={xh:H[a>>2>>>0],wh:H[a+4>>2>>>0],Yg:H[a+8>>2>>>0],ah:H[a+12>>2>>>0],Zg:H[a+16>>2>>>0],Vg:H[a+20>>2>>>0],Tg:H[a+24>>2>>>0],Ug:H[a+28>>2>>>0],Ah:H[a+32>>2>>>0],vh:H[a+36>>2>>>0],yh:v?ct(v):""},o=ct(o),v={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var C in v)o=o.replace(new RegExp(C,"g"),v[C]);var S="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),I="January February March April May June July August September October November December".split(" ");v={"%a":$=>S[$.Tg].substring(0,3),"%A":$=>S[$.Tg],"%b":$=>I[$.Zg].substring(0,3),"%B":$=>I[$.Zg],"%C":$=>f(($.Vg+1900)/100|0,2),"%d":$=>f($.ah,2),"%e":$=>s($.ah,2," "),"%g":$=>y($).toString().substring(2),"%G":$=>y($),"%H":$=>f($.Yg,2),"%I":$=>($=$.Yg,$==0?$=12:12<$&&($-=12),f($,2)),"%j":$=>{for(var M=0,G=0;G<=$.Zg-1;M+=(vt($.Vg+1900)?he:Rt)[G++]);return f($.ah+M,3)},"%m":$=>f($.Zg+1,2),"%M":$=>f($.wh,2),"%n":()=>`\n`,"%p":$=>0<=$.Yg&&12>$.Yg?"AM":"PM","%S":$=>f($.xh,2),"%t":()=>"	","%u":$=>$.Tg||7,"%U":$=>f(Math.floor(($.Ug+7-$.Tg)/7),2),"%V":$=>{var M=Math.floor(($.Ug+7-($.Tg+6)%7)/7);if(2>=($.Tg+371-$.Ug-2)%7&&M++,M)M==53&&(G=($.Tg+371-$.Ug)%7,G==4||G==3&&vt($.Vg)||(M=1));else{M=52;var G=($.Tg+7-$.Ug-1)%7;(G==4||G==5&&vt($.Vg%400-1))&&M++}return f(M,2)},"%w":$=>$.Tg,"%W":$=>f(Math.floor(($.Ug+7-($.Tg+6)%7)/7),2),"%y":$=>($.Vg+1900).toString().substring(2),"%Y":$=>$.Vg+1900,"%z":$=>{$=$.vh;var M=0<=$;return $=Math.abs($)/60,(M?"+":"-")+("0000"+($/60*100+$%60)).slice(-4)},"%Z":$=>$.yh,"%%":()=>"%"},o=o.replace(/%%/g,"\\0\\0");for(C in v)o.includes(C)&&(o=o.replace(new RegExp(C,"g"),v[C](a)));return o=o.replace(/\\0\\0/g,"%"),C=fn(o),C.length>i?0:(ie.set(C,n>>>0),C.length-1)}function kt(n){try{n()}catch(i){Je(i)}}function si(n){var i={},o;for(o in n)(function(a){var s=n[a];i[a]=typeof s=="function"?function(){Bt.push(a);try{return s.apply(null,arguments)}finally{Z||(Bt.pop()===a||Je(),nt&&ft===1&&Bt.length===0&&(ft=0,kt($a),typeof Fibers<"u"&&Fibers.Bh()))}}:s})(o);return i}var ft=0,nt=null,br=0,Bt=[],Qt={},vr={},mn=0,Jt=null,hn=[];function gn(){return new Promise((n,i)=>{Jt={resolve:n,reject:i}})}function yn(){var n=Zt(65548),i=n+12;le[n>>2>>>0]=i,le[n+4>>2>>>0]=i+65536,i=Bt[0];var o=Qt[i];return o===void 0&&(o=mn++,Qt[i]=o,vr[o]=i),H[n+8>>2>>>0]=o,n}function bn(n){if(!Z){if(ft===0){var i=!1,o=!1;n((a=0)=>{if(!Z&&(br=a,i=!0,o)){ft=2,kt(()=>xa(nt)),typeof Browser<"u"&&Browser.$g.nh&&Browser.$g.resume(),a=!1;try{var s=(0,A[vr[H[nt+8>>2>>>0]]])()}catch(g){s=g,a=!0}var f=!1;if(!nt){var p=Jt;p&&(Jt=null,(a?p.reject:p.resolve)(s),f=!0)}if(a&&!f)throw s}}),o=!0,i||(ft=1,nt=yn(),typeof Browser<"u"&&Browser.$g.nh&&Browser.$g.pause(),kt(()=>Ca(nt)))}else ft===2?(ft=0,kt(Sa),wr(nt),nt=null,hn.forEach(a=>{if(!Z)try{if(a(),!L)try{re=re=a=re,L||(e.onExit&&e.onExit(a),Z=!0),u(a,new yt(a))}catch(s){s instanceof yt||s=="unwind"||u(1,s)}}catch(s){s instanceof yt||s=="unwind"||u(1,s)}})):Je(`invalid state: ${ft}`);return br}}function vn(n){return bn(i=>{n().then(i)})}var wn={Ha:function(n,i,o){return vn(async()=>{await e.qh(n,i,o)})},u:function(n){return n=new Lt(n>>>0),n.ih()||(n.fh(!0),Et--),n.gh(!1),Ot.push(n),Cr(n.Wg),n.jh()},B:function(){W(0,0);var n=Ot.pop();It(n.Wg),Ye=0},a:function(){return lt([])},k:function(n){return lt([n>>>0])},w:function(n,i){return lt([n>>>0,i>>>0])},q:function(n,i,o){return lt([n>>>0,i>>>0,o>>>0])},pa:function(){var n=Ot.pop();n||Je("no exception to throw");var i=n.Wg;throw n.oh()||(Ot.push(n),n.gh(!0),n.fh(!1),Et++),Ye=i,Ye},s:function(n,i,o){throw n>>>=0,new Lt(n).kh(i>>>0,o>>>0),Ye=n,Et++,Ye},$:function(){return Et},g:function(n){throw Ye||(Ye=n>>>0),Ye},qa:function(){return 0},oc:function(){},Pa:function(){},Ra:function(){},Ja:function(){return 0},Ub:function(){},Ta:function(){},Jb:function(){},Ca:function(){},Qa:function(){},Na:function(){},dc:function(){},Oa:function(){},Tc:()=>!0,Oc:function(n,i,o){n=i+2097152>>>0<4194305-!!n?(n>>>0)+4294967296*i:NaN,o>>>=0,n=new Date(1e3*n),H[o>>2>>>0]=n.getUTCSeconds(),H[o+4>>2>>>0]=n.getUTCMinutes(),H[o+8>>2>>>0]=n.getUTCHours(),H[o+12>>2>>>0]=n.getUTCDate(),H[o+16>>2>>>0]=n.getUTCMonth(),H[o+20>>2>>>0]=n.getUTCFullYear()-1900,H[o+24>>2>>>0]=n.getUTCDay(),H[o+28>>2>>>0]=(n.getTime()-Date.UTC(n.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Pc:function(n,i,o){n=i+2097152>>>0<4194305-!!n?(n>>>0)+4294967296*i:NaN,o>>>=0,n=new Date(1e3*n),H[o>>2>>>0]=n.getSeconds(),H[o+4>>2>>>0]=n.getMinutes(),H[o+8>>2>>>0]=n.getHours(),H[o+12>>2>>>0]=n.getDate(),H[o+16>>2>>>0]=n.getMonth(),H[o+20>>2>>>0]=n.getFullYear()-1900,H[o+24>>2>>>0]=n.getDay(),H[o+28>>2>>>0]=(vt(n.getFullYear())?Pt:Kt)[n.getMonth()]+n.getDate()-1|0,H[o+36>>2>>>0]=-(60*n.getTimezoneOffset()),i=new Date(n.getFullYear(),6,1).getTimezoneOffset();var a=new Date(n.getFullYear(),0,1).getTimezoneOffset();H[o+32>>2>>>0]=(i!=a&&n.getTimezoneOffset()==Math.min(a,i))|0},Qc:function(n){n>>>=0;var i=new Date(H[n+20>>2>>>0]+1900,H[n+16>>2>>>0],H[n+12>>2>>>0],H[n+8>>2>>>0],H[n+4>>2>>>0],H[n>>2>>>0],0),o=H[n+32>>2>>>0],a=i.getTimezoneOffset(),s=new Date(i.getFullYear(),6,1).getTimezoneOffset(),f=new Date(i.getFullYear(),0,1).getTimezoneOffset(),p=Math.min(f,s);return 0>o?H[n+32>>2>>>0]=+(s!=f&&p==a):0<o!=(p==a)&&(s=Math.max(f,s),i.setTime(i.getTime()+6e4*((0<o?p:s)-a))),H[n+24>>2>>>0]=i.getDay(),H[n+28>>2>>>0]=(vt(i.getFullYear())?Pt:Kt)[i.getMonth()]+i.getDate()-1|0,H[n>>2>>>0]=i.getSeconds(),H[n+4>>2>>>0]=i.getMinutes(),H[n+8>>2>>>0]=i.getHours(),H[n+12>>2>>>0]=i.getDate(),H[n+16>>2>>>0]=i.getMonth(),H[n+20>>2>>>0]=i.getYear(),n=i.getTime()/1e3,At((Me=n,1<=+Math.abs(Me)?0<Me?+Math.floor(Me/4294967296)>>>0:~~+Math.ceil((Me-+(~~Me>>>0))/4294967296)>>>0:0)),n>>>0},Mc:function(){return-52},Nc:function(){},La:function(n,i,o){function a(y){return(y=y.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?y[1]:"GMT"}o>>>=0;var s=new Date().getFullYear(),f=new Date(s,0,1),p=new Date(s,6,1);s=f.getTimezoneOffset();var g=p.getTimezoneOffset();le[n>>>0>>2>>>0]=60*Math.max(s,g),H[i>>>0>>2>>>0]=+(s!=g),n=a(f),i=a(p),n=hr(n),i=hr(i),g<s?(le[o>>2>>>0]=n,le[o+4>>2>>>0]=i):(le[o>>2>>>0]=i,le[o+4>>2>>>0]=n)},ja:()=>{Je("")},x:function(n,i,o){return n>>>=0,i=gr(i>>>0,o>>>0),rt[n].apply(null,i)},wa:function(n,i,o){return n>>>=0,i=gr(i>>>0,o>>>0),rt[n].apply(null,i)},Ea:function(){return Date.now()},Ma:function(){return 4294901760},I:()=>performance.now(),yb:function(n,i,o){return i>>>=0,Ce.copyWithin(n>>>0>>>0,i>>>0,i+(o>>>0)>>>0)},Ka:function(n){n>>>=0;var i=Ce.length;if(4294901760<n)return!1;for(var o=1;4>=o;o*=2){var a=i*(1+.2/o);a=Math.min(a,n+100663296);var s=Math;a=Math.max(n,a);e:{s=s.min.call(s,4294901760,a+(65536-a%65536)%65536)-X.buffer.byteLength+65535>>>16;try{X.grow(s),ue();var f=1;break e}catch{}f=void 0}if(f)return!0}return!1},cb:function(n,i){n>>>=0,i>>>=0;var o=0;return dt().forEach(function(a,s){var f=i+o;for(s=le[n+4*s>>2>>>0]=f,f=0;f<a.length;++f)ie[s++>>0>>>0]=a.charCodeAt(f);ie[s>>0>>>0]=0,o+=a.length+1}),0},nb:function(n,i){n>>>=0,i>>>=0;var o=dt();le[n>>2>>>0]=o.length;var a=0;return o.forEach(function(s){a+=s.length+1}),le[i>>2>>>0]=a,0},ma:()=>52,Ba:function(){return 52},Rc:function(){return 70},Aa:function(n,i,o,a){i>>>=0,o>>>=0,a>>>=0;for(var s=0,f=0;f<o;f++){var p=le[i>>2>>>0],g=le[i+4>>2>>>0];i+=8;for(var y=0;y<g;y++){var v=Ce[p+y>>>0],C=yr[n];v===0||v===10?((n===1?U:K)(dn(C,0)),C.length=0):C.push(v)}s+=g}return le[a>>2>>>0]=s,0},ia:Rc,Sc:Pd,M:od,K:Pc,Uc:Ed,Wc:Id,C:Lc,z:Tc,b:wc,Da:Sd,ca:pd,f:bc,ra:_d,h:yc,F:xd,i:_c,Vc:Td,j:Sc,t:xc,r:Ec,n:kc,W:jc,Y:bd,J:Gc,oa:Jc,aa:ed,la:vd,vb:Ff,gb:ip,zc:Fd,bb:up,eb:ap,Sa:bp,Sb:xf,Dc:Gd,jb:tp,Va:gp,Ob:If,fb:op,gc:lf,Lc:Rd,pc:ef,hb:np,db:sp,Bb:zf,kc:of,nc:tf,fc:cf,Kc:kd,_a:dp,ab:lp,qb:Yf,mb:Jf,$a:cp,ic:sf,Kb:Pf,lb:Zf,Ua:yp,Tb:$f,Ic:Md,Ac:Nd,tc:Xd,pb:Xf,lc:nf,Ib:Rf,Hb:kf,c:$c,_:qc,p:Cc,P:Ad,Z:ld,ha:Uc,e:vc,za:zc,G:$d,da:Xc,O:ad,ub:Hf,fa:Nc,d:Ac,xa:Hc,Fa:wd,l:Ic,va:Yc,m:Oc,ya:Fc,ua:Qc,Ga:md,o:Bc,V:nd,ga:rd,U:id,na:cd,y:Mc,A:Dc,E:Wc,X:Cd,ta:sd,ea:Kc,N:td,L:dd,D:Zc,ba:Vc,T:ud,ka:Od,R:hd,sa:yd,Q:gd,S:fd,jc:af,zb:Vf,rb:qf,Eb:jf,Ab:Gf,Bc:Ud,Nb:Tf,xb:Uf,Fb:Mf,Pb:Af,ec:df,ob:Qf,Mb:Of,sb:Kf,Ya:pp,rc:Jd,Fc:Wd,Za:fp,Qb:_f,xc:Ld,Cb:Wf,kb:ep,vc:qd,Hc:jd,wc:Kd,Cc:Vd,Xa:mp,Ec:zd,wb:Nf,Lb:Ef,yc:Hd,Jc:Bd,ib:rp,Db:Df,Yb:bf,tb:Lf,Gc:Dd,Zb:yf,Rb:Sf,hc:uf,qc:Zd,Gb:Bf,Xb:vf,sc:Qd,mc:rf,Wa:hp,uc:Yd,Vb:Cf,Wb:wf,$b:hf,ac:mf,cc:ff,_b:gf,bc:pf,v:function(n){return n>>>0},Ia:pn,H:function(n,i,o,a){return pn(n>>>0,i>>>0,o>>>0,a>>>0)}};(function(){function n(o){if(o=o.exports,o=si(o),A=o=vp(o),X=A.Xc,ue(),Ze.unshift(A.Yc),Ee--,e.monitorRunDependencies&&e.monitorRunDependencies(Ee),Ee==0&&(qe!==null&&(clearInterval(qe),qe=null),gt)){var a=gt;gt=null,a()}return o}var i={a:wn};if(Ee++,e.monitorRunDependencies&&e.monitorRunDependencies(Ee),e.instantiateWasm)try{return e.instantiateWasm(i,n)}catch(o){K("Module.instantiateWasm callback failed with error: "+o),l(o)}return Ge(i,function(o){n(o.instance)}).catch(l),{}})(),e._OrtInit=(n,i)=>(e._OrtInit=A.Zc)(n,i),e._OrtGetLastError=(n,i)=>(e._OrtGetLastError=A._c)(n,i),e._OrtCreateSessionOptions=(n,i,o,a,s,f,p,g,y,v)=>(e._OrtCreateSessionOptions=A.$c)(n,i,o,a,s,f,p,g,y,v),e._OrtAppendExecutionProvider=(n,i)=>(e._OrtAppendExecutionProvider=A.ad)(n,i),e._OrtAddFreeDimensionOverride=(n,i,o)=>(e._OrtAddFreeDimensionOverride=A.bd)(n,i,o),e._OrtAddSessionConfigEntry=(n,i,o)=>(e._OrtAddSessionConfigEntry=A.cd)(n,i,o),e._OrtReleaseSessionOptions=n=>(e._OrtReleaseSessionOptions=A.dd)(n),e._OrtCreateSession=(n,i,o)=>(e._OrtCreateSession=A.ed)(n,i,o),e._OrtReleaseSession=n=>(e._OrtReleaseSession=A.fd)(n),e._OrtGetInputOutputCount=(n,i,o)=>(e._OrtGetInputOutputCount=A.gd)(n,i,o),e._OrtGetInputName=(n,i)=>(e._OrtGetInputName=A.hd)(n,i),e._OrtGetOutputName=(n,i)=>(e._OrtGetOutputName=A.id)(n,i),e._OrtFree=n=>(e._OrtFree=A.jd)(n),e._OrtCreateTensor=(n,i,o,a,s,f)=>(e._OrtCreateTensor=A.kd)(n,i,o,a,s,f),e._OrtGetTensorData=(n,i,o,a,s)=>(e._OrtGetTensorData=A.ld)(n,i,o,a,s),e._OrtReleaseTensor=n=>(e._OrtReleaseTensor=A.md)(n),e._OrtCreateRunOptions=(n,i,o,a)=>(e._OrtCreateRunOptions=A.nd)(n,i,o,a),e._OrtAddRunConfigEntry=(n,i,o)=>(e._OrtAddRunConfigEntry=A.od)(n,i,o),e._OrtReleaseRunOptions=n=>(e._OrtReleaseRunOptions=A.pd)(n),e._OrtCreateBinding=n=>(e._OrtCreateBinding=A.qd)(n),e._OrtBindInput=(n,i,o)=>(e._OrtBindInput=A.rd)(n,i,o),e._OrtBindOutput=(n,i,o,a)=>(e._OrtBindOutput=A.sd)(n,i,o,a),e._OrtClearBoundOutputs=n=>(e._OrtClearBoundOutputs=A.td)(n),e._OrtReleaseBinding=n=>(e._OrtReleaseBinding=A.ud)(n),e._OrtRunWithBinding=(n,i,o,a,s)=>(e._OrtRunWithBinding=A.vd)(n,i,o,a,s),e._OrtRun=(n,i,o,a,s,f,p,g)=>(e._OrtRun=A.wd)(n,i,o,a,s,f,p,g),e._OrtEndProfiling=n=>(e._OrtEndProfiling=A.xd)(n),e._JsepOutput=(n,i,o)=>(e._JsepOutput=A.yd)(n,i,o),e._JsepGetNodeName=n=>(e._JsepGetNodeName=A.zd)(n);var Zt=e._malloc=n=>(Zt=e._malloc=A.Ad)(n),wr=e._free=n=>(wr=e._free=A.Bd)(n),W=(n,i)=>(W=A.Dd)(n,i),At=n=>(At=A.Ed)(n),z=()=>(z=A.Fd)(),D=n=>(D=A.Gd)(n),Mt=n=>(Mt=A.Hd)(n),It=n=>(It=A.Id)(n),Cr=n=>(Cr=A.Jd)(n),$r=(n,i,o)=>($r=A.Kd)(n,i,o),xr=n=>(xr=A.Ld)(n),Sr=e.dynCall_vi=(n,i)=>(Sr=e.dynCall_vi=A.Md)(n,i),_r=e.dynCall_vii=(n,i,o)=>(_r=e.dynCall_vii=A.Nd)(n,i,o),er=e.dynCall_iiii=(n,i,o,a)=>(er=e.dynCall_iiii=A.Od)(n,i,o,a),Ar=e.dynCall_iii=(n,i,o)=>(Ar=e.dynCall_iii=A.Pd)(n,i,o),Cn=e.dynCall_ii=(n,i)=>(Cn=e.dynCall_ii=A.Qd)(n,i),ke=e.dynCall_iiiiiii=(n,i,o,a,s,f,p)=>(ke=e.dynCall_iiiiiii=A.Rd)(n,i,o,a,s,f,p),tr=e.dynCall_v=n=>(tr=e.dynCall_v=A.Sd)(n),rr=e.dynCall_iiiiii=(n,i,o,a,s,f)=>(rr=e.dynCall_iiiiii=A.Td)(n,i,o,a,s,f),Ir=e.dynCall_iiij=(n,i,o,a,s)=>(Ir=e.dynCall_iiij=A.Ud)(n,i,o,a,s),nr=e.dynCall_iiiii=(n,i,o,a,s)=>(nr=e.dynCall_iiiii=A.Vd)(n,i,o,a,s),Tr=e.dynCall_viii=(n,i,o,a)=>(Tr=e.dynCall_viii=A.Wd)(n,i,o,a),Or=e.dynCall_j=n=>(Or=e.dynCall_j=A.Xd)(n),Er=e.dynCall_i=n=>(Er=e.dynCall_i=A.Yd)(n),Pr=e.dynCall_iij=(n,i,o,a)=>(Pr=e.dynCall_iij=A.Zd)(n,i,o,a),Rr=e.dynCall_iiiiij=(n,i,o,a,s,f,p)=>(Rr=e.dynCall_iiiiij=A._d)(n,i,o,a,s,f,p),$n=e.dynCall_vij=(n,i,o,a)=>($n=e.dynCall_vij=A.$d)(n,i,o,a),kr=e.dynCall_viiiii=(n,i,o,a,s,f)=>(kr=e.dynCall_viiiii=A.ae)(n,i,o,a,s,f),Br=e.dynCall_viiii=(n,i,o,a,s)=>(Br=e.dynCall_viiii=A.be)(n,i,o,a,s),Mr=e.dynCall_iiiiiiii=(n,i,o,a,s,f,p,g)=>(Mr=e.dynCall_iiiiiiii=A.ce)(n,i,o,a,s,f,p,g),xn=e.dynCall_fi=(n,i)=>(xn=e.dynCall_fi=A.de)(n,i),Sn=e.dynCall_fii=(n,i,o)=>(Sn=e.dynCall_fii=A.ee)(n,i,o),jr=e.dynCall_ji=(n,i)=>(jr=e.dynCall_ji=A.fe)(n,i),jt=e.dynCall_di=(n,i)=>(jt=e.dynCall_di=A.ge)(n,i),_n=e.dynCall_jii=(n,i,o)=>(_n=e.dynCall_jii=A.he)(n,i,o),pt=e.dynCall_dii=(n,i,o)=>(pt=e.dynCall_dii=A.ie)(n,i,o),it=e.dynCall_iiiiiiiii=(n,i,o,a,s,f,p,g,y)=>(it=e.dynCall_iiiiiiiii=A.je)(n,i,o,a,s,f,p,g,y),Dr=e.dynCall_viij=(n,i,o,a,s)=>(Dr=e.dynCall_viij=A.ke)(n,i,o,a,s),Dt=e.dynCall_viiiiii=(n,i,o,a,s,f,p)=>(Dt=e.dynCall_viiiiii=A.le)(n,i,o,a,s,f,p),Wr=e.dynCall_vijj=(n,i,o,a,s,f)=>(Wr=e.dynCall_vijj=A.me)(n,i,o,a,s,f),zr=e.dynCall_viiiiiii=(n,i,o,a,s,f,p,g)=>(zr=e.dynCall_viiiiiii=A.ne)(n,i,o,a,s,f,p,g),An=e.dynCall_iiiiiiiiii=(n,i,o,a,s,f,p,g,y,v)=>(An=e.dynCall_iiiiiiiiii=A.oe)(n,i,o,a,s,f,p,g,y,v),ir=e.dynCall_viiiiiiii=(n,i,o,a,s,f,p,g,y)=>(ir=e.dynCall_viiiiiiii=A.pe)(n,i,o,a,s,f,p,g,y),In=e.dynCall_iiiiijiiiii=(n,i,o,a,s,f,p,g,y,v,C,S)=>(In=e.dynCall_iiiiijiiiii=A.qe)(n,i,o,a,s,f,p,g,y,v,C,S),Tn=e.dynCall_viiji=(n,i,o,a,s,f)=>(Tn=e.dynCall_viiji=A.re)(n,i,o,a,s,f),On=e.dynCall_viijiii=(n,i,o,a,s,f,p,g)=>(On=e.dynCall_viijiii=A.se)(n,i,o,a,s,f,p,g),En=e.dynCall_viiiiij=(n,i,o,a,s,f,p,g)=>(En=e.dynCall_viiiiij=A.te)(n,i,o,a,s,f,p,g),Pn=e.dynCall_viiiiiiiii=(n,i,o,a,s,f,p,g,y,v)=>(Pn=e.dynCall_viiiiiiiii=A.ue)(n,i,o,a,s,f,p,g,y,v),Rn=e.dynCall_viid=(n,i,o,a)=>(Rn=e.dynCall_viid=A.ve)(n,i,o,a),kn=e.dynCall_iiiiiiiij=(n,i,o,a,s,f,p,g,y,v)=>(kn=e.dynCall_iiiiiiiij=A.we)(n,i,o,a,s,f,p,g,y,v),Bn=e.dynCall_iiiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S)=>(Bn=e.dynCall_iiiiiiiiiiii=A.xe)(n,i,o,a,s,f,p,g,y,v,C,S),Wt=e.dynCall_viiiiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$)=>(Wt=e.dynCall_viiiiiiiiiiiii=A.ye)(n,i,o,a,s,f,p,g,y,v,C,S,I,$),or=e.dynCall_viijjjiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)=>(or=e.dynCall_viijjjiiiiii=A.ze)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M),Gr=e.dynCall_viiijiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I)=>(Gr=e.dynCall_viiijiiiiiii=A.Ae)(n,i,o,a,s,f,p,g,y,v,C,S,I),Vr=e.dynCall_viffiii=(n,i,o,a,s,f,p)=>(Vr=e.dynCall_viffiii=A.Be)(n,i,o,a,s,f,p),Ur=e.dynCall_viiijjjii=(n,i,o,a,s,f,p,g,y,v,C,S)=>(Ur=e.dynCall_viiijjjii=A.Ce)(n,i,o,a,s,f,p,g,y,v,C,S),ar=e.dynCall_viifiii=(n,i,o,a,s,f,p)=>(ar=e.dynCall_viifiii=A.De)(n,i,o,a,s,f,p),sr=e.dynCall_viiiiidiidi=(n,i,o,a,s,f,p,g,y,v,C)=>(sr=e.dynCall_viiiiidiidi=A.Ee)(n,i,o,a,s,f,p,g,y,v,C),Nr=e.dynCall_viiiiiiiiidi=(n,i,o,a,s,f,p,g,y,v,C,S)=>(Nr=e.dynCall_viiiiiiiiidi=A.Fe)(n,i,o,a,s,f,p,g,y,v,C,S),Fr=e.dynCall_vjiiiiii=(n,i,o,a,s,f,p,g,y)=>(Fr=e.dynCall_vjiiiiii=A.Ge)(n,i,o,a,s,f,p,g,y),Hr=e.dynCall_jiii=(n,i,o,a)=>(Hr=e.dynCall_jiii=A.He)(n,i,o,a),ur=e.dynCall_viiid=(n,i,o,a,s)=>(ur=e.dynCall_viiid=A.Ie)(n,i,o,a,s),zt=e.dynCall_viiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S)=>(zt=e.dynCall_viiiiiiiiiii=A.Je)(n,i,o,a,s,f,p,g,y,v,C,S),lr=e.dynCall_vijjjjjjjjjjjjji=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le,ot,at)=>(lr=e.dynCall_vijjjjjjjjjjjjji=A.Ke)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le,ot,at),Lr=e.dynCall_viiiji=(n,i,o,a,s,f,p)=>(Lr=e.dynCall_viiiji=A.Le)(n,i,o,a,s,f,p),Kr=e.dynCall_vijjjiiji=(n,i,o,a,s,f,p,g,y,v,C,S,I)=>(Kr=e.dynCall_vijjjiiji=A.Me)(n,i,o,a,s,f,p,g,y,v,C,S,I),qr=e.dynCall_iiiji=(n,i,o,a,s,f)=>(qr=e.dynCall_iiiji=A.Ne)(n,i,o,a,s,f),Yr=e.dynCall_iiijiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)=>(Yr=e.dynCall_iiijiiiiiiiiii=A.Oe)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M),Xr=e.dynCall_vj=(n,i,o)=>(Xr=e.dynCall_vj=A.Pe)(n,i,o),Mn=e.dynCall_jjj=(n,i,o,a,s)=>(Mn=e.dynCall_jjj=A.Qe)(n,i,o,a,s),Gt=e.dynCall_iiijiiiiii=(n,i,o,a,s,f,p,g,y,v,C)=>(Gt=e.dynCall_iiijiiiiii=A.Re)(n,i,o,a,s,f,p,g,y,v,C),Qr=e.dynCall_viiff=(n,i,o,a,s)=>(Qr=e.dynCall_viiff=A.Se)(n,i,o,a,s),c=e.dynCall_viiiiiff=(n,i,o,a,s,f,p,g)=>(c=e.dynCall_viiiiiff=A.Te)(n,i,o,a,s,f,p,g),b=e.dynCall_vfiii=(n,i,o,a,s)=>(b=e.dynCall_vfiii=A.Ue)(n,i,o,a,s),x=e.dynCall_viiiiff=(n,i,o,a,s,f,p)=>(x=e.dynCall_viiiiff=A.Ve)(n,i,o,a,s,f,p),E=e.dynCall_viiiiiiiiifiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$)=>(E=e.dynCall_viiiiiiiiifiii=A.We)(n,i,o,a,s,f,p,g,y,v,C,S,I,$),V=e.dynCall_viiiiiiiijj=(n,i,o,a,s,f,p,g,y,v,C,S,I)=>(V=e.dynCall_viiiiiiiijj=A.Xe)(n,i,o,a,s,f,p,g,y,v,C,S,I),F=e.dynCall_iiiiiiiiiiiiiifii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q)=>(F=e.dynCall_iiiiiiiiiiiiiifii=A.Ye)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q),J=e.dynCall_viiiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I)=>(J=e.dynCall_viiiiiiiiiiii=A.Ze)(n,i,o,a,s,f,p,g,y,v,C,S,I),pe=e.dynCall_ij=(n,i,o)=>(pe=e.dynCall_ij=A._e)(n,i,o),de=e.dynCall_iiiiiiiiiiiiiiiiifii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge)=>(de=e.dynCall_iiiiiiiiiiiiiiiiifii=A.$e)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge),ce=e.dynCall_vijjiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S)=>(ce=e.dynCall_vijjiiiiii=A.af)(n,i,o,a,s,f,p,g,y,v,C,S),me=e.dynCall_iiiijjj=(n,i,o,a,s,f,p,g,y,v)=>(me=e.dynCall_iiiijjj=A.bf)(n,i,o,a,s,f,p,g,y,v),xe=e.dynCall_viiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C)=>(xe=e.dynCall_viiiiiiiiii=A.cf)(n,i,o,a,s,f,p,g,y,v,C),_e=e.dynCall_iiijjj=(n,i,o,a,s,f,p,g,y)=>(_e=e.dynCall_iiijjj=A.df)(n,i,o,a,s,f,p,g,y),N=e.dynCall_fffffff=(n,i,o,a,s,f,p)=>(N=e.dynCall_fffffff=A.ef)(n,i,o,a,s,f,p),be=e.dynCall_viiiij=(n,i,o,a,s,f,p)=>(be=e.dynCall_viiiij=A.ff)(n,i,o,a,s,f,p),Te=e.dynCall_viijj=(n,i,o,a,s,f,p)=>(Te=e.dynCall_viijj=A.gf)(n,i,o,a,s,f,p),wt=e.dynCall_vjjjjjjffiifiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je)=>(wt=e.dynCall_vjjjjjjffiifiiiiii=A.hf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je),Jr=e.dynCall_viiiiiiffiifiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q)=>(Jr=e.dynCall_viiiiiiffiifiiiii=A.jf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q),Fi=e.dynCall_viiiiiiffifiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)=>(Fi=e.dynCall_viiiiiiffifiiiii=A.kf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G),Hi=e.dynCall_viiiiiiffiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)=>(Hi=e.dynCall_viiiiiiffiiiiii=A.lf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M),Li=e.dynCall_vjjjjjjjjfffiifiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le,ot,at)=>(Li=e.dynCall_vjjjjjjjjfffiifiiiiii=A.mf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le,ot,at),Ki=e.dynCall_vjjjjjjfffifiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De)=>(Ki=e.dynCall_vjjjjjjfffifiiiiiii=A.nf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De),qi=e.dynCall_vjjjjjjfffifiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se)=>(qi=e.dynCall_vjjjjjjfffifiiiii=A.of)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se),Yi=e.dynCall_vjjjjjjjjfffiifiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le,ot)=>(Yi=e.dynCall_vjjjjjjjjfffiifiiiii=A.pf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le,ot),Xi=e.dynCall_vijjfffiii=(n,i,o,a,s,f,p,g,y,v,C,S)=>(Xi=e.dynCall_vijjfffiii=A.qf)(n,i,o,a,s,f,p,g,y,v,C,S),Qi=e.dynCall_vijiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S)=>(Qi=e.dynCall_vijiiiiiiii=A.rf)(n,i,o,a,s,f,p,g,y,v,C,S),Ji=e.dynCall_vijjjjjjifiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve)=>(Ji=e.dynCall_vijjjjjjifiiiii=A.sf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve),Zi=e.dynCall_vjjjjjiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)=>(Zi=e.dynCall_vjjjjjiiii=A.tf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M),eo=e.dynCall_vjjjjfiii=(n,i,o,a,s,f,p,g,y,v,C,S,I)=>(eo=e.dynCall_vjjjjfiii=A.uf)(n,i,o,a,s,f,p,g,y,v,C,S,I),to=e.dynCall_viifi=(n,i,o,a,s)=>(to=e.dynCall_viifi=A.vf)(n,i,o,a,s),ro=e.dynCall_iiiiiji=(n,i,o,a,s,f,p,g)=>(ro=e.dynCall_iiiiiji=A.wf)(n,i,o,a,s,f,p,g),no=e.dynCall_vijjii=(n,i,o,a,s,f,p,g)=>(no=e.dynCall_vijjii=A.xf)(n,i,o,a,s,f,p,g),io=e.dynCall_viiijiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S)=>(io=e.dynCall_viiijiiiiii=A.yf)(n,i,o,a,s,f,p,g,y,v,C,S),oo=e.dynCall_viiiiijjiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)=>(oo=e.dynCall_viiiiijjiiiii=A.zf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M),ao=e.dynCall_iiiiji=(n,i,o,a,s,f,p)=>(ao=e.dynCall_iiiiji=A.Af)(n,i,o,a,s,f,p),so=e.dynCall_viiiiijiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$)=>(so=e.dynCall_viiiiijiiiiii=A.Bf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$),uo=e.dynCall_viiiijii=(n,i,o,a,s,f,p,g,y)=>(uo=e.dynCall_viiiijii=A.Cf)(n,i,o,a,s,f,p,g,y),lo=e.dynCall_viijjiii=(n,i,o,a,s,f,p,g,y,v)=>(lo=e.dynCall_viijjiii=A.Df)(n,i,o,a,s,f,p,g,y,v),co=e.dynCall_ijii=(n,i,o,a,s)=>(co=e.dynCall_ijii=A.Ef)(n,i,o,a,s),fo=e.dynCall_jjjjjjj=(n,i,o,a,s,f,p,g,y,v,C,S,I)=>(fo=e.dynCall_jjjjjjj=A.Ff)(n,i,o,a,s,f,p,g,y,v,C,S,I),po=e.dynCall_jjjjjj=(n,i,o,a,s,f,p,g,y,v,C)=>(po=e.dynCall_jjjjjj=A.Gf)(n,i,o,a,s,f,p,g,y,v,C),mo=e.dynCall_vijjjjiij=(n,i,o,a,s,f,p,g,y,v,C,S,I,$)=>(mo=e.dynCall_vijjjjiij=A.Hf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$),ho=e.dynCall_viiiiijij=(n,i,o,a,s,f,p,g,y,v,C)=>(ho=e.dynCall_viiiiijij=A.If)(n,i,o,a,s,f,p,g,y,v,C),go=e.dynCall_viiiiiijij=(n,i,o,a,s,f,p,g,y,v,C,S)=>(go=e.dynCall_viiiiiijij=A.Jf)(n,i,o,a,s,f,p,g,y,v,C,S),yo=e.dynCall_vijiii=(n,i,o,a,s,f,p)=>(yo=e.dynCall_vijiii=A.Kf)(n,i,o,a,s,f,p),bo=e.dynCall_viiiiiiiiifi=(n,i,o,a,s,f,p,g,y,v,C,S)=>(bo=e.dynCall_viiiiiiiiifi=A.Lf)(n,i,o,a,s,f,p,g,y,v,C,S),vo=e.dynCall_viiijiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)=>(vo=e.dynCall_viiijiiiiiiiii=A.Mf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M),wo=e.dynCall_iiijiiii=(n,i,o,a,s,f,p,g,y)=>(wo=e.dynCall_iiijiiii=A.Nf)(n,i,o,a,s,f,p,g,y),Co=e.dynCall_viiiiiijjiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)=>(Co=e.dynCall_viiiiiijjiiiii=A.Of)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G),$o=e.dynCall_viiiiiiijiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)=>($o=e.dynCall_viiiiiiijiiiiii=A.Pf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G),xo=e.dynCall_vif=(n,i,o)=>(xo=e.dynCall_vif=A.Qf)(n,i,o),So=e.dynCall_viif=(n,i,o,a)=>(So=e.dynCall_viif=A.Rf)(n,i,o,a),_o=e.dynCall_viiiiiifii=(n,i,o,a,s,f,p,g,y,v)=>(_o=e.dynCall_viiiiiifii=A.Sf)(n,i,o,a,s,f,p,g,y,v),Ao=e.dynCall_viiiiijiiiiiiiiiiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le)=>(Ao=e.dynCall_viiiiijiiiiiiiiiiiiiiiiiii=A.Tf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le),Io=e.dynCall_viijji=(n,i,o,a,s,f,p,g)=>(Io=e.dynCall_viijji=A.Uf)(n,i,o,a,s,f,p,g),To=e.dynCall_iiiiiiiiiiiji=(n,i,o,a,s,f,p,g,y,v,C,S,I,$)=>(To=e.dynCall_iiiiiiiiiiiji=A.Vf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$),Oo=e.dynCall_viifiifijjjii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)=>(Oo=e.dynCall_viifiifijjjii=A.Wf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G),Eo=e.dynCall_viiiiiiiiiiiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve)=>(Eo=e.dynCall_viiiiiiiiiiiiiiiiiiii=A.Xf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve),Po=e.dynCall_iif=(n,i,o)=>(Po=e.dynCall_iif=A.Yf)(n,i,o),Ro=e.dynCall_viiiiifiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I)=>(Ro=e.dynCall_viiiiifiiiiii=A.Zf)(n,i,o,a,s,f,p,g,y,v,C,S,I),ko=e.dynCall_vijiiiiiiijjii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q)=>(ko=e.dynCall_vijiiiiiiijjii=A._f)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q),Bo=e.dynCall_iiiiid=(n,i,o,a,s,f)=>(Bo=e.dynCall_iiiiid=A.$f)(n,i,o,a,s,f),Mo=e.dynCall_viiiijjj=(n,i,o,a,s,f,p,g,y,v,C)=>(Mo=e.dynCall_viiiijjj=A.ag)(n,i,o,a,s,f,p,g,y,v,C),jo=e.dynCall_viiiiiiiiiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se)=>(jo=e.dynCall_viiiiiiiiiiiiiiiiii=A.bg)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se),Do=e.dynCall_viiiiiiiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q)=>(Do=e.dynCall_viiiiiiiiiiiiiiii=A.cg)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q),Wo=e.dynCall_viiiiiiiiiiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge)=>(Wo=e.dynCall_viiiiiiiiiiiiiiiiiii=A.dg)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge),zo=e.dynCall_viiiiiiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)=>(zo=e.dynCall_viiiiiiiiiiiiiii=A.eg)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G),Go=e.dynCall_viiiiiiijjj=(n,i,o,a,s,f,p,g,y,v,C,S,I,$)=>(Go=e.dynCall_viiiiiiijjj=A.fg)(n,i,o,a,s,f,p,g,y,v,C,S,I,$),Vo=e.dynCall_iiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C)=>(Vo=e.dynCall_iiiiiiiiiii=A.gg)(n,i,o,a,s,f,p,g,y,v,C),Uo=e.dynCall_iiiiiiiiiiiiiiiiiifi=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge)=>(Uo=e.dynCall_iiiiiiiiiiiiiiiiiifi=A.hg)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge),No=e.dynCall_viiif=(n,i,o,a,s)=>(No=e.dynCall_viiif=A.ig)(n,i,o,a,s),Fo=e.dynCall_iijjj=(n,i,o,a,s,f,p,g)=>(Fo=e.dynCall_iijjj=A.jg)(n,i,o,a,s,f,p,g),Ho=e.dynCall_viiiiji=(n,i,o,a,s,f,p,g)=>(Ho=e.dynCall_viiiiji=A.kg)(n,i,o,a,s,f,p,g),Lo=e.dynCall_iijjji=(n,i,o,a,s,f,p,g,y)=>(Lo=e.dynCall_iijjji=A.lg)(n,i,o,a,s,f,p,g,y),Ko=e.dynCall_ijijji=(n,i,o,a,s,f,p,g,y)=>(Ko=e.dynCall_ijijji=A.mg)(n,i,o,a,s,f,p,g,y),qo=e.dynCall_viiijjiii=(n,i,o,a,s,f,p,g,y,v,C)=>(qo=e.dynCall_viiijjiii=A.ng)(n,i,o,a,s,f,p,g,y,v,C),Yo=e.dynCall_iiiiijji=(n,i,o,a,s,f,p,g,y,v)=>(Yo=e.dynCall_iiiiijji=A.og)(n,i,o,a,s,f,p,g,y,v),Xo=e.dynCall_viji=(n,i,o,a,s)=>(Xo=e.dynCall_viji=A.pg)(n,i,o,a,s),Qo=e.dynCall_iiiifi=(n,i,o,a,s,f)=>(Qo=e.dynCall_iiiifi=A.qg)(n,i,o,a,s,f),Jo=e.dynCall_iiijii=(n,i,o,a,s,f,p)=>(Jo=e.dynCall_iiijii=A.rg)(n,i,o,a,s,f,p),Zo=e.dynCall_iiiiiiiiijii=(n,i,o,a,s,f,p,g,y,v,C,S,I)=>(Zo=e.dynCall_iiiiiiiiijii=A.sg)(n,i,o,a,s,f,p,g,y,v,C,S,I),ea=e.dynCall_iiiijjii=(n,i,o,a,s,f,p,g,y,v)=>(ea=e.dynCall_iiiijjii=A.tg)(n,i,o,a,s,f,p,g,y,v),ta=e.dynCall_iiiiiijjjii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$)=>(ta=e.dynCall_iiiiiijjjii=A.ug)(n,i,o,a,s,f,p,g,y,v,C,S,I,$),ra=e.dynCall_iiijiii=(n,i,o,a,s,f,p,g)=>(ra=e.dynCall_iiijiii=A.vg)(n,i,o,a,s,f,p,g),na=e.dynCall_iiiiiiiijjjfi=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)=>(na=e.dynCall_iiiiiiiijjjfi=A.wg)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G),ia=e.dynCall_iijiiii=(n,i,o,a,s,f,p,g)=>(ia=e.dynCall_iijiiii=A.xg)(n,i,o,a,s,f,p,g),oa=e.dynCall_iijjjii=(n,i,o,a,s,f,p,g,y,v)=>(oa=e.dynCall_iijjjii=A.yg)(n,i,o,a,s,f,p,g,y,v),aa=e.dynCall_iiji=(n,i,o,a,s)=>(aa=e.dynCall_iiji=A.zg)(n,i,o,a,s),sa=e.dynCall_viiijiiiii=(n,i,o,a,s,f,p,g,y,v,C)=>(sa=e.dynCall_viiijiiiii=A.Ag)(n,i,o,a,s,f,p,g,y,v,C),ua=e.dynCall_iid=(n,i,o)=>(ua=e.dynCall_iid=A.Bg)(n,i,o),la=e.dynCall_iiif=(n,i,o,a)=>(la=e.dynCall_iiif=A.Cg)(n,i,o,a),ca=e.dynCall_vidi=(n,i,o,a)=>(ca=e.dynCall_vidi=A.Dg)(n,i,o,a),da=e.dynCall_vjiii=(n,i,o,a,s,f)=>(da=e.dynCall_vjiii=A.Eg)(n,i,o,a,s,f),fa=e.dynCall_iiiij=(n,i,o,a,s,f)=>(fa=e.dynCall_iiiij=A.Fg)(n,i,o,a,s,f),pa=e.dynCall_viiijii=(n,i,o,a,s,f,p,g)=>(pa=e.dynCall_viiijii=A.Gg)(n,i,o,a,s,f,p,g),ma=e.dynCall_viijiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$)=>(ma=e.dynCall_viijiiiiiiiii=A.Hg)(n,i,o,a,s,f,p,g,y,v,C,S,I,$),ha=e.dynCall_viiij=(n,i,o,a,s,f)=>(ha=e.dynCall_viiij=A.Ig)(n,i,o,a,s,f),ga=e.dynCall_fiiii=(n,i,o,a,s)=>(ga=e.dynCall_fiiii=A.Jg)(n,i,o,a,s),ya=e.dynCall_jfi=(n,i,o)=>(ya=e.dynCall_jfi=A.Kg)(n,i,o),ba=e.dynCall_viiiiiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)=>(ba=e.dynCall_viiiiiiiiiiiiii=A.Lg)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M),va=e.dynCall_jiij=(n,i,o,a,s)=>(va=e.dynCall_jiij=A.Mg)(n,i,o,a,s),wa=e.dynCall_fiii=(n,i,o,a)=>(wa=e.dynCall_fiii=A.Ng)(n,i,o,a),Ca=n=>(Ca=A.Og)(n),$a=()=>($a=A.Pg)(),xa=n=>(xa=A.Qg)(n),Sa=()=>(Sa=A.Rg)();e.___start_em_js=1323794,e.___stop_em_js=1323955;function yc(n,i,o,a){var s=z();try{return er(n,i,o,a)}catch(f){if(D(s),f!==f+0)throw f;W(1,0)}}function bc(n,i,o){var a=z();try{return Ar(n,i,o)}catch(s){if(D(a),s!==s+0)throw s;W(1,0)}}function vc(n,i,o){var a=z();try{_r(n,i,o)}catch(s){if(D(a),s!==s+0)throw s;W(1,0)}}function wc(n,i){var o=z();try{return Cn(n,i)}catch(a){if(D(o),a!==a+0)throw a;W(1,0)}}function Cc(n,i){var o=z();try{Sr(n,i)}catch(a){if(D(o),a!==a+0)throw a;W(1,0)}}function $c(n){var i=z();try{tr(n)}catch(o){if(D(i),o!==o+0)throw o;W(1,0)}}function xc(n,i,o,a,s,f,p){var g=z();try{return ke(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function Sc(n,i,o,a,s,f){var p=z();try{return rr(n,i,o,a,s,f)}catch(g){if(D(p),g!==g+0)throw g;W(1,0)}}function _c(n,i,o,a,s){var f=z();try{return nr(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function Ac(n,i,o,a){var s=z();try{Tr(n,i,o,a)}catch(f){if(D(s),f!==f+0)throw f;W(1,0)}}function Ic(n,i,o,a,s){var f=z();try{Br(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function Tc(n){var i=z();try{return Er(n)}catch(o){if(D(i),o!==o+0)throw o;W(1,0)}}function Oc(n,i,o,a,s,f){var p=z();try{kr(n,i,o,a,s,f)}catch(g){if(D(p),g!==g+0)throw g;W(1,0)}}function Ec(n,i,o,a,s,f,p,g){var y=z();try{return Mr(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function Pc(n,i){var o=z();try{return xn(n,i)}catch(a){if(D(o),a!==a+0)throw a;W(1,0)}}function Rc(n,i){var o=z();try{return jt(n,i)}catch(a){if(D(o),a!==a+0)throw a;W(1,0)}}function kc(n,i,o,a,s,f,p,g,y){var v=z();try{return it(n,i,o,a,s,f,p,g,y)}catch(C){if(D(v),C!==C+0)throw C;W(1,0)}}function Bc(n,i,o,a,s,f,p){var g=z();try{Dt(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function Mc(n,i,o,a,s,f,p,g){var y=z();try{zr(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function jc(n,i,o,a,s,f,p,g,y,v){var C=z();try{return An(n,i,o,a,s,f,p,g,y,v)}catch(S){if(D(C),S!==S+0)throw S;W(1,0)}}function Dc(n,i,o,a,s,f,p,g,y){var v=z();try{ir(n,i,o,a,s,f,p,g,y)}catch(C){if(D(v),C!==C+0)throw C;W(1,0)}}function Wc(n,i,o,a,s,f,p,g,y,v){var C=z();try{Pn(n,i,o,a,s,f,p,g,y,v)}catch(S){if(D(C),S!==S+0)throw S;W(1,0)}}function zc(n,i,o,a){var s=z();try{Rn(n,i,o,a)}catch(f){if(D(s),f!==f+0)throw f;W(1,0)}}function Gc(n,i,o,a,s,f,p,g,y,v,C,S){var I=z();try{return Bn(n,i,o,a,s,f,p,g,y,v,C,S)}catch($){if(D(I),$!==$+0)throw $;W(1,0)}}function Vc(n,i,o,a,s,f,p,g,y,v,C,S,I,$){var M=z();try{Wt(n,i,o,a,s,f,p,g,y,v,C,S,I,$)}catch(G){if(D(M),G!==G+0)throw G;W(1,0)}}function Uc(n,i,o,a,s,f,p){var g=z();try{Vr(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function Nc(n,i,o,a,s,f,p){var g=z();try{ar(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function Fc(n,i,o,a,s,f,p,g,y,v,C){var S=z();try{sr(n,i,o,a,s,f,p,g,y,v,C)}catch(I){if(D(S),I!==I+0)throw I;W(1,0)}}function Hc(n,i,o,a,s){var f=z();try{ur(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function Lc(n,i,o,a,s){var f=z();try{return ga(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function Kc(n,i,o,a,s,f,p,g,y,v,C,S,I,$){var M=z();try{E(n,i,o,a,s,f,p,g,y,v,C,S,I,$)}catch(G){if(D(M),G!==G+0)throw G;W(1,0)}}function qc(n,i,o,a,s){var f=z();try{b(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function Yc(n,i,o,a,s,f,p){var g=z();try{x(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function Xc(n,i,o,a,s){var f=z();try{Qr(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function Qc(n,i,o,a,s,f,p,g){var y=z();try{c(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function Jc(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q){var te=z();try{return F(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q)}catch(se){if(D(te),se!==se+0)throw se;W(1,0)}}function Zc(n,i,o,a,s,f,p,g,y,v,C,S,I){var $=z();try{J(n,i,o,a,s,f,p,g,y,v,C,S,I)}catch(M){if(D($),M!==M+0)throw M;W(1,0)}}function ed(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge){var ve=z();try{return de(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge)}catch(we){if(D(ve),we!==we+0)throw we;W(1,0)}}function td(n,i,o,a,s,f,p,g,y,v,C){var S=z();try{xe(n,i,o,a,s,f,p,g,y,v,C)}catch(I){if(D(S),I!==I+0)throw I;W(1,0)}}function rd(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q){var te=z();try{Jr(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q)}catch(se){if(D(te),se!==se+0)throw se;W(1,0)}}function nd(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G){var q=z();try{Fi(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)}catch(te){if(D(q),te!==te+0)throw te;W(1,0)}}function id(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M){var G=z();try{Hi(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)}catch(q){if(D(G),q!==q+0)throw q;W(1,0)}}function od(n,i,o,a,s,f,p){var g=z();try{return N(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function ad(n,i,o,a,s){var f=z();try{to(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function sd(n,i,o,a,s,f,p,g,y,v,C,S){var I=z();try{bo(n,i,o,a,s,f,p,g,y,v,C,S)}catch($){if(D(I),$!==$+0)throw $;W(1,0)}}function ud(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M){var G=z();try{ba(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)}catch(q){if(D(G),q!==q+0)throw q;W(1,0)}}function ld(n,i,o){var a=z();try{xo(n,i,o)}catch(s){if(D(a),s!==s+0)throw s;W(1,0)}}function cd(n,i,o,a,s,f,p,g,y,v){var C=z();try{_o(n,i,o,a,s,f,p,g,y,v)}catch(S){if(D(C),S!==S+0)throw S;W(1,0)}}function dd(n,i,o,a,s,f,p,g,y,v,C,S){var I=z();try{zt(n,i,o,a,s,f,p,g,y,v,C,S)}catch($){if(D(I),$!==$+0)throw $;W(1,0)}}function fd(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve){var we=z();try{Eo(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve)}catch(Se){if(D(we),Se!==Se+0)throw Se;W(1,0)}}function pd(n,i,o){var a=z();try{return Po(n,i,o)}catch(s){if(D(a),s!==s+0)throw s;W(1,0)}}function md(n,i,o,a,s,f,p,g,y,v,C,S,I){var $=z();try{Ro(n,i,o,a,s,f,p,g,y,v,C,S,I)}catch(M){if(D($),M!==M+0)throw M;W(1,0)}}function hd(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q){var te=z();try{Do(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q)}catch(se){if(D(te),se!==se+0)throw se;W(1,0)}}function gd(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge){var ve=z();try{Wo(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge)}catch(we){if(D(ve),we!==we+0)throw we;W(1,0)}}function yd(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se){var ge=z();try{jo(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se)}catch(ve){if(D(ge),ve!==ve+0)throw ve;W(1,0)}}function bd(n,i,o,a,s,f,p,g,y,v,C){var S=z();try{return Vo(n,i,o,a,s,f,p,g,y,v,C)}catch(I){if(D(S),I!==I+0)throw I;W(1,0)}}function vd(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge){var ve=z();try{return Uo(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge)}catch(we){if(D(ve),we!==we+0)throw we;W(1,0)}}function wd(n,i,o,a,s){var f=z();try{No(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function Cd(n,i,o,a,s,f,p,g,y,v,C,S){var I=z();try{Nr(n,i,o,a,s,f,p,g,y,v,C,S)}catch($){if(D(I),$!==$+0)throw $;W(1,0)}}function $d(n,i,o,a){var s=z();try{So(n,i,o,a)}catch(f){if(D(s),f!==f+0)throw f;W(1,0)}}function xd(n,i,o,a,s,f){var p=z();try{return Qo(n,i,o,a,s,f)}catch(g){if(D(p),g!==g+0)throw g;W(1,0)}}function Sd(n,i,o){var a=z();try{return ua(n,i,o)}catch(s){if(D(a),s!==s+0)throw s;W(1,0)}}function _d(n,i,o,a){var s=z();try{return la(n,i,o,a)}catch(f){if(D(s),f!==f+0)throw f;W(1,0)}}function Ad(n,i,o,a){var s=z();try{ca(n,i,o,a)}catch(f){if(D(s),f!==f+0)throw f;W(1,0)}}function Id(n,i,o,a){var s=z();try{return wa(n,i,o,a)}catch(f){if(D(s),f!==f+0)throw f;W(1,0)}}function Td(n,i,o,a,s,f){var p=z();try{return Bo(n,i,o,a,s,f)}catch(g){if(D(p),g!==g+0)throw g;W(1,0)}}function Od(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G){var q=z();try{zo(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)}catch(te){if(D(q),te!==te+0)throw te;W(1,0)}}function Ed(n,i,o){var a=z();try{return Sn(n,i,o)}catch(s){if(D(a),s!==s+0)throw s;W(1,0)}}function Pd(n,i,o){var a=z();try{return pt(n,i,o)}catch(s){if(D(a),s!==s+0)throw s;W(1,0)}}function Rd(n,i,o,a,s){var f=z();try{return Ir(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function kd(n,i,o,a){var s=z();try{return Pr(n,i,o,a)}catch(f){if(D(s),f!==f+0)throw f;W(1,0)}}function Bd(n,i,o,a){var s=z();try{$n(n,i,o,a)}catch(f){if(D(s),f!==f+0)throw f;W(1,0)}}function Md(n,i){var o=z();try{return jr(n,i)}catch(a){if(D(o),a!==a+0)throw a;W(1,0)}}function jd(n,i,o,a,s){var f=z();try{Dr(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function Dd(n,i,o,a,s,f){var p=z();try{Wr(n,i,o,a,s,f)}catch(g){if(D(p),g!==g+0)throw g;W(1,0)}}function Wd(n,i,o,a,s,f,p,g){var y=z();try{pa(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function zd(n,i,o,a,s,f,p){var g=z();try{Te(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function Gd(n,i,o,a,s,f,p,g,y,v,C,S){var I=z();try{return In(n,i,o,a,s,f,p,g,y,v,C,S)}catch($){if(D(I),$!==$+0)throw $;W(1,0)}}function Vd(n,i,o,a,s,f,p,g){var y=z();try{On(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function Ud(n,i,o,a,s,f,p,g){var y=z();try{En(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function Nd(n,i,o){var a=z();try{return _n(n,i,o)}catch(s){if(D(a),s!==s+0)throw s;W(1,0)}}function Fd(n,i,o,a,s,f,p,g,y,v){var C=z();try{return kn(n,i,o,a,s,f,p,g,y,v)}catch(S){if(D(C),S!==S+0)throw S;W(1,0)}}function Hd(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M){var G=z();try{or(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)}catch(q){if(D(G),q!==q+0)throw q;W(1,0)}}function Ld(n,i,o,a,s,f,p,g,y,v,C,S,I){var $=z();try{Gr(n,i,o,a,s,f,p,g,y,v,C,S,I)}catch(M){if(D($),M!==M+0)throw M;W(1,0)}}function Kd(n,i,o,a,s,f){var p=z();try{Tn(n,i,o,a,s,f)}catch(g){if(D(p),g!==g+0)throw g;W(1,0)}}function qd(n,i,o,a,s,f,p,g,y,v,C,S){var I=z();try{Ur(n,i,o,a,s,f,p,g,y,v,C,S)}catch($){if(D(I),$!==$+0)throw $;W(1,0)}}function Yd(n,i,o,a,s,f,p,g,y){var v=z();try{Fr(n,i,o,a,s,f,p,g,y)}catch(C){if(D(v),C!==C+0)throw C;W(1,0)}}function Xd(n,i,o,a){var s=z();try{return Hr(n,i,o,a)}catch(f){if(D(s),f!==f+0)throw f;W(1,0)}}function Qd(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le,ot,at){var Vt=z();try{lr(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le,ot,at)}catch(Ut){if(D(Vt),Ut!==Ut+0)throw Ut;W(1,0)}}function Jd(n,i,o,a,s,f,p){var g=z();try{Lr(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function Zd(n,i,o,a,s,f,p,g,y,v,C,S,I){var $=z();try{Kr(n,i,o,a,s,f,p,g,y,v,C,S,I)}catch(M){if(D($),M!==M+0)throw M;W(1,0)}}function ef(n,i,o,a,s,f){var p=z();try{return qr(n,i,o,a,s,f)}catch(g){if(D(p),g!==g+0)throw g;W(1,0)}}function tf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M){var G=z();try{return Yr(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)}catch(q){if(D(G),q!==q+0)throw q;W(1,0)}}function rf(n,i,o){var a=z();try{Xr(n,i,o)}catch(s){if(D(a),s!==s+0)throw s;W(1,0)}}function nf(n,i,o,a,s){var f=z();try{return Mn(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function of(n,i,o,a,s,f,p,g,y,v,C){var S=z();try{return Gt(n,i,o,a,s,f,p,g,y,v,C)}catch(I){if(D(S),I!==I+0)throw I;W(1,0)}}function af(n,i,o,a,s,f,p,g,y,v,C,S,I){var $=z();try{V(n,i,o,a,s,f,p,g,y,v,C,S,I)}catch(M){if(D($),M!==M+0)throw M;W(1,0)}}function sf(n,i,o){var a=z();try{return pe(n,i,o)}catch(s){if(D(a),s!==s+0)throw s;W(1,0)}}function uf(n,i,o,a,s,f,p,g,y,v,C,S){var I=z();try{ce(n,i,o,a,s,f,p,g,y,v,C,S)}catch($){if(D(I),$!==$+0)throw $;W(1,0)}}function lf(n,i,o,a,s,f,p,g,y,v){var C=z();try{return me(n,i,o,a,s,f,p,g,y,v)}catch(S){if(D(C),S!==S+0)throw S;W(1,0)}}function cf(n,i,o,a,s,f,p,g,y){var v=z();try{return _e(n,i,o,a,s,f,p,g,y)}catch(C){if(D(v),C!==C+0)throw C;W(1,0)}}function df(n,i,o,a,s,f,p){var g=z();try{be(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function ff(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je){var De=z();try{wt(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je)}catch(Ve){if(D(De),Ve!==Ve+0)throw Ve;W(1,0)}}function pf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le,ot,at){var Vt=z();try{Li(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le,ot,at)}catch(Ut){if(D(Vt),Ut!==Ut+0)throw Ut;W(1,0)}}function mf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De){var Ve=z();try{Ki(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De)}catch(Le){if(D(Ve),Le!==Le+0)throw Le;W(1,0)}}function hf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se){var je=z();try{qi(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se)}catch(De){if(D(je),De!==De+0)throw De;W(1,0)}}function gf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le,ot){var at=z();try{Yi(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le,ot)}catch(Vt){if(D(at),Vt!==Vt+0)throw Vt;W(1,0)}}function yf(n,i,o,a,s,f,p,g,y,v,C,S){var I=z();try{Xi(n,i,o,a,s,f,p,g,y,v,C,S)}catch($){if(D(I),$!==$+0)throw $;W(1,0)}}function bf(n,i,o,a,s,f,p,g,y,v,C,S){var I=z();try{Qi(n,i,o,a,s,f,p,g,y,v,C,S)}catch($){if(D(I),$!==$+0)throw $;W(1,0)}}function vf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve){var we=z();try{Ji(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve)}catch(Se){if(D(we),Se!==Se+0)throw Se;W(1,0)}}function wf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M){var G=z();try{Zi(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)}catch(q){if(D(G),q!==q+0)throw q;W(1,0)}}function Cf(n,i,o,a,s,f,p,g,y,v,C,S,I){var $=z();try{eo(n,i,o,a,s,f,p,g,y,v,C,S,I)}catch(M){if(D($),M!==M+0)throw M;W(1,0)}}function $f(n,i,o){var a=z();try{return ya(n,i,o)}catch(s){if(D(a),s!==s+0)throw s;W(1,0)}}function xf(n,i,o,a,s,f,p,g){var y=z();try{return ro(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function Sf(n,i,o,a,s,f,p,g){var y=z();try{no(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function _f(n,i,o,a,s,f,p,g,y,v,C,S){var I=z();try{io(n,i,o,a,s,f,p,g,y,v,C,S)}catch($){if(D(I),$!==$+0)throw $;W(1,0)}}function Af(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M){var G=z();try{oo(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)}catch(q){if(D(G),q!==q+0)throw q;W(1,0)}}function If(n,i,o,a,s,f,p){var g=z();try{return ao(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function Tf(n,i,o,a,s,f,p,g,y,v,C,S,I,$){var M=z();try{so(n,i,o,a,s,f,p,g,y,v,C,S,I,$)}catch(G){if(D(M),G!==G+0)throw G;W(1,0)}}function Of(n,i,o,a,s,f,p,g,y){var v=z();try{uo(n,i,o,a,s,f,p,g,y)}catch(C){if(D(v),C!==C+0)throw C;W(1,0)}}function Ef(n,i,o,a,s,f,p,g,y,v){var C=z();try{lo(n,i,o,a,s,f,p,g,y,v)}catch(S){if(D(C),S!==S+0)throw S;W(1,0)}}function Pf(n,i,o,a,s){var f=z();try{return co(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function Rf(n,i,o,a,s,f,p,g,y,v,C){var S=z();try{return po(n,i,o,a,s,f,p,g,y,v,C)}catch(I){if(D(S),I!==I+0)throw I;W(1,0)}}function kf(n,i,o,a,s,f,p,g,y,v,C,S,I){var $=z();try{return fo(n,i,o,a,s,f,p,g,y,v,C,S,I)}catch(M){if(D($),M!==M+0)throw M;W(1,0)}}function Bf(n,i,o,a,s,f,p,g,y,v,C,S,I,$){var M=z();try{mo(n,i,o,a,s,f,p,g,y,v,C,S,I,$)}catch(G){if(D(M),G!==G+0)throw G;W(1,0)}}function Mf(n,i,o,a,s,f,p,g,y,v,C){var S=z();try{ho(n,i,o,a,s,f,p,g,y,v,C)}catch(I){if(D(S),I!==I+0)throw I;W(1,0)}}function jf(n,i,o,a,s,f,p,g,y,v,C,S){var I=z();try{go(n,i,o,a,s,f,p,g,y,v,C,S)}catch($){if(D(I),$!==$+0)throw $;W(1,0)}}function Df(n,i,o,a,s,f,p){var g=z();try{yo(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function Wf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M){var G=z();try{vo(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)}catch(q){if(D(G),q!==q+0)throw q;W(1,0)}}function zf(n,i,o,a,s,f,p,g,y){var v=z();try{return wo(n,i,o,a,s,f,p,g,y)}catch(C){if(D(v),C!==C+0)throw C;W(1,0)}}function Gf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G){var q=z();try{Co(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)}catch(te){if(D(q),te!==te+0)throw te;W(1,0)}}function Vf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G){var q=z();try{$o(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)}catch(te){if(D(q),te!==te+0)throw te;W(1,0)}}function Uf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le){var ot=z();try{Ao(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le)}catch(at){if(D(ot),at!==at+0)throw at;W(1,0)}}function Nf(n,i,o,a,s,f,p,g){var y=z();try{Io(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function Ff(n,i,o,a,s,f,p,g,y,v,C,S,I,$){var M=z();try{return To(n,i,o,a,s,f,p,g,y,v,C,S,I,$)}catch(G){if(D(M),G!==G+0)throw G;W(1,0)}}function Hf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G){var q=z();try{Oo(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)}catch(te){if(D(q),te!==te+0)throw te;W(1,0)}}function Lf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q){var te=z();try{ko(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q)}catch(se){if(D(te),se!==se+0)throw se;W(1,0)}}function Kf(n,i,o,a,s,f,p,g,y,v,C){var S=z();try{Mo(n,i,o,a,s,f,p,g,y,v,C)}catch(I){if(D(S),I!==I+0)throw I;W(1,0)}}function qf(n,i,o,a,s,f,p,g,y,v,C,S,I,$){var M=z();try{Go(n,i,o,a,s,f,p,g,y,v,C,S,I,$)}catch(G){if(D(M),G!==G+0)throw G;W(1,0)}}function Yf(n,i,o,a,s,f,p,g){var y=z();try{return Fo(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function Xf(n,i,o,a,s){var f=z();try{return va(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function Qf(n,i,o,a,s,f,p,g){var y=z();try{Ho(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function Jf(n,i,o,a,s,f,p,g,y){var v=z();try{return Lo(n,i,o,a,s,f,p,g,y)}catch(C){if(D(v),C!==C+0)throw C;W(1,0)}}function Zf(n,i,o,a,s,f,p,g,y){var v=z();try{return Ko(n,i,o,a,s,f,p,g,y)}catch(C){if(D(v),C!==C+0)throw C;W(1,0)}}function ep(n,i,o,a,s,f,p,g,y,v,C){var S=z();try{qo(n,i,o,a,s,f,p,g,y,v,C)}catch(I){if(D(S),I!==I+0)throw I;W(1,0)}}function tp(n,i,o,a,s,f,p,g,y,v){var C=z();try{return Yo(n,i,o,a,s,f,p,g,y,v)}catch(S){if(D(C),S!==S+0)throw S;W(1,0)}}function rp(n,i,o,a,s){var f=z();try{Xo(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function np(n,i,o,a,s,f,p){var g=z();try{return Jo(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function ip(n,i,o,a,s,f,p,g,y,v,C,S,I){var $=z();try{return Zo(n,i,o,a,s,f,p,g,y,v,C,S,I)}catch(M){if(D($),M!==M+0)throw M;W(1,0)}}function op(n,i,o,a,s,f,p,g,y,v){var C=z();try{return ea(n,i,o,a,s,f,p,g,y,v)}catch(S){if(D(C),S!==S+0)throw S;W(1,0)}}function ap(n,i,o,a,s,f,p,g,y,v,C,S,I,$){var M=z();try{return ta(n,i,o,a,s,f,p,g,y,v,C,S,I,$)}catch(G){if(D(M),G!==G+0)throw G;W(1,0)}}function sp(n,i,o,a,s,f,p,g){var y=z();try{return ra(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function up(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G){var q=z();try{return na(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)}catch(te){if(D(q),te!==te+0)throw te;W(1,0)}}function lp(n,i,o,a,s,f,p,g){var y=z();try{return ia(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function cp(n,i,o,a,s,f,p,g,y,v){var C=z();try{return oa(n,i,o,a,s,f,p,g,y,v)}catch(S){if(D(C),S!==S+0)throw S;W(1,0)}}function dp(n,i,o,a,s){var f=z();try{return aa(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function fp(n,i,o,a,s,f,p,g,y,v,C){var S=z();try{sa(n,i,o,a,s,f,p,g,y,v,C)}catch(I){if(D(S),I!==I+0)throw I;W(1,0)}}function pp(n,i,o,a,s,f){var p=z();try{ha(n,i,o,a,s,f)}catch(g){if(D(p),g!==g+0)throw g;W(1,0)}}function mp(n,i,o,a,s,f,p,g,y,v,C,S,I,$){var M=z();try{ma(n,i,o,a,s,f,p,g,y,v,C,S,I,$)}catch(G){if(D(M),G!==G+0)throw G;W(1,0)}}function hp(n,i,o,a,s,f){var p=z();try{da(n,i,o,a,s,f)}catch(g){if(D(p),g!==g+0)throw g;W(1,0)}}function gp(n,i,o,a,s,f){var p=z();try{return fa(n,i,o,a,s,f)}catch(g){if(D(p),g!==g+0)throw g;W(1,0)}}function yp(n){var i=z();try{return Or(n)}catch(o){if(D(i),o!==o+0)throw o;W(1,0)}}function bp(n,i,o,a,s,f,p){var g=z();try{return Rr(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function vp(n){n=Object.assign({},n);var i=a=>()=>a()>>>0,o=a=>s=>a(s)>>>0;return n.__errno_location=i(n.__errno_location),n.malloc=o(n.malloc),n.stackSave=i(n.stackSave),n.stackAlloc=o(n.stackAlloc),n}e.stackAlloc=Mt,e.stackSave=z,e.stackRestore=D,e.UTF8ToString=ct,e.stringToUTF8=(n,i,o)=>bt(n,Ce,i,o),e.lengthBytesUTF8=mr;var jn;gt=function n(){jn||_a(),jn||(gt=n)};function _a(){function n(){if(!jn&&(jn=!0,e.calledRun=!0,!Z)){if(ut(Ze),d(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for(typeof e.postRun=="function"&&(e.postRun=[e.postRun]);e.postRun.length;){var i=e.postRun.shift();Ie.unshift(i)}ut(Ie)}}if(!(0<Ee)){if(e.preRun)for(typeof e.preRun=="function"&&(e.preRun=[e.preRun]);e.preRun.length;)He();ut(ae),0<Ee||(e.setStatus?(e.setStatus("Running..."),setTimeout(function(){setTimeout(function(){e.setStatus("")},1),n()},1)):n())}}if(e.preInit)for(typeof e.preInit=="function"&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return _a(),r.ready}})();typeof Ia=="object"&&typeof pi=="object"?pi.exports=Aa:typeof define=="function"&&define.amd&&define([],()=>Aa)});var Oa=Zr(()=>{});var Ea=Zr(()=>{});var Pa={};Dn(Pa,{cpus:()=>Ap});var Ap,Ra=oe(()=>{Ap=void 0});var Ma=Zr((Ba,mi)=>{"use strict";var ka=(()=>{var t=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(t=t||__filename),function(r={}){function e(){return ue.buffer!=Ee.buffer&&ee(),Ee}function d(){return ue.buffer!=Ee.buffer&&ee(),qe}function l(){return ue.buffer!=Ee.buffer&&ee(),gt}function m(){return ue.buffer!=Ee.buffer&&ee(),Je}function h(){return ue.buffer!=Ee.buffer&&ee(),_t}var u=r,w,_;u.ready=new Promise((c,b)=>{w=c,_=b}),u.jsepInit=(c,b,x,E,V,F,J,pe)=>{u.Qb=c,u.wb=b,u.yb=x,u.jb=E,u.xb=V,u.Ea=F,u.zb=J,u.Ab=pe,b=(de,ce,me)=>(...xe)=>{let _e=it,N=ce?.();xe=de(...xe);let be=ce?.();return N!==be&&(de=be,me(N),ce=me=null),it!=_e?Tn():xe},x=de=>async(...ce)=>{try{if(u.bb)throw Error("Session already started");let me=u.bb={Fb:ce[0],errors:[]},xe=await de(...ce);if(u.bb!==me)throw Error("Session mismatch");c.flush();let _e=me.errors;if(0<_e.length){let N=await Promise.all(_e);if(N=N.filter(be=>be),0<N.length)throw Error(N.join(`\n`))}return xe}finally{u.bb=null}},u._OrtRun=x(b(u._OrtRun,()=>u._OrtRun,de=>u._OrtRun=de)),u._OrtRunWithBinding=x(b(u._OrtRunWithBinding,()=>u._OrtRunWithBinding,de=>u._OrtRunWithBinding=de)),u._OrtBindInput=b(u._OrtBindInput,()=>u._OrtBindInput,de=>u._OrtBindInput=de),u.jsepRegisterBuffer=(de,ce,me,xe)=>c.registerBuffer(de,ce,me,xe),u.jsepUnregisterBuffers=de=>{c.unregisterBuffers(de)},u.jsepGetBuffer=de=>c.getBuffer(de),u.jsepCreateDownloader=(de,ce,me)=>c.createDownloader(de,ce,me)};var O=Object.assign({},u),j="./this.program",B=(c,b)=>{throw b},P=typeof window=="object",R=typeof importScripts=="function",T=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",k=u.ENVIRONMENT_IS_PTHREAD||!1,U="";function K(c){return u.locateFile?u.locateFile(c,U):U+c}var Q,L,X;if(T){var A=(ci(),cr(li)),Z=(fi(),cr(di));U=R?Z.dirname(U)+"/":__dirname+"/",Q=(b,x)=>(b=b.startsWith("file://")?new URL(b):Z.normalize(b),A.readFileSync(b,x?void 0:"utf8")),X=b=>(b=Q(b,!0),b.buffer||(b=new Uint8Array(b)),b),L=(b,x,E,V=!0)=>{b=b.startsWith("file://")?new URL(b):Z.normalize(b),A.readFile(b,V?void 0:"utf8",(F,J)=>{F?E(F):x(V?J.buffer:J)})},!u.thisProgram&&1<process.argv.length&&(j=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),B=(b,x)=>{throw process.exitCode=b,x},u.inspect=()=>"[Emscripten Module object]";let c;try{c=Oa()}catch(b){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),b}global.Worker=c.Worker}else(P||R)&&(R?U=self.location.href:typeof document<"u"&&document.currentScript&&(U=document.currentScript.src),typeof t<"u"&&t&&(U=t),U.indexOf("blob:")!==0?U=U.substr(0,U.replace(/[?#].*/,"").lastIndexOf("/")+1):U="",T||(Q=c=>{var b=new XMLHttpRequest;return b.open("GET",c,!1),b.send(null),b.responseText},R&&(X=c=>{var b=new XMLHttpRequest;return b.open("GET",c,!1),b.responseType="arraybuffer",b.send(null),new Uint8Array(b.response)}),L=(c,b,x)=>{var E=new XMLHttpRequest;E.open("GET",c,!0),E.responseType="arraybuffer",E.onload=()=>{E.status==200||E.status==0&&E.response?b(E.response):x()},E.onerror=x,E.send(null)}));T&&typeof performance>"u"&&(global.performance=Ea().performance);var re=console.log.bind(console),ie=console.error.bind(console);T&&(re=(...c)=>A.writeSync(1,c.join(" ")+`\n`),ie=(...c)=>A.writeSync(2,c.join(" ")+`\n`));var Ce=u.print||re,H=u.printErr||ie;Object.assign(u,O),O=null,u.thisProgram&&(j=u.thisProgram),u.quit&&(B=u.quit);var le;u.wasmBinary&&(le=u.wasmBinary);var Be=u.noExitRuntime||!0;typeof WebAssembly!="object"&&Ye("no native wasm support detected");var ue,ae,Ze,Ie=!1,He,Ee,qe,gt,Je,_t;function ee(){var c=ue.buffer;u.HEAP8=Ee=new Int8Array(c),u.HEAP16=new Int16Array(c),u.HEAP32=gt=new Int32Array(c),u.HEAPU8=qe=new Uint8Array(c),u.HEAPU16=new Uint16Array(c),u.HEAPU32=Je=new Uint32Array(c),u.HEAPF32=new Float32Array(c),u.HEAPF64=_t=new Float64Array(c)}var $e=u.INITIAL_MEMORY||16777216;if(5242880<=$e||Ye("INITIAL_MEMORY should be larger than STACK_SIZE, was "+$e+"! (STACK_SIZE=5242880)"),k)ue=u.wasmMemory;else if(u.wasmMemory)ue=u.wasmMemory;else if(ue=new WebAssembly.Memory({initial:$e/65536,maximum:65536,shared:!0}),!(ue.buffer instanceof SharedArrayBuffer))throw H("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),T&&H("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");ee(),$e=ue.buffer.byteLength;var Oe=[],et=[],tt=[],Ge=0;function Me(){return Be||0<Ge}var rt=0,yt=null,ut=null;function Ot(){rt++,u.monitorRunDependencies&&u.monitorRunDependencies(rt)}function Et(){if(rt--,u.monitorRunDependencies&&u.monitorRunDependencies(rt),rt==0&&(yt!==null&&(clearInterval(yt),yt=null),ut)){var c=ut;ut=null,c()}}function Ye(c){throw u.onAbort&&u.onAbort(c),c="Aborted("+c+")",H(c),Ie=!0,He=1,c=new WebAssembly.RuntimeError(c+". Build with -sASSERTIONS for more info."),_(c),c}function Lt(c){return c.startsWith("data:application/octet-stream;base64,")}var lt;lt="ort-wasm-simd-threaded.wasm",Lt(lt)||(lt=K(lt));function pr(c){if(c==lt&&le)return new Uint8Array(le);if(X)return X(c);throw"both async and sync fetching of the wasm failed"}function dn(c){if(!le&&(P||R)){if(typeof fetch=="function"&&!c.startsWith("file://"))return fetch(c,{credentials:"same-origin"}).then(b=>{if(!b.ok)throw"failed to load wasm binary file at \'"+c+"\'";return b.arrayBuffer()}).catch(()=>pr(c));if(L)return new Promise((b,x)=>{L(c,E=>b(new Uint8Array(E)),x)})}return Promise.resolve().then(()=>pr(c))}function ct(c,b,x){return dn(c).then(E=>WebAssembly.instantiate(E,b)).then(E=>E).then(x,E=>{H("failed to asynchronously prepare wasm: "+E),Ye(E)})}function mr(c,b){var x=lt;return le||typeof WebAssembly.instantiateStreaming!="function"||Lt(x)||x.startsWith("file://")||T||typeof fetch!="function"?ct(x,c,b):fetch(x,{credentials:"same-origin"}).then(E=>WebAssembly.instantiateStreaming(E,c).then(b,function(V){return H("wasm streaming compile failed: "+V),H("falling back to ArrayBuffer instantiation"),ct(x,c,b)}))}var bt,vt={911532:c=>{u.Ea("Abs",c,void 0)},911583:c=>{u.Ea("Neg",c,void 0)},911634:c=>{u.Ea("Floor",c,void 0)},911687:c=>{u.Ea("Ceil",c,void 0)},911739:c=>{u.Ea("Reciprocal",c,void 0)},911797:c=>{u.Ea("Sqrt",c,void 0)},911849:c=>{u.Ea("Exp",c,void 0)},911900:c=>{u.Ea("Erf",c,void 0)},911951:c=>{u.Ea("Sigmoid",c,void 0)},912006:c=>{u.Ea("Log",c,void 0)},912057:c=>{u.Ea("Sin",c,void 0)},912108:c=>{u.Ea("Cos",c,void 0)},912159:c=>{u.Ea("Tan",c,void 0)},912210:c=>{u.Ea("Asin",c,void 0)},912262:c=>{u.Ea("Acos",c,void 0)},912314:c=>{u.Ea("Atan",c,void 0)},912366:c=>{u.Ea("Sinh",c,void 0)},912418:c=>{u.Ea("Cosh",c,void 0)},912470:c=>{u.Ea("Asinh",c,void 0)},912523:c=>{u.Ea("Acosh",c,void 0)},912576:c=>{u.Ea("Atanh",c,void 0)},912629:c=>{u.Ea("Tanh",c,void 0)},912681:c=>{u.Ea("Not",c,void 0)},912732:(c,b,x)=>{u.Ea("ClipV10",c,{min:b,max:x})},912804:c=>{u.Ea("Clip",c,void 0)},912856:(c,b)=>{u.Ea("Elu",c,{alpha:b})},912914:c=>{u.Ea("Relu",c,void 0)},912966:(c,b)=>{u.Ea("LeakyRelu",c,{alpha:b})},913030:(c,b)=>{u.Ea("ThresholdedRelu",c,{alpha:b})},913100:(c,b)=>{u.Ea("Cast",c,{to:b})},913158:c=>{u.Ea("Add",c,void 0)},913209:c=>{u.Ea("Sub",c,void 0)},913260:c=>{u.Ea("Mul",c,void 0)},913311:c=>{u.Ea("Div",c,void 0)},913362:c=>{u.Ea("Pow",c,void 0)},913413:c=>{u.Ea("Equal",c,void 0)},913466:c=>{u.Ea("Greater",c,void 0)},913521:c=>{u.Ea("GreaterOrEqual",c,void 0)},913583:c=>{u.Ea("Less",c,void 0)},913635:c=>{u.Ea("LessOrEqual",c,void 0)},913694:(c,b,x,E,V)=>{u.Ea("ReduceMean",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[]})},913858:(c,b,x,E,V)=>{u.Ea("ReduceMax",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[]})},914021:(c,b,x,E,V)=>{u.Ea("ReduceMin",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[]})},914184:(c,b,x,E,V)=>{u.Ea("ReduceProd",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[]})},914348:(c,b,x,E,V)=>{u.Ea("ReduceSum",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[]})},914511:(c,b,x,E,V)=>{u.Ea("ReduceL1",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[]})},914673:(c,b,x,E,V)=>{u.Ea("ReduceL2",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[]})},914835:(c,b,x,E,V)=>{u.Ea("ReduceLogSum",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[]})},915001:(c,b,x,E,V)=>{u.Ea("ReduceSumSquare",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[]})},915170:(c,b,x,E,V)=>{u.Ea("ReduceLogSumExp",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[]})},915339:c=>{u.Ea("Where",c,void 0)},915392:(c,b,x)=>{u.Ea("Transpose",c,{perm:b?Array.from(l().subarray(x>>>0,x+b>>>0)):[]})},915505:(c,b,x,E,V,F,J,pe,de,ce)=>{u.Ea("Conv",c,{format:de?"NHWC":"NCHW",auto_pad:b,dilations:[x],group:E,kernel_shape:[V],pads:[F,J],strides:[pe],w_is_const:()=>!!e()[ce>>>0]})},915733:(c,b,x,E,V,F,J,pe,de,ce,me,xe,_e,N,be)=>{u.Ea("Conv",c,{format:N?"NHWC":"NCHW",auto_pad:b,dilations:[x,E],group:V,kernel_shape:[F,J],pads:[pe,de,ce,me],strides:[xe,_e],w_is_const:()=>!!e()[be>>>0]})},915992:(c,b,x,E,V,F,J,pe,de,ce)=>{u.Ea("Conv",c,{format:de?"NHWC":"NCHW",auto_pad:b,dilations:[x],group:E,kernel_shape:[V],pads:[F,J],strides:[pe],w_is_const:()=>!!e()[ce>>>0]})},916220:(c,b,x,E,V,F,J,pe,de,ce,me,xe,_e,N,be)=>{u.Ea("Conv",c,{format:N?"NHWC":"NCHW",auto_pad:b,dilations:[x,E],group:V,kernel_shape:[F,J],pads:[pe,de,ce,me],strides:[xe,_e],w_is_const:()=>!!e()[be>>>0]})},916479:(c,b,x,E,V,F,J,pe,de,ce,me,xe,_e,N)=>{u.Ea("ConvTranspose",c,{format:de?"NHWC":"NCHW",autoPad:b,dilations:[x],group:E,kernel_shape:[V],pads:[F,J],strides:[pe],wIsConst:()=>!!e()[ce>>>0],outputPadding:me?Array.from(l().subarray(xe>>>0,xe+me>>>0)):[],outputShape:_e?Array.from(l().subarray(N>>>0,N+_e>>>0)):[]})},916859:(c,b,x,E,V,F,J,pe,de,ce,me,xe,_e)=>{u.Ea("ConvTranspose",c,{format:pe?"NHWC":"NCHW",autoPad:b,dilations:Array.from(l().subarray(x>>>0,x+2>>>0)),group:E,kernelShape:Array.from(l().subarray(V>>>0,V+2>>>0)),pads:Array.from(l().subarray(F>>>0,F+4>>>0)),strides:Array.from(l().subarray(J>>>0,J+2>>>0)),wIsConst:()=>!!e()[de>>>0],outputPadding:0<ce?Array.from(l().subarray(me>>>0,me+ce>>>0)):[],outputShape:0<xe?Array.from(l().subarray(_e>>>0,_e+xe>>>0)):[]})},917382:(c,b,x,E,V,F,J,pe,de,ce,me,xe,_e,N)=>{u.Ea("ConvTranspose",c,{format:de?"NHWC":"NCHW",autoPad:b,dilations:[x],group:E,kernel_shape:[V],pads:[F,J],strides:[pe],wIsConst:()=>!!e()[ce>>>0],outputPadding:me?Array.from(l().subarray(xe>>>0,xe+me>>>0)):[],outputShape:_e?Array.from(l().subarray(N>>>0,N+_e>>>0)):[]})},917762:(c,b,x,E,V,F,J,pe,de,ce,me,xe,_e)=>{u.Ea("ConvTranspose",c,{format:pe?"NHWC":"NCHW",autoPad:b,dilations:Array.from(l().subarray(x>>>0,x+2>>>0)),group:E,kernelShape:Array.from(l().subarray(V>>>0,V+2>>>0)),pads:Array.from(l().subarray(F>>>0,F+4>>>0)),strides:Array.from(l().subarray(J>>>0,J+2>>>0)),wIsConst:()=>!!e()[de>>>0],outputPadding:0<ce?Array.from(l().subarray(me>>>0,me+ce>>>0)):[],outputShape:0<xe?Array.from(l().subarray(_e>>>0,_e+xe>>>0)):[]})},918285:(c,b)=>{u.Ea("GlobalAveragePool",c,{format:b?"NHWC":"NCHW"})},918376:(c,b,x,E,V,F,J,pe,de,ce,me,xe,_e,N,be,Te)=>{u.Ea("AveragePool",c,{format:Te?"NHWC":"NCHW",auto_pad:b,ceil_mode:x,count_include_pad:E,storage_order:V,dilations:[F,J],kernel_shape:[pe,de],pads:[ce,me,xe,_e],strides:[N,be]})},918660:(c,b)=>{u.Ea("GlobalAveragePool",c,{format:b?"NHWC":"NCHW"})},918751:(c,b,x,E,V,F,J,pe,de,ce,me,xe,_e,N,be,Te)=>{u.Ea("AveragePool",c,{format:Te?"NHWC":"NCHW",auto_pad:b,ceil_mode:x,count_include_pad:E,storage_order:V,dilations:[F,J],kernel_shape:[pe,de],pads:[ce,me,xe,_e],strides:[N,be]})},919035:(c,b)=>{u.Ea("GlobalMaxPool",c,{format:b?"NHWC":"NCHW"})},919122:(c,b,x,E,V,F,J,pe,de,ce,me,xe,_e,N,be,Te)=>{u.Ea("MaxPool",c,{format:Te?"NHWC":"NCHW",auto_pad:b,ceil_mode:x,count_include_pad:E,storage_order:V,dilations:[F,J],kernel_shape:[pe,de],pads:[ce,me,xe,_e],strides:[N,be]})},919402:(c,b)=>{u.Ea("GlobalMaxPool",c,{format:b?"NHWC":"NCHW"})},919489:(c,b,x,E,V,F,J,pe,de,ce,me,xe,_e,N,be,Te)=>{u.Ea("MaxPool",c,{format:Te?"NHWC":"NCHW",auto_pad:b,ceil_mode:x,count_include_pad:E,storage_order:V,dilations:[F,J],kernel_shape:[pe,de],pads:[ce,me,xe,_e],strides:[N,be]})},919769:(c,b,x,E,V)=>{u.Ea("Gemm",c,{alpha:b,beta:x,transA:E,transB:V})},919873:c=>{u.Ea("MatMul",c,void 0)},919927:(c,b,x,E)=>{u.Ea("ArgMax",c,{keepDims:!!b,selectLastIndex:!!x,axis:E})},920035:(c,b,x,E)=>{u.Ea("ArgMin",c,{keepDims:!!b,selectLastIndex:!!x,axis:E})},920143:(c,b)=>{u.Ea("Softmax",c,{axis:b})},920206:(c,b)=>{u.Ea("Concat",c,{axis:b})},920266:(c,b,x,E,V)=>{u.Ea("Split",c,{axis:b,numOutputs:x,splitSizes:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[]})},920411:c=>{u.Ea("Expand",c,void 0)},920465:(c,b)=>{u.Ea("Gather",c,{axis:Number(b)})},920536:(c,b)=>{u.Ea("GatherElements",c,{axis:Number(b)})},920615:(c,b,x,E,V,F,J,pe,de,ce,me)=>{u.Ea("Resize",c,{antialias:b,axes:x?Array.from(l().subarray(E>>>0,E+x>>>0)):[],coordinateTransformMode:dt(V),cubicCoeffA:F,excludeOutside:J,extrapolationValue:pe,keepAspectRatioPolicy:dt(de),mode:dt(ce),nearestMode:dt(me)})},920966:(c,b,x,E,V,F,J)=>{u.Ea("Slice",c,{starts:b?Array.from(l().subarray(x>>>0,x+b>>>0)):[],ends:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[],axes:F?Array.from(l().subarray(J>>>0,J+F>>>0)):[]})},921197:c=>{u.Ea("Tile",c,void 0)},921249:(c,b,x)=>{u.Ea("LayerNormalization",c,{axis:Number(b),epsilon:Number(x)})},921356:(c,b,x)=>{u.Ea("InstanceNormalization",c,{epsilon:b,format:x?"NHWC":"NCHW"})},921470:(c,b,x)=>{u.Ea("InstanceNormalization",c,{epsilon:b,format:x?"NHWC":"NCHW"})},921584:c=>{u.Ea("Range",c,void 0)},921637:(c,b)=>{u.Ea("Einsum",c,{equation:dt(b)})},921718:(c,b,x,E,V)=>{u.Ea("Pad",c,{mode:b,value:x,pads:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[]})},921850:c=>{u.Ea("Gelu",c,void 0)},921902:c=>{u.Ea("BiasAdd",c,void 0)},921957:c=>{u.Ea("BiasSplitGelu",c,void 0)},922018:(c,b)=>{u.Ea("SkipLayerNormalization",c,{epsilon:b})},922099:c=>{u.zb(c)},922133:(c,b)=>u.Ab(c,b,u.bb.Fb,u.bb.errors),922245:c=>u.wb(c),922278:c=>u.yb(c),922310:(c,b,x)=>{u.jb(c,b,x,!0)},922349:(c,b,x)=>{u.jb(c,b,x)}};function Pt(c){this.name="ExitStatus",this.message=`Program terminated with exit(${c})`,this.status=c}function Kt(c){c.terminate(),c.onmessage=()=>{}}function hr(c){(c=he.Qa[c])||Ye(),he.Eb(c)}function qt(c){var b=he.tb();if(!b)return 6;he.Ya.push(b),he.Qa[c.Xa]=b,b.Xa=c.Xa;var x={cmd:"run",start_routine:c.Gb,arg:c.rb,pthread_ptr:c.Xa};return T&&b.unref(),b.postMessage(x,c.Mb),0}var gr=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Yt=(c,b,x)=>{b>>>=0;var E=b+x;for(x=b;c[x]&&!(x>=E);)++x;if(16<x-b&&c.buffer&&gr)return gr.decode(c.buffer instanceof SharedArrayBuffer?c.slice(b,x):c.subarray(b,x));for(E="";b<x;){var V=c[b++];if(V&128){var F=c[b++]&63;if((V&224)==192)E+=String.fromCharCode((V&31)<<6|F);else{var J=c[b++]&63;V=(V&240)==224?(V&15)<<12|F<<6|J:(V&7)<<18|F<<12|J<<6|c[b++]&63,65536>V?E+=String.fromCharCode(V):(V-=65536,E+=String.fromCharCode(55296|V>>10,56320|V&1023))}}else E+=String.fromCharCode(V)}return E},dt=(c,b)=>(c>>>=0)?Yt(d(),c,b):"";function Xt(c){if(k)return ke(1,1,c);He=c,Me()||(he.Hb(),u.onExit&&u.onExit(c),Ie=!0),B(c,new Pt(c))}var yr=c=>{if(He=c,k)throw fn(c),"unwind";Xt(c)},he={ab:[],Ya:[],mb:[],Qa:{},gb:function(){k?he.vb():he.ub()},ub:function(){Oe.unshift(()=>{Ot(),he.Bb(()=>Et())})},vb:function(){he.receiveObjectTransfer=he.Db,he.threadInitTLS=he.lb,he.setExitStatus=he.kb,Be=!1},kb:function(c){He=c},Sb:["$terminateWorker"],Hb:function(){for(var c of he.Ya)Kt(c);for(c of he.ab)Kt(c);he.ab=[],he.Ya=[],he.Qa=[]},Eb:function(c){var b=c.Xa;delete he.Qa[b],he.ab.push(c),he.Ya.splice(he.Ya.indexOf(c),1),c.Xa=0,ar(b)},Db:function(){},lb:function(){he.mb.forEach(c=>c())},Cb:c=>new Promise(b=>{c.onmessage=F=>{F=F.data;var J=F.cmd;if(F.targetThread&&F.targetThread!=Wt()){var pe=he.Qa[F.Rb];pe?pe.postMessage(F,F.transferList):H(\'Internal error! Worker sent a message "\'+J+\'" to target pthread \'+F.targetThread+", but that thread no longer exists!")}else J==="checkMailbox"?Mt():J==="spawnThread"?qt(F):J==="cleanupThread"?hr(F.thread):J==="killThread"?(F=F.thread,J=he.Qa[F],delete he.Qa[F],Kt(J),ar(F),he.Ya.splice(he.Ya.indexOf(J),1),J.Xa=0):J==="cancelThread"?he.Qa[F.thread].postMessage({cmd:"cancel"}):J==="loaded"?(c.loaded=!0,b(c)):J==="alert"?alert("Thread "+F.threadId+": "+F.text):F.target==="setimmediate"?c.postMessage(F):J==="callHandler"?u[F.handler](...F.args):J&&H("worker sent an unknown command "+J)},c.onerror=F=>{throw H("worker sent an error! "+F.filename+":"+F.lineno+": "+F.message),F},T&&(c.on("message",function(F){c.onmessage({data:F})}),c.on("error",function(F){c.onerror(F)}));var x=[],E=["onExit","onAbort","print","printErr"],V;for(V of E)u.hasOwnProperty(V)&&x.push(V);c.postMessage({cmd:"load",handlers:x,urlOrBlob:u.mainScriptUrlOrBlob||t,wasmMemory:ue,wasmModule:Ze})}),Bb:function(c){c()},qb:function(){var c=K("ort-wasm-simd-threaded.worker.js");c=new Worker(c),he.ab.push(c)},tb:function(){return he.ab.length==0&&(he.qb(),he.Cb(he.ab[0])),he.ab.pop()}};u.PThread=he;var Rt=c=>{for(;0<c.length;)c.shift()(u)};u.establishStackSpace=function(){var c=Wt(),b=l()[c+52>>2>>>0];c=l()[c+56>>2>>>0],Hr(b,b-c),zt(b)};function fn(c){if(k)return ke(2,0,c);yr(c)}u.invokeEntryPoint=function(c,b){c=Lr.apply(null,[c,b]),Me()?he.kb(c):sr(c)};function pn(c){this.fb=c-24,this.pb=function(b){m()[this.fb+4>>2>>>0]=b},this.ob=function(b){m()[this.fb+8>>2>>>0]=b},this.gb=function(b,x){this.nb(),this.pb(b),this.ob(x)},this.nb=function(){m()[this.fb+16>>2>>>0]=0}}var kt=0,si=0;function ft(c,b,x,E){return k?ke(3,1,c,b,x,E):nt(c,b,x,E)}function nt(c,b,x,E){if(c>>>=0,b>>>=0,x>>>=0,E>>>=0,typeof SharedArrayBuffer>"u")return H("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var V=[];return k&&V.length===0?ft(c,b,x,E):(c={Gb:x,Xa:c,rb:E,Mb:V},k?(c.Ob="spawnThread",postMessage(c,V),0):qt(c))}function br(c,b,x){return k?ke(4,1,c,b,x):0}function Bt(c,b){if(k)return ke(5,1,c,b)}var Qt=c=>{for(var b=0,x=0;x<c.length;++x){var E=c.charCodeAt(x);127>=E?b++:2047>=E?b+=2:55296<=E&&57343>=E?(b+=4,++x):b+=3}return b},vr=(c,b,x,E)=>{if(x>>>=0,!(0<E))return 0;var V=x;E=x+E-1;for(var F=0;F<c.length;++F){var J=c.charCodeAt(F);if(55296<=J&&57343>=J){var pe=c.charCodeAt(++F);J=65536+((J&1023)<<10)|pe&1023}if(127>=J){if(x>=E)break;b[x++>>>0]=J}else{if(2047>=J){if(x+1>=E)break;b[x++>>>0]=192|J>>6}else{if(65535>=J){if(x+2>=E)break;b[x++>>>0]=224|J>>12}else{if(x+3>=E)break;b[x++>>>0]=240|J>>18,b[x++>>>0]=128|J>>12&63}b[x++>>>0]=128|J>>6&63}b[x++>>>0]=128|J&63}}return b[x>>>0]=0,x-V},mn=(c,b,x)=>vr(c,d(),b,x);function Jt(c,b){if(k)return ke(6,1,c,b)}function hn(c,b,x){if(k)return ke(7,1,c,b,x)}function gn(c,b,x){return k?ke(8,1,c,b,x):0}function yn(c,b){if(k)return ke(9,1,c,b)}function bn(c,b,x){if(k)return ke(10,1,c,b,x)}function vn(c,b,x,E){if(k)return ke(11,1,c,b,x,E)}function wn(c,b,x,E){if(k)return ke(12,1,c,b,x,E)}function Zt(c,b,x,E){if(k)return ke(13,1,c,b,x,E)}function wr(c){if(k)return ke(14,1,c)}function W(c,b){if(k)return ke(15,1,c,b)}function At(c,b,x){if(k)return ke(16,1,c,b,x)}var z=c=>{if(!Ie)try{if(c(),!Me())try{k?sr(He):yr(He)}catch(b){b instanceof Pt||b=="unwind"||B(1,b)}}catch(b){b instanceof Pt||b=="unwind"||B(1,b)}};function D(c){c>>>=0,typeof Atomics.Nb=="function"&&(Atomics.Nb(l(),c>>2,c).value.then(Mt),c+=128,Atomics.store(l(),c>>2,1))}u.__emscripten_thread_mailbox_await=D;function Mt(){var c=Wt();c&&(D(c),z(()=>Nr()))}u.checkMailbox=Mt;var It=c=>c%4===0&&(c%100!==0||c%400===0),Cr=[0,31,60,91,121,152,182,213,244,274,305,335],$r=[0,31,59,90,120,151,181,212,243,273,304,334];function xr(c,b,x,E,V,F,J,pe){return k?ke(17,1,c,b,x,E,V,F,J,pe):-52}function Sr(c,b,x,E,V,F,J){if(k)return ke(18,1,c,b,x,E,V,F,J)}var _r=c=>{var b=Qt(c)+1,x=or(b);return x&&mn(c,x,b),x},er=[],Ar=(c,b)=>{er.length=0;var x;for(b>>=2;x=d()[c++>>>0];)b+=x!=105&b,er.push(x==105?l()[b>>>0]:h()[b++>>>1]),++b;return er},Cn=c=>{var b=ur();return c=c(),zt(b),c};function ke(c,b){var x=arguments.length-2,E=arguments;return Cn(()=>{for(var V=lr(8*x),F=V>>3,J=0;J<x;J++){var pe=E[2+J];h()[F+J>>>0]=pe}return Ur(c,x,V,b)})}var tr=[],rr={},Ir=()=>{if(!nr){var c={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:j||"./this.program"},b;for(b in rr)rr[b]===void 0?delete c[b]:c[b]=rr[b];var x=[];for(b in c)x.push(`${b}=${c[b]}`);nr=x}return nr},nr;function Tr(c,b){if(k)return ke(19,1,c,b);c>>>=0,b>>>=0;var x=0;return Ir().forEach(function(E,V){var F=b+x;for(V=m()[c+4*V>>2>>>0]=F,F=0;F<E.length;++F)e()[V++>>0>>>0]=E.charCodeAt(F);e()[V>>0>>>0]=0,x+=E.length+1}),0}function Or(c,b){if(k)return ke(20,1,c,b);c>>>=0,b>>>=0;var x=Ir();m()[c>>2>>>0]=x.length;var E=0;return x.forEach(function(V){E+=V.length+1}),m()[b>>2>>>0]=E,0}function Er(c){return k?ke(21,1,c):52}function Pr(c,b,x,E){return k?ke(22,1,c,b,x,E):52}function Rr(c,b,x,E,V){return k?ke(23,1,c,b,x,E,V):70}var $n=[null,[],[]];function kr(c,b,x,E){if(k)return ke(24,1,c,b,x,E);b>>>=0,x>>>=0,E>>>=0;for(var V=0,F=0;F<x;F++){var J=m()[b>>2>>>0],pe=m()[b+4>>2>>>0];b+=8;for(var de=0;de<pe;de++){var ce=d()[J+de>>>0],me=$n[c];ce===0||ce===10?((c===1?Ce:H)(Yt(me,0)),me.length=0):me.push(ce)}V+=pe}return m()[E>>2>>>0]=V,0}var Br=[31,29,31,30,31,30,31,31,30,31,30,31],Mr=[31,28,31,30,31,30,31,31,30,31,30,31];function xn(c){var b=Array(Qt(c)+1);return vr(c,b,0,b.length),b}var Sn=(c,b)=>{e().set(c,b>>>0)};function jr(c,b,x,E){function V(N,be,Te){for(N=typeof N=="number"?N.toString():N||"";N.length<be;)N=Te[0]+N;return N}function F(N,be){return V(N,be,"0")}function J(N,be){function Te(Jr){return 0>Jr?-1:0<Jr?1:0}var wt;return(wt=Te(N.getFullYear()-be.getFullYear()))===0&&(wt=Te(N.getMonth()-be.getMonth()))===0&&(wt=Te(N.getDate()-be.getDate())),wt}function pe(N){switch(N.getDay()){case 0:return new Date(N.getFullYear()-1,11,29);case 1:return N;case 2:return new Date(N.getFullYear(),0,3);case 3:return new Date(N.getFullYear(),0,2);case 4:return new Date(N.getFullYear(),0,1);case 5:return new Date(N.getFullYear()-1,11,31);case 6:return new Date(N.getFullYear()-1,11,30)}}function de(N){var be=N.Za;for(N=new Date(new Date(N.$a+1900,0,1).getTime());0<be;){var Te=N.getMonth(),wt=(It(N.getFullYear())?Br:Mr)[Te];if(be>wt-N.getDate())be-=wt-N.getDate()+1,N.setDate(1),11>Te?N.setMonth(Te+1):(N.setMonth(0),N.setFullYear(N.getFullYear()+1));else{N.setDate(N.getDate()+be);break}}return Te=new Date(N.getFullYear()+1,0,4),be=pe(new Date(N.getFullYear(),0,4)),Te=pe(Te),0>=J(be,N)?0>=J(Te,N)?N.getFullYear()+1:N.getFullYear():N.getFullYear()-1}c>>>=0,b>>>=0,x>>>=0,E>>>=0;var ce=l()[E+40>>2>>>0];E={Kb:l()[E>>2>>>0],Jb:l()[E+4>>2>>>0],cb:l()[E+8>>2>>>0],ib:l()[E+12>>2>>>0],eb:l()[E+16>>2>>>0],$a:l()[E+20>>2>>>0],Wa:l()[E+24>>2>>>0],Za:l()[E+28>>2>>>0],Tb:l()[E+32>>2>>>0],Ib:l()[E+36>>2>>>0],Lb:ce?dt(ce):""},x=dt(x),ce={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var me in ce)x=x.replace(new RegExp(me,"g"),ce[me]);var xe="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),_e="January February March April May June July August September October November December".split(" ");ce={"%a":N=>xe[N.Wa].substring(0,3),"%A":N=>xe[N.Wa],"%b":N=>_e[N.eb].substring(0,3),"%B":N=>_e[N.eb],"%C":N=>F((N.$a+1900)/100|0,2),"%d":N=>F(N.ib,2),"%e":N=>V(N.ib,2," "),"%g":N=>de(N).toString().substring(2),"%G":N=>de(N),"%H":N=>F(N.cb,2),"%I":N=>(N=N.cb,N==0?N=12:12<N&&(N-=12),F(N,2)),"%j":N=>{for(var be=0,Te=0;Te<=N.eb-1;be+=(It(N.$a+1900)?Br:Mr)[Te++]);return F(N.ib+be,3)},"%m":N=>F(N.eb+1,2),"%M":N=>F(N.Jb,2),"%n":()=>`\n`,"%p":N=>0<=N.cb&&12>N.cb?"AM":"PM","%S":N=>F(N.Kb,2),"%t":()=>"	","%u":N=>N.Wa||7,"%U":N=>F(Math.floor((N.Za+7-N.Wa)/7),2),"%V":N=>{var be=Math.floor((N.Za+7-(N.Wa+6)%7)/7);if(2>=(N.Wa+371-N.Za-2)%7&&be++,be)be==53&&(Te=(N.Wa+371-N.Za)%7,Te==4||Te==3&&It(N.$a)||(be=1));else{be=52;var Te=(N.Wa+7-N.Za-1)%7;(Te==4||Te==5&&It(N.$a%400-1))&&be++}return F(be,2)},"%w":N=>N.Wa,"%W":N=>F(Math.floor((N.Za+7-(N.Wa+6)%7)/7),2),"%y":N=>(N.$a+1900).toString().substring(2),"%Y":N=>N.$a+1900,"%z":N=>{N=N.Ib;var be=0<=N;return N=Math.abs(N)/60,(be?"+":"-")+("0000"+(N/60*100+N%60)).slice(-4)},"%Z":N=>N.Lb,"%%":()=>"%"},x=x.replace(/%%/g,"\\0\\0");for(me in ce)x.includes(me)&&(x=x.replace(new RegExp(me,"g"),ce[me](E)));return x=x.replace(/\\0\\0/g,"%"),me=xn(x),me.length>b?0:(Sn(me,c),me.length-1)}function jt(c){try{c()}catch(b){Ye(b)}}function _n(c){var b={},x;for(x in c)(function(E){var V=c[E];b[E]=typeof V=="function"?function(){Dt.push(E);try{return V.apply(null,arguments)}finally{Ie||(Dt.pop()===E||Ye(),it&&pt===1&&Dt.length===0&&(pt=0,Ge+=1,jt(qr),typeof Fibers<"u"&&Fibers.Ub()))}}:V})(x);return b}var pt=0,it=null,Dr=0,Dt=[],Wr={},zr={},An=0,ir=null,In=[];function Tn(){return new Promise((c,b)=>{ir={resolve:c,reject:b}})}function On(){var c=or(65548),b=c+12;m()[c>>2>>>0]=b,m()[c+4>>2>>>0]=b+65536,b=Dt[0];var x=Wr[b];return x===void 0&&(x=An++,Wr[b]=x,zr[x]=b),b=x,l()[c+8>>2>>>0]=b,c}function En(){var c=l()[it+8>>2>>>0];return c=ae[zr[c]],--Ge,c()}function Pn(c){if(!Ie){if(pt===0){var b=!1,x=!1;c((E=0)=>{if(!Ie&&(Dr=E,b=!0,x)){pt=2,jt(()=>Yr(it)),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),E=!1;try{var V=En()}catch(pe){V=pe,E=!0}var F=!1;if(!it){var J=ir;J&&(ir=null,(E?J.reject:J.resolve)(V),F=!0)}if(E&&!F)throw V}}),x=!0,b||(pt=1,it=On(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),jt(()=>Kr(it)))}else pt===2?(pt=0,jt(Xr),Gr(it),it=null,In.forEach(E=>z(E))):Ye(`invalid state: ${pt}`);return Dr}}function Rn(c){return Pn(b=>{c().then(b)})}he.gb();var kn=[null,Xt,fn,ft,br,Bt,Jt,hn,gn,yn,bn,vn,wn,Zt,wr,W,At,xr,Sr,Tr,Or,Er,Pr,Rr,kr],Bn={r:function(c,b,x){return Rn(async()=>{await u.xb(c,b,x)})},b:function(c,b,x){throw c>>>=0,new pn(c).gb(b>>>0,x>>>0),kt=c,si++,kt},O:function(c){Vr(c>>>0,!R,1,!P,131072,!1),he.lb()},l:function(c){c>>>=0,k?postMessage({cmd:"cleanupThread",thread:c}):hr(c)},I:nt,i:br,U:Bt,E:Jt,G:hn,V:gn,S:yn,K:bn,R:vn,p:wn,F:Zt,C:wr,T:W,D:At,q:()=>!0,A:function(c,b){c>>>=0,c==b>>>0?setTimeout(()=>Mt()):k?postMessage({targetThread:c,cmd:"checkMailbox"}):(c=he.Qa[c])&&c.postMessage({cmd:"checkMailbox"})},M:function(){return-1},N:D,X:function(c){T&&he.Qa[c>>>0].ref()},u:function(c,b,x){c=b+2097152>>>0<4194305-!!c?(c>>>0)+4294967296*b:NaN,x>>>=0,c=new Date(1e3*c),l()[x>>2>>>0]=c.getUTCSeconds(),l()[x+4>>2>>>0]=c.getUTCMinutes(),l()[x+8>>2>>>0]=c.getUTCHours(),l()[x+12>>2>>>0]=c.getUTCDate(),l()[x+16>>2>>>0]=c.getUTCMonth(),l()[x+20>>2>>>0]=c.getUTCFullYear()-1900,l()[x+24>>2>>>0]=c.getUTCDay(),c=(c.getTime()-Date.UTC(c.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,l()[x+28>>2>>>0]=c},v:function(c,b,x){c=b+2097152>>>0<4194305-!!c?(c>>>0)+4294967296*b:NaN,x>>>=0,c=new Date(1e3*c),l()[x>>2>>>0]=c.getSeconds(),l()[x+4>>2>>>0]=c.getMinutes(),l()[x+8>>2>>>0]=c.getHours(),l()[x+12>>2>>>0]=c.getDate(),l()[x+16>>2>>>0]=c.getMonth(),l()[x+20>>2>>>0]=c.getFullYear()-1900,l()[x+24>>2>>>0]=c.getDay(),b=(It(c.getFullYear())?Cr:$r)[c.getMonth()]+c.getDate()-1|0,l()[x+28>>2>>>0]=b,l()[x+36>>2>>>0]=-(60*c.getTimezoneOffset()),b=new Date(c.getFullYear(),6,1).getTimezoneOffset();var E=new Date(c.getFullYear(),0,1).getTimezoneOffset();c=(b!=E&&c.getTimezoneOffset()==Math.min(E,b))|0,l()[x+32>>2>>>0]=c},w:function(c){c>>>=0;var b=new Date(l()[c+20>>2>>>0]+1900,l()[c+16>>2>>>0],l()[c+12>>2>>>0],l()[c+8>>2>>>0],l()[c+4>>2>>>0],l()[c>>2>>>0],0),x=l()[c+32>>2>>>0],E=b.getTimezoneOffset(),V=new Date(b.getFullYear(),6,1).getTimezoneOffset(),F=new Date(b.getFullYear(),0,1).getTimezoneOffset(),J=Math.min(F,V);return 0>x?l()[c+32>>2>>>0]=+(V!=F&&J==E):0<x!=(J==E)&&(V=Math.max(F,V),b.setTime(b.getTime()+6e4*((0<x?J:V)-E))),l()[c+24>>2>>>0]=b.getDay(),x=(It(b.getFullYear())?Cr:$r)[b.getMonth()]+b.getDate()-1|0,l()[c+28>>2>>>0]=x,l()[c>>2>>>0]=b.getSeconds(),l()[c+4>>2>>>0]=b.getMinutes(),l()[c+8>>2>>>0]=b.getHours(),l()[c+12>>2>>>0]=b.getDate(),l()[c+16>>2>>>0]=b.getMonth(),l()[c+20>>2>>>0]=b.getYear(),c=b.getTime()/1e3,Fr((bt=c,1<=+Math.abs(bt)?0<bt?+Math.floor(bt/4294967296)>>>0:~~+Math.ceil((bt-+(~~bt>>>0))/4294967296)>>>0:0)),c>>>0},s:xr,t:Sr,z:function(c,b,x){function E(ce){return(ce=ce.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?ce[1]:"GMT"}c>>>=0,b>>>=0,x>>>=0;var V=new Date().getFullYear(),F=new Date(V,0,1),J=new Date(V,6,1);V=F.getTimezoneOffset();var pe=J.getTimezoneOffset(),de=Math.max(V,pe);m()[c>>2>>>0]=60*de,l()[b>>2>>>0]=+(V!=pe),c=E(F),b=E(J),c=_r(c),b=_r(b),pe<V?(m()[x>>2>>>0]=c,m()[x+4>>2>>>0]=b):(m()[x>>2>>>0]=b,m()[x+4>>2>>>0]=c)},d:()=>{Ye("")},c:function(c,b,x){return c>>>=0,b=Ar(b>>>0,x>>>0),vt[c].apply(null,b)},k:function(c,b,x){return c>>>=0,b=Ar(b>>>0,x>>>0),vt[c].apply(null,b)},m:function(){},j:function(){return Date.now()},W:()=>{throw Ge+=1,"unwind"},B:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:function(){return T?(Ra(),cr(Pa)).cpus().length:navigator.hardwareConcurrency},L:function(c,b,x,E){for(he.Pb=b>>>0,tr.length=x,b=E>>>0>>3,E=0;E<x;E++)tr[E]=h()[b+E>>>0];return(0>c?vt[-c-1]:kn[c]).apply(null,tr)},y:function(c){c>>>=0;var b=d().length;if(c<=b||4294901760<c)return!1;for(var x=1;4>=x;x*=2){var E=b*(1+.2/x);E=Math.min(E,c+100663296);var V=Math;E=Math.max(c,E);e:{V=V.min.call(V,4294901760,E+(65536-E%65536)%65536)-ue.buffer.byteLength+65535>>>16;try{ue.grow(V),ee();var F=1;break e}catch{}F=void 0}if(F)return!0}return!1},P:Tr,Q:Or,H:yr,h:Er,o:Pr,x:Rr,n:kr,a:ue||u.wasmMemory,J:jr,e:function(c,b,x,E){return jr(c>>>0,b>>>0,x>>>0,E>>>0)}};(function(){function c(x,E){return x=x.exports,x=_n(x),ae=x=Mn(x),he.mb.push(ae.Da),et.unshift(ae.Y),Ze=E,Et(),x}var b={a:Bn};if(Ot(),u.instantiateWasm)try{return u.instantiateWasm(b,c)}catch(x){H("Module.instantiateWasm callback failed with error: "+x),_(x)}return mr(b,function(x){c(x.instance,x.module)}).catch(_),{}})(),u._OrtInit=(c,b)=>(u._OrtInit=ae.Z)(c,b),u._OrtGetLastError=(c,b)=>(u._OrtGetLastError=ae._)(c,b),u._OrtCreateSessionOptions=(c,b,x,E,V,F,J,pe,de,ce)=>(u._OrtCreateSessionOptions=ae.$)(c,b,x,E,V,F,J,pe,de,ce),u._OrtAppendExecutionProvider=(c,b)=>(u._OrtAppendExecutionProvider=ae.aa)(c,b),u._OrtAddFreeDimensionOverride=(c,b,x)=>(u._OrtAddFreeDimensionOverride=ae.ba)(c,b,x),u._OrtAddSessionConfigEntry=(c,b,x)=>(u._OrtAddSessionConfigEntry=ae.ca)(c,b,x),u._OrtReleaseSessionOptions=c=>(u._OrtReleaseSessionOptions=ae.da)(c),u._OrtCreateSession=(c,b,x)=>(u._OrtCreateSession=ae.ea)(c,b,x),u._OrtReleaseSession=c=>(u._OrtReleaseSession=ae.fa)(c),u._OrtGetInputOutputCount=(c,b,x)=>(u._OrtGetInputOutputCount=ae.ga)(c,b,x),u._OrtGetInputName=(c,b)=>(u._OrtGetInputName=ae.ha)(c,b),u._OrtGetOutputName=(c,b)=>(u._OrtGetOutputName=ae.ia)(c,b),u._OrtFree=c=>(u._OrtFree=ae.ja)(c),u._OrtCreateTensor=(c,b,x,E,V,F)=>(u._OrtCreateTensor=ae.ka)(c,b,x,E,V,F),u._OrtGetTensorData=(c,b,x,E,V)=>(u._OrtGetTensorData=ae.la)(c,b,x,E,V),u._OrtReleaseTensor=c=>(u._OrtReleaseTensor=ae.ma)(c),u._OrtCreateRunOptions=(c,b,x,E)=>(u._OrtCreateRunOptions=ae.na)(c,b,x,E),u._OrtAddRunConfigEntry=(c,b,x)=>(u._OrtAddRunConfigEntry=ae.oa)(c,b,x),u._OrtReleaseRunOptions=c=>(u._OrtReleaseRunOptions=ae.pa)(c),u._OrtCreateBinding=c=>(u._OrtCreateBinding=ae.qa)(c),u._OrtBindInput=(c,b,x)=>(u._OrtBindInput=ae.ra)(c,b,x),u._OrtBindOutput=(c,b,x,E)=>(u._OrtBindOutput=ae.sa)(c,b,x,E),u._OrtClearBoundOutputs=c=>(u._OrtClearBoundOutputs=ae.ta)(c),u._OrtReleaseBinding=c=>(u._OrtReleaseBinding=ae.ua)(c),u._OrtRunWithBinding=(c,b,x,E,V)=>(u._OrtRunWithBinding=ae.va)(c,b,x,E,V),u._OrtRun=(c,b,x,E,V,F,J,pe)=>(u._OrtRun=ae.wa)(c,b,x,E,V,F,J,pe),u._OrtEndProfiling=c=>(u._OrtEndProfiling=ae.xa)(c),u._JsepOutput=(c,b,x)=>(u._JsepOutput=ae.ya)(c,b,x),u._JsepGetNodeName=c=>(u._JsepGetNodeName=ae.za)(c);var Wt=u._pthread_self=()=>(Wt=u._pthread_self=ae.Aa)(),or=u._malloc=c=>(or=u._malloc=ae.Ba)(c),Gr=u._free=c=>(Gr=u._free=ae.Ca)(c);u.__emscripten_tls_init=()=>(u.__emscripten_tls_init=ae.Da)();var Vr=u.__emscripten_thread_init=(c,b,x,E,V,F)=>(Vr=u.__emscripten_thread_init=ae.Fa)(c,b,x,E,V,F);u.__emscripten_thread_crashed=()=>(u.__emscripten_thread_crashed=ae.Ga)();var Ur=(c,b,x,E)=>(Ur=ae.Ha)(c,b,x,E),ar=c=>(ar=ae.Ia)(c),sr=u.__emscripten_thread_exit=c=>(sr=u.__emscripten_thread_exit=ae.Ja)(c),Nr=u.__emscripten_check_mailbox=()=>(Nr=u.__emscripten_check_mailbox=ae.Ka)(),Fr=c=>(Fr=ae.La)(c),Hr=(c,b)=>(Hr=ae.Ma)(c,b),ur=()=>(ur=ae.Na)(),zt=c=>(zt=ae.Oa)(c),lr=c=>(lr=ae.Pa)(c),Lr=u.dynCall_ii=(c,b)=>(Lr=u.dynCall_ii=ae.Ra)(c,b),Kr=c=>(Kr=ae.Sa)(c),qr=()=>(qr=ae.Ta)(),Yr=c=>(Yr=ae.Ua)(c),Xr=()=>(Xr=ae.Va)();u.___start_em_js=922382,u.___stop_em_js=922543;function Mn(c){c=Object.assign({},c);var b=E=>()=>E()>>>0,x=E=>V=>E(V)>>>0;return c.__errno_location=b(c.__errno_location),c.pthread_self=b(c.pthread_self),c.malloc=x(c.malloc),c.stackSave=b(c.stackSave),c.stackAlloc=x(c.stackAlloc),c}u.keepRuntimeAlive=Me,u.wasmMemory=ue,u.stackAlloc=lr,u.stackSave=ur,u.stackRestore=zt,u.UTF8ToString=dt,u.stringToUTF8=mn,u.lengthBytesUTF8=Qt,u.ExitStatus=Pt,u.PThread=he;var Gt;ut=function c(){Gt||Qr(),Gt||(ut=c)};function Qr(){function c(){if(!Gt&&(Gt=!0,u.calledRun=!0,!Ie)&&(k||Rt(et),w(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!k)){if(u.postRun)for(typeof u.postRun=="function"&&(u.postRun=[u.postRun]);u.postRun.length;){var b=u.postRun.shift();tt.unshift(b)}Rt(tt)}}if(!(0<rt))if(k)w(u),k||Rt(et),startWorker(u);else{if(u.preRun)for(typeof u.preRun=="function"&&(u.preRun=[u.preRun]);u.preRun.length;)Oe.unshift(u.preRun.shift());Rt(Oe),0<rt||(u.setStatus?(u.setStatus("Running..."),setTimeout(function(){setTimeout(function(){u.setStatus("")},1),c()},1)):c())}}if(u.preInit)for(typeof u.preInit=="function"&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return Qr(),r.ready}})();typeof Ba=="object"&&typeof mi=="object"?mi.exports=ka:typeof define=="function"&&define.amd&&define([],()=>ka)});var ja=Zr((Fh,Ip)=>{Ip.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\\n\'});var yi,tn,rn,zn,nn,Ua,bi,Xe=oe(()=>{"use strict";yi=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},tn=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},rn=t=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][t],zn=t=>{switch(t){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}},nn=t=>{switch(t){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${t}`)}},Ua=t=>t==="float32"||t==="int32"||t==="int64"||t==="bool"||t==="float16"||t==="uint32",bi=t=>{switch(t){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${t}`)}}});var jp,Dp,Na,Fa,Ha,Wp,ze,Tt=oe(()=>{"use strict";Xe();jp=["V","I","W","E","F"],Dp=(t,r)=>{console.log(`[${jp[t]},${new Date().toISOString()}]${r}`)},Ha=(t,r)=>{Na=t,Fa=r},Wp=(t,r)=>{let e=nn(t),d=nn(Na);e>=d&&Dp(e,typeof r=="function"?r():r)},ze=(...t)=>{Fa&&Wp(...t)}});var La,Ka=oe(()=>{"use strict";Xe();La=(t,r)=>new(zn(r))(t)});var qa=oe(()=>{"use strict"});var Gn,zp,Ya,wi,vi,Xa,Qa=oe(()=>{"use strict";Tt();qa();Gn=t=>Math.ceil(t/16)*16,zp=1,Ya=()=>zp++,wi=async(t,r,e,d)=>{let l=Gn(e),m=t.device.createBuffer({size:l,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let h=t.getCommandEncoder();t.endComputePass(),h.copyBufferToBuffer(r,0,m,0,l),t.flush(),await m.mapAsync(GPUMapMode.READ);let u=m.getMappedRange();if(d){let w=d();return w.set(new Uint8Array(u,0,e)),w}else return new Uint8Array(u.slice(0,e))}finally{m.destroy()}},vi=class{constructor(r){this.backend=r;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(r,e){let d=e.buffer,l=e.byteOffset,m=e.byteLength,h=Gn(m),u=this.storageCache.get(r);if(!u)throw new Error("gpu data for uploading does not exist");if(u.originalSize!==m)throw new Error(`inconsistent data size. gpu data size=${u.originalSize}, data size=${m}`);let w=this.backend.device.createBuffer({mappedAtCreation:!0,size:h,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),_=w.getMappedRange();new Uint8Array(_).set(new Uint8Array(d,l,m)),w.unmap();let O=this.backend.getCommandEncoder();this.backend.endComputePass(),O.copyBufferToBuffer(w,0,u.gpuData.buffer,0,h),ze("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${r})`),this.buffersForUploadingPending.push(w)}memcpy(r,e){let d=this.storageCache.get(r);if(!d)throw new Error("source gpu data for memcpy does not exist");let l=this.storageCache.get(e);if(!l)throw new Error("destination gpu data for memcpy does not exist");if(d.originalSize!==l.originalSize)throw new Error("inconsistent source and destination gpu data size");let m=Gn(d.originalSize),h=this.backend.getCommandEncoder();this.backend.endComputePass(),h.copyBufferToBuffer(d.gpuData.buffer,0,l.gpuData.buffer,0,m)}registerExternalBuffer(r,e,d){let l;if(d){if(l=this.externalBuffers.get(d),l===void 0)throw new Error("previous buffer is not registered");if(r===d)return ze("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${l}, buffer is the same, skip.`),l;this.externalBuffers.delete(d)}else l=Ya();return this.storageCache.set(l,{gpuData:{id:l,type:0,buffer:r},originalSize:e}),this.externalBuffers.set(r,l),ze("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${l}, registered.`),l}unregisterExternalBuffer(r){let e=this.externalBuffers.get(r);e!==void 0&&(this.storageCache.delete(e),this.externalBuffers.delete(r),ze("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${e}`))}create(r,e=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let d=Gn(r),l,m=(e&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,h=(e&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(m||h){let w=m?this.freeBuffers:this.freeUniformBuffers,_=w.get(d);_||(_=[],w.set(d,_)),_.length>0?l=_.pop():l=this.backend.device.createBuffer({size:d,usage:e})}else l=this.backend.device.createBuffer({size:d,usage:e});let u={id:Ya(),type:0,buffer:l};return this.storageCache.set(u.id,{gpuData:u,originalSize:r}),ze("verbose",()=>`[WebGPU] GpuDataManager.create(size=${r}) => id=${u.id}`),u}get(r){return this.storageCache.get(r)?.gpuData}release(r){let e=this.storageCache.get(r);if(!e)throw new Error("releasing data does not exist");return ze("verbose",()=>`[WebGPU] GpuDataManager.release(id=${r}), gpuDataId=${e.gpuData.id}`),this.storageCache.delete(r),this.buffersPending.push(e.gpuData.buffer),e.originalSize}async download(r,e){let d=this.storageCache.get(r);if(!d)throw new Error("data does not exist");await wi(this.backend,d.gpuData.buffer,d.originalSize,e)}refreshPendingBuffers(){for(let r of this.buffersForUploadingPending)r.destroy();this.buffersForUploadingPending=[];for(let r of this.buffersPending)(r.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(r.size).push(r):(r.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(r.size).push(r):r.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(r=>{r.forEach(e=>{e.destroy()})}),this.freeUniformBuffers.forEach(r=>{r.forEach(e=>{e.destroy()})}),this.storageCache.forEach(r=>{r.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},Xa=(...t)=>new vi(...t)});var Ci,ye,Ne=oe(()=>{"use strict";Ci=class{constructor(r){Object.assign(this,r)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(r=>`${this[r]}`).join(";")),this._cacheKey}},ye=t=>new Ci(t)});var $i,Ct,Y,Nt,Vn,Un,Nn,Ae=oe(()=>{"use strict";$i=class{static calcMatMulShape(r,e){return r[1]!==e[0]?void 0:[r[0],e[1]]}},Ct=class{static calcShape(r,e,d=!1){let l=r.length,m=e.length;if(l===0)return e;if(m===0)return r;let h=Math.max(r.length,e.length),u=new Array(h);if(d){if(l<2||m<2)return;let w=$i.calcMatMulShape([r[l-2],r[l-1]],[e[m-2],e[m-1]]);if(w===void 0)return;[u[h-2],u[h-1]]=w}for(let w=d?3:1;w<=h;w++){let _=l-w<0?1:r[l-w],O=m-w<0?1:e[m-w];if(_!==O&&_>1&&O>1)return;u[h-w]=Math.max(_,O)}return u}static isValidBroadcast(r,e){let d=r.length,l=e.length;if(d>l)return!1;for(let m=1;m<=d;m++)if(r[d-m]!==1&&r[d-m]!==e[l-m])return!1;return!0}},Y=class t{static size(r){return t.getSizeFromDimensionRange(r,0,r.length)}static sizeFromDimension(r,e){if(e<0||e>r.length)throw new Error(`invalid dimension of ${e} for sizeFromDimension as Tensor has ${r.length} dimensions.`);return t.getSizeFromDimensionRange(r,e,r.length)}static sizeToDimension(r,e){if(e<0||e>r.length)throw new Error(`invalid dimension of ${e} for sizeToDimension as Tensor has ${r.length} dimensions.`);return t.getSizeFromDimensionRange(r,0,e)}static getSizeFromDimensionRange(r,e,d){let l=1;for(let m=e;m<d;m++){if(r[m]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");l*=r[m]}return l}static computeStrides(r){let e=r.length;if(e===0)return[];if(e===1)return[1];let d=new Array(e);d[e-1]=1,d[e-2]=r[e-1];for(let l=e-3;l>=0;--l)d[l]=d[l+1]*r[l+1];return d}static normalizeAxis(r,e){if(r<-e&&r>=e)throw new Error("unsupported axis for this operation.");return r<0?r+e:r}static normalizeAxes(r,e){return r.map(d=>this.normalizeAxis(d,e??r.length))}static sortBasedOnPerm(r,e){return e?e.map(d=>r[d]):r.slice().reverse()}static padShape(r,e){let d=r.length;return r.map((l,m)=>l+e[m]+e[m+d])}static areEqual(r,e){return r.length!==e.length?!1:r.every((d,l)=>d===e[l])}},Nt=class t{static adjustPoolAttributes(r,e,d,l,m,h){if(!r&&d.length!==e.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(r)for(let u=0;u<e.length-2;u++)u>=d.length?d.push(e[u+2]):d[u]=e[u+2];for(let u=0;u<d.length;u++)if(u<l.length){if(l[u]<0)throw new Error("strides should be greater than or equal to 1")}else l.push(1);for(let u=0;u<d.length;u++)if(u<m.length){if(m[u]<0)throw new Error("dilations should be greater than or equal to 1")}else m.push(1);for(let u=0;u<d.length*2;u++)if(u<h.length){if(h[u]<0)throw new Error("pad should be greater than or equal to 1")}else h.push(0);for(let u=0;u<d.length;u++){if(d[u]<=0)throw new Error("kernel shapes need to be greater than 0");if(h[u]>=d[u]||h[u+d.length]>=d[u])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(r,e,d,l,m,h,u){if(u){if(m.length!==2*(r.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(e.length!==r.length-2)throw new Error("length of strides should be the length of data dimensions");if(l.length!==r.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let w=0;w<r.length-2;w++)t.adjustPadAndReturnShape(r[w+(h?1:2)],e[w],d[w],l[w],m,w,w+r.length-2,u)}}static computePoolOutputShape(r,e,d,l,m,h,u){if(e.length<=0)throw new Error("input shape must be of size greater than 0");let w=[e[0],e[1]];return t.computeShapeHelper(r,e,w,d,l,m,h,u),w}static computeConvOutputShape(r,e,d,l,m,h,u){if(r.length<=0||e.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let w=[r[0],e[0]];return t.computeShapeHelper(!1,r,w,d,l,m,h,u),w}static computeShapeHelper(r,e,d,l,m,h,u,w){if(r)for(let _=0;_<e.length-2;_++)d.push(1);else for(let _=0;_<e.length-2;_++)d.push(t.adjustPadAndReturnShape(e[_+2],l[_],m[_],h[_],u,_,_+e.length-2,w))}static adjustPadAndReturnShape(r,e,d,l,m,h,u,w){let _=d*(l-1)+1;if(w&&w!=="NOTSET")switch(w){case"VALID":return m[h]=0,m[u]=0,Math.floor((r-_)/e+1);case"SAME_LOWER":case"SAME_UPPER":if(d!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let j=((r+e-1)/e-1)*e+l-r;return m[h]=Math.floor(w==="SAME_LOWER"?(j+1)/2:j/2),m[u]=j-m[h],Math.floor((r+j-l)/e+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((r+m[h]+m[u]-_)/e+1)}},Vn=class{static getShapeOfGemmResult(r,e,d,l,m){if(r.length!==2||d.length!==2)throw new Error("shape need to be of size 2");let h,u,w;e?(h=r[1],u=r[0]):(h=r[0],u=r[1]);let _=-1;if(l?(w=d[0],_=1):(w=d[1],_=0),d[_]!==u)throw new Error("dimension mismatch");if(h<=0||w<=0||u<=0)throw new Error("invalid shape specified");if(m&&!Ct.isValidBroadcast(m,[h,w]))throw new Error("gemm: invalid bias shape for broadcast");return[h,w,u]}},Un=-34028234663852886e22,Nn=34028234663852886e22});var Gp,Ja,Fe,Si,Ft,mt,Ht,dr,Za,ne,fe,xi,es,_i,Pe=oe(()=>{"use strict";Xe();Ae();Gp=64,Ja=(t,r)=>{if(r===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(t){case 10:return r>1?`vec${r}<f16>`:"f16";case 1:return r>1?`vec${r}<f32>`:"f32";case 6:return r>1?`vec${r}<i32>`:"i32";case 12:return r>1?`vec${r}<u32>`:"u32";case 7:if(r>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(r>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(r!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${t}`)}},Fe=(t,r=1)=>{let e=Ja(t,r);return typeof e=="string"?e:e[0]},Si=t=>[{type:"uint32",data:t},{type:"uint32",data:Y.computeStrides(t)}],Ft=t=>t%4===0?4:t%2===0?2:1,mt=(t="f32",r,e="0")=>!r||r===1?`${t}(${e})`:`vec${r}<${t}>(${e})`,Ht=(t,r,e)=>t==="f32"?e:r===1?`f32(${e})`:`vec${r}f(${e})`,dr=(t,r)=>r===4?`(${t}.x + ${t}.y + ${t}.z + ${t}.w)`:r===2?`(${t}.x + ${t}.y)`:r===3?`(${t}.x + ${t}.y + ${t}.z)`:t,Za=(t,r,e,d,l)=>{let m=typeof e=="number",h=m?e:e.length,u=[...new Array(h).keys()],w=h<2?"u32":h<=4?`vec${h}<u32>`:`array<u32, ${h}>`,_=Ja(r,l),O=typeof _=="string"?_:_[1],j=typeof _=="string"?_:_[0],B={indices:w,value:O,storage:j,tensor:r},P=ee=>typeof ee=="string"?ee:`${ee}u`,R={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},T=m?"uniforms.":"",k=`${T}${t}_shape`,U=`${T}${t}_strides`,K="";for(let ee=0;ee<h-1;ee++)K+=`\n    let dim${ee} = current / ${U}[${ee}];\n    let rest${ee} = current % ${U}[${ee}];\n    indices[${ee}] = dim${ee};\n    current = rest${ee};\n    `;K+=`indices[${h-1}] = current;`;let Q=h<2?"":`\n  fn o2i_${t}(offset: u32) -> ${B.indices} {\n    var indices: ${B.indices};\n    var current = offset;\n    ${K}\n    return indices;\n  }`,L=ee=>(R.offsetToIndices=!0,h<2?ee:`o2i_${t}(${ee})`),X=[];if(h>=2)for(let ee=h-1;ee>=0;ee--)X.push(`${U}[${ee}] * (indices[${ee}])`);let A=h<2?"":`\n  fn i2o_${t}(indices: ${B.indices}) -> u32 {\n    return ${X.join("+")};\n  }`,Z=ee=>(R.indicesToOffset=!0,h<2?ee:`i2o_${t}(${ee})`),re=(...ee)=>h===0?"0u":`${B.indices}(${ee.map(P).join(",")})`,ie=(ee,$e)=>h<2?`${ee}`:`${ee}[${$e}]`,Ce=(ee,$e,Oe)=>h<2?`${ee}=${Oe};`:`${ee}[${$e}]=${Oe};`,H={},le=(ee,$e)=>{R.broadcastedIndicesToOffset=!0;let Oe=`${$e.name}broadcastedIndicesTo${t}Offset`;if(Oe in H)return`${Oe}(${ee})`;let et=[];for(let tt=h-1;tt>=0;tt--){let Ge=$e.indicesGet("outputIndices",tt+$e.rank-h);et.push(`${ie(U,tt)} * (${Ge} % ${ie(k,tt)})`)}return H[Oe]=`fn ${Oe}(outputIndices: ${$e.type.indices}) -> u32 {\n             return ${et.length>0?et.join("+"):"0u"};\n           }`,`${Oe}(${ee})`},Be=(ee,$e)=>(()=>{if(B.storage===B.value)return`${t}[${ee}]=${$e};`;if(B.storage==="vec2<u32>"&&B.value==="i32")return`${t}[${ee}]=vec2<u32>(u32(${$e}), select(0u, 0xFFFFFFFFu, ${$e} < 0));`;if(B.storage==="vec2<u32>"&&B.value==="u32")return`${t}[${ee}]=vec2<u32>(u32(${$e}), 0u);`;if(B.storage==="u32"&&B.value==="vec4<bool>")return`${t}[${ee}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${$e}));`;throw new Error(`not supported combination of storage type ${B.storage} and value type ${B.value} yet`)})(),ue=ee=>(()=>{if(B.storage===B.value)return`${t}[${ee}]`;if(B.storage==="vec2<u32>"&&B.value==="i32")return`i32(${t}[${ee}].x)`;if(B.storage==="vec2<u32>"&&B.value==="u32")return`u32(${t}[${ee}].x)`;if(B.storage==="u32"&&B.value==="vec4<bool>")return`vec4<bool>(bool(${t}[${ee}] & 0xFFu), bool(${t}[${ee}] & 0xFF00u), bool(${t}[${ee}] & 0xFF0000u), bool(${t}[${ee}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${B.storage} and value type ${B.value} yet`)})(),ae=h<2?"":`\n  fn get_${t}ByIndices(indices: ${B.indices}) -> ${O} {\n    return ${ue(`i2o_${t}(indices)`)};\n  }`,Ze=h<2?"":(()=>{let ee=u.map(Oe=>`d${Oe}: u32`).join(", "),$e=u.map(Oe=>`d${Oe}`).join(", ");return`\n  fn get_${t}(${ee}) -> ${O} {\n    return get_${t}ByIndices(${re($e)});\n  }`})(),Ie=(...ee)=>{if(ee.length!==h)throw new Error(`indices length must be ${h}`);let $e=ee.map(P).join(",");return h===0?ue("0u"):h===1?ue($e[0]):(R.get=!0,R.getByIndices=!0,R.indicesToOffset=!0,`get_${t}(${$e})`)},He=ee=>h<2?ue(ee):(R.getByIndices=!0,R.indicesToOffset=!0,`get_${t}ByIndices(${ee})`),Ee=h<2?"":`\n  fn set_${t}ByIndices(indices: ${B.indices}, value: ${O}) {\n    ${Be(`i2o_${t}(indices)`,"value")}\n  }`,qe=h<2?"":(()=>{let ee=u.map(Oe=>`d${Oe}: u32`).join(", "),$e=u.map(Oe=>`d${Oe}`).join(", ");return`\n  fn set_${t}(${ee}, value: ${O}) {\n    set_${t}ByIndices(${re($e)}, value);\n  }`})();return{impl:()=>{let ee=[];return m||(ee.push(`const ${k} = ${B.indices}(${e.join(",")});`),ee.push(`const ${U} = ${B.indices}(${Y.computeStrides(e).join(",")});`)),R.offsetToIndices&&ee.push(Q),R.indicesToOffset&&ee.push(A),R.broadcastedIndicesToOffset&&Object.values(H).forEach($e=>ee.push($e)),R.set&&ee.push(qe),R.setByIndices&&ee.push(Ee),R.get&&ee.push(Ze),R.getByIndices&&ee.push(ae),ee.join(`\n`)},type:B,offsetToIndices:L,indicesToOffset:Z,broadcastedIndicesToOffset:le,indices:re,indicesGet:ie,indicesSet:Ce,set:(...ee)=>{if(ee.length!==h+1)throw new Error(`indices length must be ${h}`);let $e=ee[h];if(typeof $e!="string")throw new Error("value must be string");let Oe=ee.slice(0,h).map(P).join(",");return h===0?Be("0u",$e):h===1?Be(Oe[0],$e):(R.set=!0,R.setByIndices=!0,R.indicesToOffset=!0,`set_${t}(${Oe}, ${$e})`)},setByOffset:Be,setByIndices:(ee,$e)=>h<2?Be(ee,$e):(R.setByIndices=!0,R.indicesToOffset=!0,`set_${t}ByIndices(${ee}, ${$e});`),get:Ie,getByOffset:ue,getByIndices:He,usage:d?"input":"output",name:t,strides:U,shape:k,rank:h}},ne=(t,r,e,d=1)=>Za(t,r,e,!0,d),fe=(t,r,e,d=1)=>Za(t,r,e,!1,d),xi=class{constructor(r){this.normalizedDispatchGroup=r;this.indicesHelpers=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(r){return`if (global_idx >= ${typeof r=="number"?`${r}u`:r}) { return; }`}mainStart(r=Gp){let e=typeof r=="number"?r:r[0],d=typeof r=="number"?1:r[1],l=typeof r=="number"?1:r[2],m=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,h=m?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>`,u=m?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +\n          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${e*d*l}u + local_index;`;return`@compute @workgroup_size(${e}, ${d}, ${l})\n  fn main(${h}) {\n    ${u}\n  `}declareVariable(r,e){this.indicesHelpers.push(r),r.shape.startsWith("uniforms.")&&this.uniforms.push({name:r.shape.replace("uniforms.",""),type:r.type.indices}),r.strides.startsWith("uniforms.")&&this.uniforms.push({name:r.strides.replace("uniforms.",""),type:r.type.indices});let d=r.usage==="input"?"read":"read_write",l=r.type.storage;return`@group(0) @binding(${e}) var<storage, ${d}> ${r.name}: array<${l}>;`}declareVariables(...r){return r.map(e=>this.declareVariable(e,this.variableIndex++)).join(`\n`)}registerUniform(r,e){return this.uniforms.push({name:r,type:e}),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let r=[];for(let{name:e,type:d}of this.uniforms)r.push(`${e}:${d}`);return`\n      struct Uniforms { ${r.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.indicesHelpers.map(r=>r.impl()).join(`\n`)}},es=t=>new xi(t),_i=(t,r)=>{let e=t.length,d=[];for(let l=0;l<e;l++){let m=e-1-l,h=t[m]||1;(r[r.length-1-l]||1)>1&&h===1&&d.unshift(m)}return d}});var $t,Vp,Fn,Up,xt,ts,rs,ns,is,os,as,ss,us,ls,cs,ht,Ai=oe(()=>{"use strict";Ae();Ne();Pe();$t=t=>{if(!t||t.length===0||t.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(t.length===2&&t[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Vp=t=>["","",`var value = ${t.getByOffset("inputOffset")};`,""],Fn=(t,r,e,d,l,m,h=!1,u=!1)=>{let w=[],_=e[0].dims,O=Y.normalizeAxes(l,e[0].dims.length),j=!u&&O.length===0;_.forEach((Z,re)=>{j||O.indexOf(re)>=0?h&&w.push(1):w.push(Z)});let B=[],P=ne("_A",e[0].dataType,_),R=fe("output",m,w),T=d(P,R,O),k=`inputOffset = ${P.indicesToOffset("inputIndices")};`,U=`let ${k};`,K=`var ${k};`,Q=T[1]===""?"":K,L=(T[1]===""?U:k)+`\n`+T[2];for(let Z=0,re=0;Z<e[0].dims.length;Z++)j||O.indexOf(Z)>=0?(h&&re++,L=`for(var j${Z}: u32 = 0; j${Z} < ${e[0].dims[Z]}; j${Z}++) {\n                ${T[2].includes("lastIndex")?`let lastIndex = j${Z};`:""}\n                ${P.indicesSet("inputIndices",Z,`j${Z}`)}\n                ${L}\n              }`):(B.push(`${P.indicesSet("inputIndices",Z,R.indicesGet("outputIndices",re))};`),re++);let X=Y.size(w);return{name:t,shaderCache:r,getShaderSource:Z=>`\n        ${Z.declareVariables(P,R)}\n\n        ${Z.mainStart()}\n          ${Z.guardAgainstOutOfBoundsWorkgroupSizes(X)}\n          var inputIndices: ${P.type.indices};\n          let outputIndices = ${R.offsetToIndices("global_idx")};\n\n          ${B.join(`\n`)}\n          ${T[0]}       // init ops for reduce max/min\n          ${Q}\n          ${T[1]}\n          ${L}\n          ${T[3]}\n          ${T.length===4?R.setByOffset("global_idx","value"):T.slice(4).join(`\n`)}\n        }`,getRunData:()=>({outputs:[{dims:w,dataType:m}],dispatchGroup:{x:Math.ceil(X/64)}})}},Up=(t,r)=>{let e=[];return t[1].dims[0]>0&&t[1].getBigInt64Array().forEach(d=>e.push(Number(d))),ye({axes:e,keepDims:r.keepDims,noopWithEmptyAxes:r.noopWithEmptyAxes})},xt=(t,r,e,d)=>{let l=t.inputs,m=l.length===1?e:Up(l,e);t.compute(Fn(r,{hint:m.cacheKey},[l[0]],m.noopWithEmptyAxes&&m.axes.length===0?Vp:d,m.axes,l[0].dataType,m.keepDims,m.noopWithEmptyAxes),{inputs:[0]})},ts=(t,r)=>{$t(t.inputs),xt(t,"ReduceLogSum",r,(d,l)=>[`var value = ${l.type.storage}(0);`,"",`value += ${d.getByOffset("inputOffset")};`,"value = log(value);"])},rs=(t,r)=>{$t(t.inputs),xt(t,"ReduceL1",r,(d,l)=>[`var value = ${l.type.storage}(0);`,"",`value += abs(${d.getByOffset("inputOffset")});`,""])},ns=(t,r)=>{$t(t.inputs),xt(t,"ReduceL2",r,(d,l)=>[`var t = ${l.type.value}(0); var value = ${l.type.value}(0);`,"",`t = ${d.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])},is=(t,r)=>{$t(t.inputs),xt(t,"ReduceLogSumExp",r,(d,l)=>[`var value = ${l.type.storage}(0);`,"",`value += exp(${d.getByOffset("inputOffset")});`,"value = log(value);"])},os=(t,r)=>{$t(t.inputs),xt(t,"ReduceMax",r,(d,l,m)=>{let h=[];for(let u=0;u<d.rank;u++)(m.indexOf(u)>=0||m.length===0)&&h.push(d.indicesSet("inputIndices",u,0));return[`${h.join(`\n`)}`,`var value = ${d.getByOffset("inputOffset")};`,`value = max(value, ${d.getByOffset("inputOffset")});`,""]})},as=(t,r)=>{$t(t.inputs),xt(t,"ReduceMean",r,(d,l,m)=>{let h=1;for(let u=0;u<d.rank;u++)(m.indexOf(u)>=0||m.length===0)&&(h*=t.inputs[0].dims[u]);return["var sum = f32(0);","",`sum += f32(${d.getByOffset("inputOffset")});`,`let value = ${l.type.value}(sum / ${h});`]})},ss=(t,r)=>{$t(t.inputs),xt(t,"ReduceMin",r,(d,l,m)=>{let h=[];for(let u=0;u<d.rank;u++)(m.indexOf(u)>=0||m.length===0)&&h.push(`inputIndices[${u}] = 0;`);return[`${h.join(`\n`)}`,`var value = ${d.getByOffset("inputOffset")};`,`value = min(value, ${d.getByOffset("inputOffset")});`,""]})},us=(t,r)=>{$t(t.inputs),xt(t,"ReduceProd",r,(d,l)=>[`var value = ${l.type.storage}(1);`,"",`value *= ${d.getByOffset("inputOffset")};`,""])},ls=(t,r)=>{$t(t.inputs),xt(t,"ReduceSum",r,(d,l)=>[`var value = ${l.type.storage}(0);`,"",`value += ${d.getByOffset("inputOffset")};`,""])},cs=(t,r)=>{$t(t.inputs),xt(t,"ReduceSumSquare",r,(d,l)=>[`var t = ${l.type.value}(0); var value = ${l.type.value}(0);`,"",`t = ${d.getByOffset("inputOffset")}; value += t * t;`,""])},ht=t=>ye(t)});var ds,fs,ps,ms,Ii,hs=oe(()=>{"use strict";Xe();Ne();Ai();ds=t=>{if(!t||t.length===0||t.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(t[0].dataType!==1)throw new Error("Invalid input type.")},fs=(t,r)=>ye({axis:r.axis,keepDims:r.keepDims,selectLastIndex:r.selectLastIndex}),ps=(t,r)=>{ds(t.inputs);let e=(l,m,h)=>{let u=[];for(let w=0;w<l.rank;w++)(h.indexOf(w)>=0||h.length===0)&&u.push(`inputIndices[${w}] = 0;`);return[`${u.join(`\n`)}`,`var value = ${l.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${l.getByOffset("inputOffset")} ${r.selectLastIndex>0?"<=":"<"} value) {\n         value = ${l.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",m.setByOffset("global_idx","bestIndex")]},d=t.inputs.length===1?r:fs(t.inputs,r);t.compute(Fn("ArgMin",{hint:d.cacheKey},[t.inputs[0]],e,[d.axis],7,d.keepDims),{inputs:[0]})},ms=(t,r)=>{ds(t.inputs);let e=(l,m,h)=>{let u=[];for(let w=0;w<l.rank;w++)(h.indexOf(w)>=0||h.length===0)&&u.push(`inputIndices[${w}] = 0;`);return[`${u.join(`\n`)}`,`var value = ${l.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${l.getByOffset("inputOffset")} ${r.selectLastIndex>0?">=":">"} value) {\n         value = ${l.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",m.setByOffset("global_idx","bestIndex")]},d=t.inputs.length===1?r:fs(t.inputs,r);t.compute(Fn("argMax",{hint:d.cacheKey},[t.inputs[0]],e,[d.axis],7,d.keepDims),{inputs:[0]})},Ii=t=>ye(t)});var Np,Fp,gs,ys=oe(()=>{"use strict";Ae();Pe();Np=t=>{if(t[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(t[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(t[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(t[0].dims[2]!==t[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Fp=t=>{let r=t[0].dims,e=t[0].dims[2],d=Y.size(r)/4,l=t[0].dataType,m=ne("input",l,r,4),h=ne("bias",l,[e],4),u=ne("residual",l,r,4),w=fe("output",l,r,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:r,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)}}),getShaderSource:O=>`\n  const channels = ${e}u / 4;\n  ${O.declareVariables(m,h,u,w)}\n\n  ${O.mainStart()}\n    ${O.guardAgainstOutOfBoundsWorkgroupSizes(d)}\n    let value = ${m.getByOffset("global_idx")}\n      + ${h.getByOffset("global_idx % channels")} + ${u.getByOffset("global_idx")};\n    ${w.setByOffset("global_idx","value")}\n  }`}},gs=t=>{Np(t.inputs),t.compute(Fp(t.inputs))}});var Hp,Re,bs,vs,ws,Cs,$s,xs,Ss,_s,As,Ti,Lp,Is,Ts,Os,Es,Hn,Ps,Ln,Rs,ks,Bs,Ms,js,Ds,Ws,zs,Gs,Vs,Us,Ns,Fs,Hs,Ls,Ks,qs,Oi=oe(()=>{"use strict";Xe();Ae();Ne();Pe();Hp=(t,r,e,d,l,m)=>{let h=Math.ceil(r/4),u="";typeof l=="string"?u=`${l}(a)`:u=l("a");let w=ne("inputData",e,[h],4),_=fe("outputData",d,[h],4);return`\n  ${t.declareVariables(w,_)}\n\n  ${m??""}\n\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes(h)}\n\n    let a = ${w.getByOffset("global_idx")};\n    ${_.setByOffset("global_idx",u)}\n  }`},Re=(t,r,e,d,l,m=t.dataType)=>({name:r,shaderCache:{hint:l},getShaderSource:h=>Hp(h,Y.size(t.dims),t.dataType,m,e,d),getRunData:h=>({outputs:[{dims:t.dims,dataType:m}],dispatchGroup:{x:Math.ceil(Y.size(h[0].dims)/64/4)}})}),bs=t=>{t.compute(Re(t.inputs[0],"Abs","abs"))},vs=t=>{t.compute(Re(t.inputs[0],"Acos","acos"))},ws=t=>{t.compute(Re(t.inputs[0],"Acosh","acosh"))},Cs=t=>{t.compute(Re(t.inputs[0],"Asin","asin"))},$s=t=>{t.compute(Re(t.inputs[0],"Asinh","asinh"))},xs=t=>{t.compute(Re(t.inputs[0],"Atan","atan"))},Ss=t=>{t.compute(Re(t.inputs[0],"Atanh","atanh"))},_s=t=>ye(t),As=(t,r)=>{let e;switch(r.to){case 10:e="vec4<f16>";break;case 1:e="vec4<f32>";break;case 12:e="vec4<u32>";break;case 6:e="vec4<i32>";break;case 9:e="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${r.to}`)}t.compute(Re(t.inputs[0],"Cast",e,void 0,r.cacheKey,r.to))},Ti=(t,r)=>{let e=Fe(t.inputs[0].dataType);t.compute(Re(t.inputs[0],"Clip",d=>`clamp(${d}, clip_min_, clip_max_)`,`\n    const clip_min_: vec4<${e}> = vec4(${e}(${r.min}));\n    const clip_max_: vec4<${e}> = vec4(${e}(${r.max}));\n`,r.cacheKey),{inputs:[0]})},Lp=t=>{let r=t.length>=2?t[1].getFloat32Array()[0]:Un,e=t.length>=3?t[2].getFloat32Array()[0]:Nn;return ye({min:r,max:e})},Is=t=>{let r=Lp(t.inputs);Ti(t,r)},Ts=t=>{t.compute(Re(t.inputs[0],"Ceil","ceil"))},Os=t=>{t.compute(Re(t.inputs[0],"Cos","cos"))},Es=t=>{t.compute(Re(t.inputs[0],"Cosh","cosh"))},Hn=t=>ye(t),Ps=(t,r)=>{t.compute(Re(t.inputs[0],"Elu",e=>`elu_vf32(${e})`,`\n  const elu_alpha_: f32 = f32(${r.alpha});\n\n  fn elu_f32(a: f32) -> f32 {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,r.cacheKey))},Ln=(t,r="f32")=>`\nconst r0: ${r} = 0.3275911;\nconst r1: ${r} = 0.254829592;\nconst r2: ${r} = -0.284496736;\nconst r3: ${r} = 1.421413741;\nconst r4: ${r} = -1.453152027;\nconst r5: ${r} = 1.061405429;\n\nfn erf_vf32(v: ${t}) -> ${t} {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,Rs=t=>{let r=Fe(t.inputs[0].dataType);t.compute(Re(t.inputs[0],"Erf",e=>`erf_vf32(${e})`,Ln(`vec4<${r}>`,r)))},ks=t=>{t.compute(Re(t.inputs[0],"Exp","exp"))},Bs=t=>{t.compute(Re(t.inputs[0],"Floor","floor"))},Ms=t=>{let r=Fe(t.inputs[0].dataType);t.compute(Re(t.inputs[0],"Gelu",e=>`0.5 * ${e} * (1.0 + erf_vf32(${e} * 0.7071067811865475))`,Ln(`vec4<${r}>`,r)))},js=(t,r)=>{t.compute(Re(t.inputs[0],"LeakyRelu",e=>`select(leaky_relu_alpha_ * ${e}, ${e}, ${e} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${r.alpha});`,r.cacheKey))},Ds=t=>{t.compute(Re(t.inputs[0],"Not",r=>`!${r}`))},Ws=t=>{t.compute(Re(t.inputs[0],"Neg",r=>`-${r}`))},zs=t=>{t.compute(Re(t.inputs[0],"Reciprocal",r=>`1.0/${r}`))},Gs=t=>{t.compute(Re(t.inputs[0],"Relu",r=>`select(vec4<f32>(0.0), ${r}, ${r} > vec4<f32>(0.0))`))},Vs=t=>{t.compute(Re(t.inputs[0],"Sigmoid",r=>`(1.0 / (1.0 + exp(-${r})))`))},Us=t=>{t.compute(Re(t.inputs[0],"Sin","sin"))},Ns=t=>{t.compute(Re(t.inputs[0],"Sinh","sinh"))},Fs=t=>{t.compute(Re(t.inputs[0],"Sqrt","sqrt"))},Hs=t=>{t.compute(Re(t.inputs[0],"Tan","tan"))},Ls=t=>{t.compute(Re(t.inputs[0],"Tanh","tanh"))},Ks=(t,r)=>(t.compute(Re(t.inputs[0],"ThresholdedRelu",e=>`select(vec4<f32>(0.0), ${e}, ${e} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${r.alpha});`,r.cacheKey)),0),qs=t=>{t.compute(Re(t.inputs[0],"Log","log"))}});var qp,Yp,Ys,Xs=oe(()=>{"use strict";Ae();Pe();Oi();qp=t=>{if(t[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(t[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(t[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(t[0].dims[2]!==t[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Yp=t=>{let r=t[0].dims.slice();r[2]=r[2]/2;let e=ne("input",t[0].dataType,t[0].dims,4),d=ne("bias",t[0].dataType,[t[0].dims[2]],4),l=fe("output",t[0].dataType,r,4),m=Y.size(r)/4;return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:r,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)}}),getShaderSource:u=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${t[0].dims[2]/4/2}u;\n\n  ${u.declareVariables(e,d,l)}\n\n  ${Ln("vec4f")}\n\n  ${u.mainStart()}\n    ${u.guardAgainstOutOfBoundsWorkgroupSizes(m)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${l.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},Ys=t=>{qp(t.inputs),t.compute(Yp(t.inputs))}});var Xp,Qp,St,Qs,Js,Zs,eu,tu,ru,nu,iu,ou,au,su=oe(()=>{"use strict";Xe();Ae();Pe();Xp=(t,r,e,d,l,m,h,u,w,_,O)=>{let j=Y.size(d),B=Math.ceil(j/4),P,R;typeof h=="string"?P=R=(L,X)=>`${h}((${L}),(${X}))`:typeof h=="function"?P=R=h:(P=h.scalar,R=h.vector);let T="",k=fe("outputData",_,d,4),U=ne("aData",u,r,4),K=ne("bData",w,e,4);if(m){let L=X=>{let A=Y.computeStrides(X),Z=[];for(let re=X.length-1;re>=0;re--){let ie=k.indicesGet("outputIndices",re+d.length-X.length);Z.push(`${A[re]}u * (${ie} % ${X[re]}u)`)}return Z.length>0?Z.join("+"):"0u"};T=`\n          fn calcOffsetA(outputIndices: ${k.type.indices}) -> u32 {\n            return ${L(r)};\n          }\n\n          fn calcOffsetB(outputIndices: ${k.type.indices}) -> u32 {\n            return ${L(e)};\n          }\n        `}let Q;if(l)if(m){let L=Y.size(r)===1,X=Y.size(e)===1;L||X?Q=k.setByOffset("global_idx",R(L?`${U.type.value}(${U.getByOffset("0")}.x)`:U.getByOffset("global_idx"),X?`${K.type.value}(${K.getByOffset("0")}.x)`:K.getByOffset("global_idx"))):Q=`\n            let outputIndices = ${k.offsetToIndices("global_idx * 4u")};\n            let offsetA = calcOffsetA(outputIndices);\n            let offsetB = calcOffsetB(outputIndices);\n            ${k.setByOffset("global_idx",R(U.getByOffset("offsetA / 4u"),K.getByOffset("offsetB / 4u")))}\n          `}else Q=k.setByOffset("global_idx",R(U.getByOffset("global_idx"),K.getByOffset("global_idx")));else{if(!m)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let L=(X,A,Z="")=>{let re=`aData[indexA${A}][componentA${A}]`,ie=`bData[indexB${A}][componentB${A}]`;return`\n            let outputIndices${A} = ${k.offsetToIndices(`global_idx * 4u + ${A}u`)};\n            let offsetA${A} = calcOffsetA(outputIndices${A});\n            let offsetB${A} = calcOffsetB(outputIndices${A});\n            let indexA${A} = offsetA${A} / 4u;\n            let indexB${A} = offsetB${A} / 4u;\n            let componentA${A} = offsetA${A} % 4u;\n            let componentB${A} = offsetB${A} % 4u;\n            ${X}[${A}] = ${Z}(${P(re,ie)});\n          `};_===9?Q=`\n            var data = vec4<u32>(0);\n            ${L("data",0,"u32")}\n            ${L("data",1,"u32")}\n            ${L("data",2,"u32")}\n            ${L("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:Q=`\n            ${L("outputData[global_idx]",0)}\n            ${L("outputData[global_idx]",1)}\n            ${L("outputData[global_idx]",2)}\n            ${L("outputData[global_idx]",3)}\n          `}return`\n        ${t.declareVariables(U,K,k)}\n\n        ${O??""}\n        ${T}\n\n        ${t.mainStart()}\n        ${t.guardAgainstOutOfBoundsWorkgroupSizes(B)}\n        ${Q}\n      }`},Qp=(t,r,e,d,l,m,h=e.dataType)=>{let u=!Y.areEqual(e.dims,d.dims),w=e.dims,_=Y.size(e.dims),O=!1;if(u){let j=Ct.calcShape(e.dims,d.dims,!1);if(!j)throw new Error("Can\'t perform binary op on the given tensors");w=j,_=Y.size(w);let B=Y.size(e.dims)===1,P=Y.size(d.dims)===1,R=1;for(let T=1;T<w.length;T++){let k=e.dims[e.dims.length-T]??1,U=d.dims[d.dims.length-T]??1;if(k===U)R*=k;else break}(R%4===0||B||P)&&(O=!0)}else O=!0;return{name:t,shaderCache:{hint:r},getShaderSource:j=>Xp(j,e.dims,d.dims,w,O,u,l,e.dataType,d.dataType,h,m),getRunData:()=>({outputs:[{dims:w,dataType:h}],dispatchGroup:{x:Math.ceil(_/64/4)}})}},St=(t,r,e,d,l,m)=>{t.compute(Qp(r,l??"",t.inputs[0],t.inputs[1],e,d,m))},Qs=t=>{St(t,"Add",(r,e)=>`${r}+${e}`)},Js=t=>{St(t,"Div",(r,e)=>`${r}/${e}`)},Zs=t=>{St(t,"Equal",{scalar:(r,e)=>`u32(${r}==${e})`,vector:(r,e)=>`vec4<u32>(${r}==${e})`},void 0,void 0,9)},eu=t=>{St(t,"Mul",(r,e)=>`${r}*${e}`)},tu=t=>{let r=ne("input",t.inputs[0].dataType,t.inputs[0].dims).type.value;St(t,"Pow",{scalar:(d,l)=>`pow_custom(${d},${l})`,vector:(d,l)=>`pow_vector_custom(${d},${l})`},`\n    fn pow_custom(a : ${r}, b : ${r}) -> ${r} {\n      if (b == ${r}(0.0)) {\n        return ${r}(1.0);\n      } else if (a < ${r}(0.0) && f32(b) != floor(f32(b))) {\n        return ${r}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${r}(1.0), round(f32(abs(b) % ${r}(2.0))) != 1.0) * ${r}(${r==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${r}>, b : vec4<${r}>) -> vec4<${r}> {\n      // TODO: implement vectorized pow\n      return vec4<${r}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},ru=t=>{St(t,"Sub",(r,e)=>`${r}-${e}`)},nu=t=>{St(t,"Greater",{scalar:(r,e)=>`u32(${r}>${e})`,vector:(r,e)=>`vec4<u32>(${r}>${e})`},void 0,void 0,9)},iu=t=>{St(t,"Less",{scalar:(r,e)=>`u32(${r}<${e})`,vector:(r,e)=>`vec4<u32>(${r}<${e})`},void 0,void 0,9)},ou=t=>{St(t,"GreaterOrEqual",{scalar:(r,e)=>`u32(${r}>=${e})`,vector:(r,e)=>`vec4<u32>(${r}>=${e})`},void 0,void 0,9)},au=t=>{St(t,"LessOrEqual",{scalar:(r,e)=>`u32(${r}<=${e})`,vector:(r,e)=>`vec4<u32>(${r}<=${e})`},void 0,void 0,9)}});var Zp,em,tm,rm,uu,lu,cu=oe(()=>{"use strict";Ae();Ne();Pe();Zp=t=>{if(!t||t.length<1)throw new Error("too few inputs");let r=t[0].dataType,e=t[0].dims.length;for(let d of t){if(d.dataType!==r)throw new Error("input tensors should be one type");if(d.dims.length!==e)throw new Error("input tensors should have the same shape")}},em=t=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${t}u; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${t}u;\n  }`,tm=(t,r)=>{let e=t.length,d=[];for(let l=0;l<e;++l){let m=r.setByOffset("global_idx",t[l].getByIndices("indices"));e===1?d.push(m):l===0?d.push(`if (inputIndex == ${l}u) { ${m} }`):l===e-1?d.push(`else { ${m} }`):d.push(`else if (inputIndex == ${l}) { ${m} }`)}return d.join(`\n`)},rm=(t,r)=>{let e=t[0].dims.slice();if(r>=e.length||r<-1*e.length)throw new Error("axis specified for concat doesn\'t match input dimensionality");let d=r<0?e.length+r:r,l=e.slice(0);for(let P=1;P<t.length;P++){let R=t[P].dims.slice();for(let T=0;T<e.length;T++)if(T===d)l[d]+=R[T];else if(e[T]!==R[T])throw new Error("non concat dimensions must match")}let m=Y.size(l),h=new Array(t.length),u=new Array(t.length),w=t[0].dataType,_=0;for(let P=0;P<t.length;++P)_+=t[P].dims[d],h[P]=_,u[P]=ne(`input${P}`,w,t[P].dims);let O=fe("output",w,l),j=O.indicesGet("indices",d),B=P=>`\n  ${P.declareVariables(...u,O)}\n\n  const sizeInConcatAxis = array<u32, ${h.length}>(${h.map(R=>`${R}u`).join(",")});\n  ${em(h.length)}\n\n  ${P.mainStart()}\n    ${P.guardAgainstOutOfBoundsWorkgroupSizes(m)}\n\n    var indices = ${O.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${j});\n    if (inputIndex != 0u) {\n      ${j} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${tm(u,O)}\n  }`;return{name:"Concat",shaderCache:{hint:`${r}`},getRunData:()=>({outputs:[{dims:l,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)}}),getShaderSource:B}},uu=(t,r)=>{Zp(t.inputs),t.compute(rm(t.inputs,r.axis))},lu=t=>ye({axis:t.axis})});var Qe,Kn,qn,Yn=oe(()=>{"use strict";Qe=(t,r)=>{switch(t){case 1:return r;case 2:return`vec2<${r}>`;case 3:return`vec3<${r}>`;case 4:return`vec4<${r}>`;default:throw new Error(`${t}-component is not supported.`)}},Kn=(t,r=!1,e=!1,d=3)=>"",qn=(t,r)=>`\n      ${t?"value = value + getBiasByOutputCoords(coords);":""}\n      ${r?"value = activation(value, coords);":""}\n      `});var Xn,Ei=oe(()=>{"use strict";Xn=`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));\n}\n`});var Qn,Jn,on=oe(()=>{"use strict";Ae();Qn=t=>{switch(t.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${t.clipMin});const clip_max_=f32(${t.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},Jn=t=>{let r=t?.activation||"";if(r==="Clip"){let[e,d]=t?.activation_params||[Un,Nn];return{activation:r,clipMax:d,clipMin:e,activationCacheKey:`${r}:${e},${d}`}}return{activation:r,activationCacheKey:r}}});var nm,im,an,du,om,sn,am,Zn,un=oe(()=>{"use strict";Ae();Pe();on();Yn();nm=(t,r)=>t?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${r?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${r?", batchIndices":""});\n        `,im=(t,r)=>t?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${r===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${r===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${r===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,an=(t,r,e="f32",d,l=!1,m=32,h=!1,u=32)=>{let w=r[1]*t[1],_=r[0]*t[0],O=l?w:m,j=l?m:w,B=O/r[0],P=m/r[1];if(!((l&&B===4&&t[1]===4||!l&&(B===3||B===4))&&O%r[0]===0&&m%r[1]===0&&t[0]===4))throw new Error(`If transposeA ${l} is true, innerElementSize ${B} and workPerThread[1] ${t[1]} must be 4.\n      Otherwise, innerElementSize ${B} must be 3 or 4.\n  tileAWidth ${O} must be divisible by workgroupSize[0]${r[0]}. tileInner ${m} must be divisible by workgroupSize[1] ${r[1]}. colPerThread ${t[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${B}<${e}>, ${O/B}>, ${j}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${e}>, ${_/t[0]}>, ${m}>;\n\nconst rowPerThread = ${t[1]};\nconst colPerThread = ${t[0]};\nconst innerElementSize = ${B};\nconst tileInner = ${m};\n\n@compute @workgroup_size(${r[0]}, ${r[1]}, ${r[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${h?"0":"i32(globalId.z)"};\n  ${d?`let batchIndices = ${d.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${w};\n\n  let numTiles = ${h?`${Math.ceil(u/m)}`:"(dimInner - 1) / tileInner + 1"};\n  var kStart = ${h?`i32(globalId.z) * ${u}`:"0"};\n\n  var acc: array<vec4<${e}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${P};\n  for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${nm(l,d)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${P}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${d?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${B===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${im(l,B)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},du=(t,r)=>t?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${r?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${r?", batchIndices":""});\n            `,om=t=>t?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",sn=(t,r,e="f32",d,l=!1,m=32,h=!1,u=32,w=!1)=>{let _=t[1]*r[1],O=t[0]*r[0],j=l?_:m,B=l?m:_;if(!(B%r[1]===0&&j%r[0]===0&&m%r[1]===0))throw new Error(`tileAHight ${B} must be divisible by workgroupSize[1]${r[1]}, tileAWidth ${j} must be divisible by workgroupSize[0]${r[0]}, tileInner ${m} must be divisible by workgroupSize[1]${r[1]}`);let P=B/r[1],R=j/r[0],T=m/r[1],k=w?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${_};\n    let globalColStart = i32(workgroupId.x) * ${O};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${B}; inputRow = inputRow + ${r[1]}) {\n        for (var inputCol = localCol; inputCol < ${j}; inputCol = inputCol + ${r[0]}) {\n          ${du(l,d)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${m}; inputRow = inputRow + ${r[1]}) {\n            for (var inputCol = localCol; inputCol < ${O}; inputCol = inputCol + ${r[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${d?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${e}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${r[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${l?`mm_Asub[k][localRow + innerRow * ${r[1]}];`:`mm_Asub[localRow + innerRow * ${r[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${r[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${r[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${_};\n\nlet tileRowA = i32(localId.y) * ${P};\nlet tileColA = i32(localId.x) * ${R};\nlet tileRowB = i32(localId.y) * ${T};\n// Loop over shared dimension.\nfor (var t = 0; t < numTiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${P}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${R}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${du(l,d)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${T}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${d?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${e}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${om(l)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${e}, ${j}>, ${B}>;\n  var<workgroup> mm_Bsub : array<array<${e}, ${O}>, ${m}>;\n  const rowPerThread = ${t[1]};\n  const colPerThread = ${t[0]};\n  const tileInner = ${m};\n\n@compute @workgroup_size(${r[0]}, ${r[1]}, ${r[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${h?"0":"i32(globalId.z)"};\n    ${d?`let batchIndices = ${d.offsetToIndices("u32(batch)")};`:""}\n    let numTiles = ${h?`${Math.ceil(u/m)}`:"(dimInner - 1) / tileInner + 1"};\n    var kStart = ${h?`i32(globalId.z) * ${u}`:"0"};\n\n    var acc : array<array<${e}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${k}\n  }\n`},am=(t,r,e,d,l,m=!1)=>{let h=l[0],u=l[1],w=l[2],_=d[0],O=d[1],j=d[2],B=d[3],P=_i(h,w),R=_i(u,w),T=Fe(d[0].type.tensor),k=()=>{let Q=O.rank,L=_.rank,X=`var aIndices: ${O.type.indices};`;for(let A=Q-2-1,Z=L-1;A>=0;A--,Z--)X+=`\naIndices[${A}] = ${L>1?`batchIndices[${Z}]`:"batchIndices"};`;return P.forEach(A=>{X+=`\naIndices[${A}] = 0;`}),X+=`\naIndices[${Q-2}] = u32(row);\n                   aIndices[${Q-1}] = u32(colIn);`,X},U=()=>{let Q=j.rank,L=_.rank,X=`var bIndices: ${j.type.indices};`;for(let A=Q-2-1,Z=L-1;A>=0;A--,Z--)X+=`\nbIndices[${A}] = ${L>1?`batchIndices[${Z}]`:"batchIndices"};`;return R.forEach(A=>{X+=`\nbIndices[${A}] = 0;`}),X+=`\nbIndices[${Q-2}] = u32(row);\n                   bIndices[${Q-1}] = u32(colIn);`,X};return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${_.type.indices}) -> ${Qe(t,T)} {\n      var value = ${Qe(t,T)}(0.0);\n      let col = colIn * ${t};\n      if(row < dimAOuter && col < dimInner)\n      {\n        ${k()}\n        value = ${O.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${_.type.indices}) -> ${Qe(t,T)} {\n      var value = ${Qe(t,T)}(0.0);\n      let col = colIn * ${t};\n      if(row < dimInner && col < dimBOuter)\n      {\n        ${U()}\n        value = ${j.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Qe(t,T)}) {\n      let col = colIn * ${t};\n      if (row < dimAOuter && col < dimBOuter) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${r?`value = value + ${m?"bias[colIn]":`${Qe(t,T)}(bias[row])`};`:""}\n        ${e}\n        ${B.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},Zn=(t,r,e,d,l=!1)=>{let m=t[0].dims,h=t[1].dims,u=m.slice(0,-2),w=h.slice(0,-2),_=d?d.slice(0,-2):e.slice(0,-2),O=ne("batchDims",t[0].dataType,_),j=[O],B=[u,w,_],P=Y.size(_),R=m[m.length-2],T=m[m.length-1],k=h[h.length-1],U=T%4===0&&k%4===0,{activationFunction:K,applyActivation:Q}=Qn(r),L=R<=8?[4,1,1]:[4,4,1],X=[8,8,1],A=[Math.ceil(k/X[0]/L[0]),Math.ceil(R/X[1]/L[1]),Math.ceil(P/X[2]/L[2])],Z=Fe(t[0].dataType),re=U?4:1,ie=ne("a",t[0].dataType,[...u,R,T/re],re),Ce=ne("b",t[1].dataType,[...w,T,k/re],re),H=fe("result",t[0].dataType,[P,R,k/re],re);j.push(ie),j.push(Ce),j.push(H);let le=[ie,Ce],Be=t.length>2,ue=am(re,Be,Q,j,B,l);if(Be){let Ze=l?re:1;le.push(ne("bias",t[2].dataType,t[2].dims,Ze))}let ae=Ze=>`\n  const dimAOuter: i32 = ${R};\n  const dimBOuter: i32 = ${k};\n  const dimInner: i32 = ${T};\n  ${Ze.declareVariables(...le,H)}\n  ${ue}\n  ${K}\n  ${U?an(L,X,Z,O):sn(L,X,Z,O)}\n                   ${O.impl()}`;return{name:"MatMul",shaderCache:{hint:r.activationCacheKey},getRunData:()=>({outputs:[{dims:e,dataType:t[0].dataType}],dispatchGroup:{x:A[0],y:A[1],z:A[2]}}),getShaderSource:ae}}});var sm,fu,pu=oe(()=>{"use strict";Tt();Ae();Pe();Yn();Ei();un();sm=(t,r,e,d,l=!1,m,h=!1,u=4,w=4,_=4,O="f32")=>{let j=Ce=>{switch(Ce){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${O}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${Ce} is not supported.`)}},B=Ce=>{switch(Ce){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${Ce} is not supported.`)}},P=t?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,R=t?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,T=t?"xShape[1]":"xShape[2]",k=t?"xShape[2]":"xShape[3]",U=t?"row":"col",K=t?"col":"row",Q=`\n    let inChannels = wShape[2];\n    let outWidth = ${t?"outShape[2]":"outShape[3]"};\n    let outRow = ${U} / outWidth;\n    let outCol = ${U} % outWidth;\n\n    let WRow = ${K} / (filterDims[1] * inChannels);\n    let WCol = ${K} / inChannels % filterDims[1];\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\n    let xCh = ${K} % inChannels;\n    var resData = ${Qe(u,O)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the \'same\' padding type.\n    if (xRow >= 0 && xRow < ${T} && xCol >= 0 && xCol < ${k}) {\n      ${P}\n      let xIndex = getIndexFromCoords4D(coord, xShape);\n      ${j(u)}\n    }\n    return resData;`,L=t?r&&d?`\n    let col = colIn * ${u};\n    ${Q}`:`\n    let col = colIn * ${u};\n    if (row < dimAOuter && col < dimInner) {\n      ${Q}\n    }\n    return ${Qe(u,O)}(0.0);`:d&&e?`\n    let col = colIn * ${u};\n    ${Q}`:`\n    let col = colIn * ${u};\n    if (row < dimInner && col < dimBOuter) {\n      ${Q}\n    }\n    return ${Qe(u,O)}(0.0);`,X=`${B(w)}`,A=Qe(_,O),Z=t?Qe(u,O):Qe(w,O),re=t?Qe(w,O):Qe(u,O);return`\n    ${Kn(m,h,_===4,4)}\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${Z} {\n      ${t?L:X}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${re} {\n      ${t?X:L}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${A}) {\n      let col = colIn * ${_};\n      if (row < dimAOuter && col < dimBOuter)\n      {\n      var value = valueIn;\n      let outWidth = ${t?"outShape[2]":"outShape[3]"};\n      ${R}\n      ${qn(l,m)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},fu=(t,r,e,d,l,m,h,u)=>{let w=r.format==="NHWC",_=w?t[0].dims[3]:t[0].dims[1],O=e[0],j=w?e[2]:e[3],B=w?e[1]:e[2],P=w?e[3]:e[1],R=w&&(_%4===0||_%3===0)&&P%4===0,T=w?P:j*B,k=w?j*B:P,U=[8,8,1],K=d<=8?[4,1,1]:[4,4,1],Q=[Math.ceil(T/U[0]/K[0]),Math.ceil(k/U[1]/K[1]),Math.ceil(O/U[2]/K[2])];ze("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${Q}`);let L=R?w&&_%4!==0?3:4:K[0],X=U[1]*K[1],A=U[0]*K[0],Z=Math.max(U[0]*L,U[1]),re=d%X===0,ie=l%A===0,Ce=m%Z===0,H=R?[L,4,4]:[1,1,1],le=Fe(t[0].dataType),Be=[`@group(0) @binding(0) var<storage, read> x: array<${R&&L===4?`vec4<${le}>`:le}>;`,`@group(0) @binding(1) var<storage, read> w: array<${R?`vec4<${le}>`:le}>;`],ue=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${R?`vec4<${le}>`:le}) {\n        result[flatIndex] = ${R?`vec4<${le}>`:le}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${R?`vec4<${le}>`:le}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${R?"/ 4":""}, value);\n      }`;return h&&(Be.push(`@group(0) @binding(2) var<storage, read> bias: array<${R?`vec4<${le}>`:le}>;`),ue+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${R?`vec4<${le}>`:le} {\n          return bias[coords.${w?"w":"y"}${R?"/ 4":""}];\n        }`),{name:"Conv2DMatMul",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:e,dataType:t[0].dataType}],dispatchGroup:{x:Q[0],y:Q[1],z:Q[2]}}),getShaderSource:()=>`\n        ${Xn}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${Be.join("")}\n        @group(0) @binding(${Be.length}) var<storage, read_write> result: array<${R?`vec4<${le}>`:le}>;\n        //@group(0) @binding(${Be.length+1}) var<uniform> uniforms: Uniforms;\n\n        const xShape : vec4<i32> = vec4<i32>(${t[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${t[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${e.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${Y.computeStrides(e).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${r.kernelShape[0]}, ${r.kernelShape[1]});\n        const pad : vec2<i32> = vec2<i32>(${r.pads[0]}, ${r.pads[1]});\n        const stride : vec2<i32> = vec2<i32>(${r.strides[0]}, ${r.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${r.dilations[0]}, ${r.dilations[1]});\n        const dimAOuter : i32 = ${d};\n        const dimBOuter : i32 = ${l};\n        const dimInner : i32 = ${m};\n        ${ue}\n        ${sm(w,re,ie,Ce,h,void 0,!1,H[0],H[1],H[2],le)}\n            ${R?an(K,U,le,void 0,!w,Z):sn(K,U,le,void 0,!w,Z,!1,void 0,u)}`}}});var Pi,mu=oe(()=>{"use strict";Ae();Pe();ki();on();Pi=(t,r,e)=>{let d=t.length>2,l=d?"value += b[output_channel];":"",m=t[0].dims,h=t[1].dims,u=h[0]/r.group,{activationFunction:w,applyActivation:_}=Qn(r),O=r.format==="NHWC",j=Ri(m,h,r.dilations,r.pads,r.strides,O),B=Y.size(j),P=fe("output",t[0].dataType,j),R=ne("x",t[0].dataType,m),T=ne("w",t[1].dataType,h),k=[R,T];d&&k.push(ne("b",t[2].dataType,t[2].dims));let U=K=>`\n  const strides: vec2<u32> = vec2(${r.strides[0]}u, ${r.strides[1]}u);\n  const pads: vec2<u32> = vec2(${r.pads[0]}u, ${r.pads[1]}u);\n\n  ${K.declareVariables(...k,P)}\n\n  ${w}\n\n  ${K.mainStart()}\n    ${K.guardAgainstOutOfBoundsWorkgroupSizes(B)}\n\n    let outputIndices = ${P.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${O?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${O?1:2}], outputIndices[${O?2:3}]) * strides - pads;\n    let group_id: u32 = output_channel / ${u}u;\n\n    var value: ${P.type.value} = ${P.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < ${h[1]}u; wInChannel++) {\n      let input_channel = group_id * ${h[1]}u + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < ${h[2]}u; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * ${r.dilations[0]}u;\n\n        if (xHeight < 0u || xHeight >= ${m[O?1:2]}u) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < ${h[3]}u; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * ${r.dilations[1]}u;\n          if (xWidth < 0u || xWidth >= ${m[O?2:3]}u) {\n            continue;\n          }\n\n          let xVal = ${O?R.get("batch","xHeight","xWidth","input_channel"):R.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${T.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${l}\n    ${_}\n    ${P.setByOffset("global_idx","value")}\n  }`;return{name:"GroupedConv",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:e?e(j):j,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(B/64)}}),getShaderSource:U}}});var um,hu,lm,cm,fr,gu,yu,ei=oe(()=>{"use strict";Ae();Ne();Pe();um=t=>{if(!t||t.length!==1)throw new Error("Transpose requires 1 input.")},hu=(t,r)=>r&&r.length!==t?[...new Array(t).keys()].reverse():r,lm=(t,r)=>Y.sortBasedOnPerm(t,hu(t.length,r)),cm=(t,r,e,d)=>{let l=[];l.push(`fn perm(i: ${d.type.indices}) -> ${e.type.indices} {\n    var a: ${e.type.indices};`);for(let m=0;m<r;++m)l.push(e.indicesSet("a",t[m],`i[${m}]`));return l.push("return a;}"),l.join(`\n`)},fr=(t,r,e)=>{let d=hu(r,e),l=fe("output",t,e&&e.length||r),m=ne("a",t,r),h=u=>`\n  ${u.registerUniform("output_size","u32").declareVariables(m,l)}\n\n  ${cm(d,r,m,l)}\n\n  ${u.mainStart()}\n    ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${l.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${l.setByOffset("global_idx",m.getByIndices("aIndices"))}\n  }`;return{name:"Transpose",shaderCache:{hint:`${e}`,inputDependencies:["rank"]},getRunData:u=>{let w=lm(u[0].dims,d),_=Y.size(w);return{outputs:[{dims:w,dataType:u[0].dataType}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:[{type:"uint32",data:_},...Si(u[0].dims),...Si(w)]}},getShaderSource:h}},gu=(t,r)=>{um(t.inputs),t.compute(fr(t.inputs[0].dataType,t.inputs[0].dims.length,r.perm))},yu=t=>ye({perm:t.perm})});var Ri,bu,dm,vu,wu,fm,pm,Cu,ki=oe(()=>{"use strict";Ae();Ne();pu();un();mu();on();ei();Ri=(t,r,e,d,l,m)=>{let h=t[0],u=t.slice(m?1:2,m?3:4),w=u.length,_=r[0],j=r.slice(2).map((R,T)=>R+(R-1)*(e[T]-1)),P=u.map((R,T)=>R+d[T]+d[T+w]).map((R,T)=>Math.floor((R-j[T]+l[T])/l[T]));return P.splice(0,0,h),P.splice(m?3:1,0,_),P},bu=[2,3,1,0],dm=(t,r)=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(t[0].dims.length!==4&&t[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(t[0].dims.length!==t[1].dims.length)throw new Error("filter does not have same dimension as input");let e=t[0].dims[r.format==="NHWC"?t[0].dims.length-1:1],d=t[1].dims[1]*r.group;if(e!==d)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(t.length===3&&(t[2].dims.length!==1||t[1].dims[0]!==t[2].dims[0]))throw new Error("invalid bias");let l=t[0].dims.length-2;if(r.dilations.length!==l)throw new Error(`dilations should be ${l}D`);if(r.strides.length!==l)throw new Error(`strides should be ${l}D`);if(r.pads.length!==l*2)throw new Error(`pads should be ${l*2}D`);if(r.kernelShape.length!==0&&r.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape")},vu=(t,r)=>{let e=t.kernelShape.slice();for(let m=2;m<r[1].dims.length;++m)e[m-2]===0&&(e[m-2]=r[1].dims[m]);let d=t.pads.slice();Nt.adjustPadsBasedOnAutoPad(r[0].dims,t.strides,t.dilations,e,d,t.format==="NHWC",t.autoPad);let l=Object.assign({},t);return Object.assign(l,{kernelShape:e,pads:d,cacheKey:t.cacheKey}),l},wu=t=>{let r=Jn(t),e=t.format,d=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][t.auto_pad],l=t.dilations,m=t.group,h=t.kernel_shape,u=t.pads,w=t.strides,_=t.w_is_const();return ye({autoPad:d,format:e,dilations:l,group:m,kernelShape:h,pads:u,strides:w,wIsConst:_,...r})},fm=(t,r,e)=>{let d=vu(e,r);if(e.group!==1){t.compute(Pi(r,d));return}let l=e.format==="NHWC",m=r.length===3,h=r[0].dims[l?1:2],u=r[0].dims[l?2:3],w=r[0].dims[l?3:1],_=r[1].dims[2],O=r[1].dims[3],j=Ri(r[0].dims,r[1].dims,e.dilations,d.pads,e.strides,l),B=j[l?1:2],P=j[l?2:3],R=j[l?3:1],T=l&&_===h&&O===u&&e.pads[0]===0&&e.pads[1]===0;if(T||_===1&&O===1&&e.dilations[0]===1&&e.dilations[1]===1&&e.strides[0]===1&&e.strides[1]===1&&e.pads[0]===0&&e.pads[1]===0){let A=j[0],Z,re,ie,Ce=[];if(l){let H=t.kernelCustomData.wT??t.compute(fr(r[1].dataType,r[1].dims.length,bu),{inputs:[1],outputs:[e.wIsConst?-2:-1]})[0];if(e.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=H),T){let le=h*u*w;Z=r[0].reshape([1,A,le]),re=H.reshape([1,le,R]),ie=[1,A,R]}else Z=r[0].reshape([A,h*u,w]),re=H.reshape([1,w,R]),ie=[A,B*P,R];Ce.push(Z),Ce.push(re)}else Z=r[0].reshape([A,w,h*u]),re=r[1].reshape([1,R,w]),ie=[A,R,B*P],Ce.push(re),Ce.push(Z);m&&Ce.push(r[2]),t.compute(Zn(Ce,d,j,ie,l),{inputs:Ce});return}let k=!0,U=t.kernelCustomData.wT??t.compute(fr(r[1].dataType,r[1].dims.length,bu),{inputs:[1],outputs:[e.wIsConst?-2:-1]})[0];e.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=U);let K=[r[0],U];m&&K.push(r[2]);let Q=l?B*P:R,L=l?R:B*P,X=_*O*w;t.compute(fu(K,d,j,Q,L,X,m,k),{inputs:K})},pm=(t,r)=>{let e=r.format==="NHWC",d=[t.inputs[0].reshape(e?[t.inputs[0].dims[0],1,t.inputs[0].dims[1],t.inputs[0].dims[2]]:[t.inputs[0].dims[0],t.inputs[0].dims[1],1,t.inputs[0].dims[2]]),t.inputs[1].reshape([t.inputs[1].dims[0],t.inputs[1].dims[1],1,t.inputs[1].dims[2]])];t.inputs.length===3&&d.push(t.inputs[2]);let l=[0,r.pads[0],0,r.pads[1]],m=[1].concat(r.strides),h=[1].concat(r.dilations),u=[1].concat(r.kernelShape),w=vu({...r,pads:l,strides:m,dilations:h,kernelShape:u},d);t.compute(Pi(d,w,_=>e?[_[0],_[2],_[3]]:[]))},Cu=(t,r)=>{dm(t.inputs,r),t.inputs[0].dims.length===3?pm(t,r):fm(t,t.inputs,r)}});var mm,$u,xu=oe(()=>{"use strict";Tt();Ae();Yn();Ei();un();mm=(t,r=!1,e,d=!1,l=4)=>{let m=Qe(l,"f32"),h=U=>{switch(U){case 1:return"return W[getIndexFromCoords4D(coord, wShape)];";case 4:return`\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            `;default:throw new Error(`innerElementSize ${U} is not supported.`)}},u=t?`\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      `:`\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      `,w=t?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,_=t?"outBackprop[1]":"outBackprop[2]",O=t?"outBackprop[2]":"outBackprop[3]",j=t?"row":"col",B=t?"col":"row",P=`\n      let inChannels = ${t?"outBackprop[3]":"outBackprop[1]"};\n      let outWidth = ${t?"outShape[2]":"outShape[3]"};\n      let outRow = ${j} / outWidth;\n      let outCol = ${j} % outWidth;\n\n      let WRow = ${B} / (filterDims[1] * inChannels);\n      let WCol = ${B} / inChannels % filterDims[1];\n      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);\n      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);\n      if (xR < 0.0 || xR >= f32(${_}) || fract(xR) > 0.0) {\n        return ${m}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${O}) || fract(xC) > 0.0) {\n        return ${m}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${B} % inChannels;\n      ${u}\n      return x[getIndexFromCoords4D(coord, xShape)/${l}];`,R=t?`\n      let col = colIn * ${l};\n      if (row < dimAOuter && col < dimInner) {\n        ${P}\n      }\n      return ${m}(0.0);`:`\n      let col = colIn * ${l};\n      if (row < dimInner && col < dimBOuter) {\n        ${P}\n      }\n      return ${m}(0.0);`,T=`\n      let col = colIn * ${l};\n      let inChannels = ${t?"outBackprop[3]":"outBackprop[1]"};\n      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);\n      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];\n      if (${t?"row < dimInner && col < dimBOuter":"row < dimInner && col < dimAOuter"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${h(l)}\n      }\n      return ${m}(0.0);\n      `;return`\n  ${Kn(e,d,l===4,4)}\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${m} {\n    ${t?R:T}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${m} {\n    ${t?T:R}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${m}) {\n    let col = colIn * ${l};\n    if (row < dimAOuter && col < dimBOuter) {\n      var value = valueInput;\n      let outWidth = ${t?"outShape[2]":"outShape[3]"};\n      ${w}\n      ${qn(r,e)}\n      result[getIndexFromCoords4D(coords, outShape)/${l}] = value;\n    }\n  }`},$u=(t,r,e,d,l,m,h,u)=>{let w=r.format==="NHWC",_=w?t[0].dims[3]:t[0].dims[1],O=e[0],j=w?e[2]:e[3],B=w?e[1]:e[2],P=w?e[3]:e[1],R=w?_%4===0&&P%4===0:j%4===0&&P%4===0,T=w?P:j*B,k=w?j*B:P,U=R?[8,8,1]:[T<=4||k<=4?4:16,T>4&&k<=4?4:16,1],K=R?[4,4,1]:[T<=4?1:4,T>4&&k<=4?1:4,1],Q=[Math.ceil(T/U[0]/K[0]),Math.ceil(k/U[1]/K[1]),Math.ceil(O/U[2]/K[2])];ze("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${Q}`);let L=R?4:1,X=Math.max(U[0]*L,U[1]),A=[`@group(0) @binding(0) var<storage, read> x: array<${R?"vec4<f32>":"f32"}>;`,"@group(0) @binding(1) var<storage, read> W: array<f32>;"],Z="";return h&&(A.push(`@group(0) @binding(2) var<storage, read> bias: array<${R?"vec4<f32>":"f32"}>;`),Z+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${R?"vec4<f32>":"f32"} {\n          return bias[coords.${w?"w":"y"}${R?"/ 4":""}];\n        }`),{name:"Conv2DTransposeMatMul",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:e,dataType:t[0].dataType}],dispatchGroup:{x:Q[0],y:Q[1],z:Q[2]}}),getShaderSource:()=>`\n        ${Xn}\n        ${A.join(`\n`)}\n        @group(0) @binding(${A.length}) var<storage, read_write> result: array<${R?"vec4<f32>":"f32"}>;\n        const outBackprop : vec4<i32> = vec4<i32>(${t[0].dims.join(",")});\n        const xShape : vec4<i32> = vec4<i32>(${t[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${t[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${e.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${Y.computeStrides(e).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${r.kernelShape[w?1:2]}, ${r.kernelShape[w?2:3]});\n        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(\n              ${r.dilations[0]<=1?0:(r.kernelShape[w?1:2]-1)*(r.dilations[0]-1)},\n              ${r.dilations[1]<=1?0:(r.kernelShape[w?2:3]-1)*(r.dilations[1]-1)});\n        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,\n                                         i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);\n        const strides : vec2<i32> = vec2<i32>(${r.strides[0]}, ${r.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${r.dilations[0]}, ${r.dilations[1]});\n        const dimAOuter : i32 = ${d};\n        const dimBOuter : i32 = ${l};\n        const dimInner : i32 = ${m};\n        ${Z}\n        ${mm(w,h,void 0,!1,L)}\n        ${R?an(K,U,"f32",void 0,!w,X):sn(K,U,"f32",void 0,!w,X,!1,void 0,u)}`}}});var hm,Bi,Su=oe(()=>{"use strict";Tt();Ae();Pe();hm=(t,r,e,d,l,m,h=!1,u)=>{let w=e.format==="NHWC",_=w?1:2,O=w?2:3,j=w?3:1,B=Y.size(d),P=h?2:1,R=e.group,T=r[1].dims,k=T[0]/R,U=T[1],K=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${h?`vec4<${u}>`:u}) {\n    result[flatIndex] = ${h?`vec4<${u}>`:u}(value);\n  }`;l&&(K+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${h?`vec4<${u}>`:u} {\n      return bias[coords.${w?"w":"y"}${h?"/ 4":""}];\n    }`);let Q=h?4:1,L=ne("W",r[1].dataType,r[1].dims,Q),X=ne("Dy",r[0].dataType,r[0].dims,Q),A=[X,L];l&&A.push(ne("bias",r[2].dataType,[d[j]],Q));let Z=fe("result",r[0].dataType,d,Q),re=`{\n        let batch: u32 = ${m?"global_id.z":"workgroup_id.z"} / outShape[1];\n        let r = ${m?"global_id.z":"workgroup_id.z"} % outShape[1];\n        let c = ${m?"global_id.y":"workgroup_id.y"} * ${P};\n        let d1: u32 = ${m?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${u}>, ${P}>;\n        for (var i = 0; i < ${P}; i++) {\n          dotProd[i] = vec4<${u}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {\n          var dyR = (${u}(dyCorner.x) + ${u}(wR)) / ${u}(strides.x);\n          let wRPerm = filterDims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${u}(outBackprop[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {\n            let dyC = (${u}(dyCorner.y) + ${u}(wC)) / ${u}(strides.y);\n            let dyC2 = (${u}(dyCorner.y) + 1.0 + ${u}(wC)) / ${u}(strides.y);\n            let wCPerm = filterDims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${u}(outBackprop[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${u}(outBackprop[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${X.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${u}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${X.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${u}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = outBackprop[${j}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${X.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${u}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${X.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${u}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${P}; i = i + 1) {\n          let value = dotProd[i] + ${l?"bias[c+i]":"0.0"};\n          ${Z.set("batch","r","c + i","d1","value")};\n        }\n      }`,ie=`\n          let outputIndices = ${Z.offsetToIndices("global_idx")};\n          let batch = ${Z.indicesGet("outputIndices",0)};\n          let d1 = ${Z.indicesGet("outputIndices",j)};\n          let r = ${Z.indicesGet("outputIndices",_)};\n          let c = ${Z.indicesGet("outputIndices",O)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / ${U};\n          let wOutChannel = d1 - groupId * ${U};\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = 0.0;\n          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {\n            if (wR % dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${u}(dyRCorner) + ${u}(wR)) / ${u}(strides[0]);\n            let wRPerm = filterDims.x - 1 - wR / dilations.x;\n            if (dyR < 0.0 || dyR >= ${u}(outBackprop[${_}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {\n              if (wC % dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${u}(dyCCorner) + ${u}(wC)) / ${u}(strides.y);\n              let wCPerm = filterDims.y - 1 - wC / dilations.y;\n              if (dyC < 0.0 || dyC >= ${u}(outBackprop[${O}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * ${k};\n              for (var d2: u32 = 0; d2 < ${k}; d2 = d2 + 1) {\n                let xValue = ${w?X.get("batch","idyR","idyC","inputChannel"):X.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${L.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${l?"bias[d1]":"0.0"};\n          ${Z.setByOffset("global_idx","value")};\n        `;return`\n  ${t.declareVariables(...A,Z)}\n  ${K}\n  const outShape : vec4<u32> = vec4<u32>(${d.join(",")});\n  const outBackprop : vec4<u32> = vec4<u32>(${r[0].dims.join(",")});\n  const strides : vec2<u32> = vec2<u32>(${e.strides[0]}, ${e.strides[1]});\n  const filterDims : vec2<u32> = vec2<u32>(${e.kernelShape[w?1:2]}, ${e.kernelShape[w?2:3]});\n  const dilations : vec2<u32> = vec2<u32>(${e.dilations[0]}, ${e.dilations[1]});\n  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(\n          ${e.dilations[0]<=1?0:(e.kernelShape[w?1:2]-1)*(e.dilations[0]-1)},\n          ${e.dilations[1]<=1?0:(e.kernelShape[w?2:3]-1)*(e.dilations[1]-1)});\n  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${e.pads[0]+e.pads[2]})/2,\n                                     i32(effectiveFilterDims[1]) - 1 - (${e.pads[1]+e.pads[3]})/2);\n    ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes(B)};\n  ${h?re:ie}}`},Bi=(t,r,e)=>{let d=t.length>2,l=r.outputShape,m=Y.size(l),h=[Math.ceil(m/64),1,1];ze("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${h}`);let u=Fe(t[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:r.cacheKey},getRunData:()=>({dispatchGroup:{x:h[0],y:h[1],z:h[2]},outputs:[{dims:e?e(l):l,dataType:t[0].dataType}]}),getShaderSource:w=>hm(w,t,r,l,d,h[1]===1&&h[2]===1,!1,u)}}});var gm,ym,bm,_u,Au,vm,wm,Cm,$m,Iu,Tu=oe(()=>{"use strict";Ne();xu();Su();on();ei();gm=(t,r,e,d,l,m)=>(t-1)*r+e+(d-1)*l+1-m,ym=(t,r,e,d,l)=>{let m=Math.floor(t/2);r==="SAME_UPPER"?(e[d]=m,e[l]=t-m):r==="SAME_LOWER"&&(e[d]=t-m,e[l]=m)},bm=(t,r,e,d,l,m,h,u,w,_)=>{let O=t.length-2,j=_.length===0;if(w.length===0)for(let R=0;R<O;++R)w.push(0);let B=t[0],P=r[u?3:1]*l;for(let R=0,T=t.length-O-(u?1:0);R<O;++R,++T){let k=t[T],U=j?k*h[R]:_[R],K=gm(k,h[R],m[R],r[T],e[R],U);ym(K,d,m,R,R+O),j&&_.push(h[R]*(k-1)+w[R]+(r[T]-1)*e[R]+1-m[R]-m[R+O])}_.splice(0,0,B),_.splice(u?3:1,0,P)},_u=(t,r)=>{let e=t.kernelShape.slice();if(t.kernelShape.length===0||t.kernelShape.reduce((B,P)=>B*P,1)===0){e.length=0;for(let B=2;B<r[1].dims.length;++B)e.push(r[1].dims[B])}let d=t.format==="NHWC";e.splice(0,0,r[1].dims[0]),e.splice(d?3:1,0,r[1].dims[1]);let l=t.pads.slice(),m=t.outputShape.slice(),h=t.outputPadding.slice(),u=r[0].dims,w=t.dilations.slice();if(w.reduce((B,P)=>B+P,0)===0){let B=r[0].dims.length-2;w=new Array(B).fill(1)}let _=t.strides.slice();if(_.reduce((B,P)=>B+P,0)===0){let B=r[0].dims.length-2;_=new Array(B).fill(1)}bm(u,e,w,t.autoPad,t.group,l,_,d,h,m);let O=Object.assign({},t),j=t.cacheKey+[e.join("n,"),l.join(","),_.join(","),h.join(","),m.join(","),w.join(",")].join("_");return Object.assign(O,{kernelShape:e,pads:l,outputPadding:h,outputShape:m,dilations:w,strides:_,cacheKey:j}),O},Au=t=>{let r=Jn(t),e=t.format,d=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof t.autoPad>"u"?0:t.autoPad],l=t.dilations,m=t.group,h=t.kernelShape,u=t.pads,w=t.strides,_=t.wIsConst(),O=t.outputPadding,j=t.outputShape;return ye({autoPad:d,format:e,dilations:l,group:m,kernelShape:h,outputPadding:O,outputShape:j,pads:u,strides:w,wIsConst:_,...r})},vm=(t,r)=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(t[0].dims.length!==4&&t[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(t[0].dims.length!==t[1].dims.length)throw new Error("filter does not have same dimension as input");let e=t[0].dims[r.format==="NHWC"?t[0].dims.length-1:1],d=t[1].dims[0];if(e!==d)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let l=t[1].dims[1]*r.group;if(t.length===3&&(t[2].dims.length!==1||t[2].dims[0]!==l))throw new Error("invalid bias");let m=t[0].dims.length-2;if(r.dilations.reduce((O,j)=>O+j,0)>0&&r.dilations.length!==m)throw new Error(`dilations should be ${m}D`);if(r.strides.reduce((O,j)=>O+j,0)>0&&r.strides.length!==m)throw new Error(`strides should be ${m}D`);if(r.pads.reduce((O,j)=>O+j,0)>0&&r.pads.length!==m*2)throw new Error(`pads should be ${m*2}D`);if(r.outputPadding.length!==m&&r.outputPadding.length!==0)throw new Error(`output_padding should be ${m}D`);if(r.kernelShape.reduce((O,j)=>O+j,0)>0&&r.kernelShape.length!==0&&r.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape");if(r.outputShape.length!==0&&r.outputShape.length!==t[0].dims.length-2)throw new Error("invalid output shape")},wm=[2,3,1,0],Cm=(t,r,e)=>{let d=_u(e,r),l=e.format==="NHWC",m=r.length===3;if(d.group!==1){t.compute(Bi(r,d));return}let h=d.outputShape,u=h[l?1:2],w=h[l?2:3],_=h[l?3:1],O=r[1].dims[2],j=r[1].dims[3],B=r[0].dims[l?3:1],P=l?u*w:_,R=l?_:u*w,T=O*j*B,k=!0,U=t.kernelCustomData.wT??t.compute(fr(r[1].dataType,r[1].dims.length,wm),{inputs:[1],outputs:[e.wIsConst?-2:-1]})[0];e.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=U);let K=[r[0],U];m&&(!l&&r[2].dims.length===1?K.push(r[2].reshape([r[2].dims[0],1,1])):K.push(r[2])),t.compute($u(K,d,h,P,R,T,m,k),{inputs:K})},$m=(t,r)=>{let e=r.format==="NHWC",d=[t.inputs[0].reshape(e?[t.inputs[0].dims[0],1,t.inputs[0].dims[1],t.inputs[0].dims[2]]:[t.inputs[0].dims[0],t.inputs[0].dims[1],1,t.inputs[0].dims[2]]),t.inputs[1].reshape([t.inputs[1].dims[0],t.inputs[1].dims[1],1,t.inputs[1].dims[2]])];d.length===3&&d.push(t.inputs[2]);let l=r.kernelShape;(l.length===0||l[0]===0)&&(l=[t.inputs[1].dims[2]]);let m=r.dilations;(m.length===0||m[0]===0)&&(m=[1]);let h=r.strides;(h.length===0||h[0]===0)&&(h=[1]);let u=r.pads;u.length===0&&(u=[0,0]),u=[0,u[0],0,u[1]],h=[1].concat(h),m=[1].concat(m),l=[1].concat(l);let w=_u({...r,pads:u,strides:h,dilations:m,kernelShape:l},d);t.compute(Bi(d,w,_=>e?[_[0],_[2],_[3]]:[_[0],_[1],_[3]]))},Iu=(t,r)=>{vm(t.inputs,r),t.inputs[0].dims.length===3?$m(t,r):Cm(t,t.inputs,r)}});var Mi,ti,Ou,xm,Sm,ji,Di,_m,Eu,Pu,Ru=oe(()=>{"use strict";Ae();Ne();Pe();Mi="[a-zA-Z]|\\\\.\\\\.\\\\.",ti="("+Mi+")+",Ou="^"+ti+"$",xm="("+ti+",)*"+ti,Sm="^"+xm+"$",ji=class{constructor(r=-1){this.symbolToIndices=new Map,this.inputIndex=r}addSymbol(r,e){let d=this.symbolToIndices.get(r);d===void 0?d=[e]:d.push(e),this.symbolToIndices.set(r,d)}},Di=class{constructor(r,e){this.equation=e;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[d,l]=e.includes("->")?e.split("->",2):[e,""];if(!d.match(RegExp(Sm)))throw new Error("Invalid LHS term");if(d.split(",").forEach((u,w)=>{let _=r[w].dims.slice();if(!u.match(RegExp(Ou)))throw new Error("Invalid LHS term");let O=this.processTerm(u,!0,_,w);this.lhs.push(O)}),l==="")l+=[...this.symbolToInfo.entries()].filter(([u,w])=>w.count===1||u==="...").map(([u])=>u).join("");else if(!l.match(RegExp(ti)))throw new Error("Invalid RHS");l.match(RegExp(Mi,"g"))?.forEach(u=>{if(u==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let w=this.symbolToInfo.get(u);if(w===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(w.dimValue)}}),this.rhs=this.processTerm(l,!0,this.outputDims)}addSymbol(r,e,d){let l=this.symbolToInfo.get(r);if(l!==void 0){if(l.dimValue!==e&&l.count!==1)throw new Error("Dimension mismatch");l.count++,l.inputIndices.push(d)}else l={count:1,dimValue:e,inputIndices:[d]};this.symbolToInfo.set(r,l)}processTerm(r,e,d,l=-1){let m=d.length,h=!1,u=[],w=0;if(!r.match(RegExp(Ou))&&!e&&r!=="")throw new Error("Invalid LHS term");let _=r.match(RegExp(Mi,"g")),O=new ji(l);return _?.forEach((j,B)=>{if(j==="..."){if(h)throw new Error("Only one ellipsis is allowed per input term");h=!0;let P=m-_.length+1;if(P<0)throw new Error("Ellipsis out of bounds");if(u=d.slice(w,w+P),this.hasEllipsis){if(this.ellipsisDims.length!==u.length||this.ellipsisDims.toString()!==u.toString())throw new Error("Ellipsis dimensions mismatch")}else if(e)this.hasEllipsis=!0,this.ellipsisDims=u;else throw new Error("Ellipsis must be specified in the LHS");for(let R=0;R<u.length;R++){let T=String.fromCharCode("0".charCodeAt(0)+B);O.addSymbol(T,B+R),this.addSymbol(T,d[w++],l)}}else O.addSymbol(j,B),this.addSymbol(j,d[w++],l)}),O}},_m=(t,r)=>{let e=t[0].dataType,d=new Array(t.length);for(let Q=0;Q<t.length;++Q)d[Q]=ne(`input${Q}`,e,t[Q].dims);let l=r.outputDims,m=Y.size(l),h=fe("output",e,l),u=[],w=Array.from(r.rhs.symbolToIndices.keys()),_="var prod = 1.0;",O="var sum = 0.0;",j="sum += prod;",B=[],P=[],R=[],T=[],k=r.symbolToInfo.size===w.length;r.symbolToInfo.forEach((Q,L)=>{if(w.includes(L)){let X=w.indexOf(L);r.lhs.forEach((A,Z)=>{if(Q.inputIndices.includes(Z)){let re=A.symbolToIndices.get(L);if(re===void 0)throw new Error("Invalid symbol error");re.forEach(ie=>{u.push(`${d[Z].indicesSet(`input${Z}Indices`,ie,h.indicesGet("outputIndices",X))}`)})}})}else r.lhs.forEach((X,A)=>{let Z=r.symbolToInfo.get(L);if(Z===void 0)throw new Error("Invalid symbol error");if(Z.inputIndices.includes(A)){let re=X.symbolToIndices.get(L);if(re===void 0)throw new Error("Invalid symbol error");re.forEach(ie=>{B.push(`${d[A].indicesSet(`input${A}Indices`,ie,`${L}`)}`)}),T.push(`prod *= ${d[A].getByIndices(`input${A}Indices`)};`)}}),P.push(`for(var ${L}: u32 = 0; ${L} < ${r.symbolToInfo.get(L)?.dimValue}; ${L}++) {`),R.push("}")});let U=k?[...u,`let sum = ${d.map((Q,L)=>Q.getByIndices(`input${L}Indices`)).join(" * ")};`]:[...u,O,...P,...B,_,...T,j,...R],K=Q=>`\n      ${Q.declareVariables(...d,h)}\n\n      ${Q.mainStart()}\n        ${Q.guardAgainstOutOfBoundsWorkgroupSizes(m)}\n        var outputIndices = ${h.offsetToIndices("global_idx")};\n        ${d.map((L,X)=>`var input${X}Indices: ${d[X].type.indices};`).join(`\n`)}\n        ${U.join(`\n`)};\n        ${h.setByOffset("global_idx","sum")};\n      }`;return{name:"Einsum",shaderCache:{hint:r.equation},getRunData:()=>({outputs:[{dims:l,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)}}),getShaderSource:K}},Eu=(t,r)=>{let e=new Di(t.inputs,r.equation);t.compute(_m(t.inputs,e))},Pu=t=>{let r=t.equation.replace(/\\s+/g,"");return ye({equation:r})}});var Am,ku,Im,Tm,Bu,Mu=oe(()=>{"use strict";Ae();Pe();Am=t=>{if(!t||t.length!==2)throw new Error("Expand requires 2 input.");let r=t[0].dims,e=Array.from(t[1].getBigInt64Array(),Number),d=e.length<r.length?0:e.length-r.length,l=r.length<e.length?0:r.length-e.length;for(;d<e.length&&l<r.length;++d,++l)if(e[d]!==r[l]&&e[d]!==1&&r[l]!==1)throw new Error("Expand requires shape to be broadcastable to input")},ku=(t,r)=>{let e=t.length-r.length,d=[];for(let l=0;l<e;++l)d.push(t[l]);for(let l=0;l<r.length;++l)d.push(r[l]===1?t[l+e]:r[l]);return d},Im=(t,r)=>t.length>r.length?ku(t,r):ku(r,t),Tm=t=>{let r=t[0].dims,e=Array.from(t[1].getBigInt64Array(),Number),d=Im(r,e),l=Y.size(d),m=t[0].dataType,h=ne("input",m,r),u=fe("output",m,d),w=_=>`\n  const inputShape = ${h.indices(...r)};\n  ${_.declareVariables(h,u)}\n  ${_.mainStart()}\n  ${_.guardAgainstOutOfBoundsWorkgroupSizes(l)}\n    let outputIndices = ${u.offsetToIndices("global_idx")};\n    var inputIndices: ${h.type.indices};\n    for (var i = 0; i < ${r.length}; i++) {\n      if (${h.indicesGet("inputShape","i")} == 1) {\n        ${h.indicesSet("inputIndices","i",0)}\n      } else {\n        ${h.indicesSet("inputIndices","i",u.indicesGet("outputIndices",`i + ${d.length-r.length}`))}\n      }\n    }\n    ${u.setByOffset("global_idx",h.getByIndices("inputIndices"))}\n  }`;return{name:"Expand",shaderCache:{hint:`${d}`},getShaderSource:w,getRunData:()=>({outputs:[{dims:d,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)}})}},Bu=t=>{Am(t.inputs),t.compute(Tm(t.inputs),{inputs:[0]})}});var Om,Em,ju,Du,Wu=oe(()=>{"use strict";Ae();Ne();Pe();Om=t=>{if(!t||t.length!==2)throw new Error("Gather requires 2 inputs.")},Em=(t,r)=>{let e=t[0].dims,d=t[1].dims,l=e.length,m=Y.normalizeAxis(r.axis,l),h=e.slice(0);h.splice(m,1,...d);let u=e[m],w=Y.size(h),_=ne("data",t[0].dataType,t[0].dims),O=ne("inputIndices",t[1].dataType,t[1].dims),j=fe("output",t[0].dataType,h),B=()=>{let R=d.length,T=`var indicesIndices  = ${O.type.indices}(0);`;for(let k=0;k<R;k++)T+=`${R>1?`indicesIndices[${k}]`:"indicesIndices"} = ${h.length>1?`outputIndices[${m+k}]`:"outputIndices"};`;T+=`\n        var idx = ${O.getByIndices("indicesIndices")};\n        if (idx < 0) {\n          idx = idx + ${u};\n        }\n        var dataIndices = ${_.type.indices}(0);\n      `;for(let k=0,U=0;k<l;k++)k===m?(T+=`${l>1?`dataIndices[${k}]`:"dataIndices"} = u32(idx);`,U+=R):(T+=`${l>1?`dataIndices[${k}]`:"dataIndices"} = ${h.length>1?`outputIndices[${U}]`:"outputIndices"};`,U++);return T},P=R=>`\n      ${R.declareVariables(_,O,j)}\n      ${R.mainStart()}\n        ${R.guardAgainstOutOfBoundsWorkgroupSizes(w)}\n        let outputIndices = ${j.offsetToIndices("global_idx")};\n        ${B()};\n        let value = ${_.getByIndices("dataIndices")};\n        ${j.setByOffset("global_idx","value")};\n      }`;return{name:"Gather",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:h,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)}}),getShaderSource:P}},ju=t=>ye({axis:t.axis}),Du=(t,r)=>{let e=t.inputs;Om(e),t.compute(Em(t.inputs,r))}});var Pm,Rm,zu,Gu,Vu=oe(()=>{"use strict";Ae();Ne();Pe();Pm=t=>{if(!t||t.length!==2)throw new Error("GatherElements requires 2 inputs.");if(t[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(t[0].dims.length!==t[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},Rm=(t,r)=>{let e=t[0].dims,d=t[0].dataType,l=e.length,m=Y.computeStrides(e),h=Y.size(e),u=t[1].dims,w=t[1].dataType,_=Y.size(u),O=Y.normalizeAxis(r.axis,l),j=e[O],B=u.slice(0),P=Y.size(B),R=ne("input",d,e),T=ne("indices",w,[_]),k=fe("output",d,B),U=K=>`\n      const inputStrides = array<u32, ${m.length}>(${m.map(Q=>`${Q}u`).join(",")});\n      ${K.declareVariables(R,T,k)}\n      ${K.mainStart()}\n      ${K.guardAgainstOutOfBoundsWorkgroupSizes(P)}\n\n      let outputIndices = ${k.offsetToIndices("global_idx")};\n\n      var idx = ${T.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + ${j};\n      }\n\n      var srcOffset = u32(0);\n\n      for (var i = 0; i < ${e.length}; i++) {\n        if (i == ${O}) {\n          srcOffset +=  u32(idx) * inputStrides[i];\n        } else {\n          srcOffset += ${k.indicesGet("outputIndices","i")} * inputStrides[i];\n        }\n      }\n\n      // Should never hit this with valid values in indices\n      // This is a guard against malicious data in the indices input\n      if (srcOffset < 0 || srcOffset >= ${h}) {\n        return;\n      }\n\n      output[global_idx] = input[srcOffset];\n  }`;return{name:"GatherElements",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:B,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(P/64)}}),getShaderSource:U}},zu=t=>ye({axis:t.axis}),Gu=(t,r)=>{let e=t.inputs;Pm(e),t.compute(Rm(t.inputs,r))}});var km,Bm,Mm,Uu,Nu,Fu=oe(()=>{"use strict";Ae();Ne();Pe();km=t=>{if(!t)throw new Error("Input is missing");if(t.length<2||t.length>3)throw new Error("Invaid input number.");if(t.length===3&&t[2].dims.length>2)throw new Error("Invalid input shape of C");if(t[0].dataType!==t[1].dataType||t.length===3&&t[0].dataType!==t[2].dataType)throw new Error("Input types are mismatched")},Bm=(t,r,e)=>{if(e.length===0)return"0u";let d=e.length===1&&t!==1||e.length===2&&e[0]!==t,l=e[e.length-1]!==r,m="0u";return d||(m+=`+ m * ${e[e.length-1]}u`),l||(m+="+n"),m},Mm=(t,r)=>{let e=t[0].dims.slice(),d=t[1].dims.slice(),[l,m,h]=Vn.getShapeOfGemmResult(e,r.transA,d,r.transB,t.length===3?t[2].dims:void 0),u=[l,m];if(!u)throw new Error("Can\'t use gemm on the given tensors");let w=Y.size(u),_="";r.transA&&r.transB?_="value += a[k * M + m] * b[n * K + k];":r.transA&&!r.transB?_="value += a[k * M + m] * b[k * N + n];":!r.transA&&r.transB?_="value += a[m * K + k] * b[n * K + k];":!r.transA&&!r.transB&&(_="value += a[m * K + k] * b[k * N + n];");let O=Fe(t[0].dataType),j=r.alpha===1?"":"value *= alpha;",B=t.length===3?`value += beta * c[${Bm(l,m,t[2].dims)}];`:"",P=[`@group(0) @binding(0) var<storage, read> a : array<${O}>;`,`@group(0) @binding(1) var<storage, read> b : array<${O}>;`];t.length===3&&P.push(`@group(0) @binding(2) var<storage, read> c : array<${O}>;`);let R=T=>`\n  const M: u32 = ${l}u;\n  const N: u32 = ${m}u;\n  const K: u32 = ${h}u;\n  const alpha = ${O}(${r.alpha});\n  const beta = ${O}(${r.beta});\n\n  ${P.join(`\n`)}\n  @group(0) @binding(${t.length}) var<storage, read_write> output : array<${O}>;\n\n  ${T.mainStart()}\n    ${T.guardAgainstOutOfBoundsWorkgroupSizes(w)}\n\n    let m = global_id.x / N;\n    let n = global_id.x % N;\n\n    var value = ${O}(0);\n    for (var k: u32 = 0u; k<${h}u; k++) {\n      ${_}\n    }\n\n    ${j}\n    ${B}\n    output[global_id.x] = value;\n\n  }`;return{name:"Gemm",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:u,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)}}),getShaderSource:R}},Uu=(t,r)=>{km(t.inputs),t.compute(Mm(t.inputs,r))},Nu=t=>ye(t)});var jm,Dm,Wm,zm,Hu,Lu,Ku=oe(()=>{"use strict";Xe();Ae();Ne();Pe();jm={name:"InstanceNormalization"},Dm=(t,r)=>{let e=t[0].dims,d=e,l=2,m=Y.sizeToDimension(e,l),h=Y.sizeFromDimension(e,l),u=e[1],w=ne("x",t[0].dataType,[e[0],e[1],h]),_=ne("scale",t[1].dataType,t[1].dims),O=ne("bias",t[2].dataType,t[2].dims),j=fe("output",t[0].dataType,[e[0],e[1],h]),B=[w,_,O,j],P=w.type.value,R=64,T=k=>`\n\n  const C: u32 = ${u};\n  const normSize: u32 = ${h};\n  const epsilon: f32 = ${r.epsilon};\n  var<workgroup> meanShared : ${P};\n  var<workgroup> squaredNormShared : ${P};\n  var<workgroup> workgroupShared : array<${P}, ${R}>;\n  const workgroupSize = ${R}u;\n  ${k.declareVariables(...B)}\n  ${k.mainStart(R)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / C;\n    let channel = norm % C;\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial: ${P} = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      initial = initial + ${w.get("batch","channel","h")};\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = workgroupShared[0] / ${P}(normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let deviation =  ${w.get("batch","channel","h")} - meanShared;\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = workgroupShared[0];\n    }\n    workgroupBarrier();\n\n    let invStdDev = 1 / sqrt(squaredNormShared / ${P}(normSize) + epsilon);\n    let channelScale = invStdDev * ${_.getByOffset("channel")};\n    let channelShift = ${O.getByOffset("channel")} - meanShared * channelScale;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let value = ${w.get("batch","channel","h")} * channelScale + channelShift;\n      ${j.set("batch","channel","h","value")};\n    }\n  }`;return{...jm,shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:d,dataType:t[0].dataType}],dispatchGroup:{x:m}}),getShaderSource:T}},Wm=(t,r,e,d,l,m,h,u)=>{let w=Ft(h),_=ne("input",r.dataType,r.dims,w),O=ne("scale",e.dataType,e.dims,w),j=ne("bias",d.dataType,d.dims,w),B=64,P=w===1?"vec2f":`mat2x${w}f`,R=w===1?"f32":`vec${w}f`,T=(X,A)=>`${P}(${X}, ${A})`,k=l*h/w,U=Math.ceil(m/B),K=X=>`\n  const H: u32 = ${m};\n  const C: u32 = ${h/w};\n  const imageSize: u32 = ${m*h/w};\n\n  ${X.declareVariables(_)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${P}>;\n\n  ${X.mainStart(B)}\n    let currentImageNumber = global_idx / ${B} / C;\n    let currentChannelNumber = (global_idx / ${B}) % C;\n    let wgId = global_idx % ${B};\n    let wgOffset = wgId * ${U};\n    if (wgOffset >= H) {\n        return;\n    }\n    let wgMax = min(wgOffset + ${U}, H);\n\n    let offset = currentImageNumber * imageSize + currentChannelNumber;\n    var sum = ${mt("f32",w)};\n    var squaredSum = ${mt("f32",w)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${R}(input[offset + i * C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${T("sum","squaredSum")};\n  }`,Q=t.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:w,n:l,h:m,c:h})},getRunData:()=>({outputs:[{dims:[l,h,B,2],dataType:1}],dispatchGroup:{x:l*h/w}}),getShaderSource:K},{inputs:[r],outputs:[-1]})[0],L=X=>`\n  const H: u32 = ${m};\n  const C: u32 = ${h/w};\n  const imageSize: u32 = ${B*h/w};\n  const epsilon: f32 = ${u};\n\n  @group(0) @binding(0) var<storage, read> input : array<${P}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${O.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${j.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${P}>;\n\n  ${X.mainStart()}\n    ${X.guardAgainstOutOfBoundsWorkgroupSizes(k)}\n    let currentImageNumber = global_idx / C;\n    let currentChannelNumber = global_idx % C;\n\n    let offset = currentImageNumber * imageSize;\n    var sum = ${mt("f32",w)};\n    var squaredSum = ${mt("f32",w)};\n    for (var i: u32 = 0; i < ${B}; i++) {\n        let value = input[offset + i + currentChannelNumber * ${B}];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(H);\n    squaredSum = squaredSum / f32(H);\n    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);\n    let channelScale = invStdDev * ${R}(scale[currentChannelNumber]);\n    let channelShift = ${R}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${T("channelScale","channelShift")};\n  }`;return t.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:w,n:l,h:m,c:h,epsilon:u})},getRunData:()=>({outputs:[{dims:[l,h,2],dataType:1}],dispatchGroup:{x:Math.ceil(k/64)}}),getShaderSource:L},{inputs:[Q,e,d],outputs:[-1]})[0]},zm=(t,r,e)=>{let d=r[0].dims,l=d,m=d[0],h=d[d.length-1],u=Y.sizeFromDimension(d,1)/h,w=Ft(h),_=Y.size(l)/w,O=ne("input",r[0].dataType,r[0].dims,w),j=fe("output",r[0].dataType,l,w),B=Fe(r[0].dataType),P=w===1?"vec2f":`mat2x${w}f`,R=w===1?B:`vec${w}<${B}>`,T=Wm(t,r[0],r[1],r[2],m,u,h,e.epsilon),k=U=>`\n  const H: u32 = ${u};\n  const C: u32 = ${h/w};\n\n  @group(0) @binding(0) var<storage, read> input : array<${O.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${P}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${j.type.storage}>;\n\n  ${U.mainStart()}\n    let currentImageNumber = global_idx / (C * H);\n    let currentChannelNumber = global_idx % C;\n\n    let scaleOffset = currentImageNumber * C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${R}(scale[0]), ${R}(scale[1]));\n  }`;t.compute({name:"InstanceNormalization",shaderCache:{hint:`${e.cacheKey}`},getRunData:()=>({outputs:[{dims:l,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(_/64)}}),getShaderSource:k},{inputs:[r[0],T]})},Hu=t=>ye({epsilon:t.epsilon,format:t.format}),Lu=(t,r)=>{r.format==="NHWC"?zm(t,t.inputs,r):t.compute(Dm(t.inputs,r))}});var Gm,Vm,qu,Yu,Xu=oe(()=>{"use strict";Xe();Ae();Ne();Pe();Gm=t=>{if(!t||t.length<2)throw new Error("layerNorm requires at least 2 inputs.")},Vm=(t,r,e)=>{let d=t[0].dims,l=t[1],m=t[2],h=d,u=Y.normalizeAxis(r.axis,d.length),w=Y.sizeToDimension(d,u),_=Y.sizeFromDimension(d,u),O=Y.size(l.dims),j=m?Y.size(m.dims):0;if(O!==_||m&&j!==_)throw new Error(`Size of X.shape()[axis:] == ${_}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${O} and bias size of ${j}`);let B=[];for(let L=0;L<d.length;++L)L<u?B.push(d[L]):B.push(1);let P=Ft(_),R=Fe(t[0].dataType),T=[ne("x",t[0].dataType,t[0].dims,P),ne("scale",l.dataType,l.dims,P)];m&&T.push(ne("bias",m.dataType,m.dims,P)),T.push(fe("output",t[0].dataType,h,P));let k=e>1,U=e>2;k&&T.push(fe("meanDataOutput",1,B)),U&&T.push(fe("invStdOutput",1,B));let K=L=>`\n  const normSize: f32 = ${_};\n  const normSizeVectorized: u32 = ${_/P};\n  const epsilon: f32 = ${r.epsilon};\n\n  ${L.declareVariables(...T)}\n  ${L.mainStart()}\n    ${L.guardAgainstOutOfBoundsWorkgroupSizes(w)}\n    let offset = global_idx * normSizeVectorized;\n    var meanVector = ${mt("f32",P)};\n    var meanSquareVector = ${mt("f32",P)};\n\n    for (var h: u32 = 0u; h < normSizeVectorized; h++) {\n      let value = ${Ht(R,P,"x[h + offset]")};\n      meanVector += value;\n      meanSquareVector += value * value;\n    }\n    let mean = ${dr("meanVector",P)} / normSize;\n    let meanSquare = sqrt(${dr("meanSquareVector",P)} \n      / normSize - mean * mean + epsilon);\n\n    for (var j: u32 = 0; j < normSizeVectorized; j++) {\n      let f32input = ${Ht(R,P,"x[j + offset]")};\n      let f32scale = ${Ht(R,P,"scale[j]")};\n      output[j + offset] = ${T[0].type.value}((f32input - mean) / meanSquare * f32scale\n        ${m?`+ ${Ht(R,P,"bias[j]")}`:""}\n      );\n    }\n\n    ${k?"meanDataOutput[global_idx] = mean":""};\n    ${U?"invStdOutput[global_idx] = 1 / meanSquare":""};\n  }`,Q=[{dims:h,dataType:t[0].dataType}];return k&&Q.push({dims:B,dataType:1}),U&&Q.push({dims:B,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${r.cacheKey}|${e}|${t.length}`},getRunData:()=>({outputs:Q,dispatchGroup:{x:Math.ceil(w/64)}}),getShaderSource:K}},qu=t=>ye({axis:t.axis,epsilon:t.epsilon}),Yu=(t,r)=>{Gm(t.inputs),t.compute(Vm(t.inputs,r,t.outputCount))}});var Um,Qu,Ju=oe(()=>{"use strict";Ae();un();Um=t=>{if(!t||t.length!==2)throw new Error("MatMul requires 2 inputs.");if(t[0].dims[t[0].dims.length-1]!==t[1].dims[t[1].dims.length-2])throw new Error("shared dimension does not match.")},Qu=t=>{Um(t.inputs);let r=Ct.calcShape(t.inputs[0].dims,t.inputs[1].dims,!0);if(!r)throw new Error("Can\'t use matmul on the given tensors");t.compute(Zn(t.inputs,{activation:"",activationCacheKey:""},r))}});var Nm,Fm,Hm,Lm,Km,qm,Ym,Xm,Qm,Zu,el,tl=oe(()=>{"use strict";Xe();Ae();Ne();Pe();Nm=t=>{if(!t||t.length<1)throw new Error("Too few inputs");if(t[0].dataType!==1)throw new Error("Input type must be float.");if(t.length>=2){let r=t[0].dims.length*2===t[1].dims[0];if(t.length===4&&(r=t[3].dims[0]*2===t[1].dims[0]),!r)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},Fm=(t,r,e,d,l,m,h)=>{let u=e.length,w="";for(let _=u-1;_>=0;--_)w+=`\n            k = i32(${t.indicesGet("indices",_)}) - ${l[_]};\n            if (k < 0) {\n              break;\n            }\n            if (k >= ${e[_]}) {\n              break;\n            }\n            offset += k * ${d[_]};\n        `;return`\n          value = ${m}(${h});\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${w}\n            value = x[offset];\n          }\n      `},Hm=(t,r,e,d,l)=>{let m=e.length,h="";for(let u=m-1;u>=0;--u)h+=`\n                k = i32(${t.indicesGet("indices",u)}) - ${l[u]};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = ${2*(e[u]-1)};\n                  k = k % _2n_1;\n                  if(k >= ${e[u]}) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * ${d[u]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${h}\n              value = x[offset];\n          `},Lm=(t,r,e,d,l)=>{let m=e.length,h="";for(let u=m-1;u>=0;--u)h+=`\n                k = i32(${t.indicesGet("indices",u)}) - ${l[u]};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= ${e[u]}) {\n                  k = ${e[u]-1};\n                }\n                offset += k * ${d[u]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${h}\n              value = x[offset];\n          `},Km=(t,r,e,d,l)=>{let m=e.length,h="";for(let u=m-1;u>=0;--u)h+=`\n                k = i32(${t.indicesGet("indices",u)}) - ${l[u]};\n                if (k < 0)  {\n                  k += ${e[u]};\n                }\n                if (k >= ${e[u]}) {\n                  k -= ${e[u]};\n                }\n                offset += k * ${d[u]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${h}\n              value = x[offset];\n          `},qm=(t,r,e,d,l,m)=>{switch(l.mode){case 0:return Fm(t,r,e,d,l.pads,m,l.value);case 1:return Hm(t,r,e,d,l.pads);case 2:return Lm(t,r,e,d,l.pads);case 3:return Km(t,r,e,d,l.pads);default:throw new Error("Invalid mode")}},Ym=(t,r,e,d)=>{let l=r[0].dims,m=Y.padShape(l.slice(),e.pads),h=Y.size(m),u=Y.computeStrides(l),w=fe("output",r[0].dataType,m),_=ne("x",r[0].dataType,l),O=qm(w,m,l,u,e,d);return`\n              ${t.declareVariables(_,w)}\n              ${t.mainStart()}\n              ${t.guardAgainstOutOfBoundsWorkgroupSizes(h)}\n\n              let indices = ${w.offsetToIndices("global_idx")};\n\n              var value = ${d}(0);\n              ${O}\n              output[global_idx] = value;\n          }`},Xm=(t,r)=>{let e=Y.padShape(t[0].dims.slice(),r.pads);return{name:"Pad",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:e,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(Y.size(e)/64)}}),getShaderSource:d=>Ym(d,t,r,"f32")}},Qm=(t,r)=>{if(t.length>1){let e=t[1].getBigInt64Array(),d=t.length>=3&&t[2].data?t[2].getFloat32Array()[0]:0,l=t[0].dims.length,m=new Int32Array(2*l).fill(0);if(t.length>=4){let u=t[3].getBigInt64Array();for(let w=0;w<u.length;w++)m[Number(u[w])]=Number(e[w]),m[Number(u[w])+l]=Number(e[w+u.length])}else e.forEach((u,w)=>m[Number(w)]=Number(u));let h=[];return m.forEach(u=>h.push(u)),ye({mode:r.mode,value:d,pads:h})}else return r},Zu=(t,r)=>{Nm(t.inputs);let e=Qm(t.inputs,r);t.compute(Xm(t.inputs,e),{inputs:[0]})},el=t=>{let r=t.mode,e=t.value,d=t.pads;return ye({mode:r,value:e,pads:d})}});var ri,rl,nl,il,ol,al,sl,ul,ll,cl,dl,fl,pl,ml,hl,gl=oe(()=>{"use strict";Ae();Ne();Pe();ri=t=>{if(!t||t.length!==1)throw new Error("Pool ops requires 1 input.");if(t[0].dims.length!==4)throw new Error("Pool ops supports 2-D inputs only for now.")},rl=(t,r,e)=>{let d=r.format==="NHWC",l=d?[t.dims[0],t.dims[3],t.dims[1],t.dims[2]]:t.dims.slice(),m=Object.hasOwnProperty.call(r,"dilations"),h=r.kernelShape.slice(),u=r.strides.slice(),w=m?r.dilations.slice():[],_=r.pads.slice();Nt.adjustPoolAttributes(e,l,h,u,w,_);let O=Nt.computePoolOutputShape(e,l,u,w,h,_,r.autoPad),j=Object.assign({},r);return m?Object.assign(j,{kernelShape:h,strides:u,pads:_,dilations:w,cacheKey:r.cacheKey}):Object.assign(j,{kernelShape:h,strides:u,pads:_,cacheKey:r.cacheKey}),[j,d?[O[0],O[2],O[3],O[1]]:O]},nl=(t,r,e,d,l,m,h,u)=>{let w=l.format==="NHWC",_=e,O=r.type.value,j=_.length,B=Y.size(d),P=fe("output",r.type.tensor,d);if(l.kernelShape.length<=2){let R=l.kernelShape[l.kernelShape.length-1],T=l.strides[l.strides.length-1],k=l.pads[l.pads.length/2-1],U=l.pads[l.pads.length-1],K=j-(w?2:1),Q="",L="",X="";if(k+U!==0?Q=`\n              for (var i: u32 = 0u; i < ${R}u; i++) {\n                xIndices[${K}] = indices[${K}] * ${T} - ${k} + i;\n                if (xIndices[${K}] < 0 || xIndices[${K}] >= ${_[K]}) {\n                  pad++;\n                  continue;\n                }\n                let x_val = x[${r.indicesToOffset("xIndices")}];\n                ${m}\n              }`:Q=`\n              for (var i: u32 = 0u; i < ${R}u; i++) {\n                xIndices[${K}] = indices[${K}] * ${T} - ${k} + i;\n                let x_val = x[${r.indicesToOffset("xIndices")}];\n                ${m}\n              }`,l.kernelShape.length===2){let Z=l.kernelShape[l.kernelShape.length-2],re=l.strides[l.strides.length-2],ie=l.pads[l.pads.length/2-2],Ce=l.pads[l.pads.length-2],H=j-(w?3:2),le=_[H];ie+Ce!==0?L=`\n                for (var j: u32 = 0u; j < ${Z}u; j++) {\n                  xIndices[${H}] = indices[${H}] * ${re} - ${ie} + j;\n                  if (xIndices[${H}] < 0 || xIndices[${H}] >= ${le}) {\n                    pad+= ${R};\n                    continue;\n                  }\n              `:L=`\n                for (var j: u32 = 0u; j < ${Z}u; j++) {\n                  xIndices[${H}] = indices[${H}] * ${re} - ${ie} + j;\n                `,X=`\n              }\n            `}return`\n            ${t.declareVariables(r,P)}\n\n            ${t.mainStart()}\n              ${t.guardAgainstOutOfBoundsWorkgroupSizes(B)}\n\n              let indices = ${P.offsetToIndices("global_idx")};\n              var xIndices = ${P.offsetToIndices("global_idx")};\n\n              var value: ${O} = ${O}(${u});\n              var pad = 0;\n              ${L}\n              ${Q}\n              ${X}\n              ${h}\n\n              output[global_idx] = value;\n            }`}else{if(w)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let R=Y.size(l.kernelShape),T=Y.computeStrides(l.kernelShape),k=T.length,U=l.pads.length,K=l.pads.reduce((X,A)=>X+A),Q="";return K?Q=`\n                if (xIndices[j] >= inputDims[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${r.indicesToOffset("xIndices")}];\n                ${m}\n              }`:Q=`\n              }\n              let x_val = x[${r.indicesToOffset("xIndices")}];\n              ${m}\n            `,`\n            ${t.declareVariables(r,P)}\n\n            const pads = array<u32, ${U}>(${l.pads.map(X=>`${X}u`).join(",")});\n            const inputDims = array<u32, ${j}>(${_.map(X=>`${X}u`).join(",")});\n            const kernelStrides = array<u32, ${k}>(${T.map(X=>`${X}u`).join(",")});\n            const strides = array<u32, ${k}>(${l.strides.map(X=>`${X}u`).join(",")});\n\n            ${t.mainStart()}\n              ${t.guardAgainstOutOfBoundsWorkgroupSizes(B)}\n\n              let indices = ${P.offsetToIndices("global_idx")};\n              let xIndices = ${P.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${k}>;\n\n              var value = ${P.type.value}(${u});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < ${R}u; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${k-1}u; j++) {\n                  offsets[j] = offset / kernelStrides[j];\n                  offset -= offsets[j] * kernelStrides[j];\n                }\n                offsets[${k-1}] = offset;\n\n                isPad = false;\n                for (var j = ${j-k}u; j < ${j}u; j++) {\n                  xIndices[j] = indices[j] * strides[j - ${j-k}u]\n                    + offsets[j - ${j-k}u] - pads[j - 2u];\n                  ${Q}\n              }\n              ${h}\n\n              output[global_idx] = value;\n            }`}},il=t=>({format:t.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][t.auto_pad],ceilMode:t.ceil_mode,kernelShape:t.kernel_shape,strides:t.strides,pads:t.pads}),ol=(t,r,e,d)=>{let[l,m]=rl(r,d,e),h=Y.size(l.kernelShape),u=ne("x",r.dataType,r.dims),w=u.type.value,_="value += x_val;",O="";return l.countIncludePad?O+=`value /= ${w}(${h});`:O+=`value /= ${w}(${h} - pad);`,{name:t,shaderCache:{hint:d.cacheKey},getRunData:()=>({outputs:[{dims:m,dataType:r.dataType}],dispatchGroup:{x:Math.ceil(Y.size(m)/64)}}),getShaderSource:j=>nl(j,u,r.dims,m,l,_,O,"0.0")}},al=t=>{let r=t.count_include_pad!==0,e=il(t);if(e.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return ye({countIncludePad:r,...e})},sl=(t,r)=>{ri(t.inputs),t.compute(ol("AveragePool",t.inputs[0],!1,r))},ul={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},ll=t=>{let r=t.format;return{format:r,...ul,cacheKey:r}},cl=(t,r)=>{ri(t.inputs),t.compute(ol("GlobalAveragePool",t.inputs[0],!0,r))},dl=(t,r,e,d)=>{let[l,m]=rl(r,d,e),h=`\n      value = max(x_val, value);\n    `,u="",w=ne("x",r.dataType,r.dims);return{name:t,shaderCache:{hint:d.cacheKey},getRunData:()=>({outputs:[{dims:m,dataType:r.dataType}],dispatchGroup:{x:Math.ceil(Y.size(m)/64)}}),getShaderSource:_=>nl(_,w,r.dims,m,l,h,u,"-1e5")}},fl=(t,r)=>{ri(t.inputs),t.compute(dl("MaxPool",t.inputs[0],!1,r))},pl=t=>{let r=t.storage_order,e=t.dilations,d=il(t);if(r!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(d.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return ye({storageOrder:r,dilations:e,...d})},ml=t=>{let r=t.format;return{format:r,...ul,cacheKey:r}},hl=(t,r)=>{ri(t.inputs),t.compute(dl("GlobalMaxPool",t.inputs[0],!0,r))}});var Wi=oe(()=>{"use strict"});var yl=oe(()=>{"use strict";Wi()});var bl,vl=oe(()=>{"use strict";bl="1.17.0"});var wl,zi,Cl=oe(()=>{"use strict";vl();wl="warning",zi={wasm:{},webgl:{},webgpu:{},versions:{common:bl},set logLevel(t){if(t!==void 0){if(typeof t!="string"||["verbose","info","warning","error","fatal"].indexOf(t)===-1)throw new Error(`Unsupported logging level: ${t}`);wl=t}},get logLevel(){return wl}};Object.defineProperty(zi,"logLevel",{enumerable:!0})});var $l,xl=oe(()=>{"use strict";Cl();$l=zi});var Sl=oe(()=>{"use strict"});var _l=oe(()=>{"use strict";ni()});var Il=oe(()=>{"use strict"});var Tl=oe(()=>{"use strict";ni()});var ni=oe(()=>{"use strict";Sl();_l();Il();Tl()});var Gi=oe(()=>{"use strict";ni()});var Ol=oe(()=>{"use strict";Wi();Gi()});var El=oe(()=>{"use strict";Ol()});var Pl=oe(()=>{"use strict"});var Rl=oe(()=>{"use strict"});var kl=oe(()=>{"use strict";Rl()});var Bl=oe(()=>{"use strict";yl();xl();El();Gi();Pl();kl()});var Zm,eh,Ml,jl=oe(()=>{"use strict";Bl();Xe();Pe();Zm=(t,r,e)=>{let d=t===r,l=t<r&&e<0,m=t>r&&e>0;if(d||l||m)throw new Error("Range these inputs\' contents are invalid.")},eh=(t,r,e,d)=>{let l=Math.abs(Math.ceil((r-t)/e)),m=[l],h=l,u=fe("output",d,m),w=u.type.storage,_=O=>`\n        ${O.declareVariables(u)}\n        ${O.mainStart()}\n        ${O.guardAgainstOutOfBoundsWorkgroupSizes(h)}\n        output[global_idx] = ${w}(${t}) + ${w}(global_idx) * ${w}(${e});\n      }`;return{name:"Range",shaderCache:{hint:[t,r,e].map(O=>O.toString()).join("_")},getShaderSource:_,getRunData:()=>({outputs:[{dims:m,dataType:d}],dispatchGroup:{x:Math.ceil(h/64)}})}},Ml=t=>{let r=0,e=0,d=0;t.inputs[0].dataType===6?(r=t.inputs[0].getInt32Array()[0],e=t.inputs[1].getInt32Array()[0],d=t.inputs[2].getInt32Array()[0]):t.inputs[0].dataType===1&&(r=t.inputs[0].getFloat32Array()[0],e=t.inputs[1].getFloat32Array()[0],d=t.inputs[2].getFloat32Array()[0]),$l.webgpu.validateInputContent&&Zm(r,e,d),t.compute(eh(r,e,d,t.inputs[0].dataType),{inputs:[]})}});var th,rh,nh,ih,oh,ah,sh,uh,lh,ch,dh,fh,ph,mh,hh,Dl,Wl,zl=oe(()=>{"use strict";Ae();Ne();Pe();th=(t,r)=>{if(t.every(e=>e>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),t.length>0){if(r.mode==="linear"){if(!(t.length===2||t.length===4&&t[0]===1&&t[1]===1||t.length===4&&t[0]===1&&t[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(r.mode==="cubic"&&!(t.length===2||t.length===4&&t[0]===1&&t[1]===1||t.length===4&&t[0]===1&&t[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},rh=(t,r,e)=>{r.every(l=>l>=0&&l<e||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let d=new Array(e).fill(1);return r.forEach((l,m)=>d[l]=t[m]),d},nh=(t,r,e,d,l,m)=>{let[h,u,w]=e>10?[1,2,3]:[-1,t.length>1?1:-1,-1],_=t[0].dims.length;if(h>0&&t.length>h&&t[h].dims.length>0)t[h].getFloat32Array().forEach(O=>m.push(O));else if(r.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(u>0&&t.length>u&&t[u].dims.length>0){if(t[u].getFloat32Array().forEach(O=>d.push(O)),d.length!==0&&d.length!==_&&e>=18&&d.length!==r.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");th(d,r),r.axes.length>0&&rh(d,r.axes,_).forEach((O,j)=>d[j]=O)}if(w>0&&t.length>w&&(t[w].getBigInt64Array().forEach(O=>l.push(Number(O))),l.length!==_||e>=18&&l.length===r.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(r.axes.length>0){if(d.length!==r.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(l.length!==r.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(typeof d<"u"&&typeof l<"u"&&d.length>0&&l.length>_)throw new Error("Resize requires only of scales or sizes to be specified")},ih=t=>"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(t){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`\n`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${t} is not supported`)}})()+"}",oh=(t,r)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(t){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(r<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${t} is not supported`)}})()+"}",ah=(t,r,e)=>{let d=new Array(e).fill(0).concat(new Array(e).fill(1)),l=t.length===0?d:t.slice();return r.length>0?(r.forEach((m,h)=>{d[m]=l[h],d[h+e]=l[r.length+h]}),d):l},sh=(t,r,e,d)=>{let l=[];if(e.length>0)if(d.length>0){if(t.forEach(m=>l.push(m)),Math.max(...d)>t.length)throw new Error("axes is out of bound");d.forEach((m,h)=>l[m]=e[h])}else e.forEach(m=>l.push(m));else{if(r.length===0)throw new Error("Resize requires either scales or sizes.");l=t.map((m,h)=>Math.round(m*r[h]))}return l},uh=(t,r,e,d)=>{let l=(()=>{switch(d.keepAspectRatioPolicy){case"not_larger":return d.axes.length>0?Math.min(...d.axes.map(h=>e[h]),Number.MAX_VALUE):Math.min(...e,Number.MAX_VALUE);case"not_smaller":return d.axes.length>0?Math.max(...d.axes.map(h=>e[h]),Number.MIN_VALUE):Math.max(...e,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${d.keepAspectRatioPolicy} is not supported`)}})();e.fill(1,0,e.length);let m=t.slice();return d.axes.length>0?(d.axes.forEach(h=>e[h]=l),d.axes.forEach(h=>m[h]=Math.round(t[h]*e[h]))):(e.fill(l,0,e.length),m.forEach((h,u)=>m[u]=Math.round(h*e[u]))),m},lh=(t,r,e,d,l)=>`\n    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${t.type.indices}) -> array<f32, ${e.length}> {\n      const inputShape = array<u32, ${r.length}>(${r.map(m=>`${m}u`).join(",")});\n      const outputShape = array<u32, ${e.length}>(${e.map(m=>`${m}u`).join(",")});\n      const scales = array<f32, ${d.length}>(${d.map(m=>`${m}f`).join(",")});\n      const roi = array<f32, ${l.length}>(${l.map(m=>`${m}f`).join(",")});\n      var originalIndices: array<f32, ${e.length}>;\n      for (var i:u32 = 0; i < ${e.length}; i++) {\n        var outputIndex = ${e.length===1?"outputIndices":"outputIndices[i]"};\n        if (scales[i] == 1.0) {\n          originalIndices[i] = f32(outputIndex);\n        } else {\n          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${r.length}]);\n        }\n      }\n      return originalIndices;\n    }`,ch=(t,r,e,d,l,m,h)=>`\n    fn calculateInputIndicesFromOutputIndices(outputIndices: ${r.type.indices}) -> ${t.type.indices} {\n        const inputShape = array<u32, ${e.length}>(${e.map(u=>`${u}u`).join(",")});\n        const outputShape = array<u32, ${d.length}>(${d.map(u=>`${u}u`).join(",")});\n        const scales = array<f32, ${l.length}>(${l.map(u=>`${u}f`).join(",")});\n        const roi = array<f32, ${m.length}>(${m.map(u=>`${u}f`).join(",")});\n        var inputIndices: ${t.type.indices};\n        for (var i:u32 = 0; i < ${d.length}; i++) {\n          var outputIndex = ${d.length===1?"outputIndices":"outputIndices[i]"};\n          var inputIndex: u32;\n          if (scales[i] == 1.0) {\n            inputIndex = outputIndex;\n          } else {\n            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${e.length}]);\n            if (!${h} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {\n              if (original_idx < 0) {\n                inputIndex = 0;\n              } else if (original_idx > (f32(inputShape[i]) - 1)) {\n                inputIndex = inputShape[i] - 1;\n              } else {\n                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));\n              }\n            } else {\n              inputIndex = u32(original_idx);\n            }\n          }\n          ${t.indicesSet("inputIndices","i","inputIndex")}\n        }\n        return inputIndices;\n    }`,dh=(t,r)=>`\n    fn checkInputIndices(inputIndices: ${t.type.indices}) -> bool {\n      const inputShape = array<u32, ${r.length}>(${r.map(e=>`${e}u`).join(",")});\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var inputIndex = ${r.length===1?"inputIndices":"inputIndices[i]"};\n        if (inputIndex < 0 || inputIndex >= inputShape[i]) {\n          return false;\n        }\n      }\n      return true;\n    }`,fh=(t,r,e,d,l,m,h)=>{let[u,w,_,O]=e.length===2?[-1,0,1,-1]:l[1]===1?[0,2,3,1]:[0,1,2,3];return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {\n      var inputIndices: ${t.type.indices};\n      inputIndices[${w}] = max(0, min(row, ${e[w]} - 1));\n      inputIndices[${_}] = max(0, min(col, ${e[_]} - 1));\n      if (${e.length} > 2) {\n        inputIndices[${O}] = channel;\n        inputIndices[${u}] = batch;\n      };\n      return input[${t.indicesToOffset("inputIndices")}];\n    }\n\n    fn bilinearInterpolation(outputIndices: ${r.type.indices}) -> f32 {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);\n      var row:f32 = originalIndices[${w}];\n      var col:f32 = originalIndices[${_}];\n      if (${m} && (row < 0 || row > (${e[w]} - 1) || col < 0 || col > ${e[_]} - 1)) {\n        return ${h};\n      }\n      row = max(0, min(row, ${e[w]} - 1));\n      col = max(0, min(col, ${e[_]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = 0;\n      var batch: u32 = 0;\n      if (${e.length>2}) {\n        channel = u32(originalIndices[${O}]);\n        batch = u32(originalIndices[${u}]);\n      }\n      var x11: f32 = getInputValue(batch, channel, row1, col1);\n      var x12: f32 = getInputValue(batch, channel, row1, col2);\n      var x21: f32 = getInputValue(batch, channel, row2, col1);\n      var x22: f32 = getInputValue(batch, channel, row2, col2);\n      var dx1: f32 = row - f32(row1);\n      var dx2: f32 = f32(row2 ) - row;\n      var dy1 = col - f32(col1);\n      var dy2 = f32(col2) - col;\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},ph=(t,r,e,d,l,m,h,u,w,_)=>{let[O,j]=e.length===2?[0,1]:l[1]===1?[2,3]:[1,2],B=P=>{let R=P===O?"row":"col";return`\n      fn ${R}CubicInterpolation(inputIndices: ${t.type.indices}, outputIndices: ${r.type.indices}) -> f32 {\n        var outputIndex = ${d.length===1?"outputIndices":`outputIndices[${P}]`};\n        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${l[P]},\n        f32(${d[P]}), f32(${e[P]}), ${m[P]}, ${m[P]} + ${e.length});\n        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${u} && (originalIdx < 0 || originalIdx > (${e[P]} - 1))) {\n          return ${w};\n        }\n        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${R}: f32 = originalIdx + f32(i);\n          if (${R} < 0 || ${R} >= ${e[P]}) {\n            if (${_}) {\n              coefs[i + 1] = 0.0;\n              continue;\n            } else if (${u}) {\n              return ${w};\n            } else {\n              ${R} = max(0, min(${R}, ${e[P]} - 1));\n            }\n          }\n          var inputIndicesCopy: ${t.type.indices} = inputIndices;\n          inputIndicesCopy[${P}] = u32(${R});\n          data[i + 1] = ${P===O?`input[${t.indicesToOffset("inputIndicesCopy")}];`:`\n                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);`}\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${B(O)};\n    ${B(j)};\n  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {\n    var absS = abs(s);\n    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: f32 = 1.0 - absS;\n    var twoMinusAbsS: f32 = 2.0 - absS;\n    var onePlusAbsS: f32 = 1.0 + absS;\n    coeffs[0] = ((${h} * onePlusAbsS - 5 * ${h}) * onePlusAbsS + 8 * ${h}) * onePlusAbsS - 4 * ${h};\n    coeffs[1] = ((${h} + 2) * absS - (${h} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${h} + 2) * oneMinusAbsS - (${h} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${h} * twoMinusAbsS - 5 * ${h}) * twoMinusAbsS + 8 * ${h}) * twoMinusAbsS - 4 * ${h};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {\n    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(outputIndices: ${r.type.indices}) -> f32 {\n    var inputIndices: ${t.type.indices} = outputIndices;\n    return colCubicInterpolation(inputIndices, outputIndices);\n  }\n    `},mh=(t,r,e,d,l,m)=>{let h=t.dims,u=ah(m,r.axes,h.length),w=sh(h,d,l,r.axes),_=d.slice();d.length===0&&(_=h.map((k,U)=>k===0?1:w[U]/k),r.keepAspectRatioPolicy!=="stretch"&&(w=uh(h,w,_,r)));let O=fe("output",t.dataType,w),j=ne("input",t.dataType,h),B=Y.size(w),P=h.length===w.length&&h.every((k,U)=>k===w[U]),R=r.coordinateTransformMode==="tf_crop_and_resize",T=k=>`\n      ${ih(r.coordinateTransformMode)};\n      ${(()=>{switch(r.mode){case"nearest":return`\n              ${dh(j,h)};\n              ${oh(r.nearestMode,e)};\n              ${ch(j,O,h,w,_,u,R)};\n              `;case"linear":return`\n              ${lh(O,h,w,_,u)};\n              ${fh(j,O,h,w,_,R,r.extrapolationValue)};\n              `;case"cubic":return`\n            ${ph(j,O,h,w,_,u,r.cubicCoeffA,R,r.extrapolationValue,r.excludeOutside)};\n            `;default:throw Error("Invalid resize mode")}})()};\n      ${k.declareVariables(j,O)}\n      ${k.mainStart()}\n        ${k.guardAgainstOutOfBoundsWorkgroupSizes(B)}\n        if (${P}) {\n          output[global_idx] = input[global_idx];\n        } else {\n          let outputIndices = ${O.offsetToIndices("global_idx")};\n          var inputIndices: ${j.type.indices};\n          ${(()=>{switch(r.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);\n                  if (checkInputIndices(inputIndices)) {\n                    output[global_idx] = input[${j.indicesToOffset("inputIndices")}];\n                  } else {\n                    output[global_idx] = ${r.extrapolationValue};\n                  }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${r.mode}`)}})()};\n        }\n      }`;return{name:"Resize",shaderCache:{hint:`${r.cacheKey}|${e}|${_.length>0?_:""}|${l.length>0?l:""}`},getShaderSource:T,getRunData:()=>({outputs:[{dims:w,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(B/64)}})}},hh=t=>{let r=t.customDataBuffer;return new Uint32Array(r,r.byteOffset,1)[0]},Dl=(t,r)=>{let e=[],d=[],l=[],m=hh(t);nh(t.inputs,r,m,e,d,l),t.compute(mh(t.inputs[0],r,m,e,d,l),{inputs:[0]})},Wl=t=>{let r=t.antialias,e=t.axes,d=t.coordinateTransformMode,l=t.cubicCoeffA,m=t.excludeOutside!==0,h=t.extrapolationValue,u=t.keepAspectRatioPolicy,w=t.mode,_=t.nearestMode===""?"simple":t.nearestMode;return ye({antialias:r,axes:e,coordinateTransformMode:d,cubicCoeffA:l,excludeOutside:m,extrapolationValue:h,keepAspectRatioPolicy:u,mode:w,nearestMode:_})}});var gh,yh,Gl,Vl,Ul=oe(()=>{"use strict";Xe();Ae();Ne();Pe();gh=t=>{if(!t||t.length<3)throw new Error("layerNorm requires at least 3 inputs.");let r=t[0],e=t[1],d=t[2];if(r.dataType!==e.dataType||r.dataType!==d.dataType)throw new Error("All inputs must have the same data type");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Input must be 2D or 3D");if(e.dims.length!==3&&e.dims.length!==2)throw new Error("Skip must be 2D or 3D");let l=r.dims[r.dims.length-1],m=r.dims[r.dims.length-2];if(e.dims[e.dims.length-1]!==l)throw new Error("Skip must have the same hidden size as input");if(e.dims[e.dims.length-2]!==m)throw new Error("Skip must have the same sequence length as input");if(d.dims.length!==1)throw new Error("Gamma must be 1D");if(d.dims[d.dims.length-1]!==l)throw new Error("Gamma must have the same hidden size as input");if(t.length>3){let h=t[3];if(h.dims.length!==1)throw new Error("Beta must be 1D");if(h.dims[h.dims.length-1]!==l)throw new Error("Beta must have the same hidden size as input")}if(t.length>4){let h=t[4];if(h.dims.length!==1)throw new Error("Bias must be 1D");if(h.dims[h.dims.length-1]!==l)throw new Error("Bias must have the same hidden size as input")}},yh=(t,r,e,d)=>{let l=t[0].dims,m=Y.size(l),h=l,u=m,w=l.slice(-1)[0],_=d?l.slice(0,-1).concat(1):[],O=t.length>3,j=t.length>4,B=d&&e>1,P=d&&e>2,R=e>3,T=Ft(w),k=[ne("x",t[0].dataType,t[0].dims,T),ne("skip",t[1].dataType,t[1].dims,T),ne("gamma",t[2].dataType,t[2].dims,T)];O&&k.push(ne("beta",t[3].dataType,t[3].dims,T)),j&&k.push(ne("bias",t[4].dataType,t[4].dims,T)),k.push(fe("output",t[0].dataType,h,T)),B&&k.push(fe("meanOutput",1,_)),P&&k.push(fe("invStdOutput",1,_)),R&&k.push(fe("inputSkipBiasSum",t[0].dataType,h,T));let U=Fe(t[0].dataType),K=L=>`\n      const hiddenSize: f32 = ${w};\n      const hiddenSizeVectorized: u32 = ${w/T};\n      const epsilon: f32 = ${r.epsilon};\n\n      ${L.declareVariables(...k)}\n\n      ${L.mainStart()}\n        ${L.guardAgainstOutOfBoundsWorkgroupSizes(u/w)}\n        let offset = global_idx * hiddenSizeVectorized;\n        var sum = ${mt("f32",T)};\n        var squareSum = ${mt("f32",T)};\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          let skipValue = skip[offset + i];\n          let biasValue = ${j?"bias[i]":"0.0"};\n          let inputValue = x[offset + i];\n          let value = inputValue + skipValue + biasValue;\n          ${R?"inputSkipBiasSum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32Value = ${Ht(U,T,"value")};\n          sum += f32Value;\n          squareSum += f32Value * f32Value;\n        }\n        let mean = ${dr("sum",T)} / hiddenSize;\n        let variance = sqrt(${dr("squareSum",T)} / hiddenSize - mean * mean + epsilon);\n        ${B?"meanOutput[global_idx] = mean;":""}\n        ${P?"invStdOutput[global_idx] = 1.0 / variance;":""}\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          output[offset + i] = (output[offset + i] - ${U}(mean)) / ${U}(variance) * gamma[i]\n           + ${O?"beta[i]":"0.0"};\n        }\n      }`,Q=[{dims:h,dataType:t[0].dataType}];return e>1&&Q.push({dims:_,dataType:1}),e>2&&Q.push({dims:_,dataType:1}),e>3&&Q.push({dims:l,dataType:t[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:r.cacheKey},getShaderSource:K,getRunData:()=>({outputs:Q,dispatchGroup:{x:Math.ceil(u/w/64)}})}},Gl=(t,r)=>{gh(t.inputs);let d=[0];t.outputCount>1&&d.push(-3),t.outputCount>2&&d.push(-3),t.outputCount>3&&d.push(3),t.compute(yh(t.inputs,r,t.outputCount,!1),{outputs:d})},Vl=t=>{let r=t.epsilon;return ye({epsilon:r})}});var bh,ii,vh,Nl,wh,Ch,Fl,Hl,Ll=oe(()=>{"use strict";Xe();Ae();Ne();Pe();bh=(t,r)=>{if(!t||t.length<1)throw new Error("too few inputs");if(r.axes.length!==0){if(r.axes.length!==r.starts.length||r.axes.length!==r.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(r.starts.length!==r.ends.length)throw new Error("starts and ends must have the same length");t.slice(1).forEach((e,d)=>{if(t[d+1].dataType!==6&&t[d+1].dataType!==7)throw new Error(`Input ${d} must be an array of int32 or int64`)})},ii=(t,r)=>{let e=[];if(t.length>r)if(t[r].dataType===7)t[r].getBigInt64Array().forEach(d=>e.push(Number(d)));else if(t[r].dataType===6)t[r].getInt32Array().forEach(d=>e.push(Number(d)));else throw new Error(`Input ${r} must be an array of int32 or int64`);return e},vh=(t,r)=>{if(t.length>1){let e=ii(t,1),d=ii(t,2),l=ii(t,3);return l.length===0&&(l=[...Array(t[0].dims.length).keys()]),ye({starts:e,ends:d,axes:l})}else return r},Nl=(t,r,e,d,l)=>{let m=t;return t<0&&(m+=e[d[r]]),l[r]<0?Math.max(0,Math.min(m,e[d[r]]-1)):Math.max(0,Math.min(m,e[d[r]]))},wh=(t,r,e,d)=>`fn calculateInputIndices(outputIndices: ${r.type.indices}) -> ${t.type.indices} {\n          var inputIndices: ${t.type.indices};\n          var carry = 0u;\n          for (var i = ${e.length}; i >= 0; i--) {\n            var outputIndex = ${d.length===1?"outputIndices":"outputIndices[i]"};\n            var inputIndex = outputIndex * steps[i] + starts[i] + carry;\n            carry = inputIndex / inputShape[i];\n            inputIndex = inputIndex % inputShape[i];\n            if (signs[i] < 0) {\n              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];\n            }\n            ${e.length===1?"inputIndices":"inputIndices[i]"} = inputIndex;\n          }\n          return inputIndices;\n      }`,Ch=(t,r)=>{let e=t[0].dims,d=Y.size(e),l=r.axes.length>0?Y.normalizeAxes(r.axes,e.length):[...Array(e.length).keys()],m=ii(t,4);m.forEach(T=>T!==0||(()=>{throw new Error("step cannot be 0")})),m.length===0&&(m=Array(l.length).fill(1));let h=r.starts.map((T,k)=>Nl(T,k,e,l,m)),u=r.ends.map((T,k)=>Nl(T,k,e,l,m));if(l.length!==e.length)for(let T=0;T<e.length;++T)l.includes(T)||(h.splice(T,0,0),u.splice(T,0,e[T]),m.splice(T,0,1));let w=m.map(T=>Math.sign(T));m.forEach((T,k,U)=>{if(T<0){let K=(u[k]-h[k])/T,Q=h[k],L=Q+K*m[k];h[k]=L,u[k]=Q,U[k]=-T}});let _=e.slice(0);l.forEach((T,k)=>{_[T]=Math.ceil((u[T]-h[T])/m[T])});let O={dims:_,dataType:t[0].dataType},j=fe("output",t[0].dataType,_),B=ne("input",t[0].dataType,e),P=Y.size(_),R=T=>`\n      ${T.declareVariables(B,j)}\n        const signs = array<i32, ${w.length}>(${w.map(k=>`${k}i`).join(",")});\n        const starts = array<u32, ${h.length}>(${h.map(k=>`${k}u`).join(",")});\n        const ends = array<u32, ${u.length}>(${u.map(k=>`${k}u`).join(",")});\n        const steps = array<u32, ${m.length}>(${m.map(k=>`${k}u`).join(",")});\n        const inputShape = array<u32, ${e.length}>(${e.map(k=>`${k}u`).join(",")});\n\n        ${wh(B,j,e,_)}\n        ${T.mainStart()}\n          ${T.guardAgainstOutOfBoundsWorkgroupSizes(P)}\n          let outputIndices = ${j.offsetToIndices("global_idx")};\n          let inputIndices = calculateInputIndices(outputIndices);\n          ${j.setByOffset("global_idx",B.getByIndices("inputIndices"))}\n      }`;return{name:"Slice",shaderCache:{hint:`${r.cacheKey}|${t[4]?.dims??""}`},getShaderSource:R,getRunData:()=>({outputs:[O],dispatchGroup:{x:Math.ceil(d/64)}})}},Fl=(t,r)=>{bh(t.inputs,r);let e=vh(t.inputs,r);t.compute(Ch(t.inputs,e),{inputs:[0]})},Hl=t=>{let r=t.starts,e=t.ends,d=t.axes;return ye({starts:r,ends:e,axes:d})}});var $h,xh,Kl,ql,Yl=oe(()=>{"use strict";Ae();Ne();Pe();$h=t=>{if(!t||t.length!==1)throw new Error("Softmax op requires 1 input.")},xh=(t,r)=>{let e=Fe(t.dataType),d=t.dims,l=Y.size(d),m=64,h=r.axis;if(h<0&&(h=d.length+h),h<d.length-1)throw new Error("softmax only supports last axis for now.");let u=d[h],w=l/u,_=e==="f32"?"var threadMax: f32 = -3.402823e+38f;":"var threadMax: f16 = -65504.0h;";return{name:"Softmax",getRunData:()=>({outputs:[{dims:d,dataType:t.dataType}],dispatchGroup:{x:w}}),getShaderSource:j=>`\n      var<workgroup> rowMaxShared : ${e};\n      var<workgroup> rowSumShared : ${e};\n      var<workgroup> threadShared : array<${e}, ${m}>;\n\n      @group(0) @binding(0) var<storage, read> x : array<${e}>;\n      @group(0) @binding(1) var<storage, read_write> result : array<${e}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${e} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${e}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n\n      @compute @workgroup_size(${m}, 1, 1)\n      fn main(@builtin(local_invocation_id) local_id : vec3<u32>, @builtin(global_invocation_id) global_id : vec3u) {\n        let gindex = i32(global_id.x);\n        let lindex = i32(local_id.x);\n        const wg = ${m};\n        let row = gindex / wg;\n        let cols = ${u};\n        let row_stride : i32 = ${u};\n\n        // find the rows max\n        ${_}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = threadShared[0];\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum: ${e} = 0.0;\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = threadShared[0];\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`}},Kl=(t,r)=>{$h(t.inputs),t.compute(xh(t.inputs[0],r))},ql=t=>ye({axis:t.axis})});var Sh,_h,Ah,Ih,Th,Xl,Ql,Jl=oe(()=>{"use strict";Ae();Ne();Pe();Sh=t=>{if(!t||t.length<1)throw new Error("too few inputs")},_h=(t,r)=>{let e=[],d=r.numOutputs;return t[1].dims[0]>0&&(t[1].getBigInt64Array().forEach(l=>e.push(Number(l))),d=e.length),ye({numOutputs:d,axis:r.axis,splitSizes:e})},Ah=t=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${t}u; i += 1u ) {\n    if (index < sizeInConcatAxis[i]) {\n        return i;\n    }\n    }\n    return ${t}u;\n}`,Ih=t=>{let r=t.length,e=[];for(let d=0;d<r;++d){let l=t[d].setByIndices("indices","input[global_idx]");r===1?e.push(l):d===0?e.push(`if (outputNumber == ${d}u) { ${l} }`):d===r-1?e.push(`else { ${l} }`):e.push(`else if (outputNumber == ${d}) { ${l} }`)}return`\n      fn writeBufferData(outputNumber: u32, indices: ${t[0].type.indices}, global_idx: u32) {\n        ${e.join(`\n`)}\n      }`},Th=(t,r)=>{let e=t[0].dims,d=Y.size(e),l=t[0].dataType,m=e.length,h=r.axis,u=h<0?e.length+h:h,w=new Array(r.numOutputs),_=ne("input",l,e),O=new Array(r.numOutputs),j=[],B=[],P=0;for(let k=0;k<r.numOutputs;k++){P+=r.splitSizes[k],O[k]=P;let U=e.slice();U[r.axis]=r.splitSizes[k],B.push(U),w[k]=fe(`output${k}`,l,B[k]),j.push({dims:B[k],dataType:t[0].dataType})}let R=m<2?"indices":`indices[${u}]`,T=k=>`\n  ${k.declareVariables(_,...w)}\n  const sizeInConcatAxis = array<u32, ${O.length}>(${O.map(U=>`${U}u`).join(",")});\n  ${Ah(O.length)}\n  ${Ih(w)}\n\n  ${k.mainStart()}\n    ${k.guardAgainstOutOfBoundsWorkgroupSizes(d)}\n\n    var indices = ${_.offsetToIndices("global_idx")};\n    let outputNumber = calculateOutputIndex(${R});\n    if (outputNumber != 0) {\n        ${R} -= sizeInConcatAxis[outputNumber - 1u];\n    }\n    writeBufferData(outputNumber, indices, global_idx);\n  }`;return{name:"Split",shaderCache:{hint:r.cacheKey},getShaderSource:T,getRunData:()=>({outputs:j,dispatchGroup:{x:Math.ceil(d/64)}})}},Xl=(t,r)=>{Sh(t.inputs);let e=t.inputs.length===1?r:_h(t.inputs,r);t.compute(Th(t.inputs,e),{inputs:[0]})},Ql=t=>{let r=t.axis,e=t.splitSizes,d=t.numOutputs<0?e.length:t.numOutputs;if(d!==e.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ye({axis:r,numOutputs:d,splitSizes:e})}});var Zl,Oh,Eh,Ph,ec,tc=oe(()=>{"use strict";Xe();Ae();Pe();Zl=t=>Array.from(t.getBigInt64Array(),Number),Oh=t=>{if(!t||t.length!==2)throw new Error("Tile requires 2 inputs.");if(t[0].dataType!==1&&t[0].dataType!==6&&t[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(t[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(t[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(Zl(t[1]).length!==t[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Eh=(t,r)=>{let e=[];for(let d=0;d<t.length;++d)e.push(t[d]*r[d]);return e},Ph=t=>{let r=t[0].dims,e=Zl(t[1]),d=Eh(r,e),l=Y.size(d),m=t[0].dataType,h=ne("input",m,r),u=fe("output",m,d),w=_=>`\n      const inputShape = ${h.indices(...r)};\n      ${_.declareVariables(h,u)}\n      ${_.mainStart()}\n      ${_.guardAgainstOutOfBoundsWorkgroupSizes(l)}\n      let outputIndices = ${u.offsetToIndices("global_idx")};\n      var inputIndices: ${h.type.indices};\n      for (var i = 0; i < ${r.length}; i++) {\n        let inputDimValue = ${u.indicesGet("outputIndices","i")}  % ${h.indicesGet("inputShape","i")};\n\n        ${h.indicesSet("inputIndices","i","inputDimValue")}\n      }\n      ${u.setByOffset("global_idx",h.getByIndices("inputIndices"))}\n    }`;return{name:"Tile",shaderCache:{hint:`${e}`},getRunData:()=>({outputs:[{dims:d,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)}}),getShaderSource:w}},ec=t=>{Oh(t.inputs),t.compute(Ph(t.inputs),{inputs:[0]})}});var Rh,kh,rc,nc=oe(()=>{"use strict";Xe();Ae();Pe();Rh=(t,r,e,d,l)=>{let m=Y.size(e),h=Math.ceil(m/4),u=fe("outputData",l,e,4),w=ne("aData",r[1].dataType,r[1].dims,4),_=ne("bData",r[2].dataType,r[2].dims,4),O=ne("cData",r[0].dataType,r[0].dims,4),j,B=(P,R,T)=>`select(${R}, ${P}, ${T})`;if(!d)j=u.setByOffset("global_idx",B(w.getByOffset("global_idx"),_.getByOffset("global_idx"),O.getByOffset("global_idx")));else{let P=(R,T,k="")=>{let U=`aData[indexA${T}][componentA${T}]`,K=`bData[indexB${T}][componentB${T}]`,Q=`bool(cData[indexC${T}] & ${4278190080>>>(3-T)*8}u)`;return`\n            let outputIndices${T} = ${u.offsetToIndices(`global_idx * 4u + ${T}u`)};\n            let offsetA${T} = ${w.broadcastedIndicesToOffset(`outputIndices${T}`,u)};\n            let offsetB${T} = ${_.broadcastedIndicesToOffset(`outputIndices${T}`,u)};\n            let offsetC${T} = ${O.broadcastedIndicesToOffset(`outputIndices${T}`,u)};\n            let indexA${T} = offsetA${T} / 4u;\n            let indexB${T} = offsetB${T} / 4u;\n            let indexC${T} = offsetC${T} / 4u;\n            let componentA${T} = offsetA${T} % 4u;\n            let componentB${T} = offsetB${T} % 4u;\n            ${R}[${T}] = ${k}(${B(U,K,Q)});\n          `};l===9?j=`\n            var data = vec4<u32>(0);\n            ${P("data",0,"u32")}\n            ${P("data",1,"u32")}\n            ${P("data",2,"u32")}\n            ${P("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:j=`\n            ${P("outputData[global_idx]",0)}\n            ${P("outputData[global_idx]",1)}\n            ${P("outputData[global_idx]",2)}\n            ${P("outputData[global_idx]",3)}\n          `}return`\n        ${t.declareVariables(O,w,_,u)}\n        ${t.mainStart()}\n        ${t.guardAgainstOutOfBoundsWorkgroupSizes(h)}\n        ${j}\n      }`},kh=t=>{let r=t[1].dims,e=t[2].dims,d=t[0].dims,l=t[1].dataType,m=!(Y.areEqual(r,e)&&Y.areEqual(e,d)),h=r,u=Y.size(r);if(m){let w=Ct.calcShape(Ct.calcShape(r,e,!1),d,!1);if(!w)throw new Error("Can\'t perform where op on the given tensors");h=w,u=Y.size(h)}return{name:"Where",getShaderSource:w=>Rh(w,t,h,m,l),getRunData:()=>({outputs:[{dims:h,dataType:l}],dispatchGroup:{x:Math.ceil(u/64/4)}})}},rc=t=>{t.compute(kh(t.inputs))}});var ic,oc=oe(()=>{"use strict";hs();ys();Xs();su();cu();ki();Tu();Ru();Mu();Wu();Vu();Fu();Ku();Xu();Ju();tl();gl();jl();Ai();zl();Ul();Ll();Yl();Jl();tc();ei();Oi();nc();ic=new Map([["Abs",[bs]],["Acos",[vs]],["Acosh",[ws]],["Add",[Qs]],["ArgMax",[ms,Ii]],["ArgMin",[ps,Ii]],["Asin",[Cs]],["Asinh",[$s]],["Atan",[xs]],["Atanh",[Ss]],["AveragePool",[sl,al]],["BiasAdd",[gs]],["BiasSplitGelu",[Ys]],["Cast",[As,_s]],["Ceil",[Ts]],["ClipV10",[Ti]],["Clip",[Is]],["Concat",[uu,lu]],["Conv",[Cu,wu]],["ConvTranspose",[Iu,Au]],["Cos",[Os]],["Cosh",[Es]],["Div",[Js]],["Einsum",[Eu,Pu]],["Elu",[Ps,Hn]],["Equal",[Zs]],["Erf",[Rs]],["Exp",[ks]],["Expand",[Bu]],["Floor",[Bs]],["Gather",[Du,ju]],["GatherElements",[Gu,zu]],["Gelu",[Ms]],["Gemm",[Uu,Nu]],["GlobalAveragePool",[cl,ll]],["GlobalMaxPool",[hl,ml]],["Greater",[nu]],["GreaterOrEqual",[ou]],["InstanceNormalization",[Lu,Hu]],["LayerNormalization",[Yu,qu]],["LeakyRelu",[js,Hn]],["Less",[iu]],["LessOrEqual",[au]],["Log",[qs]],["MatMul",[Qu]],["MaxPool",[fl,pl]],["Mul",[eu]],["Neg",[Ws]],["Not",[Ds]],["Pad",[Zu,el]],["Pow",[tu]],["Range",[Ml]],["Reciprocal",[zs]],["ReduceMin",[ss,ht]],["ReduceMean",[as,ht]],["ReduceMax",[os,ht]],["ReduceSum",[ls,ht]],["ReduceProd",[us,ht]],["ReduceL1",[rs,ht]],["ReduceL2",[ns,ht]],["ReduceLogSum",[ts,ht]],["ReduceLogSumExp",[is,ht]],["ReduceSumSquare",[cs,ht]],["Relu",[Gs]],["Resize",[Dl,Wl]],["Sigmoid",[Vs]],["Sin",[Us]],["Sinh",[Ns]],["Slice",[Fl,Hl]],["SkipLayerNormalization",[Gl,Vl]],["Split",[Xl,Ql]],["Sqrt",[Fs]],["Softmax",[Kl,ql]],["Sub",[ru]],["Tan",[Hs]],["Tanh",[Ls]],["ThresholdedRelu",[Ks,Hn]],["Tile",[ec]],["Transpose",[gu,yu]],["Where",[rc]]])});var oi,ac=oe(()=>{"use strict";Xe();Tt();Pe();oi=class{constructor(r){this.backend=r;this.repo=new Map,this.attributesBound=!1}getArtifact(r){return this.repo.get(r)}setArtifact(r,e){this.repo.set(r,e)}run(r,e,d,l,m,h,u){let w=this.backend.device,_=this.backend.getComputePassEncoder(),O=this.backend.supportTimestampQuery&&this.backend.env.webgpu.profilingMode==="default";O&&_.writeTimestamp(this.backend.profilingQuerySet,0),_.setPipeline(r.computePipeline);let j=[];for(let P of l)j.push({binding:j.length,resource:{buffer:P.buffer}});for(let P of m)j.push({binding:j.length,resource:{buffer:P.buffer}});u&&j.push({binding:j.length,resource:u});let B=w.createBindGroup({layout:r.computePipeline.getBindGroupLayout(0),entries:j,label:r.programInfo.name});if(_.setBindGroup(0,B),_.dispatchWorkgroups(...h),this.backend.pendingDispatchNumber++,O){_.writeTimestamp(this.backend.profilingQuerySet,1),this.backend.profilingQueryData==null&&(this.backend.profilingQueryData=this.backend.gpuDataManager.create(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let P=this.backend.gpuDataManager.create(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.profilingQuerySet,0,2,this.backend.profilingQueryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.profilingQueryData.buffer,0,P.buffer,0,16),this.backend.flush();let R=this.backend.currentKernelId,T=this.backend.kernels.get(R),k=`[${T[0]}] ${T[1]}`;P.buffer.mapAsync(GPUMapMode.READ).then(()=>{let U=new BigUint64Array(P.buffer.getMappedRange()),K=U[0],Q=U[1];P.buffer.unmap(),typeof this.backend.profilingTimeBase>"u"&&(this.backend.profilingTimeBase=K);let L=Number(K-this.backend.profilingTimeBase),X=Number(Q-this.backend.profilingTimeBase);if(!Number.isSafeInteger(L)||!Number.isSafeInteger(X))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(P.id);let A="";e.forEach((re,ie)=>{A+=`input[${ie}]: [${re.dims}] | ${tn(re.dataType)}, `});let Z="";d.forEach((re,ie)=>{Z+=`output[${ie}]: [${re.dims}] | ${tn(re.dataType)}, `}),console.log(`[profiling] kernel "${R}|${k}" ${A}${Z}execution time: ${X-L} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(r,e){let d=this.backend.device,l=[];d.features.has("shader-f16")&&l.push("enable f16;");let m=es(e),h=r.getShaderSource(m),u=`${l.join(`\n`)}\n${m.additionalImplementations}\n${h}`,w=d.createShaderModule({code:u,label:r.name});ze("verbose",()=>`[WebGPU] shader code: ${u}`);let _=d.createComputePipeline({compute:{module:w,entryPoint:"main"},layout:"auto",label:r.name});return{programInfo:r,computePipeline:_}}normalizeDispatchGroupSize(r){let e=typeof r=="number"?r:r.x,d=typeof r=="number"?1:r.y||1,l=typeof r=="number"?1:r.z||1,m=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(e<=m&&d<=m&&l<=m)return[e,d,l];let h=e*d*l,u=Math.ceil(Math.sqrt(h));if(u>m){if(u=Math.ceil(Math.cbrt(h)),u>m)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[u,u,u]}else return[u,u,1]}}});var Bh,Mh,ai,sc=oe(()=>{"use strict";Tt();Ka();Qa();oc();ac();Bh=(t,r)=>{if(r.length!==t.length)throw new Error(`inputDependencies length ${r.length} is not equal to inputTensors length ${t.length}.`);let e=[];for(let d=0;d<t.length;++d){let l=t[d].dataType;switch(r[d]){case"none":{e.push("");break}case"type":{e.push(`${l}`);break}case"rank":{let m=t[d].dims.length;e.push(`${l};${m}`);break}case"dims":{let m=t[d].dims.join(",");e.push(`${l};${m}`);break}default:throw new Error(`unsupported input dependency: ${r[d]}`)}}return e.join("|")},Mh=(t,r)=>{let e=t.name;return t.shaderCache?.hint&&(e+="["+t.shaderCache.hint+"]"),e+=`:${Bh(r,t.shaderCache?.inputDependencies??new Array(r.length).fill("dims"))}`,e},ai=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.supportTimestampQuery=!1;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let r=this.kernelCustomData.get(this.currentKernelId);return r||(r={},this.kernelCustomData.set(this.currentKernelId,r)),r}async initialize(r){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let e=await navigator.gpu.requestAdapter();if(!e)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=r;let d=[],l={requiredLimits:{maxComputeWorkgroupStorageSize:e.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:e.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:e.limits.maxStorageBufferBindingSize,maxBufferSize:e.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:e.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:e.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:e.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:e.limits.maxComputeWorkgroupSizeZ},requiredFeatures:d};e.features.has("timestamp-query-inside-passes")&&(this.supportTimestampQuery=!0,d.push("timestamp-query-inside-passes")),e.features.has("shader-f16")&&d.push("shader-f16"),this.device=await e.requestDevice(l),this.gpuDataManager=Xa(this),this.programManager=new oi(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Ha(r.logLevel,!!r.debug),this.device.onuncapturederror=m=>{m.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${m.error.message}`)},this.supportTimestampQuery&&(this.profilingQuerySet=this.device.createQuerySet({type:"timestamp",count:2})),Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){return this.computePassEncoder||(this.computePassEncoder=this.getCommandEncoder().beginComputePass()),this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}run(r,e,d,l,m){let h=[];for(let U=0;U<e.length;++U){let K=this.gpuDataManager.get(e[U].data);if(!K)throw new Error(`no GPU data for input: ${e[U].data}`);h[U]=K}let u=Mh(r,e),w=this.programManager.getArtifact(u),{outputs:_,dispatchGroup:O,programUniforms:j}=r.getRunData(e),B=d.length===0?_.map((U,K)=>K):d;if(B.length!==_.length)throw new Error(`Output size ${B.length} must be equal to ${_.length}.`);let P=[],R=[];for(let U=0;U<_.length;++U){if(!Number.isInteger(B[U])||B[U]<-3||B[U]>=_.length)throw new Error(`Invalid output index: ${B[U]}`);if(B[U]===-3)continue;let K=B[U]===-1,Q=B[U]===-2,L=K||Q?m(_[U].dataType,_[U].dims):l(B[U],_[U].dataType,_[U].dims),X=this.gpuDataManager.get(L.data);if(!X)throw new Error(`no GPU data for output: ${L.data}`);if(K&&this.temporaryData.push(X),Q){let A=this.kernelPersistentData.get(this.currentKernelId);A||(A=[],this.kernelPersistentData.set(this.currentKernelId,A)),A.push(X)}P.push(L),R.push(X)}let T;if(j){let U=0,K=0,Q=[],L=1;j.forEach(Z=>{let re=typeof Z.data=="number"?[Z.data]:Z.data,ie;switch(re.length){case 1:ie=4;break;case 2:ie=8;break;case 3:ie=16;break;case 4:ie=16;break;case 5:ie=16;break;case 6:ie=16;break;default:throw new Error(`unsupported data length: ${re.length}`)}(K===5||K===6)&&(ie=16),ie>L&&(L=ie),U=Math.ceil(U/ie)*ie,K=re.length,Q.push(U),U+=re.length*4}),U=Math.ceil(U/L)*L;let X=new ArrayBuffer(U);j.forEach((Z,re)=>{let ie=Q[re],Ce=typeof Z.data=="number"?[Z.data]:Z.data;Z.type==="int32"?new Int32Array(X,ie,Ce.length).set(Ce):Z.type==="uint32"?new Uint32Array(X,ie,Ce.length).set(Ce):new Float32Array(X,ie,Ce.length).set(Ce)});let A=this.gpuDataManager.create(U,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(A.buffer,0,X,0,U),this.gpuDataManager.release(A.id),T={offset:0,size:U,buffer:A.buffer}}let k=this.programManager.normalizeDispatchGroupSize(O);return w||(w=this.programManager.build(r,k),this.programManager.setArtifact(u,w)),ze("info",()=>`[ProgramManager] run "${r.name}" (key=${u}) with ${k[0]}x${k[1]}x${k[2]}`),this.programManager.run(w,e,P,h,R,k,T),P}upload(r,e){this.gpuDataManager.upload(r,e)}memcpy(r,e){this.gpuDataManager.memcpy(r,e)}async download(r,e){await this.gpuDataManager.download(r,e)}alloc(r){return this.gpuDataManager.create(r).id}free(r){return this.gpuDataManager.release(r)}createKernel(r,e,d,l){let m=ic.get(r);if(!m)throw new Error(`kernel not implemented: ${r}`);this.kernels.set(e,[r,l,m[0],[m[1],d]])}releaseKernel(r){let e=this.kernelPersistentData.get(r);if(e){for(let d of e)this.gpuDataManager.release(d.id);this.kernelPersistentData.delete(r)}this.kernelCustomData.delete(r),this.kernels.delete(r)}computeKernel(r,e,d){let l=this.kernels.get(r);if(!l)throw new Error(`kernel not created: ${r}`);let[m,h,u,w]=l;if(this.currentKernelId!==null)throw new Error(`kernel "[${m}] ${h}" is not allowed to be called recursively`);this.currentKernelId=r,w[0]&&(w[1]=w[0](w[1]),w[0]=void 0),ze("info",()=>`[WebGPU] Start to run kernel "[${m}] ${h}"...`);let _=this.env.debug;this.temporaryData=[];try{return _&&this.device.pushErrorScope("validation"),u(e,w[1]),0}catch(O){return d.push(Promise.resolve(`[WebGPU] Kernel "[${m}] ${h}" failed. ${O}`)),1}finally{_&&d.push(this.device.popErrorScope().then(O=>O?`GPU validation error for kernel "[${m}] ${h}": ${O.message}`:null));for(let O of this.temporaryData)this.gpuDataManager.release(O.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(r,e,d,l){let m=this.sessionExternalDataMapping.get(r);m||(m=new Map,this.sessionExternalDataMapping.set(r,m));let h=m.get(e),u=this.gpuDataManager.registerExternalBuffer(d,l,h?.[1]);return m.set(e,[u,d]),u}unregisterBuffers(r){let e=this.sessionExternalDataMapping.get(r);e&&(e.forEach(d=>this.gpuDataManager.unregisterExternalBuffer(d[1])),this.sessionExternalDataMapping.delete(r))}getBuffer(r){let e=this.gpuDataManager.get(r);if(!e)throw new Error(`no GPU data for buffer: ${r}`);return e.buffer}createDownloader(r,e,d){return async()=>{let l=await wi(this,r,e);return La(l.buffer,d)}}}});var uc={};Dn(uc,{init:()=>jh});var ln,Vi,jh,lc=oe(()=>{"use strict";Xe();sc();Tt();Ae();ln=class t{constructor(r,e,d,l){this.module=r;this.dataType=e;this.data=d;this.dims=l}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let r=Y.size(this.dims);return r===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,r)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let r=Y.size(this.dims);return r===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,r)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let r=Y.size(this.dims);return r===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,r)}reshape(r){if(Y.size(r)!==Y.size(this.dims))throw new Error("Invalid new shape");return new t(this.module,this.dataType,this.data,r)}},Vi=class{constructor(r,e,d){this.module=r;this.backend=e;this.customDataOffset=0;this.customDataSize=0;let l=r.HEAPU32,m=d>>2;this.opKernelContext=l[m++];let h=l[m++];this.outputCount=l[m++],this.customDataOffset=l[m++],this.customDataSize=l[m++];let u=[];for(let w=0;w<h;w++){let _=l[m++],O=l[m++],j=l[m++],B=[];for(let P=0;P<j;P++)B.push(l[m++]);u.push(new ln(r,_,O,B))}this.inputs=u}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(r,e){let d=e?.inputs?.map(u=>typeof u=="number"?this.inputs[u]:u)??this.inputs,l=e?.outputs??[],m=(u,w,_)=>new ln(this.module,w,this.output(u,_),_),h=(u,w)=>{let _=rn(u);if(!_)throw new Error(`Unsupported data type: ${u}`);let O=_*Y.size(w);return new ln(this.module,u,this.backend.gpuDataManager.create(O).id,w)};return this.backend.run(r,d,l,m,h)}output(r,e){let d=this.module.stackSave();try{let l=this.module.stackAlloc((1+e.length)*4),m=l>>2;this.module.HEAPU32[m++]=e.length;for(let h=0;h<e.length;h++)this.module.HEAPU32[m++]=e[h];return this.module._JsepOutput(this.opKernelContext,r,l)}catch(l){throw new Error(`Failed to generate kernel\'s output[${r}] with dims [${e}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${l}`)}finally{this.module.stackRestore(d)}}},jh=async(t,r)=>{let e=t.jsepInit;if(e&&navigator.gpu){if(!r.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let d=new ai;await d.initialize(r),e(d,l=>d.alloc(l),l=>d.free(l),(l,m,h,u=!1)=>{if(u)ze("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${l}, dst=${m}, size=${h}`),d.memcpy(l,m);else{ze("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${l}, gpuDataId=${m}, size=${h}`);let w=t.HEAPU8.subarray(l,l+h);d.upload(m,w)}},async(l,m,h)=>{ze("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${l}, dataOffset=${m}, size=${h}`),await d.download(l,()=>t.HEAPU8.subarray(m,m+h))},(l,m,h)=>d.createKernel(l,m,h,r.debug||r.webgpu.profilingMode==="default"?t.UTF8ToString(t._JsepGetNodeName(m)):`${m}`),l=>d.releaseKernel(l),(l,m,h,u)=>{ze("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${h}, kernel=${l}, contextDataOffset=${m}`);let w=new Vi(t,d,m);return d.computeKernel(l,w,u)})}}});var Wa;Wa=Ta();var Tp=Ma(),hi,gi=!1,Wn=!1,Da=!1,Op=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},Ep=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Pp=(t,r)=>t?r?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":r?"ort-wasm-threaded.wasm":"ort-wasm.wasm",za=async t=>{if(gi)return Promise.resolve();if(Wn)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(Da)throw new Error("previous call to \'initializeWebAssembly()\' failed.");Wn=!0;let r=t.initTimeout,e=t.numThreads,d=t.simd,l=e>1&&Op(),m=d&&Ep(),h=t.wasmPaths,u=typeof h=="string"?h:void 0,w=Pp(m,l),_=typeof h=="object"?h[w]:void 0,O=!1,j=[];if(r>0&&j.push(new Promise(B=>{setTimeout(()=>{O=!0,B()},r)})),j.push(new Promise((B,P)=>{let R=l?Tp:Wa,T={locateFile:(k,U)=>{if(l&&k.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([ja()],{type:"text/javascript"}));if(k.endsWith(".wasm")){if(_)return _;let K=u??U;return w==="ort-wasm-simd.wasm"?K+"ort-wasm-simd.jsep.wasm":w==="ort-wasm-simd-threaded.wasm"?K+"ort-wasm-simd-threaded.jsep.wasm":K+w}return U+k}};if(l)if(typeof Blob>"u")T.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let k=`var ortWasmThreaded=${R.toString()};`;T.mainScriptUrlOrBlob=new Blob([k],{type:"text/javascript"})}R(T).then(k=>{Wn=!1,gi=!0,hi=k,B()},k=>{Wn=!1,Da=!0,P(k)})})),await Promise.race(j),O)throw new Error(`WebAssembly backend initializing failed due to timeout: ${r}ms`)},Ue=()=>{if(gi&&hi)return hi;throw new Error("WebAssembly is not initialized yet.")};var Ke=(t,r)=>{let e=Ue(),d=e.lengthBytesUTF8(t)+1,l=e._malloc(d);return e.stringToUTF8(t,l,d),r.push(l),l},en=(t,r,e,d)=>{if(typeof t=="object"&&t!==null){if(e.has(t))throw new Error("Circular reference in options");e.add(t)}Object.entries(t).forEach(([l,m])=>{let h=r?r+l:l;if(typeof m=="object")en(m,h+".",e,d);else if(typeof m=="string"||typeof m=="number")d(h,m.toString());else if(typeof m=="boolean")d(h,m?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof m}`)})},We=t=>{let r=Ue(),e=r.stackSave();try{let d=r.stackAlloc(8);r._OrtGetLastError(d,d+4);let l=r.HEAP32[d/4],m=r.HEAPU32[d/4+1],h=m?r.UTF8ToString(m):"";throw new Error(`${t} ERROR_CODE: ${l}, ERROR_MESSAGE: ${h}`)}finally{r.stackRestore(e)}};var Ga=t=>{let r=Ue(),e=0,d=[],l=t||{};try{if(t?.logSeverityLevel===void 0)l.logSeverityLevel=2;else if(typeof t.logSeverityLevel!="number"||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(t?.logVerbosityLevel===void 0)l.logVerbosityLevel=0;else if(typeof t.logVerbosityLevel!="number"||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);t?.terminate===void 0&&(l.terminate=!1);let m=0;return t?.tag!==void 0&&(m=Ke(t.tag,d)),e=r._OrtCreateRunOptions(l.logSeverityLevel,l.logVerbosityLevel,!!l.terminate,m),e===0&&We("Can\'t create run options."),t?.extra!==void 0&&en(t.extra,"",new WeakSet,(h,u)=>{let w=Ke(h,d),_=Ke(u,d);r._OrtAddRunConfigEntry(e,w,_)!==0&&We(`Can\'t set a run config entry: ${h} - ${u}.`)}),[e,d]}catch(m){throw e!==0&&r._OrtReleaseRunOptions(e),d.forEach(h=>r._free(h)),m}};var Rp=t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}},kp=t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}},Bp=t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});let r=t.extra.session;r.use_ort_model_bytes_directly||(r.use_ort_model_bytes_directly="1"),t.executionProviders&&t.executionProviders.some(e=>(typeof e=="string"?e:e.name)==="webgpu")&&(t.enableMemPattern=!1)},Mp=(t,r,e)=>{for(let d of r){let l=typeof d=="string"?d:d.name;switch(l){case"xnnpack":l="XNNPACK";break;case"webnn":if(l="WEBNN",typeof d!="string"){let h=d;if(h?.deviceType){let u=Ke("deviceType",e),w=Ke(h.deviceType,e);Ue()._OrtAddSessionConfigEntry(t,u,w)!==0&&We(`Can\'t set a session config entry: \'deviceType\' - ${h.deviceType}.`)}if(h?.powerPreference){let u=Ke("powerPreference",e),w=Ke(h.powerPreference,e);Ue()._OrtAddSessionConfigEntry(t,u,w)!==0&&We(`Can\'t set a session config entry: \'powerPreference\' - ${h.powerPreference}.`)}}break;case"webgpu":if(l="JS",typeof d!="string"){let h=d;if(h?.preferredLayout){if(h.preferredLayout!=="NCHW"&&h.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${h.preferredLayout}`);let u=Ke("preferredLayout",e),w=Ke(h.preferredLayout,e);Ue()._OrtAddSessionConfigEntry(t,u,w)!==0&&We(`Can\'t set a session config entry: \'preferredLayout\' - ${h.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${l}`)}let m=Ke(l,e);Ue()._OrtAppendExecutionProvider(t,m)!==0&&We(`Can\'t append execution provider: ${l}.`)}},Va=t=>{let r=Ue(),e=0,d=[],l=t||{};Bp(l);try{let m=Rp(l.graphOptimizationLevel??"all"),h=kp(l.executionMode??"sequential"),u=typeof l.logId=="string"?Ke(l.logId,d):0,w=l.logSeverityLevel??2;if(!Number.isInteger(w)||w<0||w>4)throw new Error(`log serverity level is not valid: ${w}`);let _=l.logVerbosityLevel??0;if(!Number.isInteger(_)||_<0||_>4)throw new Error(`log verbosity level is not valid: ${_}`);let O=typeof l.optimizedModelFilePath=="string"?Ke(l.optimizedModelFilePath,d):0;if(e=r._OrtCreateSessionOptions(m,!!l.enableCpuMemArena,!!l.enableMemPattern,h,!!l.enableProfiling,0,u,w,_,O),e===0&&We("Can\'t create session options."),l.executionProviders&&Mp(e,l.executionProviders,d),l.freeDimensionOverrides)for(let[j,B]of Object.entries(l.freeDimensionOverrides)){if(typeof j!="string")throw new Error(`free dimension override name must be a string: ${j}`);if(typeof B!="number"||!Number.isInteger(B)||B<0)throw new Error(`free dimension override value must be a non-negative integer: ${B}`);let P=Ke(j,d);r._OrtAddFreeDimensionOverride(e,P,B)!==0&&We(`Can\'t set a free dimension override: ${j} - ${B}.`)}return l.extra!==void 0&&en(l.extra,"",new WeakSet,(j,B)=>{let P=Ke(j,d),R=Ke(B,d);r._OrtAddSessionConfigEntry(e,P,R)!==0&&We(`Can\'t set a session config entry: ${j} - ${B}.`)}),[e,d]}catch(m){throw e!==0&&r._OrtReleaseSessionOptions(e),d.forEach(h=>r._free(h)),m}};Xe();var Dh=t=>{let r=Ue(),e=r.stackSave();try{let d=r.stackAlloc(8);return r._OrtGetInputOutputCount(t,d,d+4)!==0&&We("Can\'t get session input/output count."),[r.HEAP32[d/4],r.HEAP32[d/4+1]]}finally{r.stackRestore(e)}},Wh=(t,r)=>{Ue()._OrtInit(t,r)!==0&&We("Can\'t initialize onnxruntime.")},dc=async t=>{Wh(t.wasm.numThreads,nn(t.logLevel));{let r=(lc(),cr(uc)).init;await r(Ue(),t)}},cn=new Map,Ui=t=>{let r=Ue(),e=r._malloc(t.byteLength);if(e===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${t.byteLength}.`);return r.HEAPU8.set(t,e),[e,t.byteLength]},Ni=(t,r)=>{let e=Ue(),d=0,l=0,m=0,h=[],u=[],w=[];try{[l,h]=Va(r),d=e._OrtCreateSession(t[0],t[1],l),d===0&&We("Can\'t create a session.");let[_,O]=Dh(d),j=[],B=[],P=[];for(let T=0;T<_;T++){let k=e._OrtGetInputName(d,T);k===0&&We("Can\'t get an input name."),u.push(k),j.push(e.UTF8ToString(k))}for(let T=0;T<O;T++){let k=e._OrtGetOutputName(d,T);k===0&&We("Can\'t get an output name."),w.push(k);let U=e.UTF8ToString(k);B.push(U);{let K=typeof r?.preferredOutputLocation=="string"?r.preferredOutputLocation:r?.preferredOutputLocation?.[U]??"cpu";if(K!=="cpu"&&K!=="cpu-pinned"&&K!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${K}.`);P.push(K)}}let R=null;return P.some(T=>T==="gpu-buffer")&&(m=e._OrtCreateBinding(d),m===0&&We("Can\'t create IO binding."),R={handle:m,outputPreferredLocations:P,outputPreferredLocationsEncoded:P.map(T=>bi(T))}),cn.set(d,[d,u,w,R]),[d,j,B]}catch(_){throw u.forEach(O=>e._OrtFree(O)),w.forEach(O=>e._OrtFree(O)),m!==0&&e._OrtReleaseBinding(m),d!==0&&e._OrtReleaseSession(d),_}finally{e._free(t[0]),l!==0&&e._OrtReleaseSessionOptions(l),h.forEach(_=>e._free(_))}},fc=(t,r)=>{let e=Ui(t);return Ni(e,r)},pc=t=>{let r=Ue(),e=cn.get(t);if(!e)throw new Error(`cannot release session. invalid session id: ${t}`);let[d,l,m,h]=e;h&&r._OrtReleaseBinding(h.handle),r.jsepUnregisterBuffers?.(t),l.forEach(u=>r._OrtFree(u)),m.forEach(u=>r._OrtFree(u)),r._OrtReleaseSession(d),cn.delete(t)},cc=(t,r,e,d,l)=>{if(!t){r.push(0);return}let m=Ue(),h=t[0],u=t[1],w=t[3],_,O;if(h==="string"&&w==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(w==="gpu-buffer"){let P=t[2].gpuBuffer,R=rn(yi(h));O=u.reduce((T,k)=>T*k,1)*R,_=m.jsepRegisterBuffer(d,l,P,O)}else{let P=t[2];if(Array.isArray(P)){O=4*P.length,_=m._malloc(O),e.push(_);let R=_/4;for(let T=0;T<P.length;T++){if(typeof P[T]!="string")throw new TypeError(`tensor data at index ${T} is not a string`);m.HEAPU32[R++]=Ke(P[T],e)}}else O=P.byteLength,_=m._malloc(O),e.push(_),m.HEAPU8.set(new Uint8Array(P.buffer,P.byteOffset,O),_)}let j=m.stackSave(),B=m.stackAlloc(4*u.length);try{let P=B/4;u.forEach(T=>m.HEAP32[P++]=T);let R=m._OrtCreateTensor(yi(h),_,O,B,u.length,bi(w));R===0&&We(`Can\'t create tensor for input/output. session=${d}, index=${l}.`),r.push(R)}finally{m.stackRestore(j)}},mc=async(t,r,e,d,l,m)=>{let h=Ue(),u=cn.get(t);if(!u)throw new Error(`cannot run inference. invalid session id: ${t}`);let[w,_,O,j]=u,B=r.length,P=d.length,R=0,T=[],k=[],U=[],K=[],Q=h.stackSave(),L=h.stackAlloc(B*4),X=h.stackAlloc(B*4),A=h.stackAlloc(P*4),Z=h.stackAlloc(P*4);try{[R,T]=Ga(m);for(let ue=0;ue<B;ue++)cc(e[ue],k,K,t,r[ue]);for(let ue=0;ue<P;ue++)cc(l[ue],U,K,t,B+d[ue]);let re=L/4,ie=X/4,Ce=A/4,H=Z/4;for(let ue=0;ue<B;ue++)h.HEAPU32[re++]=k[ue],h.HEAPU32[ie++]=_[r[ue]];for(let ue=0;ue<P;ue++)h.HEAPU32[Ce++]=U[ue],h.HEAPU32[H++]=O[d[ue]];if(j){let{handle:ue,outputPreferredLocations:ae,outputPreferredLocationsEncoded:Ze}=j;if(_.length!==B)throw new Error(`input count from feeds (${B}) is expected to be always equal to model\'s input count (${_.length}).`);for(let Ie=0;Ie<B;Ie++){let He=r[Ie];await h._OrtBindInput(ue,_[He],k[Ie])!==0&&We(`Can\'t bind input[${Ie}] for session=${t}.`)}for(let Ie=0;Ie<P;Ie++){let He=d[Ie];l[Ie]?.[3]?h._OrtBindOutput(ue,O[He],U[Ie],0)!==0&&We(`Can\'t bind pre-allocated output[${Ie}] for session=${t}.`):h._OrtBindOutput(ue,O[He],0,Ze[He])!==0&&We(`Can\'t bind output[${Ie}] to ${ae[Ie]} for session=${t}.`)}}let le;j?le=await h._OrtRunWithBinding(w,j.handle,P,A,R):le=await h._OrtRun(w,X,L,B,Z,P,A,R),le!==0&&We("failed to call OrtRun().");let Be=[];for(let ue=0;ue<P;ue++){let ae=h.HEAPU32[A/4+ue];if(ae===U[ue]){Be.push(l[ue]);continue}let Ze=h.stackSave(),Ie=h.stackAlloc(4*4),He=!1,Ee,qe=0;try{h._OrtGetTensorData(ae,Ie,Ie+4,Ie+8,Ie+12)!==0&&We(`Can\'t access output tensor data on index ${ue}.`);let Je=Ie/4,_t=h.HEAPU32[Je++];qe=h.HEAPU32[Je++];let ee=h.HEAPU32[Je++],$e=h.HEAPU32[Je++],Oe=[];for(let Ge=0;Ge<$e;Ge++)Oe.push(h.HEAPU32[ee/4+Ge]);h._OrtFree(ee);let et=Oe.reduce((Ge,Me)=>Ge*Me,1);Ee=tn(_t);let tt=j?.outputPreferredLocations[d[ue]];if(Ee==="string"){if(tt==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Ge=[],Me=qe/4;for(let rt=0;rt<et;rt++){let yt=h.HEAPU32[Me++],ut=rt===et-1?void 0:h.HEAPU32[Me]-yt;Ge.push(h.UTF8ToString(yt,ut))}Be.push([Ee,Oe,Ge,"cpu"])}else if(tt==="gpu-buffer"&&et>0){let Ge=h.jsepGetBuffer(qe),Me=rn(_t);if(Me===void 0||!Ua(Ee))throw new Error(`Unsupported data type: ${Ee}`);He=!0,Be.push([Ee,Oe,{gpuBuffer:Ge,download:h.jsepCreateDownloader(Ge,et*Me,Ee),dispose:()=>{h._OrtReleaseTensor(ae)}},"gpu-buffer"])}else{let Ge=zn(Ee),Me=new Ge(et);new Uint8Array(Me.buffer,Me.byteOffset,Me.byteLength).set(h.HEAPU8.subarray(qe,qe+Me.byteLength)),Be.push([Ee,Oe,Me,"cpu"])}}finally{h.stackRestore(Ze),Ee==="string"&&qe&&h._free(qe),He||h._OrtReleaseTensor(ae)}}return j&&h._OrtClearBoundOutputs(j.handle),Be}finally{h.stackRestore(Q),k.forEach(re=>h._OrtReleaseTensor(re)),U.forEach(re=>h._OrtReleaseTensor(re)),K.forEach(re=>h._free(re)),R!==0&&h._OrtReleaseRunOptions(R),T.forEach(re=>h._free(re))}},hc=t=>{let r=Ue(),e=cn.get(t);if(!e)throw new Error("invalid session id");let d=e[0],l=r._OrtEndProfiling(d);l===0&&We("Can\'t get an profile file name."),r._OrtFree(l)},gc=t=>{let r=[];for(let e of t){let d=e[2];!Array.isArray(d)&&"buffer"in d&&r.push(d.buffer)}return r};self.onmessage=t=>{switch(t.data.type){case"init-wasm":try{za(t.data.in).then(()=>postMessage({type:"init-wasm"}),r=>postMessage({type:"init-wasm",err:r}))}catch(r){postMessage({type:"init-wasm",err:r})}break;case"init-ort":try{dc(t.data.in).then(()=>postMessage({type:"init-ort"}),r=>postMessage({type:"init-ort",err:r}))}catch(r){postMessage({type:"init-ort",err:r})}break;case"create_allocate":try{let{model:r}=t.data.in,e=Ui(r);postMessage({type:"create_allocate",out:e})}catch(r){postMessage({type:"create_allocate",err:r})}break;case"create_finalize":try{let{modeldata:r,options:e}=t.data.in,d=Ni(r,e);postMessage({type:"create_finalize",out:d})}catch(r){postMessage({type:"create_finalize",err:r})}break;case"create":try{let{model:r,options:e}=t.data.in,d=fc(r,e);postMessage({type:"create",out:d})}catch(r){postMessage({type:"create",err:r})}break;case"release":try{let r=t.data.in;pc(r),postMessage({type:"release"})}catch(r){postMessage({type:"release",err:r})}break;case"run":try{let{sessionId:r,inputIndices:e,inputs:d,outputIndices:l,options:m}=t.data.in;mc(r,e,d,l,m).then(h=>{postMessage({type:"run",out:h},gc(h))},h=>{postMessage({type:"run",err:h})})}catch(r){postMessage({type:"run",err:r})}break;case"end-profiling":try{let r=t.data.in;hc(r),postMessage({type:"end-profiling"})}catch(r){postMessage({type:"end-profiling",err:r})}break;default:}};})();\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n'});var qr,Ht,ds,dl,pl,il,ol,al,sl,ul,ll,cl,fl,In,gI,fs,av,sv,uv,lv,hl,cv,fv,dv,ml=X(()=>{"use strict";lr();iv();ii();qr=()=>!!De.wasm.proxy&&typeof document<"u",ds=!1,dl=!1,pl=!1,al=[],sl=[],ul=[],ll=[],cl=[],fl=[],In=()=>{if(ds||!dl||pl||!Ht)throw new Error("worker not ready")},gI=n=>{switch(n.data.type){case"init-wasm":ds=!1,n.data.err?(pl=!0,il[1](n.data.err)):(dl=!0,il[0]());break;case"init-ort":n.data.err?ol[1](n.data.err):ol[0]();break;case"create_allocate":n.data.err?al.shift()[1](n.data.err):al.shift()[0](n.data.out);break;case"create_finalize":n.data.err?sl.shift()[1](n.data.err):sl.shift()[0](n.data.out);break;case"create":n.data.err?ul.shift()[1](n.data.err):ul.shift()[0](n.data.out);break;case"release":n.data.err?ll.shift()[1](n.data.err):ll.shift()[0]();break;case"run":n.data.err?cl.shift()[1](n.data.err):cl.shift()[0](n.data.out);break;case"end-profiling":n.data.err?fl.shift()[1](n.data.err):fl.shift()[0]();break;default:}},fs=typeof document<"u"?document?.currentScript?.src:void 0,av=async()=>{if(qr()){if(dl)return;if(ds)throw new Error("multiple calls to 'initWasm()' detected.");if(pl)throw new Error("previous call to 'initWasm()' failed.");return ds=!0,De.wasm.wasmPaths===void 0&&fs&&fs.indexOf("blob:")!==0&&(De.wasm.wasmPaths=fs.substr(0,+fs.lastIndexOf("/")+1)),new Promise((n,e)=>{Ht?.terminate();let r=URL.createObjectURL(new Blob([ov()],{type:"text/javascript"}));Ht=new Worker(r,{name:"ort-wasm-proxy-worker"}),Ht.onerror=i=>e(i),Ht.onmessage=gI,URL.revokeObjectURL(r),il=[n,e];let t={type:"init-wasm",in:De.wasm};Ht.postMessage(t)})}else return Wg(De.wasm)},sv=async n=>{if(qr())return In(),new Promise((e,r)=>{ol=[e,r];let t={type:"init-ort",in:n};Ht.postMessage(t)});await Z0(n)},uv=async n=>qr()?(In(),new Promise((e,r)=>{al.push([e,r]);let t={type:"create_allocate",in:{model:n}};Ht.postMessage(t,[n.buffer])})):rl(n),lv=async(n,e)=>qr()?(In(),new Promise((r,t)=>{sl.push([r,t]);let i={type:"create_finalize",in:{modeldata:n,options:e}};Ht.postMessage(i)})):nl(n,e),hl=async(n,e)=>{if(qr()){if(e?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return In(),new Promise((r,t)=>{ul.push([r,t]);let i={type:"create",in:{model:n,options:e}};Ht.postMessage(i,[n.buffer])})}else return Q0(n,e)},cv=async n=>{if(qr())return In(),new Promise((e,r)=>{ll.push([e,r]);let t={type:"release",in:n};Ht.postMessage(t)});ev(n)},fv=async(n,e,r,t,i,o)=>{if(qr()){if(r.some(s=>s[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(i.some(s=>s))throw new Error("pre-allocated output tensor is not supported for proxy.");return In(),new Promise((s,a)=>{cl.push([s,a]);let u=r,c={type:"run",in:{sessionId:n,inputIndices:e,inputs:u,outputIndices:t,options:o}};Ht.postMessage(c,nv(u))})}else return tv(n,e,r,t,i,o)},dv=async n=>{if(qr())return In(),new Promise((e,r)=>{fl.push([e,r]);let t={type:"end-profiling",in:n};Ht.postMessage(t)});rv(n)}});var pv,ps,hv,yI,hs,mv=X(()=>{"use strict";lr();ml();_t();hv=(n,e)=>{switch(n.location){case"cpu":return[n.type,n.dims,n.data,"cpu"];case"gpu-buffer":return[n.type,n.dims,{gpuBuffer:n.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${n.location} for ${e()}`)}},yI=n=>{switch(n[3]){case"cpu":return new qt(n[0],n[2],n[1]);case"gpu-buffer":{let e=n[0];if(!Va(e))throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);let{gpuBuffer:r,download:t,dispose:i}=n[2];return qt.fromGpuBuffer(r,{dataType:e,dims:n[1],download:t,dispose:i})}default:throw new Error(`invalid data location: ${n[3]}`)}},hs=class{async createSessionAllocate(e){let r=await fetch(e);if(r.status!==200)throw new Error(`failed to load model: ${e}`);let t=await r.arrayBuffer();return uv(new Uint8Array(t))}async loadModel(e,r){if(pv||(ps||(ps=sv(De)),await ps,ps=void 0,pv=!0),typeof e=="string")if(typeof process<"u"&&process.versions&&process.versions.node){let t=await(void 0)(e);[this.sessionId,this.inputNames,this.outputNames]=await hl(t,r)}else{let t=await this.createSessionAllocate(e);[this.sessionId,this.inputNames,this.outputNames]=await lv(t,r)}else[this.sessionId,this.inputNames,this.outputNames]=await hl(e,r)}async dispose(){return cv(this.sessionId)}async run(e,r,t){let i=[],o=[];Object.entries(e).forEach(T=>{let S=T[0],O=T[1],I=this.inputNames.indexOf(S);if(I===-1)throw new Error(`invalid input '${S}'`);i.push(O),o.push(I)});let s=[],a=[];Object.entries(r).forEach(T=>{let S=T[0],O=T[1],I=this.outputNames.indexOf(S);if(I===-1)throw new Error(`invalid output '${S}'`);s.push(O),a.push(I)});let u=i.map((T,S)=>hv(T,()=>`input "${this.inputNames[o[S]]}"`)),c=s.map((T,S)=>T?hv(T,()=>`output "${this.outputNames[a[S]]}"`):null),g=await fv(this.sessionId,o,u,a,c,t),v={};for(let T=0;T<g.length;T++)v[this.outputNames[a[T]]]=s[T]??yI(g[T]);return v}startProfiling(){}endProfiling(){dv(this.sessionId)}}});var bI,ms,gv=X(()=>{"use strict";lr();ml();mv();bI=()=>{if((typeof De.wasm.initTimeout!="number"||De.wasm.initTimeout<0)&&(De.wasm.initTimeout=0),typeof De.wasm.simd!="boolean"&&(De.wasm.simd=!0),typeof De.wasm.proxy!="boolean"&&(De.wasm.proxy=!1),typeof De.wasm.numThreads!="number"||!Number.isInteger(De.wasm.numThreads)||De.wasm.numThreads<=0){let n=typeof navigator>"u"?(void 0)().length:navigator.hardwareConcurrency;De.wasm.numThreads=Math.min(4,Math.ceil((n||1)/2))}},ms=class{async init(){bI(),await av()}async createInferenceSessionHandler(e,r){let t=new hs;return await t.loadModel(e,r),Promise.resolve(t)}}});var yv={};ln(yv,{wasmBackend:()=>vI});var vI,bv=X(()=>{"use strict";gv();vI=new ms});var wI={};ln(wI,{InferenceSession:()=>I1,Tensor:()=>qt,TrainingSession:()=>C1,env:()=>De,registerBackend:()=>Mr});module.exports=Rr(wI);lr();lr();var Sf="1.17.0";{let n=(Og(),Rr(Ag)).onnxjsBackend;Mr("webgl",n,-10)}{let n=(bv(),Rr(yv)).wasmBackend;typeof navigator<"u"&&navigator.gpu&&Mr("webgpu",n,5),Mr("cpu",n,10),Mr("wasm",n,10),Mr("xnnpack",n,9),Mr("webnn",n,9)}Object.defineProperty(De.versions,"web",{value:Sf,enumerable:!0});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/*! Bundled license information:

long/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=ort.all.min.js.map
