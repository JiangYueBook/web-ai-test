/*!
 * ONNX Runtime Web v1.17.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
"use strict";var Tn=Object.defineProperty;var Ih=Object.getOwnPropertyDescriptor;var Ah=Object.getOwnPropertyNames;var Eh=Object.prototype.hasOwnProperty;var ie=(t,r)=>()=>(t&&(r=t(t=0)),r);var wr=(t,r)=>()=>(r||t((r={exports:{}}).exports,r),r.exports),$r=(t,r)=>{for(var e in r)Tn(t,e,{get:r[e],enumerable:!0})},Oh=(t,r,e,d)=>{if(r&&typeof r=="object"||typeof r=="function")for(let u of Ah(r))!Eh.call(t,u)&&u!==e&&Tn(t,u,{get:()=>r[u],enumerable:!(d=Ih(r,u))||d.enumerable});return t};var kt=t=>Oh(Tn({},"__esModule",{value:!0}),t);var Ki,Xt,jt,ss,Rn=ie(()=>{"use strict";Ki=new Map,Xt=[],jt=(t,r,e)=>{if(r&&typeof r.init=="function"&&typeof r.createInferenceSessionHandler=="function"){let d=Ki.get(t);if(d===void 0)Ki.set(t,{backend:r,priority:e});else{if(d.priority>e)return;if(d.priority===e&&d.backend!==r)throw new Error(`cannot register backend "${t}" using priority ${e}`)}if(e>=0){let u=Xt.indexOf(t);u!==-1&&Xt.splice(u,1);for(let h=0;h<Xt.length;h++)if(Ki.get(Xt[h]).priority<=e){Xt.splice(h,0,t);return}Xt.push(t)}return}throw new TypeError("not a valid backend")},ss=async t=>{let r=t.length===0?Xt:t,e=[];for(let d of r){let u=Ki.get(d);if(u){if(u.initialized)return u.backend;if(u.aborted)continue;let h=!!u.initPromise;try{return h||(u.initPromise=u.backend.init()),await u.initPromise,u.initialized=!0,u.backend}catch(m){h||e.push({name:d,err:m}),u.aborted=!0}finally{delete u.initPromise}}}throw new Error(`no available backend found. ERR: ${e.map(d=>`[${d.name}] ${d.err}`).join(", ")}`)}});var us=ie(()=>{"use strict";Rn()});var ls,ds=ie(()=>{"use strict";ls="1.17.0"});var cs,kn,fs=ie(()=>{"use strict";ds();cs="warning",kn={wasm:{},webgl:{},webgpu:{},versions:{common:ls},set logLevel(t){if(t!==void 0){if(typeof t!="string"||["verbose","info","warning","error","fatal"].indexOf(t)===-1)throw new Error(`Unsupported logging level: ${t}`);cs=t}},get logLevel(){return cs}};Object.defineProperty(kn,"logLevel",{enumerable:!0})});var ze,ps=ie(()=>{"use strict";fs();ze=kn});var hs,ms,gs=ie(()=>{"use strict";hs=(t,r)=>{let e=document.createElement("canvas");e.width=t.dims[3],e.height=t.dims[2];let d=e.getContext("2d");if(d!=null){let u,h;r?.tensorLayout!==void 0&&r.tensorLayout==="NHWC"?(u=t.dims[2],h=t.dims[3]):(u=t.dims[3],h=t.dims[2]);let m=r?.format!==void 0?r.format:"RGB",o=r?.norm,y,$;o===void 0||o.mean===void 0?y=[255,255,255,255]:typeof o.mean=="number"?y=[o.mean,o.mean,o.mean,o.mean]:(y=[o.mean[0],o.mean[1],o.mean[2],0],o.mean[3]!==void 0&&(y[3]=o.mean[3])),o===void 0||o.bias===void 0?$=[0,0,0,0]:typeof o.bias=="number"?$=[o.bias,o.bias,o.bias,o.bias]:($=[o.bias[0],o.bias[1],o.bias[2],0],o.bias[3]!==void 0&&($[3]=o.bias[3]));let A=h*u,T=0,O=A,R=A*2,j=-1;m==="RGBA"?(T=0,O=A,R=A*2,j=A*3):m==="RGB"?(T=0,O=A,R=A*2):m==="RBG"&&(T=0,R=A,O=A*2);for(let k=0;k<h;k++)for(let P=0;P<u;P++){let D=(t.data[T++]-$[0])*y[0],F=(t.data[O++]-$[1])*y[1],Y=(t.data[R++]-$[2])*y[2],L=j===-1?255:(t.data[j++]-$[3])*y[3];d.fillStyle="rgba("+D+","+F+","+Y+","+L+")",d.fillRect(P,k,1,1)}return e.toDataURL()}else throw new Error("Can not access image data")},ms=(t,r)=>{let e=document.createElement("canvas").getContext("2d"),d;if(e!=null){let u,h,m;r?.tensorLayout!==void 0&&r.tensorLayout==="NHWC"?(u=t.dims[2],h=t.dims[1],m=t.dims[3]):(u=t.dims[3],h=t.dims[2],m=t.dims[1]);let o=r!==void 0&&r.format!==void 0?r.format:"RGB",y=r?.norm,$,A;y===void 0||y.mean===void 0?$=[255,255,255,255]:typeof y.mean=="number"?$=[y.mean,y.mean,y.mean,y.mean]:($=[y.mean[0],y.mean[1],y.mean[2],255],y.mean[3]!==void 0&&($[3]=y.mean[3])),y===void 0||y.bias===void 0?A=[0,0,0,0]:typeof y.bias=="number"?A=[y.bias,y.bias,y.bias,y.bias]:(A=[y.bias[0],y.bias[1],y.bias[2],0],y.bias[3]!==void 0&&(A[3]=y.bias[3]));let T=h*u;if(r!==void 0&&(r.format!==void 0&&m===4&&r.format!=="RGBA"||m===3&&r.format!=="RGB"&&r.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let O=4,R=0,j=1,k=2,P=3,D=0,F=T,Y=T*2,L=-1;o==="RGBA"?(D=0,F=T,Y=T*2,L=T*3):o==="RGB"?(D=0,F=T,Y=T*2):o==="RBG"&&(D=0,Y=T,F=T*2),d=e.createImageData(u,h);for(let X=0;X<h*u;R+=O,j+=O,k+=O,P+=O,X++)d.data[R]=(t.data[D++]-A[0])*$[0],d.data[j]=(t.data[F++]-A[1])*$[1],d.data[k]=(t.data[Y++]-A[2])*$[2],d.data[P]=L===-1?255:(t.data[L++]-A[3])*$[3]}else throw new Error("Can not access image data");return d}});var jn,ys,vs,bs,ws,$s=ie(()=>{"use strict";Yi();jn=(t,r)=>{if(t===void 0)throw new Error("Image buffer must be defined");if(r.height===void 0||r.width===void 0)throw new Error("Image height and width must be defined");if(r.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:e,width:d}=r,u=r.norm??{mean:255,bias:0},h,m;typeof u.mean=="number"?h=[u.mean,u.mean,u.mean,u.mean]:h=[u.mean[0],u.mean[1],u.mean[2],u.mean[3]??255],typeof u.bias=="number"?m=[u.bias,u.bias,u.bias,u.bias]:m=[u.bias[0],u.bias[1],u.bias[2],u.bias[3]??0];let o=r.format!==void 0?r.format:"RGBA",y=r.tensorFormat!==void 0&&r.tensorFormat!==void 0?r.tensorFormat:"RGB",$=e*d,A=y==="RGBA"?new Float32Array($*4):new Float32Array($*3),T=4,O=0,R=1,j=2,k=3,P=0,D=$,F=$*2,Y=-1;o==="RGB"&&(T=3,O=0,R=1,j=2,k=-1),y==="RGBA"?Y=$*3:y==="RBG"?(P=0,F=$,D=$*2):y==="BGR"&&(F=0,D=$,P=$*2);for(let X=0;X<$;X++,O+=T,j+=T,R+=T,k+=T)A[P++]=(t[O]+m[0])/h[0],A[D++]=(t[R]+m[1])/h[1],A[F++]=(t[j]+m[2])/h[2],Y!==-1&&k!==-1&&(A[Y++]=(t[k]+m[3])/h[3]);return y==="RGBA"?new rt("float32",A,[1,4,e,d]):new rt("float32",A,[1,3,e,d])},ys=async(t,r)=>{let e=typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement,d=typeof ImageData<"u"&&t instanceof ImageData,u=typeof ImageBitmap<"u"&&t instanceof ImageBitmap,h=typeof t=="string",m,o=r??{};if(e){let y=document.createElement("canvas");y.width=t.width,y.height=t.height;let $=y.getContext("2d");if($!=null){let A=t.height,T=t.width;if(r!==void 0&&r.resizedHeight!==void 0&&r.resizedWidth!==void 0&&(A=r.resizedHeight,T=r.resizedWidth),r!==void 0){if(o=r,r.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");o.tensorFormat="RGBA",o.height=A,o.width=T}else o.tensorFormat="RGBA",o.height=A,o.width=T;$.drawImage(t,0,0),m=$.getImageData(0,0,T,A).data}else throw new Error("Can not access image data")}else if(d){let y,$;if(r!==void 0&&r.resizedWidth!==void 0&&r.resizedHeight!==void 0?(y=r.resizedHeight,$=r.resizedWidth):(y=t.height,$=t.width),r!==void 0&&(o=r),o.format="RGBA",o.height=y,o.width=$,r!==void 0){let A=document.createElement("canvas");A.width=$,A.height=y;let T=A.getContext("2d");if(T!=null)T.putImageData(t,0,0),m=T.getImageData(0,0,$,y).data;else throw new Error("Can not access image data")}else m=t.data}else if(u){if(r===void 0)throw new Error("Please provide image config with format for Imagebitmap");let y=document.createElement("canvas");y.width=t.width,y.height=t.height;let $=y.getContext("2d");if($!=null){let A=t.height,T=t.width;return $.drawImage(t,0,0,T,A),m=$.getImageData(0,0,T,A).data,o.height=A,o.width=T,jn(m,o)}else throw new Error("Can not access image data")}else{if(h)return new Promise((y,$)=>{let A=document.createElement("canvas"),T=A.getContext("2d");if(!t||!T)return $();let O=new Image;O.crossOrigin="Anonymous",O.src=t,O.onload=()=>{A.width=O.width,A.height=O.height,T.drawImage(O,0,0,A.width,A.height);let R=T.getImageData(0,0,A.width,A.height);o.height=A.height,o.width=A.width,y(jn(R.data,o))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(m!==void 0)return jn(m,o);throw new Error("Input data provided is not supported - aborted tensor creation")},vs=(t,r)=>{let{width:e,height:d,download:u,dispose:h}=r,m=[1,d,e,4];return new rt({location:"texture",type:"float32",texture:t,dims:m,download:u,dispose:h})},bs=(t,r)=>{let{dataType:e,dims:d,download:u,dispose:h}=r;return new rt({location:"gpu-buffer",type:e??"float32",gpuBuffer:t,dims:d,download:u,dispose:h})},ws=(t,r,e)=>new rt({location:"cpu-pinned",type:t,data:r,dims:e??[r.length]})});var ci,Xi,Cs,_s,xs=ie(()=>{"use strict";ci=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),Xi=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),Cs=!1,_s=()=>{if(!Cs){Cs=!0;let t=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",r=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function";t&&(ci.set("int64",BigInt64Array),Xi.set(BigInt64Array,"int64")),r&&(ci.set("uint64",BigUint64Array),Xi.set(BigUint64Array,"uint64"))}}});var Ss,Is,As=ie(()=>{"use strict";Yi();Ss=t=>{let r=1;for(let e=0;e<t.length;e++){let d=t[e];if(typeof d!="number"||!Number.isSafeInteger(d))throw new TypeError(`dims[${e}] must be an integer, got: ${d}`);if(d<0)throw new RangeError(`dims[${e}] must be a non-negative integer, got: ${d}`);r*=d}return r},Is=(t,r)=>{switch(t.location){case"cpu":return new rt(t.type,t.data,r);case"cpu-pinned":return new rt({location:"cpu-pinned",data:t.data,type:t.type,dims:r});case"texture":return new rt({location:"texture",texture:t.texture,type:t.type,dims:r});case"gpu-buffer":return new rt({location:"gpu-buffer",gpuBuffer:t.gpuBuffer,type:t.type,dims:r});default:throw new Error(`tensorReshape: tensor location ${t.location} is not supported`)}}});var rt,Yi=ie(()=>{"use strict";gs();$s();xs();As();rt=class{constructor(r,e,d){_s();let u,h;if(typeof r=="object"&&"location"in r)switch(this.dataLocation=r.location,u=r.type,h=r.dims,r.location){case"cpu-pinned":{let o=ci.get(u);if(!o)throw new TypeError(`unsupported type "${u}" to create tensor from pinned buffer`);if(!(r.data instanceof o))throw new TypeError(`buffer should be of type ${o.name}`);this.cpuData=r.data;break}case"texture":{if(u!=="float32")throw new TypeError(`unsupported type "${u}" to create tensor from texture`);this.gpuTextureData=r.texture,this.downloader=r.download,this.disposer=r.dispose;break}case"gpu-buffer":{if(u!=="float32"&&u!=="float16"&&u!=="int32"&&u!=="int64"&&u!=="uint32"&&u!=="bool")throw new TypeError(`unsupported type "${u}" to create tensor from gpu buffer`);this.gpuBufferData=r.gpuBuffer,this.downloader=r.download,this.disposer=r.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let o,y;if(typeof r=="string")if(u=r,y=d,r==="string"){if(!Array.isArray(e))throw new TypeError("A string tensor's data must be a string array.");o=e}else{let $=ci.get(r);if($===void 0)throw new TypeError(`Unsupported tensor type: ${r}.`);if(Array.isArray(e)){if(r==="float16")throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");r==="uint64"||r==="int64"?o=$.from(e,BigInt):o=$.from(e)}else if(e instanceof $)o=e;else throw new TypeError(`A ${u} tensor's data must be type of ${$}`)}else if(y=e,Array.isArray(r)){if(r.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let $=typeof r[0];if($==="string")u="string",o=r;else if($==="boolean")u="bool",o=Uint8Array.from(r);else throw new TypeError(`Invalid element type of data array: ${$}.`)}else{let $=Xi.get(r.constructor);if($===void 0)throw new TypeError(`Unsupported type for tensor data: ${r.constructor}.`);u=$,o=r}if(y===void 0)y=[o.length];else if(!Array.isArray(y))throw new TypeError("A tensor's dims must be a number array");h=y,this.cpuData=o,this.dataLocation="cpu"}let m=Ss(h);if(this.cpuData&&m!==this.cpuData.length)throw new Error(`Tensor's size(${m}) does not match data length(${this.cpuData.length}).`);this.type=u,this.dims=h,this.size=m}static async fromImage(r,e){return ys(r,e)}static fromTexture(r,e){return vs(r,e)}static fromGpuBuffer(r,e){return bs(r,e)}static fromPinnedBuffer(r,e,d){return ws(r,e,d)}toDataURL(r){return hs(this,r)}toImageData(r){return ms(this,r)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(r){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let e=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=e,r&&this.disposer&&(this.disposer(),this.disposer=void 0),e}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(r){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return Is(this,r)}}});var xt,Pn=ie(()=>{"use strict";Yi();xt=rt});var Qi,Es=ie(()=>{"use strict";Rn();Pn();Qi=class t{constructor(r){this.handler=r}async run(r,e,d){let u={},h={};if(typeof r!="object"||r===null||r instanceof xt||Array.isArray(r))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let m=!0;if(typeof e=="object"){if(e===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(e instanceof xt)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(e)){if(e.length===0)throw new TypeError("'fetches' cannot be an empty array.");m=!1;for(let $ of e){if(typeof $!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf($)===-1)throw new RangeError(`'fetches' contains invalid output name: ${$}.`);u[$]=null}if(typeof d=="object"&&d!==null)h=d;else if(typeof d<"u")throw new TypeError("'options' must be an object.")}else{let $=!1,A=Object.getOwnPropertyNames(e);for(let T of this.outputNames)if(A.indexOf(T)!==-1){let O=e[T];(O===null||O instanceof xt)&&($=!0,m=!1,u[T]=O)}if($){if(typeof d=="object"&&d!==null)h=d;else if(typeof d<"u")throw new TypeError("'options' must be an object.")}else h=e}}else if(typeof e<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let $ of this.inputNames)if(typeof r[$]>"u")throw new Error(`input '${$}' is missing in 'feeds'.`);if(m)for(let $ of this.outputNames)u[$]=null;let o=await this.handler.run(r,u,h),y={};for(let $ in o)if(Object.hasOwnProperty.call(o,$)){let A=o[$];A instanceof xt?y[$]=A:y[$]=new xt(A.type,A.data,A.dims)}return y}async release(){return this.handler.dispose()}static async create(r,e,d,u){let h,m={};if(typeof r=="string"){if(h=r,typeof e=="object"&&e!==null)m=e;else if(typeof e<"u")throw new TypeError("'options' must be an object.")}else if(r instanceof Uint8Array){if(h=r,typeof e=="object"&&e!==null)m=e;else if(typeof e<"u")throw new TypeError("'options' must be an object.")}else if(r instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&r instanceof SharedArrayBuffer){let T=r,O=0,R=r.byteLength;if(typeof e=="object"&&e!==null)m=e;else if(typeof e=="number"){if(O=e,!Number.isSafeInteger(O))throw new RangeError("'byteOffset' must be an integer.");if(O<0||O>=T.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${T.byteLength}).`);if(R=r.byteLength-O,typeof d=="number"){if(R=d,!Number.isSafeInteger(R))throw new RangeError("'byteLength' must be an integer.");if(R<=0||O+R>T.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${T.byteLength-O}].`);if(typeof u=="object"&&u!==null)m=u;else if(typeof u<"u")throw new TypeError("'options' must be an object.")}else if(typeof d<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof e<"u")throw new TypeError("'options' must be an object.");h=new Uint8Array(T,O,R)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let y=(m.executionProviders||[]).map(T=>typeof T=="string"?T:T.name),A=await(await ss(y)).createInferenceSessionHandler(h,m);return new t(A)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var Th,Os=ie(()=>{"use strict";Es();Th=Qi});var Ts=ie(()=>{"use strict"});var Ji,Rs=ie(()=>{"use strict";Ji=class{constructor(r){this.handler=r}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}static async create(r,e){throw new Error("Method not implemented")}async loadParametersBuffer(r,e){throw new Error("Method not implemented.")}async getContiguousParameters(r){throw new Error("Method not implemented.")}async runTrainStep(r,e,d){throw new Error("Method not implemented.")}async release(){return this.handler.dispose()}}});var Rh,ks=ie(()=>{"use strict";Rs();Rh=Ji});var Qt=ie(()=>{"use strict";us();ps();Os();Pn();Ts();ks()});var Bn={};$r(Bn,{readFile:()=>kh});var kh,Mn=ie(()=>{kh=void 0});var Dn={};$r(Dn,{join:()=>jh});var jh,zn=ie(()=>{jh=void 0});var Ms=wr((Bs,Wn)=>{"use strict";var Ps=(()=>{var t=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(t=t||__filename),function(r={}){var e=r,d,u;e.ready=new Promise((i,n)=>{d=i,u=n}),e.jsepInit=(i,n,a,s,l,f,p,g)=>{e.zh=i,e.ph=n,e.rh=a,e.eh=s,e.qh=l,e.Cd=f,e.sh=p,e.th=g,n=(v,w,C)=>(...S)=>{let E=at,_=w?.();S=v(...S);let M=w?.();return _!==M&&(v=M,C(_),w=C=null),at!=E?Ai():S},a=v=>async(...w)=>{try{if(e.Xg)throw Error("Session already started");let C=e.Xg={uh:w[0],errors:[]},S=await v(...w);if(e.Xg!==C)throw Error("Session mismatch");i.flush();let E=C.errors;if(0<E.length){let _=await Promise.all(E);if(_=_.filter(M=>M),0<_.length)throw Error(_.join(`
`))}return S}finally{e.Xg=null}},e._OrtRun=a(n(e._OrtRun,()=>e._OrtRun,v=>e._OrtRun=v)),e._OrtRunWithBinding=a(n(e._OrtRunWithBinding,()=>e._OrtRunWithBinding,v=>e._OrtRunWithBinding=v)),e._OrtBindInput=n(e._OrtBindInput,()=>e._OrtBindInput,v=>e._OrtBindInput=v),e.jsepRegisterBuffer=(v,w,C,S)=>i.registerBuffer(v,w,C,S),e.jsepUnregisterBuffers=v=>{i.unregisterBuffers(v)},e.jsepGetBuffer=v=>i.getBuffer(v),e.jsepCreateDownloader=(v,w,C)=>i.createDownloader(v,w,C)};var h=Object.assign({},e),m="./this.program",o=(i,n)=>{throw n},y=typeof window=="object",$=typeof importScripts=="function",A=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",T="",O,R,j;if(A){var k=(Mn(),kt(Bn)),P=(zn(),kt(Dn));T=$?P.dirname(T)+"/":__dirname+"/",O=(i,n)=>(i=i.startsWith("file://")?new URL(i):P.normalize(i),k.readFileSync(i,n?void 0:"utf8")),j=i=>(i=O(i,!0),i.buffer||(i=new Uint8Array(i)),i),R=(i,n,a,s=!0)=>{i=i.startsWith("file://")?new URL(i):P.normalize(i),k.readFile(i,s?void 0:"utf8",(l,f)=>{l?a(l):n(s?f.buffer:f)})},!e.thisProgram&&1<process.argv.length&&(m=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),o=(i,n)=>{throw process.exitCode=i,n},e.inspect=()=>"[Emscripten Module object]"}else(y||$)&&($?T=self.location.href:typeof document<"u"&&document.currentScript&&(T=document.currentScript.src),t&&(T=t),T.indexOf("blob:")!==0?T=T.substr(0,T.replace(/[?#].*/,"").lastIndexOf("/")+1):T="",O=i=>{var n=new XMLHttpRequest;return n.open("GET",i,!1),n.send(null),n.responseText},$&&(j=i=>{var n=new XMLHttpRequest;return n.open("GET",i,!1),n.responseType="arraybuffer",n.send(null),new Uint8Array(n.response)}),R=(i,n,a)=>{var s=new XMLHttpRequest;s.open("GET",i,!0),s.responseType="arraybuffer",s.onload=()=>{s.status==200||s.status==0&&s.response?n(s.response):a()},s.onerror=a,s.send(null)});var D=e.print||console.log.bind(console),F=e.printErr||console.error.bind(console);Object.assign(e,h),h=null,e.thisProgram&&(m=e.thisProgram),e.quit&&(o=e.quit);var Y;e.wasmBinary&&(Y=e.wasmBinary);var L=e.noExitRuntime||!0;typeof WebAssembly!="object"&&Ze("no native wasm support detected");var X,I,Z=!1,re,ae,$e,q,le,Pe;function ue(){var i=X.buffer;e.HEAP8=ae=new Int8Array(i),e.HEAP16=new Int16Array(i),e.HEAP32=q=new Int32Array(i),e.HEAPU8=$e=new Uint8Array(i),e.HEAPU16=new Uint16Array(i),e.HEAPU32=le=new Uint32Array(i),e.HEAPF32=new Float32Array(i),e.HEAPF64=Pe=new Float64Array(i)}var oe=[],et=[],Ae=[];function Le(){var i=e.preRun.shift();oe.unshift(i)}var Te=0,Xe=null,bt=null;function Ze(i){throw e.onAbort&&e.onAbort(i),i="Aborted("+i+")",F(i),Z=!0,re=1,i=new WebAssembly.RuntimeError(i+". Build with -sASSERTIONS for more info."),u(i),i}function Ot(i){return i.startsWith("data:application/octet-stream;base64,")}var ee;if(ee="ort-wasm-simd.wasm",!Ot(ee)){var Ce=ee;ee=e.locateFile?e.locateFile(Ce,T):T+Ce}function Oe(i){if(i==ee&&Y)return new Uint8Array(Y);if(j)return j(i);throw"both async and sync fetching of the wasm failed"}function tt(i){if(!Y&&(y||$)){if(typeof fetch=="function"&&!i.startsWith("file://"))return fetch(i,{credentials:"same-origin"}).then(n=>{if(!n.ok)throw"failed to load wasm binary file at '"+i+"'";return n.arrayBuffer()}).catch(()=>Oe(i));if(R)return new Promise((n,a)=>{R(i,s=>n(new Uint8Array(s)),a)})}return Promise.resolve().then(()=>Oe(i))}function it(i,n,a){return tt(i).then(s=>WebAssembly.instantiate(s,n)).then(s=>s).then(a,s=>{F("failed to asynchronously prepare wasm: "+s),Ze(s)})}function Ue(i,n){var a=ee;return Y||typeof WebAssembly.instantiateStreaming!="function"||Ot(a)||a.startsWith("file://")||A||typeof fetch!="function"?it(a,i,n):fetch(a,{credentials:"same-origin"}).then(s=>WebAssembly.instantiateStreaming(s,i).then(n,function(l){return F("wasm streaming compile failed: "+l),F("falling back to ArrayBuffer instantiation"),it(a,i,n)}))}var Be,nt={1312944:i=>{e.Cd("Abs",i,void 0)},1312995:i=>{e.Cd("Neg",i,void 0)},1313046:i=>{e.Cd("Floor",i,void 0)},1313099:i=>{e.Cd("Ceil",i,void 0)},1313151:i=>{e.Cd("Reciprocal",i,void 0)},1313209:i=>{e.Cd("Sqrt",i,void 0)},1313261:i=>{e.Cd("Exp",i,void 0)},1313312:i=>{e.Cd("Erf",i,void 0)},1313363:i=>{e.Cd("Sigmoid",i,void 0)},1313418:i=>{e.Cd("Log",i,void 0)},1313469:i=>{e.Cd("Sin",i,void 0)},1313520:i=>{e.Cd("Cos",i,void 0)},1313571:i=>{e.Cd("Tan",i,void 0)},1313622:i=>{e.Cd("Asin",i,void 0)},1313674:i=>{e.Cd("Acos",i,void 0)},1313726:i=>{e.Cd("Atan",i,void 0)},1313778:i=>{e.Cd("Sinh",i,void 0)},1313830:i=>{e.Cd("Cosh",i,void 0)},1313882:i=>{e.Cd("Asinh",i,void 0)},1313935:i=>{e.Cd("Acosh",i,void 0)},1313988:i=>{e.Cd("Atanh",i,void 0)},1314041:i=>{e.Cd("Tanh",i,void 0)},1314093:i=>{e.Cd("Not",i,void 0)},1314144:(i,n,a)=>{e.Cd("ClipV10",i,{min:n,max:a})},1314216:i=>{e.Cd("Clip",i,void 0)},1314268:(i,n)=>{e.Cd("Elu",i,{alpha:n})},1314326:i=>{e.Cd("Relu",i,void 0)},1314378:(i,n)=>{e.Cd("LeakyRelu",i,{alpha:n})},1314442:(i,n)=>{e.Cd("ThresholdedRelu",i,{alpha:n})},1314512:(i,n)=>{e.Cd("Cast",i,{to:n})},1314570:i=>{e.Cd("Add",i,void 0)},1314621:i=>{e.Cd("Sub",i,void 0)},1314672:i=>{e.Cd("Mul",i,void 0)},1314723:i=>{e.Cd("Div",i,void 0)},1314774:i=>{e.Cd("Pow",i,void 0)},1314825:i=>{e.Cd("Equal",i,void 0)},1314878:i=>{e.Cd("Greater",i,void 0)},1314933:i=>{e.Cd("GreaterOrEqual",i,void 0)},1314995:i=>{e.Cd("Less",i,void 0)},1315047:i=>{e.Cd("LessOrEqual",i,void 0)},1315106:(i,n,a,s,l)=>{e.Cd("ReduceMean",i,{keepDims:!!n,noopWithEmptyAxes:!!a,axes:s?Array.from(q.subarray(l>>>0,l+s>>>0)):[]})},1315270:(i,n,a,s,l)=>{e.Cd("ReduceMax",i,{keepDims:!!n,noopWithEmptyAxes:!!a,axes:s?Array.from(q.subarray(l>>>0,l+s>>>0)):[]})},1315433:(i,n,a,s,l)=>{e.Cd("ReduceMin",i,{keepDims:!!n,noopWithEmptyAxes:!!a,axes:s?Array.from(q.subarray(l>>>0,l+s>>>0)):[]})},1315596:(i,n,a,s,l)=>{e.Cd("ReduceProd",i,{keepDims:!!n,noopWithEmptyAxes:!!a,axes:s?Array.from(q.subarray(l>>>0,l+s>>>0)):[]})},1315760:(i,n,a,s,l)=>{e.Cd("ReduceSum",i,{keepDims:!!n,noopWithEmptyAxes:!!a,axes:s?Array.from(q.subarray(l>>>0,l+s>>>0)):[]})},1315923:(i,n,a,s,l)=>{e.Cd("ReduceL1",i,{keepDims:!!n,noopWithEmptyAxes:!!a,axes:s?Array.from(q.subarray(l>>>0,l+s>>>0)):[]})},1316085:(i,n,a,s,l)=>{e.Cd("ReduceL2",i,{keepDims:!!n,noopWithEmptyAxes:!!a,axes:s?Array.from(q.subarray(l>>>0,l+s>>>0)):[]})},1316247:(i,n,a,s,l)=>{e.Cd("ReduceLogSum",i,{keepDims:!!n,noopWithEmptyAxes:!!a,axes:s?Array.from(q.subarray(l>>>0,l+s>>>0)):[]})},1316413:(i,n,a,s,l)=>{e.Cd("ReduceSumSquare",i,{keepDims:!!n,noopWithEmptyAxes:!!a,axes:s?Array.from(q.subarray(l>>>0,l+s>>>0)):[]})},1316582:(i,n,a,s,l)=>{e.Cd("ReduceLogSumExp",i,{keepDims:!!n,noopWithEmptyAxes:!!a,axes:s?Array.from(q.subarray(l>>>0,l+s>>>0)):[]})},1316751:i=>{e.Cd("Where",i,void 0)},1316804:(i,n,a)=>{e.Cd("Transpose",i,{perm:n?Array.from(q.subarray(a>>>0,a+n>>>0)):[]})},1316917:(i,n,a,s,l,f,p,g,v,w)=>{e.Cd("Conv",i,{format:v?"NHWC":"NCHW",auto_pad:n,dilations:[a],group:s,kernel_shape:[l],pads:[f,p],strides:[g],w_is_const:()=>!!ae[w>>>0]})},1317145:(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M)=>{e.Cd("Conv",i,{format:_?"NHWC":"NCHW",auto_pad:n,dilations:[a,s],group:l,kernel_shape:[f,p],pads:[g,v,w,C],strides:[S,E],w_is_const:()=>!!ae[M>>>0]})},1317404:(i,n,a,s,l,f,p,g,v,w)=>{e.Cd("Conv",i,{format:v?"NHWC":"NCHW",auto_pad:n,dilations:[a],group:s,kernel_shape:[l],pads:[f,p],strides:[g],w_is_const:()=>!!ae[w>>>0]})},1317632:(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M)=>{e.Cd("Conv",i,{format:_?"NHWC":"NCHW",auto_pad:n,dilations:[a,s],group:l,kernel_shape:[f,p],pads:[g,v,w,C],strides:[S,E],w_is_const:()=>!!ae[M>>>0]})},1317891:(i,n,a,s,l,f,p,g,v,w,C,S,E,_)=>{e.Cd("ConvTranspose",i,{format:v?"NHWC":"NCHW",autoPad:n,dilations:[a],group:s,kernel_shape:[l],pads:[f,p],strides:[g],wIsConst:()=>!!ae[w>>>0],outputPadding:C?Array.from(q.subarray(S>>>0,S+C>>>0)):[],outputShape:E?Array.from(q.subarray(_>>>0,_+E>>>0)):[]})},1318271:(i,n,a,s,l,f,p,g,v,w,C,S,E)=>{e.Cd("ConvTranspose",i,{format:g?"NHWC":"NCHW",autoPad:n,dilations:Array.from(q.subarray(a>>>0,a+2>>>0)),group:s,kernelShape:Array.from(q.subarray(l>>>0,l+2>>>0)),pads:Array.from(q.subarray(f>>>0,f+4>>>0)),strides:Array.from(q.subarray(p>>>0,p+2>>>0)),wIsConst:()=>!!ae[v>>>0],outputPadding:0<w?Array.from(q.subarray(C>>>0,C+w>>>0)):[],outputShape:0<S?Array.from(q.subarray(E>>>0,E+S>>>0)):[]})},1318794:(i,n,a,s,l,f,p,g,v,w,C,S,E,_)=>{e.Cd("ConvTranspose",i,{format:v?"NHWC":"NCHW",autoPad:n,dilations:[a],group:s,kernel_shape:[l],pads:[f,p],strides:[g],wIsConst:()=>!!ae[w>>>0],outputPadding:C?Array.from(q.subarray(S>>>0,S+C>>>0)):[],outputShape:E?Array.from(q.subarray(_>>>0,_+E>>>0)):[]})},1319174:(i,n,a,s,l,f,p,g,v,w,C,S,E)=>{e.Cd("ConvTranspose",i,{format:g?"NHWC":"NCHW",autoPad:n,dilations:Array.from(q.subarray(a>>>0,a+2>>>0)),group:s,kernelShape:Array.from(q.subarray(l>>>0,l+2>>>0)),pads:Array.from(q.subarray(f>>>0,f+4>>>0)),strides:Array.from(q.subarray(p>>>0,p+2>>>0)),wIsConst:()=>!!ae[v>>>0],outputPadding:0<w?Array.from(q.subarray(C>>>0,C+w>>>0)):[],outputShape:0<S?Array.from(q.subarray(E>>>0,E+S>>>0)):[]})},1319697:(i,n)=>{e.Cd("GlobalAveragePool",i,{format:n?"NHWC":"NCHW"})},1319788:(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U)=>{e.Cd("AveragePool",i,{format:U?"NHWC":"NCHW",auto_pad:n,ceil_mode:a,count_include_pad:s,storage_order:l,dilations:[f,p],kernel_shape:[g,v],pads:[w,C,S,E],strides:[_,M]})},1320072:(i,n)=>{e.Cd("GlobalAveragePool",i,{format:n?"NHWC":"NCHW"})},1320163:(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U)=>{e.Cd("AveragePool",i,{format:U?"NHWC":"NCHW",auto_pad:n,ceil_mode:a,count_include_pad:s,storage_order:l,dilations:[f,p],kernel_shape:[g,v],pads:[w,C,S,E],strides:[_,M]})},1320447:(i,n)=>{e.Cd("GlobalMaxPool",i,{format:n?"NHWC":"NCHW"})},1320534:(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U)=>{e.Cd("MaxPool",i,{format:U?"NHWC":"NCHW",auto_pad:n,ceil_mode:a,count_include_pad:s,storage_order:l,dilations:[f,p],kernel_shape:[g,v],pads:[w,C,S,E],strides:[_,M]})},1320814:(i,n)=>{e.Cd("GlobalMaxPool",i,{format:n?"NHWC":"NCHW"})},1320901:(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U)=>{e.Cd("MaxPool",i,{format:U?"NHWC":"NCHW",auto_pad:n,ceil_mode:a,count_include_pad:s,storage_order:l,dilations:[f,p],kernel_shape:[g,v],pads:[w,C,S,E],strides:[_,M]})},1321181:(i,n,a,s,l)=>{e.Cd("Gemm",i,{alpha:n,beta:a,transA:s,transB:l})},1321285:i=>{e.Cd("MatMul",i,void 0)},1321339:(i,n,a,s)=>{e.Cd("ArgMax",i,{keepDims:!!n,selectLastIndex:!!a,axis:s})},1321447:(i,n,a,s)=>{e.Cd("ArgMin",i,{keepDims:!!n,selectLastIndex:!!a,axis:s})},1321555:(i,n)=>{e.Cd("Softmax",i,{axis:n})},1321618:(i,n)=>{e.Cd("Concat",i,{axis:n})},1321678:(i,n,a,s,l)=>{e.Cd("Split",i,{axis:n,numOutputs:a,splitSizes:s?Array.from(q.subarray(l>>>0,l+s>>>0)):[]})},1321823:i=>{e.Cd("Expand",i,void 0)},1321877:(i,n)=>{e.Cd("Gather",i,{axis:Number(n)})},1321948:(i,n)=>{e.Cd("GatherElements",i,{axis:Number(n)})},1322027:(i,n,a,s,l,f,p,g,v,w,C)=>{e.Cd("Resize",i,{antialias:n,axes:a?Array.from(q.subarray(s>>>0,s+a>>>0)):[],coordinateTransformMode:pt(l),cubicCoeffA:f,excludeOutside:p,extrapolationValue:g,keepAspectRatioPolicy:pt(v),mode:pt(w),nearestMode:pt(C)})},1322378:(i,n,a,s,l,f,p)=>{e.Cd("Slice",i,{starts:n?Array.from(q.subarray(a>>>0,a+n>>>0)):[],ends:s?Array.from(q.subarray(l>>>0,l+s>>>0)):[],axes:f?Array.from(q.subarray(p>>>0,p+f>>>0)):[]})},1322609:i=>{e.Cd("Tile",i,void 0)},1322661:(i,n,a)=>{e.Cd("LayerNormalization",i,{axis:Number(n),epsilon:Number(a)})},1322768:(i,n,a)=>{e.Cd("InstanceNormalization",i,{epsilon:n,format:a?"NHWC":"NCHW"})},1322882:(i,n,a)=>{e.Cd("InstanceNormalization",i,{epsilon:n,format:a?"NHWC":"NCHW"})},1322996:i=>{e.Cd("Range",i,void 0)},1323049:(i,n)=>{e.Cd("Einsum",i,{equation:pt(n)})},1323130:(i,n,a,s,l)=>{e.Cd("Pad",i,{mode:n,value:a,pads:s?Array.from(q.subarray(l>>>0,l+s>>>0)):[]})},1323262:i=>{e.Cd("Gelu",i,void 0)},1323314:i=>{e.Cd("BiasAdd",i,void 0)},1323369:i=>{e.Cd("BiasSplitGelu",i,void 0)},1323430:(i,n)=>{e.Cd("SkipLayerNormalization",i,{epsilon:n})},1323511:i=>{e.sh(i)},1323545:(i,n)=>e.th(i,n,e.Xg.uh,e.Xg.errors),1323657:i=>e.ph(i),1323690:i=>e.rh(i),1323722:(i,n,a)=>{e.eh(i,n,a,!0)},1323761:(i,n,a)=>{e.eh(i,n,a)}};function wt(i){this.name="ExitStatus",this.message=`Program terminated with exit(${i})`,this.status=i}var ct=i=>{for(;0<i.length;)i.shift()(e)},Mt=[],Dt=0,Qe=0;function rr(i){this.Wg=i,this.Sg=i-24,this.mh=function(n){le[this.Sg+4>>2>>>0]=n},this.bh=function(){return le[this.Sg+4>>2>>>0]},this.lh=function(n){le[this.Sg+8>>2>>>0]=n},this.fh=function(n){ae[this.Sg+12>>0>>>0]=n?1:0},this.ih=function(){return ae[this.Sg+12>>0>>>0]!=0},this.gh=function(n){ae[this.Sg+13>>0>>>0]=n?1:0},this.oh=function(){return ae[this.Sg+13>>0>>>0]!=0},this.kh=function(n,a){this.dh(0),this.mh(n),this.lh(a)},this.dh=function(n){le[this.Sg+16>>2>>>0]=n},this.hh=function(){return le[this.Sg+16>>2>>>0]},this.jh=function(){if(Br(this.bh()))return le[this.Wg>>2>>>0];var n=this.hh();return n!==0?n:this.Wg}}var ft=i=>{var n=Qe;if(!n)return Tt(0),0;var a=new rr(n);a.dh(n);var s=a.bh();if(!s)return Tt(0),n;for(var l in i){var f=i[l];if(f===0||f===s)break;if(Pr(f,s,a.Sg+16))return Tt(f),n}return Tt(s),n},Sr=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Ci=(i,n,a)=>{n>>>=0;var s=n+a;for(a=n;i[a]&&!(a>=s);)++a;if(16<a-n&&i.buffer&&Sr)return Sr.decode(i.subarray(n,a));for(s="";n<a;){var l=i[n++];if(l&128){var f=i[n++]&63;if((l&224)==192)s+=String.fromCharCode((l&31)<<6|f);else{var p=i[n++]&63;l=(l&240)==224?(l&15)<<12|f<<6|p:(l&7)<<18|f<<12|p<<6|i[n++]&63,65536>l?s+=String.fromCharCode(l):(l-=65536,s+=String.fromCharCode(55296|l>>10,56320|l&1023))}}else s+=String.fromCharCode(l)}return s},pt=(i,n)=>(i>>>=0)?Ci($e,i,n):"",Ir=i=>{for(var n=0,a=0;a<i.length;++a){var s=i.charCodeAt(a);127>=s?n++:2047>=s?n+=2:55296<=s&&57343>=s?(n+=4,++a):n+=3}return n},$t=(i,n,a,s)=>{if(a>>>=0,!(0<s))return 0;var l=a;s=a+s-1;for(var f=0;f<i.length;++f){var p=i.charCodeAt(f);if(55296<=p&&57343>=p){var g=i.charCodeAt(++f);p=65536+((p&1023)<<10)|g&1023}if(127>=p){if(a>=s)break;n[a++>>>0]=p}else{if(2047>=p){if(a+1>=s)break;n[a++>>>0]=192|p>>6}else{if(65535>=p){if(a+2>=s)break;n[a++>>>0]=224|p>>12}else{if(a+3>=s)break;n[a++>>>0]=240|p>>18,n[a++>>>0]=128|p>>12&63}n[a++>>>0]=128|p>>6&63}n[a++>>>0]=128|p&63}}return n[a>>>0]=0,a-l},Ct=i=>i%4===0&&(i%100!==0||i%400===0),zt=[0,31,60,91,121,152,182,213,244,274,305,335],ir=[0,31,59,90,120,151,181,212,243,273,304,334],Ar=i=>{var n=Ir(i)+1,a=lr(n);return a&&$t(i,$e,a,n),a},nr=[],Er=(i,n)=>{nr.length=0;var a;for(n>>=2;a=$e[i++>>>0];)n+=a!=105&n,nr.push(a==105?q[n>>>0]:Pe[n++>>>1]),++n;return nr},ar={},ht=()=>{if(!or){var i={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"},n;for(n in ar)ar[n]===void 0?delete i[n]:i[n]=ar[n];var a=[];for(n in i)a.push(`${n}=${i[n]}`);or=a}return or},or,Or=[null,[],[]],me=[31,29,31,30,31,30,31,31,30,31,30,31],Wt=[31,28,31,30,31,30,31,31,30,31,30,31];function _i(i){var n=Array(Ir(i)+1);return $t(i,n,0,n.length),n}function xi(i,n,a,s){function l(_,M,U){for(_=typeof _=="number"?_.toString():_||"";_.length<M;)_=U[0]+_;return _}function f(_,M){return l(_,M,"0")}function p(_,M){function U(te){return 0>te?-1:0<te?1:0}var K;return(K=U(_.getFullYear()-M.getFullYear()))===0&&(K=U(_.getMonth()-M.getMonth()))===0&&(K=U(_.getDate()-M.getDate())),K}function g(_){switch(_.getDay()){case 0:return new Date(_.getFullYear()-1,11,29);case 1:return _;case 2:return new Date(_.getFullYear(),0,3);case 3:return new Date(_.getFullYear(),0,2);case 4:return new Date(_.getFullYear(),0,1);case 5:return new Date(_.getFullYear()-1,11,31);case 6:return new Date(_.getFullYear()-1,11,30)}}function v(_){var M=_.Ug;for(_=new Date(new Date(_.Vg+1900,0,1).getTime());0<M;){var U=_.getMonth(),K=(Ct(_.getFullYear())?me:Wt)[U];if(M>K-_.getDate())M-=K-_.getDate()+1,_.setDate(1),11>U?_.setMonth(U+1):(_.setMonth(0),_.setFullYear(_.getFullYear()+1));else{_.setDate(_.getDate()+M);break}}return U=new Date(_.getFullYear()+1,0,4),M=g(new Date(_.getFullYear(),0,4)),U=g(U),0>=p(M,_)?0>=p(U,_)?_.getFullYear()+1:_.getFullYear():_.getFullYear()-1}i>>>=0,n>>>=0,a>>>=0,s>>>=0;var w=q[s+40>>2>>>0];s={xh:q[s>>2>>>0],wh:q[s+4>>2>>>0],Yg:q[s+8>>2>>>0],ah:q[s+12>>2>>>0],Zg:q[s+16>>2>>>0],Vg:q[s+20>>2>>>0],Tg:q[s+24>>2>>>0],Ug:q[s+28>>2>>>0],Ah:q[s+32>>2>>>0],vh:q[s+36>>2>>>0],yh:w?pt(w):""},a=pt(a),w={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var C in w)a=a.replace(new RegExp(C,"g"),w[C]);var S="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),E="January February March April May June July August September October November December".split(" ");w={"%a":_=>S[_.Tg].substring(0,3),"%A":_=>S[_.Tg],"%b":_=>E[_.Zg].substring(0,3),"%B":_=>E[_.Zg],"%C":_=>f((_.Vg+1900)/100|0,2),"%d":_=>f(_.ah,2),"%e":_=>l(_.ah,2," "),"%g":_=>v(_).toString().substring(2),"%G":_=>v(_),"%H":_=>f(_.Yg,2),"%I":_=>(_=_.Yg,_==0?_=12:12<_&&(_-=12),f(_,2)),"%j":_=>{for(var M=0,U=0;U<=_.Zg-1;M+=(Ct(_.Vg+1900)?me:Wt)[U++]);return f(_.ah+M,3)},"%m":_=>f(_.Zg+1,2),"%M":_=>f(_.wh,2),"%n":()=>`
`,"%p":_=>0<=_.Yg&&12>_.Yg?"AM":"PM","%S":_=>f(_.xh,2),"%t":()=>"	","%u":_=>_.Tg||7,"%U":_=>f(Math.floor((_.Ug+7-_.Tg)/7),2),"%V":_=>{var M=Math.floor((_.Ug+7-(_.Tg+6)%7)/7);if(2>=(_.Tg+371-_.Ug-2)%7&&M++,M)M==53&&(U=(_.Tg+371-_.Ug)%7,U==4||U==3&&Ct(_.Vg)||(M=1));else{M=52;var U=(_.Tg+7-_.Ug-1)%7;(U==4||U==5&&Ct(_.Vg%400-1))&&M++}return f(M,2)},"%w":_=>_.Tg,"%W":_=>f(Math.floor((_.Ug+7-(_.Tg+6)%7)/7),2),"%y":_=>(_.Vg+1900).toString().substring(2),"%Y":_=>_.Vg+1900,"%z":_=>{_=_.vh;var M=0<=_;return _=Math.abs(_)/60,(M?"+":"-")+("0000"+(_/60*100+_%60)).slice(-4)},"%Z":_=>_.yh,"%%":()=>"%"},a=a.replace(/%%/g,"\0\0");for(C in w)a.includes(C)&&(a=a.replace(new RegExp(C,"g"),w[C](s)));return a=a.replace(/\0\0/g,"%"),C=_i(a),C.length>n?0:(ae.set(C,i>>>0),C.length-1)}function Nt(i){try{i()}catch(n){Ze(n)}}function On(i){var n={},a;for(a in i)(function(s){var l=i[s];n[s]=typeof l=="function"?function(){Ut.push(s);try{return l.apply(null,arguments)}finally{Z||(Ut.pop()===s||Ze(),at&&mt===1&&Ut.length===0&&(mt=0,Nt(is),typeof Fibers<"u"&&Fibers.Bh()))}}:l})(a);return n}var mt=0,at=null,Tr=0,Ut=[],sr={},Rr={},Si=0,ur=null,Ii=[];function Ai(){return new Promise((i,n)=>{ur={resolve:i,reject:n}})}function Ei(){var i=lr(65548),n=i+12;le[i>>2>>>0]=n,le[i+4>>2>>>0]=n+65536,n=Ut[0];var a=sr[n];return a===void 0&&(a=Si++,sr[n]=a,Rr[a]=n),q[i+8>>2>>>0]=a,i}function Oi(i){if(!Z){if(mt===0){var n=!1,a=!1;i((s=0)=>{if(!Z&&(Tr=s,n=!0,a)){mt=2,Nt(()=>ns(at)),typeof Browser<"u"&&Browser.$g.nh&&Browser.$g.resume(),s=!1;try{var l=(0,I[Rr[q[at+8>>2>>>0]]])()}catch(g){l=g,s=!0}var f=!1;if(!at){var p=ur;p&&(ur=null,(s?p.reject:p.resolve)(l),f=!0)}if(s&&!f)throw l}}),a=!0,n||(mt=1,at=Ei(),typeof Browser<"u"&&Browser.$g.nh&&Browser.$g.pause(),Nt(()=>rs(at)))}else mt===2?(mt=0,Nt(as),kr(at),at=null,Ii.forEach(s=>{if(!Z)try{if(s(),!L)try{re=re=s=re,L||(e.onExit&&e.onExit(s),Z=!0),o(s,new wt(s))}catch(l){l instanceof wt||l=="unwind"||o(1,l)}}catch(l){l instanceof wt||l=="unwind"||o(1,l)}})):Ze(`invalid state: ${mt}`);return Tr}}function Ti(i){return Oi(n=>{i().then(n)})}var Ri={Ha:function(i,n,a){return Ti(async()=>{await e.qh(i,n,a)})},u:function(i){return i=new rr(i>>>0),i.ih()||(i.fh(!0),Dt--),i.gh(!1),Mt.push(i),jr(i.Wg),i.jh()},B:function(){W(0,0);var i=Mt.pop();Rt(i.Wg),Qe=0},a:function(){return ft([])},k:function(i){return ft([i>>>0])},w:function(i,n){return ft([i>>>0,n>>>0])},q:function(i,n,a){return ft([i>>>0,n>>>0,a>>>0])},pa:function(){var i=Mt.pop();i||Ze("no exception to throw");var n=i.Wg;throw i.oh()||(Mt.push(i),i.gh(!0),i.fh(!1),Dt++),Qe=n,Qe},s:function(i,n,a){throw i>>>=0,new rr(i).kh(n>>>0,a>>>0),Qe=i,Dt++,Qe},$:function(){return Dt},g:function(i){throw Qe||(Qe=i>>>0),Qe},qa:function(){return 0},oc:function(){},Pa:function(){},Ra:function(){},Ja:function(){return 0},Ub:function(){},Ta:function(){},Jb:function(){},Ca:function(){},Qa:function(){},Na:function(){},dc:function(){},Oa:function(){},Tc:()=>!0,Oc:function(i,n,a){i=n+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*n:NaN,a>>>=0,i=new Date(1e3*i),q[a>>2>>>0]=i.getUTCSeconds(),q[a+4>>2>>>0]=i.getUTCMinutes(),q[a+8>>2>>>0]=i.getUTCHours(),q[a+12>>2>>>0]=i.getUTCDate(),q[a+16>>2>>>0]=i.getUTCMonth(),q[a+20>>2>>>0]=i.getUTCFullYear()-1900,q[a+24>>2>>>0]=i.getUTCDay(),q[a+28>>2>>>0]=(i.getTime()-Date.UTC(i.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Pc:function(i,n,a){i=n+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*n:NaN,a>>>=0,i=new Date(1e3*i),q[a>>2>>>0]=i.getSeconds(),q[a+4>>2>>>0]=i.getMinutes(),q[a+8>>2>>>0]=i.getHours(),q[a+12>>2>>>0]=i.getDate(),q[a+16>>2>>>0]=i.getMonth(),q[a+20>>2>>>0]=i.getFullYear()-1900,q[a+24>>2>>>0]=i.getDay(),q[a+28>>2>>>0]=(Ct(i.getFullYear())?zt:ir)[i.getMonth()]+i.getDate()-1|0,q[a+36>>2>>>0]=-(60*i.getTimezoneOffset()),n=new Date(i.getFullYear(),6,1).getTimezoneOffset();var s=new Date(i.getFullYear(),0,1).getTimezoneOffset();q[a+32>>2>>>0]=(n!=s&&i.getTimezoneOffset()==Math.min(s,n))|0},Qc:function(i){i>>>=0;var n=new Date(q[i+20>>2>>>0]+1900,q[i+16>>2>>>0],q[i+12>>2>>>0],q[i+8>>2>>>0],q[i+4>>2>>>0],q[i>>2>>>0],0),a=q[i+32>>2>>>0],s=n.getTimezoneOffset(),l=new Date(n.getFullYear(),6,1).getTimezoneOffset(),f=new Date(n.getFullYear(),0,1).getTimezoneOffset(),p=Math.min(f,l);return 0>a?q[i+32>>2>>>0]=+(l!=f&&p==s):0<a!=(p==s)&&(l=Math.max(f,l),n.setTime(n.getTime()+6e4*((0<a?p:l)-s))),q[i+24>>2>>>0]=n.getDay(),q[i+28>>2>>>0]=(Ct(n.getFullYear())?zt:ir)[n.getMonth()]+n.getDate()-1|0,q[i>>2>>>0]=n.getSeconds(),q[i+4>>2>>>0]=n.getMinutes(),q[i+8>>2>>>0]=n.getHours(),q[i+12>>2>>>0]=n.getDate(),q[i+16>>2>>>0]=n.getMonth(),q[i+20>>2>>>0]=n.getYear(),i=n.getTime()/1e3,Tt((Be=i,1<=+Math.abs(Be)?0<Be?+Math.floor(Be/4294967296)>>>0:~~+Math.ceil((Be-+(~~Be>>>0))/4294967296)>>>0:0)),i>>>0},Mc:function(){return-52},Nc:function(){},La:function(i,n,a){function s(v){return(v=v.toTimeString().match(/\(([A-Za-z ]+)\)$/))?v[1]:"GMT"}a>>>=0;var l=new Date().getFullYear(),f=new Date(l,0,1),p=new Date(l,6,1);l=f.getTimezoneOffset();var g=p.getTimezoneOffset();le[i>>>0>>2>>>0]=60*Math.max(l,g),q[n>>>0>>2>>>0]=+(l!=g),i=s(f),n=s(p),i=Ar(i),n=Ar(n),g<l?(le[a>>2>>>0]=i,le[a+4>>2>>>0]=n):(le[a>>2>>>0]=n,le[a+4>>2>>>0]=i)},ja:()=>{Ze("")},x:function(i,n,a){return i>>>=0,n=Er(n>>>0,a>>>0),nt[i].apply(null,n)},wa:function(i,n,a){return i>>>=0,n=Er(n>>>0,a>>>0),nt[i].apply(null,n)},Ea:function(){return Date.now()},Ma:function(){return 4294901760},I:()=>performance.now(),yb:function(i,n,a){return n>>>=0,$e.copyWithin(i>>>0>>>0,n>>>0,n+(a>>>0)>>>0)},Ka:function(i){i>>>=0;var n=$e.length;if(4294901760<i)return!1;for(var a=1;4>=a;a*=2){var s=n*(1+.2/a);s=Math.min(s,i+100663296);var l=Math;s=Math.max(i,s);e:{l=l.min.call(l,4294901760,s+(65536-s%65536)%65536)-X.buffer.byteLength+65535>>>16;try{X.grow(l),ue();var f=1;break e}catch{}f=void 0}if(f)return!0}return!1},cb:function(i,n){i>>>=0,n>>>=0;var a=0;return ht().forEach(function(s,l){var f=n+a;for(l=le[i+4*l>>2>>>0]=f,f=0;f<s.length;++f)ae[l++>>0>>>0]=s.charCodeAt(f);ae[l>>0>>>0]=0,a+=s.length+1}),0},nb:function(i,n){i>>>=0,n>>>=0;var a=ht();le[i>>2>>>0]=a.length;var s=0;return a.forEach(function(l){s+=l.length+1}),le[n>>2>>>0]=s,0},ma:()=>52,Ba:function(){return 52},Rc:function(){return 70},Aa:function(i,n,a,s){n>>>=0,a>>>=0,s>>>=0;for(var l=0,f=0;f<a;f++){var p=le[n>>2>>>0],g=le[n+4>>2>>>0];n+=8;for(var v=0;v<g;v++){var w=$e[p+v>>>0],C=Or[i];w===0||w===10?((i===1?D:F)(Ci(C,0)),C.length=0):C.push(w)}l+=g}return le[s>>2>>>0]=l,0},ia:zc,Sc:zf,M:ff,K:Dc,Uc:Df,Wc:Pf,C:Jc,z:Pc,b:Ic,Da:Rf,ca:wf,f:xc,ra:kf,h:_c,F:Tf,i:Rc,Vc:Bf,j:Tc,t:Oc,r:Mc,n:Wc,W:Gc,Y:Sf,J:Lc,oa:af,aa:sf,la:If,vb:Xp,gb:dh,zc:Qf,bb:hh,eb:fh,Sa:xh,Sb:Op,Dc:qf,jb:sh,Va:Ch,Ob:jp,fb:ch,gc:mp,Lc:Wf,pc:sp,hb:lh,db:ph,Bb:Hp,kc:cp,nc:up,fc:gp,Kc:Nf,_a:yh,ab:mh,qb:th,mb:nh,$a:gh,ic:pp,Kb:Dp,lb:ah,Ua:_h,Tb:Ep,Ic:Gf,Ac:Xf,tc:ip,pb:rh,lc:dp,Ib:zp,Hb:Wp,c:Ec,_:ef,p:Ac,P:jf,Z:gf,ha:Kc,e:Sc,za:Hc,G:Of,da:rf,O:pf,ub:Qp,fa:Yc,d:kc,xa:Qc,Fa:Af,l:jc,va:tf,m:Bc,ya:Xc,ua:nf,Ga:$f,o:Nc,V:df,ga:lf,U:cf,na:yf,y:Uc,A:Vc,E:Fc,X:Ef,ta:hf,ea:Zc,N:uf,L:vf,D:of,ba:qc,T:mf,ka:Mf,R:Cf,sa:xf,Q:_f,S:bf,jc:fp,zb:qp,rb:eh,Eb:Gp,Ab:Lp,Bc:Yf,Nb:Pp,xb:Kp,Fb:Up,Pb:kp,ec:yp,ob:ih,Mb:Bp,sb:Zp,Ya:bh,rc:ap,Fc:Hf,Za:vh,Qb:Rp,xc:Zf,Cb:Fp,kb:oh,vc:tp,Hc:Vf,wc:ep,Cc:Kf,Xa:wh,Ec:Lf,wb:Yp,Lb:Mp,yc:Jf,Jc:Uf,ib:uh,Db:Vp,Yb:xp,tb:Jp,Gc:Ff,Zb:_p,Rb:Tp,hc:hp,qc:op,Gb:Np,Xb:Sp,sc:np,mc:lp,Wa:$h,uc:rp,Vb:Ap,Wb:Ip,$b:$p,ac:wp,cc:vp,_b:Cp,bc:bp,v:function(i){return i>>>0},Ia:xi,H:function(i,n,a,s){return xi(i>>>0,n>>>0,a>>>0,s>>>0)}};(function(){function i(a){if(a=a.exports,a=On(a),I=a=Sh(a),X=I.Xc,ue(),et.unshift(I.Yc),Te--,e.monitorRunDependencies&&e.monitorRunDependencies(Te),Te==0&&(Xe!==null&&(clearInterval(Xe),Xe=null),bt)){var s=bt;bt=null,s()}return a}var n={a:Ri};if(Te++,e.monitorRunDependencies&&e.monitorRunDependencies(Te),e.instantiateWasm)try{return e.instantiateWasm(n,i)}catch(a){F("Module.instantiateWasm callback failed with error: "+a),u(a)}return Ue(n,function(a){i(a.instance)}).catch(u),{}})(),e._OrtInit=(i,n)=>(e._OrtInit=I.Zc)(i,n),e._OrtGetLastError=(i,n)=>(e._OrtGetLastError=I._c)(i,n),e._OrtCreateSessionOptions=(i,n,a,s,l,f,p,g,v,w)=>(e._OrtCreateSessionOptions=I.$c)(i,n,a,s,l,f,p,g,v,w),e._OrtAppendExecutionProvider=(i,n)=>(e._OrtAppendExecutionProvider=I.ad)(i,n),e._OrtAddFreeDimensionOverride=(i,n,a)=>(e._OrtAddFreeDimensionOverride=I.bd)(i,n,a),e._OrtAddSessionConfigEntry=(i,n,a)=>(e._OrtAddSessionConfigEntry=I.cd)(i,n,a),e._OrtReleaseSessionOptions=i=>(e._OrtReleaseSessionOptions=I.dd)(i),e._OrtCreateSession=(i,n,a)=>(e._OrtCreateSession=I.ed)(i,n,a),e._OrtReleaseSession=i=>(e._OrtReleaseSession=I.fd)(i),e._OrtGetInputOutputCount=(i,n,a)=>(e._OrtGetInputOutputCount=I.gd)(i,n,a),e._OrtGetInputName=(i,n)=>(e._OrtGetInputName=I.hd)(i,n),e._OrtGetOutputName=(i,n)=>(e._OrtGetOutputName=I.id)(i,n),e._OrtFree=i=>(e._OrtFree=I.jd)(i),e._OrtCreateTensor=(i,n,a,s,l,f)=>(e._OrtCreateTensor=I.kd)(i,n,a,s,l,f),e._OrtGetTensorData=(i,n,a,s,l)=>(e._OrtGetTensorData=I.ld)(i,n,a,s,l),e._OrtReleaseTensor=i=>(e._OrtReleaseTensor=I.md)(i),e._OrtCreateRunOptions=(i,n,a,s)=>(e._OrtCreateRunOptions=I.nd)(i,n,a,s),e._OrtAddRunConfigEntry=(i,n,a)=>(e._OrtAddRunConfigEntry=I.od)(i,n,a),e._OrtReleaseRunOptions=i=>(e._OrtReleaseRunOptions=I.pd)(i),e._OrtCreateBinding=i=>(e._OrtCreateBinding=I.qd)(i),e._OrtBindInput=(i,n,a)=>(e._OrtBindInput=I.rd)(i,n,a),e._OrtBindOutput=(i,n,a,s)=>(e._OrtBindOutput=I.sd)(i,n,a,s),e._OrtClearBoundOutputs=i=>(e._OrtClearBoundOutputs=I.td)(i),e._OrtReleaseBinding=i=>(e._OrtReleaseBinding=I.ud)(i),e._OrtRunWithBinding=(i,n,a,s,l)=>(e._OrtRunWithBinding=I.vd)(i,n,a,s,l),e._OrtRun=(i,n,a,s,l,f,p,g)=>(e._OrtRun=I.wd)(i,n,a,s,l,f,p,g),e._OrtEndProfiling=i=>(e._OrtEndProfiling=I.xd)(i),e._JsepOutput=(i,n,a)=>(e._JsepOutput=I.yd)(i,n,a),e._JsepGetNodeName=i=>(e._JsepGetNodeName=I.zd)(i);var lr=e._malloc=i=>(lr=e._malloc=I.Ad)(i),kr=e._free=i=>(kr=e._free=I.Bd)(i),W=(i,n)=>(W=I.Dd)(i,n),Tt=i=>(Tt=I.Ed)(i),N=()=>(N=I.Fd)(),z=i=>(z=I.Gd)(i),Gt=i=>(Gt=I.Hd)(i),Rt=i=>(Rt=I.Id)(i),jr=i=>(jr=I.Jd)(i),Pr=(i,n,a)=>(Pr=I.Kd)(i,n,a),Br=i=>(Br=I.Ld)(i),Mr=e.dynCall_vi=(i,n)=>(Mr=e.dynCall_vi=I.Md)(i,n),Dr=e.dynCall_vii=(i,n,a)=>(Dr=e.dynCall_vii=I.Nd)(i,n,a),dr=e.dynCall_iiii=(i,n,a,s)=>(dr=e.dynCall_iiii=I.Od)(i,n,a,s),zr=e.dynCall_iii=(i,n,a)=>(zr=e.dynCall_iii=I.Pd)(i,n,a),ki=e.dynCall_ii=(i,n)=>(ki=e.dynCall_ii=I.Qd)(i,n),je=e.dynCall_iiiiiii=(i,n,a,s,l,f,p)=>(je=e.dynCall_iiiiiii=I.Rd)(i,n,a,s,l,f,p),cr=e.dynCall_v=i=>(cr=e.dynCall_v=I.Sd)(i),fr=e.dynCall_iiiiii=(i,n,a,s,l,f)=>(fr=e.dynCall_iiiiii=I.Td)(i,n,a,s,l,f),Wr=e.dynCall_iiij=(i,n,a,s,l)=>(Wr=e.dynCall_iiij=I.Ud)(i,n,a,s,l),pr=e.dynCall_iiiii=(i,n,a,s,l)=>(pr=e.dynCall_iiiii=I.Vd)(i,n,a,s,l),Nr=e.dynCall_viii=(i,n,a,s)=>(Nr=e.dynCall_viii=I.Wd)(i,n,a,s),Ur=e.dynCall_j=i=>(Ur=e.dynCall_j=I.Xd)(i),Gr=e.dynCall_i=i=>(Gr=e.dynCall_i=I.Yd)(i),Vr=e.dynCall_iij=(i,n,a,s)=>(Vr=e.dynCall_iij=I.Zd)(i,n,a,s),Fr=e.dynCall_iiiiij=(i,n,a,s,l,f,p)=>(Fr=e.dynCall_iiiiij=I._d)(i,n,a,s,l,f,p),ji=e.dynCall_vij=(i,n,a,s)=>(ji=e.dynCall_vij=I.$d)(i,n,a,s),Hr=e.dynCall_viiiii=(i,n,a,s,l,f)=>(Hr=e.dynCall_viiiii=I.ae)(i,n,a,s,l,f),Lr=e.dynCall_viiii=(i,n,a,s,l)=>(Lr=e.dynCall_viiii=I.be)(i,n,a,s,l),qr=e.dynCall_iiiiiiii=(i,n,a,s,l,f,p,g)=>(qr=e.dynCall_iiiiiiii=I.ce)(i,n,a,s,l,f,p,g),Pi=e.dynCall_fi=(i,n)=>(Pi=e.dynCall_fi=I.de)(i,n),Bi=e.dynCall_fii=(i,n,a)=>(Bi=e.dynCall_fii=I.ee)(i,n,a),Kr=e.dynCall_ji=(i,n)=>(Kr=e.dynCall_ji=I.fe)(i,n),Vt=e.dynCall_di=(i,n)=>(Vt=e.dynCall_di=I.ge)(i,n),Mi=e.dynCall_jii=(i,n,a)=>(Mi=e.dynCall_jii=I.he)(i,n,a),gt=e.dynCall_dii=(i,n,a)=>(gt=e.dynCall_dii=I.ie)(i,n,a),ot=e.dynCall_iiiiiiiii=(i,n,a,s,l,f,p,g,v)=>(ot=e.dynCall_iiiiiiiii=I.je)(i,n,a,s,l,f,p,g,v),Yr=e.dynCall_viij=(i,n,a,s,l)=>(Yr=e.dynCall_viij=I.ke)(i,n,a,s,l),Ft=e.dynCall_viiiiii=(i,n,a,s,l,f,p)=>(Ft=e.dynCall_viiiiii=I.le)(i,n,a,s,l,f,p),Xr=e.dynCall_vijj=(i,n,a,s,l,f)=>(Xr=e.dynCall_vijj=I.me)(i,n,a,s,l,f),Qr=e.dynCall_viiiiiii=(i,n,a,s,l,f,p,g)=>(Qr=e.dynCall_viiiiiii=I.ne)(i,n,a,s,l,f,p,g),Di=e.dynCall_iiiiiiiiii=(i,n,a,s,l,f,p,g,v,w)=>(Di=e.dynCall_iiiiiiiiii=I.oe)(i,n,a,s,l,f,p,g,v,w),hr=e.dynCall_viiiiiiii=(i,n,a,s,l,f,p,g,v)=>(hr=e.dynCall_viiiiiiii=I.pe)(i,n,a,s,l,f,p,g,v),zi=e.dynCall_iiiiijiiiii=(i,n,a,s,l,f,p,g,v,w,C,S)=>(zi=e.dynCall_iiiiijiiiii=I.qe)(i,n,a,s,l,f,p,g,v,w,C,S),Wi=e.dynCall_viiji=(i,n,a,s,l,f)=>(Wi=e.dynCall_viiji=I.re)(i,n,a,s,l,f),Ni=e.dynCall_viijiii=(i,n,a,s,l,f,p,g)=>(Ni=e.dynCall_viijiii=I.se)(i,n,a,s,l,f,p,g),Ui=e.dynCall_viiiiij=(i,n,a,s,l,f,p,g)=>(Ui=e.dynCall_viiiiij=I.te)(i,n,a,s,l,f,p,g),Gi=e.dynCall_viiiiiiiii=(i,n,a,s,l,f,p,g,v,w)=>(Gi=e.dynCall_viiiiiiiii=I.ue)(i,n,a,s,l,f,p,g,v,w),Vi=e.dynCall_viid=(i,n,a,s)=>(Vi=e.dynCall_viid=I.ve)(i,n,a,s),Fi=e.dynCall_iiiiiiiij=(i,n,a,s,l,f,p,g,v,w)=>(Fi=e.dynCall_iiiiiiiij=I.we)(i,n,a,s,l,f,p,g,v,w),Hi=e.dynCall_iiiiiiiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S)=>(Hi=e.dynCall_iiiiiiiiiiii=I.xe)(i,n,a,s,l,f,p,g,v,w,C,S),Ht=e.dynCall_viiiiiiiiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_)=>(Ht=e.dynCall_viiiiiiiiiiiii=I.ye)(i,n,a,s,l,f,p,g,v,w,C,S,E,_),mr=e.dynCall_viijjjiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M)=>(mr=e.dynCall_viijjjiiiiii=I.ze)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M),Jr=e.dynCall_viiijiiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E)=>(Jr=e.dynCall_viiijiiiiiii=I.Ae)(i,n,a,s,l,f,p,g,v,w,C,S,E),Zr=e.dynCall_viffiii=(i,n,a,s,l,f,p)=>(Zr=e.dynCall_viffiii=I.Be)(i,n,a,s,l,f,p),ei=e.dynCall_viiijjjii=(i,n,a,s,l,f,p,g,v,w,C,S)=>(ei=e.dynCall_viiijjjii=I.Ce)(i,n,a,s,l,f,p,g,v,w,C,S),gr=e.dynCall_viifiii=(i,n,a,s,l,f,p)=>(gr=e.dynCall_viifiii=I.De)(i,n,a,s,l,f,p),yr=e.dynCall_viiiiidiidi=(i,n,a,s,l,f,p,g,v,w,C)=>(yr=e.dynCall_viiiiidiidi=I.Ee)(i,n,a,s,l,f,p,g,v,w,C),ti=e.dynCall_viiiiiiiiidi=(i,n,a,s,l,f,p,g,v,w,C,S)=>(ti=e.dynCall_viiiiiiiiidi=I.Fe)(i,n,a,s,l,f,p,g,v,w,C,S),ri=e.dynCall_vjiiiiii=(i,n,a,s,l,f,p,g,v)=>(ri=e.dynCall_vjiiiiii=I.Ge)(i,n,a,s,l,f,p,g,v),ii=e.dynCall_jiii=(i,n,a,s)=>(ii=e.dynCall_jiii=I.He)(i,n,a,s),vr=e.dynCall_viiid=(i,n,a,s,l)=>(vr=e.dynCall_viiid=I.Ie)(i,n,a,s,l),Lt=e.dynCall_viiiiiiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S)=>(Lt=e.dynCall_viiiiiiiiiii=I.Je)(i,n,a,s,l,f,p,g,v,w,C,S),br=e.dynCall_vijjjjjjjjjjjjji=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe,Me,De,Ge,qe,st,ut)=>(br=e.dynCall_vijjjjjjjjjjjjji=I.Ke)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe,Me,De,Ge,qe,st,ut),ni=e.dynCall_viiiji=(i,n,a,s,l,f,p)=>(ni=e.dynCall_viiiji=I.Le)(i,n,a,s,l,f,p),ai=e.dynCall_vijjjiiji=(i,n,a,s,l,f,p,g,v,w,C,S,E)=>(ai=e.dynCall_vijjjiiji=I.Me)(i,n,a,s,l,f,p,g,v,w,C,S,E),oi=e.dynCall_iiiji=(i,n,a,s,l,f)=>(oi=e.dynCall_iiiji=I.Ne)(i,n,a,s,l,f),si=e.dynCall_iiijiiiiiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M)=>(si=e.dynCall_iiijiiiiiiiiii=I.Oe)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M),ui=e.dynCall_vj=(i,n,a)=>(ui=e.dynCall_vj=I.Pe)(i,n,a),Li=e.dynCall_jjj=(i,n,a,s,l)=>(Li=e.dynCall_jjj=I.Qe)(i,n,a,s,l),qt=e.dynCall_iiijiiiiii=(i,n,a,s,l,f,p,g,v,w,C)=>(qt=e.dynCall_iiijiiiiii=I.Re)(i,n,a,s,l,f,p,g,v,w,C),li=e.dynCall_viiff=(i,n,a,s,l)=>(li=e.dynCall_viiff=I.Se)(i,n,a,s,l),c=e.dynCall_viiiiiff=(i,n,a,s,l,f,p,g)=>(c=e.dynCall_viiiiiff=I.Te)(i,n,a,s,l,f,p,g),b=e.dynCall_vfiii=(i,n,a,s,l)=>(b=e.dynCall_vfiii=I.Ue)(i,n,a,s,l),x=e.dynCall_viiiiff=(i,n,a,s,l,f,p)=>(x=e.dynCall_viiiiff=I.Ve)(i,n,a,s,l,f,p),B=e.dynCall_viiiiiiiiifiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_)=>(B=e.dynCall_viiiiiiiiifiii=I.We)(i,n,a,s,l,f,p,g,v,w,C,S,E,_),G=e.dynCall_viiiiiiiijj=(i,n,a,s,l,f,p,g,v,w,C,S,E)=>(G=e.dynCall_viiiiiiiijj=I.Xe)(i,n,a,s,l,f,p,g,v,w,C,S,E),H=e.dynCall_iiiiiiiiiiiiiifii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K)=>(H=e.dynCall_iiiiiiiiiiiiiifii=I.Ye)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K),J=e.dynCall_viiiiiiiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E)=>(J=e.dynCall_viiiiiiiiiiii=I.Ze)(i,n,a,s,l,f,p,g,v,w,C,S,E),pe=e.dynCall_ij=(i,n,a)=>(pe=e.dynCall_ij=I._e)(i,n,a),ce=e.dynCall_iiiiiiiiiiiiiiiiifii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge)=>(ce=e.dynCall_iiiiiiiiiiiiiiiiifii=I.$e)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge),de=e.dynCall_vijjiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S)=>(de=e.dynCall_vijjiiiiii=I.af)(i,n,a,s,l,f,p,g,v,w,C,S),he=e.dynCall_iiiijjj=(i,n,a,s,l,f,p,g,v,w)=>(he=e.dynCall_iiiijjj=I.bf)(i,n,a,s,l,f,p,g,v,w),_e=e.dynCall_viiiiiiiiii=(i,n,a,s,l,f,p,g,v,w,C)=>(_e=e.dynCall_viiiiiiiiii=I.cf)(i,n,a,s,l,f,p,g,v,w,C),Se=e.dynCall_iiijjj=(i,n,a,s,l,f,p,g,v)=>(Se=e.dynCall_iiijjj=I.df)(i,n,a,s,l,f,p,g,v),V=e.dynCall_fffffff=(i,n,a,s,l,f,p)=>(V=e.dynCall_fffffff=I.ef)(i,n,a,s,l,f,p),ve=e.dynCall_viiiij=(i,n,a,s,l,f,p)=>(ve=e.dynCall_viiiij=I.ff)(i,n,a,s,l,f,p),Ee=e.dynCall_viijj=(i,n,a,s,l,f,p)=>(Ee=e.dynCall_viijj=I.gf)(i,n,a,s,l,f,p),_t=e.dynCall_vjjjjjjffiifiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe,Me)=>(_t=e.dynCall_vjjjjjjffiifiiiiii=I.hf)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe,Me),di=e.dynCall_viiiiiiffiifiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K)=>(di=e.dynCall_viiiiiiffiifiiiii=I.jf)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K),Sa=e.dynCall_viiiiiiffifiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U)=>(Sa=e.dynCall_viiiiiiffifiiiii=I.kf)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U),Ia=e.dynCall_viiiiiiffiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M)=>(Ia=e.dynCall_viiiiiiffiiiiii=I.lf)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M),Aa=e.dynCall_vjjjjjjjjfffiifiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe,Me,De,Ge,qe,st,ut)=>(Aa=e.dynCall_vjjjjjjjjfffiifiiiiii=I.mf)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe,Me,De,Ge,qe,st,ut),Ea=e.dynCall_vjjjjjjfffifiiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe,Me,De)=>(Ea=e.dynCall_vjjjjjjfffifiiiiiii=I.nf)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe,Me,De),Oa=e.dynCall_vjjjjjjfffifiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe)=>(Oa=e.dynCall_vjjjjjjfffifiiiii=I.of)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe),Ta=e.dynCall_vjjjjjjjjfffiifiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe,Me,De,Ge,qe,st)=>(Ta=e.dynCall_vjjjjjjjjfffiifiiiii=I.pf)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe,Me,De,Ge,qe,st),Ra=e.dynCall_vijjfffiii=(i,n,a,s,l,f,p,g,v,w,C,S)=>(Ra=e.dynCall_vijjfffiii=I.qf)(i,n,a,s,l,f,p,g,v,w,C,S),ka=e.dynCall_vijiiiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S)=>(ka=e.dynCall_vijiiiiiiii=I.rf)(i,n,a,s,l,f,p,g,v,w,C,S),ja=e.dynCall_vijjjjjjifiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be)=>(ja=e.dynCall_vijjjjjjifiiiii=I.sf)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be),Pa=e.dynCall_vjjjjjiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M)=>(Pa=e.dynCall_vjjjjjiiii=I.tf)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M),Ba=e.dynCall_vjjjjfiii=(i,n,a,s,l,f,p,g,v,w,C,S,E)=>(Ba=e.dynCall_vjjjjfiii=I.uf)(i,n,a,s,l,f,p,g,v,w,C,S,E),Ma=e.dynCall_viifi=(i,n,a,s,l)=>(Ma=e.dynCall_viifi=I.vf)(i,n,a,s,l),Da=e.dynCall_iiiiiji=(i,n,a,s,l,f,p,g)=>(Da=e.dynCall_iiiiiji=I.wf)(i,n,a,s,l,f,p,g),za=e.dynCall_vijjii=(i,n,a,s,l,f,p,g)=>(za=e.dynCall_vijjii=I.xf)(i,n,a,s,l,f,p,g),Wa=e.dynCall_viiijiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S)=>(Wa=e.dynCall_viiijiiiiii=I.yf)(i,n,a,s,l,f,p,g,v,w,C,S),Na=e.dynCall_viiiiijjiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M)=>(Na=e.dynCall_viiiiijjiiiii=I.zf)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M),Ua=e.dynCall_iiiiji=(i,n,a,s,l,f,p)=>(Ua=e.dynCall_iiiiji=I.Af)(i,n,a,s,l,f,p),Ga=e.dynCall_viiiiijiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_)=>(Ga=e.dynCall_viiiiijiiiiii=I.Bf)(i,n,a,s,l,f,p,g,v,w,C,S,E,_),Va=e.dynCall_viiiijii=(i,n,a,s,l,f,p,g,v)=>(Va=e.dynCall_viiiijii=I.Cf)(i,n,a,s,l,f,p,g,v),Fa=e.dynCall_viijjiii=(i,n,a,s,l,f,p,g,v,w)=>(Fa=e.dynCall_viijjiii=I.Df)(i,n,a,s,l,f,p,g,v,w),Ha=e.dynCall_ijii=(i,n,a,s,l)=>(Ha=e.dynCall_ijii=I.Ef)(i,n,a,s,l),La=e.dynCall_jjjjjjj=(i,n,a,s,l,f,p,g,v,w,C,S,E)=>(La=e.dynCall_jjjjjjj=I.Ff)(i,n,a,s,l,f,p,g,v,w,C,S,E),qa=e.dynCall_jjjjjj=(i,n,a,s,l,f,p,g,v,w,C)=>(qa=e.dynCall_jjjjjj=I.Gf)(i,n,a,s,l,f,p,g,v,w,C),Ka=e.dynCall_vijjjjiij=(i,n,a,s,l,f,p,g,v,w,C,S,E,_)=>(Ka=e.dynCall_vijjjjiij=I.Hf)(i,n,a,s,l,f,p,g,v,w,C,S,E,_),Ya=e.dynCall_viiiiijij=(i,n,a,s,l,f,p,g,v,w,C)=>(Ya=e.dynCall_viiiiijij=I.If)(i,n,a,s,l,f,p,g,v,w,C),Xa=e.dynCall_viiiiiijij=(i,n,a,s,l,f,p,g,v,w,C,S)=>(Xa=e.dynCall_viiiiiijij=I.Jf)(i,n,a,s,l,f,p,g,v,w,C,S),Qa=e.dynCall_vijiii=(i,n,a,s,l,f,p)=>(Qa=e.dynCall_vijiii=I.Kf)(i,n,a,s,l,f,p),Ja=e.dynCall_viiiiiiiiifi=(i,n,a,s,l,f,p,g,v,w,C,S)=>(Ja=e.dynCall_viiiiiiiiifi=I.Lf)(i,n,a,s,l,f,p,g,v,w,C,S),Za=e.dynCall_viiijiiiiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M)=>(Za=e.dynCall_viiijiiiiiiiii=I.Mf)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M),eo=e.dynCall_iiijiiii=(i,n,a,s,l,f,p,g,v)=>(eo=e.dynCall_iiijiiii=I.Nf)(i,n,a,s,l,f,p,g,v),to=e.dynCall_viiiiiijjiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U)=>(to=e.dynCall_viiiiiijjiiiii=I.Of)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U),ro=e.dynCall_viiiiiiijiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U)=>(ro=e.dynCall_viiiiiiijiiiiii=I.Pf)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U),io=e.dynCall_vif=(i,n,a)=>(io=e.dynCall_vif=I.Qf)(i,n,a),no=e.dynCall_viif=(i,n,a,s)=>(no=e.dynCall_viif=I.Rf)(i,n,a,s),ao=e.dynCall_viiiiiifii=(i,n,a,s,l,f,p,g,v,w)=>(ao=e.dynCall_viiiiiifii=I.Sf)(i,n,a,s,l,f,p,g,v,w),oo=e.dynCall_viiiiijiiiiiiiiiiiiiiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe,Me,De,Ge,qe)=>(oo=e.dynCall_viiiiijiiiiiiiiiiiiiiiiiii=I.Tf)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe,Me,De,Ge,qe),so=e.dynCall_viijji=(i,n,a,s,l,f,p,g)=>(so=e.dynCall_viijji=I.Uf)(i,n,a,s,l,f,p,g),uo=e.dynCall_iiiiiiiiiiiji=(i,n,a,s,l,f,p,g,v,w,C,S,E,_)=>(uo=e.dynCall_iiiiiiiiiiiji=I.Vf)(i,n,a,s,l,f,p,g,v,w,C,S,E,_),lo=e.dynCall_viifiifijjjii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U)=>(lo=e.dynCall_viifiifijjjii=I.Wf)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U),co=e.dynCall_viiiiiiiiiiiiiiiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be)=>(co=e.dynCall_viiiiiiiiiiiiiiiiiiii=I.Xf)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be),fo=e.dynCall_iif=(i,n,a)=>(fo=e.dynCall_iif=I.Yf)(i,n,a),po=e.dynCall_viiiiifiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E)=>(po=e.dynCall_viiiiifiiiiii=I.Zf)(i,n,a,s,l,f,p,g,v,w,C,S,E),ho=e.dynCall_vijiiiiiiijjii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K)=>(ho=e.dynCall_vijiiiiiiijjii=I._f)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K),mo=e.dynCall_iiiiid=(i,n,a,s,l,f)=>(mo=e.dynCall_iiiiid=I.$f)(i,n,a,s,l,f),go=e.dynCall_viiiijjj=(i,n,a,s,l,f,p,g,v,w,C)=>(go=e.dynCall_viiiijjj=I.ag)(i,n,a,s,l,f,p,g,v,w,C),yo=e.dynCall_viiiiiiiiiiiiiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se)=>(yo=e.dynCall_viiiiiiiiiiiiiiiiii=I.bg)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se),vo=e.dynCall_viiiiiiiiiiiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K)=>(vo=e.dynCall_viiiiiiiiiiiiiiii=I.cg)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K),bo=e.dynCall_viiiiiiiiiiiiiiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge)=>(bo=e.dynCall_viiiiiiiiiiiiiiiiiii=I.dg)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge),wo=e.dynCall_viiiiiiiiiiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U)=>(wo=e.dynCall_viiiiiiiiiiiiiii=I.eg)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U),$o=e.dynCall_viiiiiiijjj=(i,n,a,s,l,f,p,g,v,w,C,S,E,_)=>($o=e.dynCall_viiiiiiijjj=I.fg)(i,n,a,s,l,f,p,g,v,w,C,S,E,_),Co=e.dynCall_iiiiiiiiiii=(i,n,a,s,l,f,p,g,v,w,C)=>(Co=e.dynCall_iiiiiiiiiii=I.gg)(i,n,a,s,l,f,p,g,v,w,C),_o=e.dynCall_iiiiiiiiiiiiiiiiiifi=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge)=>(_o=e.dynCall_iiiiiiiiiiiiiiiiiifi=I.hg)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge),xo=e.dynCall_viiif=(i,n,a,s,l)=>(xo=e.dynCall_viiif=I.ig)(i,n,a,s,l),So=e.dynCall_iijjj=(i,n,a,s,l,f,p,g)=>(So=e.dynCall_iijjj=I.jg)(i,n,a,s,l,f,p,g),Io=e.dynCall_viiiiji=(i,n,a,s,l,f,p,g)=>(Io=e.dynCall_viiiiji=I.kg)(i,n,a,s,l,f,p,g),Ao=e.dynCall_iijjji=(i,n,a,s,l,f,p,g,v)=>(Ao=e.dynCall_iijjji=I.lg)(i,n,a,s,l,f,p,g,v),Eo=e.dynCall_ijijji=(i,n,a,s,l,f,p,g,v)=>(Eo=e.dynCall_ijijji=I.mg)(i,n,a,s,l,f,p,g,v),Oo=e.dynCall_viiijjiii=(i,n,a,s,l,f,p,g,v,w,C)=>(Oo=e.dynCall_viiijjiii=I.ng)(i,n,a,s,l,f,p,g,v,w,C),To=e.dynCall_iiiiijji=(i,n,a,s,l,f,p,g,v,w)=>(To=e.dynCall_iiiiijji=I.og)(i,n,a,s,l,f,p,g,v,w),Ro=e.dynCall_viji=(i,n,a,s,l)=>(Ro=e.dynCall_viji=I.pg)(i,n,a,s,l),ko=e.dynCall_iiiifi=(i,n,a,s,l,f)=>(ko=e.dynCall_iiiifi=I.qg)(i,n,a,s,l,f),jo=e.dynCall_iiijii=(i,n,a,s,l,f,p)=>(jo=e.dynCall_iiijii=I.rg)(i,n,a,s,l,f,p),Po=e.dynCall_iiiiiiiiijii=(i,n,a,s,l,f,p,g,v,w,C,S,E)=>(Po=e.dynCall_iiiiiiiiijii=I.sg)(i,n,a,s,l,f,p,g,v,w,C,S,E),Bo=e.dynCall_iiiijjii=(i,n,a,s,l,f,p,g,v,w)=>(Bo=e.dynCall_iiiijjii=I.tg)(i,n,a,s,l,f,p,g,v,w),Mo=e.dynCall_iiiiiijjjii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_)=>(Mo=e.dynCall_iiiiiijjjii=I.ug)(i,n,a,s,l,f,p,g,v,w,C,S,E,_),Do=e.dynCall_iiijiii=(i,n,a,s,l,f,p,g)=>(Do=e.dynCall_iiijiii=I.vg)(i,n,a,s,l,f,p,g),zo=e.dynCall_iiiiiiiijjjfi=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U)=>(zo=e.dynCall_iiiiiiiijjjfi=I.wg)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U),Wo=e.dynCall_iijiiii=(i,n,a,s,l,f,p,g)=>(Wo=e.dynCall_iijiiii=I.xg)(i,n,a,s,l,f,p,g),No=e.dynCall_iijjjii=(i,n,a,s,l,f,p,g,v,w)=>(No=e.dynCall_iijjjii=I.yg)(i,n,a,s,l,f,p,g,v,w),Uo=e.dynCall_iiji=(i,n,a,s,l)=>(Uo=e.dynCall_iiji=I.zg)(i,n,a,s,l),Go=e.dynCall_viiijiiiii=(i,n,a,s,l,f,p,g,v,w,C)=>(Go=e.dynCall_viiijiiiii=I.Ag)(i,n,a,s,l,f,p,g,v,w,C),Vo=e.dynCall_iid=(i,n,a)=>(Vo=e.dynCall_iid=I.Bg)(i,n,a),Fo=e.dynCall_iiif=(i,n,a,s)=>(Fo=e.dynCall_iiif=I.Cg)(i,n,a,s),Ho=e.dynCall_vidi=(i,n,a,s)=>(Ho=e.dynCall_vidi=I.Dg)(i,n,a,s),Lo=e.dynCall_vjiii=(i,n,a,s,l,f)=>(Lo=e.dynCall_vjiii=I.Eg)(i,n,a,s,l,f),qo=e.dynCall_iiiij=(i,n,a,s,l,f)=>(qo=e.dynCall_iiiij=I.Fg)(i,n,a,s,l,f),Ko=e.dynCall_viiijii=(i,n,a,s,l,f,p,g)=>(Ko=e.dynCall_viiijii=I.Gg)(i,n,a,s,l,f,p,g),Yo=e.dynCall_viijiiiiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_)=>(Yo=e.dynCall_viijiiiiiiiii=I.Hg)(i,n,a,s,l,f,p,g,v,w,C,S,E,_),Xo=e.dynCall_viiij=(i,n,a,s,l,f)=>(Xo=e.dynCall_viiij=I.Ig)(i,n,a,s,l,f),Qo=e.dynCall_fiiii=(i,n,a,s,l)=>(Qo=e.dynCall_fiiii=I.Jg)(i,n,a,s,l),Jo=e.dynCall_jfi=(i,n,a)=>(Jo=e.dynCall_jfi=I.Kg)(i,n,a),Zo=e.dynCall_viiiiiiiiiiiiii=(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M)=>(Zo=e.dynCall_viiiiiiiiiiiiii=I.Lg)(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M),es=e.dynCall_jiij=(i,n,a,s,l)=>(es=e.dynCall_jiij=I.Mg)(i,n,a,s,l),ts=e.dynCall_fiii=(i,n,a,s)=>(ts=e.dynCall_fiii=I.Ng)(i,n,a,s),rs=i=>(rs=I.Og)(i),is=()=>(is=I.Pg)(),ns=i=>(ns=I.Qg)(i),as=()=>(as=I.Rg)();e.___start_em_js=1323794,e.___stop_em_js=1323955;function _c(i,n,a,s){var l=N();try{return dr(i,n,a,s)}catch(f){if(z(l),f!==f+0)throw f;W(1,0)}}function xc(i,n,a){var s=N();try{return zr(i,n,a)}catch(l){if(z(s),l!==l+0)throw l;W(1,0)}}function Sc(i,n,a){var s=N();try{Dr(i,n,a)}catch(l){if(z(s),l!==l+0)throw l;W(1,0)}}function Ic(i,n){var a=N();try{return ki(i,n)}catch(s){if(z(a),s!==s+0)throw s;W(1,0)}}function Ac(i,n){var a=N();try{Mr(i,n)}catch(s){if(z(a),s!==s+0)throw s;W(1,0)}}function Ec(i){var n=N();try{cr(i)}catch(a){if(z(n),a!==a+0)throw a;W(1,0)}}function Oc(i,n,a,s,l,f,p){var g=N();try{return je(i,n,a,s,l,f,p)}catch(v){if(z(g),v!==v+0)throw v;W(1,0)}}function Tc(i,n,a,s,l,f){var p=N();try{return fr(i,n,a,s,l,f)}catch(g){if(z(p),g!==g+0)throw g;W(1,0)}}function Rc(i,n,a,s,l){var f=N();try{return pr(i,n,a,s,l)}catch(p){if(z(f),p!==p+0)throw p;W(1,0)}}function kc(i,n,a,s){var l=N();try{Nr(i,n,a,s)}catch(f){if(z(l),f!==f+0)throw f;W(1,0)}}function jc(i,n,a,s,l){var f=N();try{Lr(i,n,a,s,l)}catch(p){if(z(f),p!==p+0)throw p;W(1,0)}}function Pc(i){var n=N();try{return Gr(i)}catch(a){if(z(n),a!==a+0)throw a;W(1,0)}}function Bc(i,n,a,s,l,f){var p=N();try{Hr(i,n,a,s,l,f)}catch(g){if(z(p),g!==g+0)throw g;W(1,0)}}function Mc(i,n,a,s,l,f,p,g){var v=N();try{return qr(i,n,a,s,l,f,p,g)}catch(w){if(z(v),w!==w+0)throw w;W(1,0)}}function Dc(i,n){var a=N();try{return Pi(i,n)}catch(s){if(z(a),s!==s+0)throw s;W(1,0)}}function zc(i,n){var a=N();try{return Vt(i,n)}catch(s){if(z(a),s!==s+0)throw s;W(1,0)}}function Wc(i,n,a,s,l,f,p,g,v){var w=N();try{return ot(i,n,a,s,l,f,p,g,v)}catch(C){if(z(w),C!==C+0)throw C;W(1,0)}}function Nc(i,n,a,s,l,f,p){var g=N();try{Ft(i,n,a,s,l,f,p)}catch(v){if(z(g),v!==v+0)throw v;W(1,0)}}function Uc(i,n,a,s,l,f,p,g){var v=N();try{Qr(i,n,a,s,l,f,p,g)}catch(w){if(z(v),w!==w+0)throw w;W(1,0)}}function Gc(i,n,a,s,l,f,p,g,v,w){var C=N();try{return Di(i,n,a,s,l,f,p,g,v,w)}catch(S){if(z(C),S!==S+0)throw S;W(1,0)}}function Vc(i,n,a,s,l,f,p,g,v){var w=N();try{hr(i,n,a,s,l,f,p,g,v)}catch(C){if(z(w),C!==C+0)throw C;W(1,0)}}function Fc(i,n,a,s,l,f,p,g,v,w){var C=N();try{Gi(i,n,a,s,l,f,p,g,v,w)}catch(S){if(z(C),S!==S+0)throw S;W(1,0)}}function Hc(i,n,a,s){var l=N();try{Vi(i,n,a,s)}catch(f){if(z(l),f!==f+0)throw f;W(1,0)}}function Lc(i,n,a,s,l,f,p,g,v,w,C,S){var E=N();try{return Hi(i,n,a,s,l,f,p,g,v,w,C,S)}catch(_){if(z(E),_!==_+0)throw _;W(1,0)}}function qc(i,n,a,s,l,f,p,g,v,w,C,S,E,_){var M=N();try{Ht(i,n,a,s,l,f,p,g,v,w,C,S,E,_)}catch(U){if(z(M),U!==U+0)throw U;W(1,0)}}function Kc(i,n,a,s,l,f,p){var g=N();try{Zr(i,n,a,s,l,f,p)}catch(v){if(z(g),v!==v+0)throw v;W(1,0)}}function Yc(i,n,a,s,l,f,p){var g=N();try{gr(i,n,a,s,l,f,p)}catch(v){if(z(g),v!==v+0)throw v;W(1,0)}}function Xc(i,n,a,s,l,f,p,g,v,w,C){var S=N();try{yr(i,n,a,s,l,f,p,g,v,w,C)}catch(E){if(z(S),E!==E+0)throw E;W(1,0)}}function Qc(i,n,a,s,l){var f=N();try{vr(i,n,a,s,l)}catch(p){if(z(f),p!==p+0)throw p;W(1,0)}}function Jc(i,n,a,s,l){var f=N();try{return Qo(i,n,a,s,l)}catch(p){if(z(f),p!==p+0)throw p;W(1,0)}}function Zc(i,n,a,s,l,f,p,g,v,w,C,S,E,_){var M=N();try{B(i,n,a,s,l,f,p,g,v,w,C,S,E,_)}catch(U){if(z(M),U!==U+0)throw U;W(1,0)}}function ef(i,n,a,s,l){var f=N();try{b(i,n,a,s,l)}catch(p){if(z(f),p!==p+0)throw p;W(1,0)}}function tf(i,n,a,s,l,f,p){var g=N();try{x(i,n,a,s,l,f,p)}catch(v){if(z(g),v!==v+0)throw v;W(1,0)}}function rf(i,n,a,s,l){var f=N();try{li(i,n,a,s,l)}catch(p){if(z(f),p!==p+0)throw p;W(1,0)}}function nf(i,n,a,s,l,f,p,g){var v=N();try{c(i,n,a,s,l,f,p,g)}catch(w){if(z(v),w!==w+0)throw w;W(1,0)}}function af(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K){var te=N();try{return H(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K)}catch(se){if(z(te),se!==se+0)throw se;W(1,0)}}function of(i,n,a,s,l,f,p,g,v,w,C,S,E){var _=N();try{J(i,n,a,s,l,f,p,g,v,w,C,S,E)}catch(M){if(z(_),M!==M+0)throw M;W(1,0)}}function sf(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge){var be=N();try{return ce(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge)}catch(we){if(z(be),we!==we+0)throw we;W(1,0)}}function uf(i,n,a,s,l,f,p,g,v,w,C){var S=N();try{_e(i,n,a,s,l,f,p,g,v,w,C)}catch(E){if(z(S),E!==E+0)throw E;W(1,0)}}function lf(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K){var te=N();try{di(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K)}catch(se){if(z(te),se!==se+0)throw se;W(1,0)}}function df(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U){var K=N();try{Sa(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U)}catch(te){if(z(K),te!==te+0)throw te;W(1,0)}}function cf(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M){var U=N();try{Ia(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M)}catch(K){if(z(U),K!==K+0)throw K;W(1,0)}}function ff(i,n,a,s,l,f,p){var g=N();try{return V(i,n,a,s,l,f,p)}catch(v){if(z(g),v!==v+0)throw v;W(1,0)}}function pf(i,n,a,s,l){var f=N();try{Ma(i,n,a,s,l)}catch(p){if(z(f),p!==p+0)throw p;W(1,0)}}function hf(i,n,a,s,l,f,p,g,v,w,C,S){var E=N();try{Ja(i,n,a,s,l,f,p,g,v,w,C,S)}catch(_){if(z(E),_!==_+0)throw _;W(1,0)}}function mf(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M){var U=N();try{Zo(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M)}catch(K){if(z(U),K!==K+0)throw K;W(1,0)}}function gf(i,n,a){var s=N();try{io(i,n,a)}catch(l){if(z(s),l!==l+0)throw l;W(1,0)}}function yf(i,n,a,s,l,f,p,g,v,w){var C=N();try{ao(i,n,a,s,l,f,p,g,v,w)}catch(S){if(z(C),S!==S+0)throw S;W(1,0)}}function vf(i,n,a,s,l,f,p,g,v,w,C,S){var E=N();try{Lt(i,n,a,s,l,f,p,g,v,w,C,S)}catch(_){if(z(E),_!==_+0)throw _;W(1,0)}}function bf(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be){var we=N();try{co(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be)}catch(xe){if(z(we),xe!==xe+0)throw xe;W(1,0)}}function wf(i,n,a){var s=N();try{return fo(i,n,a)}catch(l){if(z(s),l!==l+0)throw l;W(1,0)}}function $f(i,n,a,s,l,f,p,g,v,w,C,S,E){var _=N();try{po(i,n,a,s,l,f,p,g,v,w,C,S,E)}catch(M){if(z(_),M!==M+0)throw M;W(1,0)}}function Cf(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K){var te=N();try{vo(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K)}catch(se){if(z(te),se!==se+0)throw se;W(1,0)}}function _f(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge){var be=N();try{bo(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge)}catch(we){if(z(be),we!==we+0)throw we;W(1,0)}}function xf(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se){var ge=N();try{yo(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se)}catch(be){if(z(ge),be!==be+0)throw be;W(1,0)}}function Sf(i,n,a,s,l,f,p,g,v,w,C){var S=N();try{return Co(i,n,a,s,l,f,p,g,v,w,C)}catch(E){if(z(S),E!==E+0)throw E;W(1,0)}}function If(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge){var be=N();try{return _o(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge)}catch(we){if(z(be),we!==we+0)throw we;W(1,0)}}function Af(i,n,a,s,l){var f=N();try{xo(i,n,a,s,l)}catch(p){if(z(f),p!==p+0)throw p;W(1,0)}}function Ef(i,n,a,s,l,f,p,g,v,w,C,S){var E=N();try{ti(i,n,a,s,l,f,p,g,v,w,C,S)}catch(_){if(z(E),_!==_+0)throw _;W(1,0)}}function Of(i,n,a,s){var l=N();try{no(i,n,a,s)}catch(f){if(z(l),f!==f+0)throw f;W(1,0)}}function Tf(i,n,a,s,l,f){var p=N();try{return ko(i,n,a,s,l,f)}catch(g){if(z(p),g!==g+0)throw g;W(1,0)}}function Rf(i,n,a){var s=N();try{return Vo(i,n,a)}catch(l){if(z(s),l!==l+0)throw l;W(1,0)}}function kf(i,n,a,s){var l=N();try{return Fo(i,n,a,s)}catch(f){if(z(l),f!==f+0)throw f;W(1,0)}}function jf(i,n,a,s){var l=N();try{Ho(i,n,a,s)}catch(f){if(z(l),f!==f+0)throw f;W(1,0)}}function Pf(i,n,a,s){var l=N();try{return ts(i,n,a,s)}catch(f){if(z(l),f!==f+0)throw f;W(1,0)}}function Bf(i,n,a,s,l,f){var p=N();try{return mo(i,n,a,s,l,f)}catch(g){if(z(p),g!==g+0)throw g;W(1,0)}}function Mf(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U){var K=N();try{wo(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U)}catch(te){if(z(K),te!==te+0)throw te;W(1,0)}}function Df(i,n,a){var s=N();try{return Bi(i,n,a)}catch(l){if(z(s),l!==l+0)throw l;W(1,0)}}function zf(i,n,a){var s=N();try{return gt(i,n,a)}catch(l){if(z(s),l!==l+0)throw l;W(1,0)}}function Wf(i,n,a,s,l){var f=N();try{return Wr(i,n,a,s,l)}catch(p){if(z(f),p!==p+0)throw p;W(1,0)}}function Nf(i,n,a,s){var l=N();try{return Vr(i,n,a,s)}catch(f){if(z(l),f!==f+0)throw f;W(1,0)}}function Uf(i,n,a,s){var l=N();try{ji(i,n,a,s)}catch(f){if(z(l),f!==f+0)throw f;W(1,0)}}function Gf(i,n){var a=N();try{return Kr(i,n)}catch(s){if(z(a),s!==s+0)throw s;W(1,0)}}function Vf(i,n,a,s,l){var f=N();try{Yr(i,n,a,s,l)}catch(p){if(z(f),p!==p+0)throw p;W(1,0)}}function Ff(i,n,a,s,l,f){var p=N();try{Xr(i,n,a,s,l,f)}catch(g){if(z(p),g!==g+0)throw g;W(1,0)}}function Hf(i,n,a,s,l,f,p,g){var v=N();try{Ko(i,n,a,s,l,f,p,g)}catch(w){if(z(v),w!==w+0)throw w;W(1,0)}}function Lf(i,n,a,s,l,f,p){var g=N();try{Ee(i,n,a,s,l,f,p)}catch(v){if(z(g),v!==v+0)throw v;W(1,0)}}function qf(i,n,a,s,l,f,p,g,v,w,C,S){var E=N();try{return zi(i,n,a,s,l,f,p,g,v,w,C,S)}catch(_){if(z(E),_!==_+0)throw _;W(1,0)}}function Kf(i,n,a,s,l,f,p,g){var v=N();try{Ni(i,n,a,s,l,f,p,g)}catch(w){if(z(v),w!==w+0)throw w;W(1,0)}}function Yf(i,n,a,s,l,f,p,g){var v=N();try{Ui(i,n,a,s,l,f,p,g)}catch(w){if(z(v),w!==w+0)throw w;W(1,0)}}function Xf(i,n,a){var s=N();try{return Mi(i,n,a)}catch(l){if(z(s),l!==l+0)throw l;W(1,0)}}function Qf(i,n,a,s,l,f,p,g,v,w){var C=N();try{return Fi(i,n,a,s,l,f,p,g,v,w)}catch(S){if(z(C),S!==S+0)throw S;W(1,0)}}function Jf(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M){var U=N();try{mr(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M)}catch(K){if(z(U),K!==K+0)throw K;W(1,0)}}function Zf(i,n,a,s,l,f,p,g,v,w,C,S,E){var _=N();try{Jr(i,n,a,s,l,f,p,g,v,w,C,S,E)}catch(M){if(z(_),M!==M+0)throw M;W(1,0)}}function ep(i,n,a,s,l,f){var p=N();try{Wi(i,n,a,s,l,f)}catch(g){if(z(p),g!==g+0)throw g;W(1,0)}}function tp(i,n,a,s,l,f,p,g,v,w,C,S){var E=N();try{ei(i,n,a,s,l,f,p,g,v,w,C,S)}catch(_){if(z(E),_!==_+0)throw _;W(1,0)}}function rp(i,n,a,s,l,f,p,g,v){var w=N();try{ri(i,n,a,s,l,f,p,g,v)}catch(C){if(z(w),C!==C+0)throw C;W(1,0)}}function ip(i,n,a,s){var l=N();try{return ii(i,n,a,s)}catch(f){if(z(l),f!==f+0)throw f;W(1,0)}}function np(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe,Me,De,Ge,qe,st,ut){var Kt=N();try{br(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe,Me,De,Ge,qe,st,ut)}catch(Yt){if(z(Kt),Yt!==Yt+0)throw Yt;W(1,0)}}function ap(i,n,a,s,l,f,p){var g=N();try{ni(i,n,a,s,l,f,p)}catch(v){if(z(g),v!==v+0)throw v;W(1,0)}}function op(i,n,a,s,l,f,p,g,v,w,C,S,E){var _=N();try{ai(i,n,a,s,l,f,p,g,v,w,C,S,E)}catch(M){if(z(_),M!==M+0)throw M;W(1,0)}}function sp(i,n,a,s,l,f){var p=N();try{return oi(i,n,a,s,l,f)}catch(g){if(z(p),g!==g+0)throw g;W(1,0)}}function up(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M){var U=N();try{return si(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M)}catch(K){if(z(U),K!==K+0)throw K;W(1,0)}}function lp(i,n,a){var s=N();try{ui(i,n,a)}catch(l){if(z(s),l!==l+0)throw l;W(1,0)}}function dp(i,n,a,s,l){var f=N();try{return Li(i,n,a,s,l)}catch(p){if(z(f),p!==p+0)throw p;W(1,0)}}function cp(i,n,a,s,l,f,p,g,v,w,C){var S=N();try{return qt(i,n,a,s,l,f,p,g,v,w,C)}catch(E){if(z(S),E!==E+0)throw E;W(1,0)}}function fp(i,n,a,s,l,f,p,g,v,w,C,S,E){var _=N();try{G(i,n,a,s,l,f,p,g,v,w,C,S,E)}catch(M){if(z(_),M!==M+0)throw M;W(1,0)}}function pp(i,n,a){var s=N();try{return pe(i,n,a)}catch(l){if(z(s),l!==l+0)throw l;W(1,0)}}function hp(i,n,a,s,l,f,p,g,v,w,C,S){var E=N();try{de(i,n,a,s,l,f,p,g,v,w,C,S)}catch(_){if(z(E),_!==_+0)throw _;W(1,0)}}function mp(i,n,a,s,l,f,p,g,v,w){var C=N();try{return he(i,n,a,s,l,f,p,g,v,w)}catch(S){if(z(C),S!==S+0)throw S;W(1,0)}}function gp(i,n,a,s,l,f,p,g,v){var w=N();try{return Se(i,n,a,s,l,f,p,g,v)}catch(C){if(z(w),C!==C+0)throw C;W(1,0)}}function yp(i,n,a,s,l,f,p){var g=N();try{ve(i,n,a,s,l,f,p)}catch(v){if(z(g),v!==v+0)throw v;W(1,0)}}function vp(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe,Me){var De=N();try{_t(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe,Me)}catch(Ge){if(z(De),Ge!==Ge+0)throw Ge;W(1,0)}}function bp(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe,Me,De,Ge,qe,st,ut){var Kt=N();try{Aa(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe,Me,De,Ge,qe,st,ut)}catch(Yt){if(z(Kt),Yt!==Yt+0)throw Yt;W(1,0)}}function wp(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe,Me,De){var Ge=N();try{Ea(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe,Me,De)}catch(qe){if(z(Ge),qe!==qe+0)throw qe;W(1,0)}}function $p(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe){var Me=N();try{Oa(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe)}catch(De){if(z(Me),De!==De+0)throw De;W(1,0)}}function Cp(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe,Me,De,Ge,qe,st){var ut=N();try{Ta(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe,Me,De,Ge,qe,st)}catch(Kt){if(z(ut),Kt!==Kt+0)throw Kt;W(1,0)}}function _p(i,n,a,s,l,f,p,g,v,w,C,S){var E=N();try{Ra(i,n,a,s,l,f,p,g,v,w,C,S)}catch(_){if(z(E),_!==_+0)throw _;W(1,0)}}function xp(i,n,a,s,l,f,p,g,v,w,C,S){var E=N();try{ka(i,n,a,s,l,f,p,g,v,w,C,S)}catch(_){if(z(E),_!==_+0)throw _;W(1,0)}}function Sp(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be){var we=N();try{ja(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be)}catch(xe){if(z(we),xe!==xe+0)throw xe;W(1,0)}}function Ip(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M){var U=N();try{Pa(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M)}catch(K){if(z(U),K!==K+0)throw K;W(1,0)}}function Ap(i,n,a,s,l,f,p,g,v,w,C,S,E){var _=N();try{Ba(i,n,a,s,l,f,p,g,v,w,C,S,E)}catch(M){if(z(_),M!==M+0)throw M;W(1,0)}}function Ep(i,n,a){var s=N();try{return Jo(i,n,a)}catch(l){if(z(s),l!==l+0)throw l;W(1,0)}}function Op(i,n,a,s,l,f,p,g){var v=N();try{return Da(i,n,a,s,l,f,p,g)}catch(w){if(z(v),w!==w+0)throw w;W(1,0)}}function Tp(i,n,a,s,l,f,p,g){var v=N();try{za(i,n,a,s,l,f,p,g)}catch(w){if(z(v),w!==w+0)throw w;W(1,0)}}function Rp(i,n,a,s,l,f,p,g,v,w,C,S){var E=N();try{Wa(i,n,a,s,l,f,p,g,v,w,C,S)}catch(_){if(z(E),_!==_+0)throw _;W(1,0)}}function kp(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M){var U=N();try{Na(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M)}catch(K){if(z(U),K!==K+0)throw K;W(1,0)}}function jp(i,n,a,s,l,f,p){var g=N();try{return Ua(i,n,a,s,l,f,p)}catch(v){if(z(g),v!==v+0)throw v;W(1,0)}}function Pp(i,n,a,s,l,f,p,g,v,w,C,S,E,_){var M=N();try{Ga(i,n,a,s,l,f,p,g,v,w,C,S,E,_)}catch(U){if(z(M),U!==U+0)throw U;W(1,0)}}function Bp(i,n,a,s,l,f,p,g,v){var w=N();try{Va(i,n,a,s,l,f,p,g,v)}catch(C){if(z(w),C!==C+0)throw C;W(1,0)}}function Mp(i,n,a,s,l,f,p,g,v,w){var C=N();try{Fa(i,n,a,s,l,f,p,g,v,w)}catch(S){if(z(C),S!==S+0)throw S;W(1,0)}}function Dp(i,n,a,s,l){var f=N();try{return Ha(i,n,a,s,l)}catch(p){if(z(f),p!==p+0)throw p;W(1,0)}}function zp(i,n,a,s,l,f,p,g,v,w,C){var S=N();try{return qa(i,n,a,s,l,f,p,g,v,w,C)}catch(E){if(z(S),E!==E+0)throw E;W(1,0)}}function Wp(i,n,a,s,l,f,p,g,v,w,C,S,E){var _=N();try{return La(i,n,a,s,l,f,p,g,v,w,C,S,E)}catch(M){if(z(_),M!==M+0)throw M;W(1,0)}}function Np(i,n,a,s,l,f,p,g,v,w,C,S,E,_){var M=N();try{Ka(i,n,a,s,l,f,p,g,v,w,C,S,E,_)}catch(U){if(z(M),U!==U+0)throw U;W(1,0)}}function Up(i,n,a,s,l,f,p,g,v,w,C){var S=N();try{Ya(i,n,a,s,l,f,p,g,v,w,C)}catch(E){if(z(S),E!==E+0)throw E;W(1,0)}}function Gp(i,n,a,s,l,f,p,g,v,w,C,S){var E=N();try{Xa(i,n,a,s,l,f,p,g,v,w,C,S)}catch(_){if(z(E),_!==_+0)throw _;W(1,0)}}function Vp(i,n,a,s,l,f,p){var g=N();try{Qa(i,n,a,s,l,f,p)}catch(v){if(z(g),v!==v+0)throw v;W(1,0)}}function Fp(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M){var U=N();try{Za(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M)}catch(K){if(z(U),K!==K+0)throw K;W(1,0)}}function Hp(i,n,a,s,l,f,p,g,v){var w=N();try{return eo(i,n,a,s,l,f,p,g,v)}catch(C){if(z(w),C!==C+0)throw C;W(1,0)}}function Lp(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U){var K=N();try{to(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U)}catch(te){if(z(K),te!==te+0)throw te;W(1,0)}}function qp(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U){var K=N();try{ro(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U)}catch(te){if(z(K),te!==te+0)throw te;W(1,0)}}function Kp(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe,Me,De,Ge,qe){var st=N();try{oo(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K,te,se,ge,be,we,xe,Me,De,Ge,qe)}catch(ut){if(z(st),ut!==ut+0)throw ut;W(1,0)}}function Yp(i,n,a,s,l,f,p,g){var v=N();try{so(i,n,a,s,l,f,p,g)}catch(w){if(z(v),w!==w+0)throw w;W(1,0)}}function Xp(i,n,a,s,l,f,p,g,v,w,C,S,E,_){var M=N();try{return uo(i,n,a,s,l,f,p,g,v,w,C,S,E,_)}catch(U){if(z(M),U!==U+0)throw U;W(1,0)}}function Qp(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U){var K=N();try{lo(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U)}catch(te){if(z(K),te!==te+0)throw te;W(1,0)}}function Jp(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K){var te=N();try{ho(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U,K)}catch(se){if(z(te),se!==se+0)throw se;W(1,0)}}function Zp(i,n,a,s,l,f,p,g,v,w,C){var S=N();try{go(i,n,a,s,l,f,p,g,v,w,C)}catch(E){if(z(S),E!==E+0)throw E;W(1,0)}}function eh(i,n,a,s,l,f,p,g,v,w,C,S,E,_){var M=N();try{$o(i,n,a,s,l,f,p,g,v,w,C,S,E,_)}catch(U){if(z(M),U!==U+0)throw U;W(1,0)}}function th(i,n,a,s,l,f,p,g){var v=N();try{return So(i,n,a,s,l,f,p,g)}catch(w){if(z(v),w!==w+0)throw w;W(1,0)}}function rh(i,n,a,s,l){var f=N();try{return es(i,n,a,s,l)}catch(p){if(z(f),p!==p+0)throw p;W(1,0)}}function ih(i,n,a,s,l,f,p,g){var v=N();try{Io(i,n,a,s,l,f,p,g)}catch(w){if(z(v),w!==w+0)throw w;W(1,0)}}function nh(i,n,a,s,l,f,p,g,v){var w=N();try{return Ao(i,n,a,s,l,f,p,g,v)}catch(C){if(z(w),C!==C+0)throw C;W(1,0)}}function ah(i,n,a,s,l,f,p,g,v){var w=N();try{return Eo(i,n,a,s,l,f,p,g,v)}catch(C){if(z(w),C!==C+0)throw C;W(1,0)}}function oh(i,n,a,s,l,f,p,g,v,w,C){var S=N();try{Oo(i,n,a,s,l,f,p,g,v,w,C)}catch(E){if(z(S),E!==E+0)throw E;W(1,0)}}function sh(i,n,a,s,l,f,p,g,v,w){var C=N();try{return To(i,n,a,s,l,f,p,g,v,w)}catch(S){if(z(C),S!==S+0)throw S;W(1,0)}}function uh(i,n,a,s,l){var f=N();try{Ro(i,n,a,s,l)}catch(p){if(z(f),p!==p+0)throw p;W(1,0)}}function lh(i,n,a,s,l,f,p){var g=N();try{return jo(i,n,a,s,l,f,p)}catch(v){if(z(g),v!==v+0)throw v;W(1,0)}}function dh(i,n,a,s,l,f,p,g,v,w,C,S,E){var _=N();try{return Po(i,n,a,s,l,f,p,g,v,w,C,S,E)}catch(M){if(z(_),M!==M+0)throw M;W(1,0)}}function ch(i,n,a,s,l,f,p,g,v,w){var C=N();try{return Bo(i,n,a,s,l,f,p,g,v,w)}catch(S){if(z(C),S!==S+0)throw S;W(1,0)}}function fh(i,n,a,s,l,f,p,g,v,w,C,S,E,_){var M=N();try{return Mo(i,n,a,s,l,f,p,g,v,w,C,S,E,_)}catch(U){if(z(M),U!==U+0)throw U;W(1,0)}}function ph(i,n,a,s,l,f,p,g){var v=N();try{return Do(i,n,a,s,l,f,p,g)}catch(w){if(z(v),w!==w+0)throw w;W(1,0)}}function hh(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U){var K=N();try{return zo(i,n,a,s,l,f,p,g,v,w,C,S,E,_,M,U)}catch(te){if(z(K),te!==te+0)throw te;W(1,0)}}function mh(i,n,a,s,l,f,p,g){var v=N();try{return Wo(i,n,a,s,l,f,p,g)}catch(w){if(z(v),w!==w+0)throw w;W(1,0)}}function gh(i,n,a,s,l,f,p,g,v,w){var C=N();try{return No(i,n,a,s,l,f,p,g,v,w)}catch(S){if(z(C),S!==S+0)throw S;W(1,0)}}function yh(i,n,a,s,l){var f=N();try{return Uo(i,n,a,s,l)}catch(p){if(z(f),p!==p+0)throw p;W(1,0)}}function vh(i,n,a,s,l,f,p,g,v,w,C){var S=N();try{Go(i,n,a,s,l,f,p,g,v,w,C)}catch(E){if(z(S),E!==E+0)throw E;W(1,0)}}function bh(i,n,a,s,l,f){var p=N();try{Xo(i,n,a,s,l,f)}catch(g){if(z(p),g!==g+0)throw g;W(1,0)}}function wh(i,n,a,s,l,f,p,g,v,w,C,S,E,_){var M=N();try{Yo(i,n,a,s,l,f,p,g,v,w,C,S,E,_)}catch(U){if(z(M),U!==U+0)throw U;W(1,0)}}function $h(i,n,a,s,l,f){var p=N();try{Lo(i,n,a,s,l,f)}catch(g){if(z(p),g!==g+0)throw g;W(1,0)}}function Ch(i,n,a,s,l,f){var p=N();try{return qo(i,n,a,s,l,f)}catch(g){if(z(p),g!==g+0)throw g;W(1,0)}}function _h(i){var n=N();try{return Ur(i)}catch(a){if(z(n),a!==a+0)throw a;W(1,0)}}function xh(i,n,a,s,l,f,p){var g=N();try{return Fr(i,n,a,s,l,f,p)}catch(v){if(z(g),v!==v+0)throw v;W(1,0)}}function Sh(i){i=Object.assign({},i);var n=s=>()=>s()>>>0,a=s=>l=>s(l)>>>0;return i.__errno_location=n(i.__errno_location),i.malloc=a(i.malloc),i.stackSave=n(i.stackSave),i.stackAlloc=a(i.stackAlloc),i}e.stackAlloc=Gt,e.stackSave=N,e.stackRestore=z,e.UTF8ToString=pt,e.stringToUTF8=(i,n,a)=>$t(i,$e,n,a),e.lengthBytesUTF8=Ir;var qi;bt=function i(){qi||os(),qi||(bt=i)};function os(){function i(){if(!qi&&(qi=!0,e.calledRun=!0,!Z)){if(ct(et),d(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for(typeof e.postRun=="function"&&(e.postRun=[e.postRun]);e.postRun.length;){var n=e.postRun.shift();Ae.unshift(n)}ct(Ae)}}if(!(0<Te)){if(e.preRun)for(typeof e.preRun=="function"&&(e.preRun=[e.preRun]);e.preRun.length;)Le();ct(oe),0<Te||(e.setStatus?(e.setStatus("Running..."),setTimeout(function(){setTimeout(function(){e.setStatus("")},1),i()},1)):i())}}if(e.preInit)for(typeof e.preInit=="function"&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return os(),r.ready}})();typeof Bs=="object"&&typeof Wn=="object"?Wn.exports=Ps:typeof define=="function"&&define.amd&&define([],()=>Ps)});var Ds=wr(()=>{});var zs=wr(()=>{});var Ws={};$r(Ws,{cpus:()=>Ph});var Ph,Ns=ie(()=>{Ph=void 0});var Vs=wr((Gs,Nn)=>{"use strict";var Us=(()=>{var t=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(t=t||__filename),function(r={}){function e(){return ue.buffer!=Te.buffer&&ee(),Te}function d(){return ue.buffer!=Te.buffer&&ee(),Xe}function u(){return ue.buffer!=Te.buffer&&ee(),bt}function h(){return ue.buffer!=Te.buffer&&ee(),Ze}function m(){return ue.buffer!=Te.buffer&&ee(),Ot}var o=r,y,$;o.ready=new Promise((c,b)=>{y=c,$=b}),o.jsepInit=(c,b,x,B,G,H,J,pe)=>{o.Qb=c,o.wb=b,o.yb=x,o.jb=B,o.xb=G,o.Ea=H,o.zb=J,o.Ab=pe,b=(ce,de,he)=>(..._e)=>{let Se=ot,V=de?.();_e=ce(..._e);let ve=de?.();return V!==ve&&(ce=ve,he(V),de=he=null),ot!=Se?Wi():_e},x=ce=>async(...de)=>{try{if(o.bb)throw Error("Session already started");let he=o.bb={Fb:de[0],errors:[]},_e=await ce(...de);if(o.bb!==he)throw Error("Session mismatch");c.flush();let Se=he.errors;if(0<Se.length){let V=await Promise.all(Se);if(V=V.filter(ve=>ve),0<V.length)throw Error(V.join(`
`))}return _e}finally{o.bb=null}},o._OrtRun=x(b(o._OrtRun,()=>o._OrtRun,ce=>o._OrtRun=ce)),o._OrtRunWithBinding=x(b(o._OrtRunWithBinding,()=>o._OrtRunWithBinding,ce=>o._OrtRunWithBinding=ce)),o._OrtBindInput=b(o._OrtBindInput,()=>o._OrtBindInput,ce=>o._OrtBindInput=ce),o.jsepRegisterBuffer=(ce,de,he,_e)=>c.registerBuffer(ce,de,he,_e),o.jsepUnregisterBuffers=ce=>{c.unregisterBuffers(ce)},o.jsepGetBuffer=ce=>c.getBuffer(ce),o.jsepCreateDownloader=(ce,de,he)=>c.createDownloader(ce,de,he)};var A=Object.assign({},o),T="./this.program",O=(c,b)=>{throw b},R=typeof window=="object",j=typeof importScripts=="function",k=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",P=o.ENVIRONMENT_IS_PTHREAD||!1,D="";function F(c){return o.locateFile?o.locateFile(c,D):D+c}var Y,L,X;if(k){var I=(Mn(),kt(Bn)),Z=(zn(),kt(Dn));D=j?Z.dirname(D)+"/":__dirname+"/",Y=(b,x)=>(b=b.startsWith("file://")?new URL(b):Z.normalize(b),I.readFileSync(b,x?void 0:"utf8")),X=b=>(b=Y(b,!0),b.buffer||(b=new Uint8Array(b)),b),L=(b,x,B,G=!0)=>{b=b.startsWith("file://")?new URL(b):Z.normalize(b),I.readFile(b,G?void 0:"utf8",(H,J)=>{H?B(H):x(G?J.buffer:J)})},!o.thisProgram&&1<process.argv.length&&(T=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),O=(b,x)=>{throw process.exitCode=b,x},o.inspect=()=>"[Emscripten Module object]";let c;try{c=Ds()}catch(b){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),b}global.Worker=c.Worker}else(R||j)&&(j?D=self.location.href:typeof document<"u"&&document.currentScript&&(D=document.currentScript.src),typeof t<"u"&&t&&(D=t),D.indexOf("blob:")!==0?D=D.substr(0,D.replace(/[?#].*/,"").lastIndexOf("/")+1):D="",k||(Y=c=>{var b=new XMLHttpRequest;return b.open("GET",c,!1),b.send(null),b.responseText},j&&(X=c=>{var b=new XMLHttpRequest;return b.open("GET",c,!1),b.responseType="arraybuffer",b.send(null),new Uint8Array(b.response)}),L=(c,b,x)=>{var B=new XMLHttpRequest;B.open("GET",c,!0),B.responseType="arraybuffer",B.onload=()=>{B.status==200||B.status==0&&B.response?b(B.response):x()},B.onerror=x,B.send(null)}));k&&typeof performance>"u"&&(global.performance=zs().performance);var re=console.log.bind(console),ae=console.error.bind(console);k&&(re=(...c)=>I.writeSync(1,c.join(" ")+`
`),ae=(...c)=>I.writeSync(2,c.join(" ")+`
`));var $e=o.print||re,q=o.printErr||ae;Object.assign(o,A),A=null,o.thisProgram&&(T=o.thisProgram),o.quit&&(O=o.quit);var le;o.wasmBinary&&(le=o.wasmBinary);var Pe=o.noExitRuntime||!0;typeof WebAssembly!="object"&&Qe("no native wasm support detected");var ue,oe,et,Ae=!1,Le,Te,Xe,bt,Ze,Ot;function ee(){var c=ue.buffer;o.HEAP8=Te=new Int8Array(c),o.HEAP16=new Int16Array(c),o.HEAP32=bt=new Int32Array(c),o.HEAPU8=Xe=new Uint8Array(c),o.HEAPU16=new Uint16Array(c),o.HEAPU32=Ze=new Uint32Array(c),o.HEAPF32=new Float32Array(c),o.HEAPF64=Ot=new Float64Array(c)}var Ce=o.INITIAL_MEMORY||16777216;if(5242880<=Ce||Qe("INITIAL_MEMORY should be larger than STACK_SIZE, was "+Ce+"! (STACK_SIZE=5242880)"),P)ue=o.wasmMemory;else if(o.wasmMemory)ue=o.wasmMemory;else if(ue=new WebAssembly.Memory({initial:Ce/65536,maximum:65536,shared:!0}),!(ue.buffer instanceof SharedArrayBuffer))throw q("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),k&&q("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");ee(),Ce=ue.buffer.byteLength;var Oe=[],tt=[],it=[],Ue=0;function Be(){return Pe||0<Ue}var nt=0,wt=null,ct=null;function Mt(){nt++,o.monitorRunDependencies&&o.monitorRunDependencies(nt)}function Dt(){if(nt--,o.monitorRunDependencies&&o.monitorRunDependencies(nt),nt==0&&(wt!==null&&(clearInterval(wt),wt=null),ct)){var c=ct;ct=null,c()}}function Qe(c){throw o.onAbort&&o.onAbort(c),c="Aborted("+c+")",q(c),Ae=!0,Le=1,c=new WebAssembly.RuntimeError(c+". Build with -sASSERTIONS for more info."),$(c),c}function rr(c){return c.startsWith("data:application/octet-stream;base64,")}var ft;ft="ort-wasm-simd-threaded.wasm",rr(ft)||(ft=F(ft));function Sr(c){if(c==ft&&le)return new Uint8Array(le);if(X)return X(c);throw"both async and sync fetching of the wasm failed"}function Ci(c){if(!le&&(R||j)){if(typeof fetch=="function"&&!c.startsWith("file://"))return fetch(c,{credentials:"same-origin"}).then(b=>{if(!b.ok)throw"failed to load wasm binary file at '"+c+"'";return b.arrayBuffer()}).catch(()=>Sr(c));if(L)return new Promise((b,x)=>{L(c,B=>b(new Uint8Array(B)),x)})}return Promise.resolve().then(()=>Sr(c))}function pt(c,b,x){return Ci(c).then(B=>WebAssembly.instantiate(B,b)).then(B=>B).then(x,B=>{q("failed to asynchronously prepare wasm: "+B),Qe(B)})}function Ir(c,b){var x=ft;return le||typeof WebAssembly.instantiateStreaming!="function"||rr(x)||x.startsWith("file://")||k||typeof fetch!="function"?pt(x,c,b):fetch(x,{credentials:"same-origin"}).then(B=>WebAssembly.instantiateStreaming(B,c).then(b,function(G){return q("wasm streaming compile failed: "+G),q("falling back to ArrayBuffer instantiation"),pt(x,c,b)}))}var $t,Ct={911532:c=>{o.Ea("Abs",c,void 0)},911583:c=>{o.Ea("Neg",c,void 0)},911634:c=>{o.Ea("Floor",c,void 0)},911687:c=>{o.Ea("Ceil",c,void 0)},911739:c=>{o.Ea("Reciprocal",c,void 0)},911797:c=>{o.Ea("Sqrt",c,void 0)},911849:c=>{o.Ea("Exp",c,void 0)},911900:c=>{o.Ea("Erf",c,void 0)},911951:c=>{o.Ea("Sigmoid",c,void 0)},912006:c=>{o.Ea("Log",c,void 0)},912057:c=>{o.Ea("Sin",c,void 0)},912108:c=>{o.Ea("Cos",c,void 0)},912159:c=>{o.Ea("Tan",c,void 0)},912210:c=>{o.Ea("Asin",c,void 0)},912262:c=>{o.Ea("Acos",c,void 0)},912314:c=>{o.Ea("Atan",c,void 0)},912366:c=>{o.Ea("Sinh",c,void 0)},912418:c=>{o.Ea("Cosh",c,void 0)},912470:c=>{o.Ea("Asinh",c,void 0)},912523:c=>{o.Ea("Acosh",c,void 0)},912576:c=>{o.Ea("Atanh",c,void 0)},912629:c=>{o.Ea("Tanh",c,void 0)},912681:c=>{o.Ea("Not",c,void 0)},912732:(c,b,x)=>{o.Ea("ClipV10",c,{min:b,max:x})},912804:c=>{o.Ea("Clip",c,void 0)},912856:(c,b)=>{o.Ea("Elu",c,{alpha:b})},912914:c=>{o.Ea("Relu",c,void 0)},912966:(c,b)=>{o.Ea("LeakyRelu",c,{alpha:b})},913030:(c,b)=>{o.Ea("ThresholdedRelu",c,{alpha:b})},913100:(c,b)=>{o.Ea("Cast",c,{to:b})},913158:c=>{o.Ea("Add",c,void 0)},913209:c=>{o.Ea("Sub",c,void 0)},913260:c=>{o.Ea("Mul",c,void 0)},913311:c=>{o.Ea("Div",c,void 0)},913362:c=>{o.Ea("Pow",c,void 0)},913413:c=>{o.Ea("Equal",c,void 0)},913466:c=>{o.Ea("Greater",c,void 0)},913521:c=>{o.Ea("GreaterOrEqual",c,void 0)},913583:c=>{o.Ea("Less",c,void 0)},913635:c=>{o.Ea("LessOrEqual",c,void 0)},913694:(c,b,x,B,G)=>{o.Ea("ReduceMean",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:B?Array.from(u().subarray(G>>>0,G+B>>>0)):[]})},913858:(c,b,x,B,G)=>{o.Ea("ReduceMax",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:B?Array.from(u().subarray(G>>>0,G+B>>>0)):[]})},914021:(c,b,x,B,G)=>{o.Ea("ReduceMin",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:B?Array.from(u().subarray(G>>>0,G+B>>>0)):[]})},914184:(c,b,x,B,G)=>{o.Ea("ReduceProd",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:B?Array.from(u().subarray(G>>>0,G+B>>>0)):[]})},914348:(c,b,x,B,G)=>{o.Ea("ReduceSum",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:B?Array.from(u().subarray(G>>>0,G+B>>>0)):[]})},914511:(c,b,x,B,G)=>{o.Ea("ReduceL1",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:B?Array.from(u().subarray(G>>>0,G+B>>>0)):[]})},914673:(c,b,x,B,G)=>{o.Ea("ReduceL2",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:B?Array.from(u().subarray(G>>>0,G+B>>>0)):[]})},914835:(c,b,x,B,G)=>{o.Ea("ReduceLogSum",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:B?Array.from(u().subarray(G>>>0,G+B>>>0)):[]})},915001:(c,b,x,B,G)=>{o.Ea("ReduceSumSquare",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:B?Array.from(u().subarray(G>>>0,G+B>>>0)):[]})},915170:(c,b,x,B,G)=>{o.Ea("ReduceLogSumExp",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:B?Array.from(u().subarray(G>>>0,G+B>>>0)):[]})},915339:c=>{o.Ea("Where",c,void 0)},915392:(c,b,x)=>{o.Ea("Transpose",c,{perm:b?Array.from(u().subarray(x>>>0,x+b>>>0)):[]})},915505:(c,b,x,B,G,H,J,pe,ce,de)=>{o.Ea("Conv",c,{format:ce?"NHWC":"NCHW",auto_pad:b,dilations:[x],group:B,kernel_shape:[G],pads:[H,J],strides:[pe],w_is_const:()=>!!e()[de>>>0]})},915733:(c,b,x,B,G,H,J,pe,ce,de,he,_e,Se,V,ve)=>{o.Ea("Conv",c,{format:V?"NHWC":"NCHW",auto_pad:b,dilations:[x,B],group:G,kernel_shape:[H,J],pads:[pe,ce,de,he],strides:[_e,Se],w_is_const:()=>!!e()[ve>>>0]})},915992:(c,b,x,B,G,H,J,pe,ce,de)=>{o.Ea("Conv",c,{format:ce?"NHWC":"NCHW",auto_pad:b,dilations:[x],group:B,kernel_shape:[G],pads:[H,J],strides:[pe],w_is_const:()=>!!e()[de>>>0]})},916220:(c,b,x,B,G,H,J,pe,ce,de,he,_e,Se,V,ve)=>{o.Ea("Conv",c,{format:V?"NHWC":"NCHW",auto_pad:b,dilations:[x,B],group:G,kernel_shape:[H,J],pads:[pe,ce,de,he],strides:[_e,Se],w_is_const:()=>!!e()[ve>>>0]})},916479:(c,b,x,B,G,H,J,pe,ce,de,he,_e,Se,V)=>{o.Ea("ConvTranspose",c,{format:ce?"NHWC":"NCHW",autoPad:b,dilations:[x],group:B,kernel_shape:[G],pads:[H,J],strides:[pe],wIsConst:()=>!!e()[de>>>0],outputPadding:he?Array.from(u().subarray(_e>>>0,_e+he>>>0)):[],outputShape:Se?Array.from(u().subarray(V>>>0,V+Se>>>0)):[]})},916859:(c,b,x,B,G,H,J,pe,ce,de,he,_e,Se)=>{o.Ea("ConvTranspose",c,{format:pe?"NHWC":"NCHW",autoPad:b,dilations:Array.from(u().subarray(x>>>0,x+2>>>0)),group:B,kernelShape:Array.from(u().subarray(G>>>0,G+2>>>0)),pads:Array.from(u().subarray(H>>>0,H+4>>>0)),strides:Array.from(u().subarray(J>>>0,J+2>>>0)),wIsConst:()=>!!e()[ce>>>0],outputPadding:0<de?Array.from(u().subarray(he>>>0,he+de>>>0)):[],outputShape:0<_e?Array.from(u().subarray(Se>>>0,Se+_e>>>0)):[]})},917382:(c,b,x,B,G,H,J,pe,ce,de,he,_e,Se,V)=>{o.Ea("ConvTranspose",c,{format:ce?"NHWC":"NCHW",autoPad:b,dilations:[x],group:B,kernel_shape:[G],pads:[H,J],strides:[pe],wIsConst:()=>!!e()[de>>>0],outputPadding:he?Array.from(u().subarray(_e>>>0,_e+he>>>0)):[],outputShape:Se?Array.from(u().subarray(V>>>0,V+Se>>>0)):[]})},917762:(c,b,x,B,G,H,J,pe,ce,de,he,_e,Se)=>{o.Ea("ConvTranspose",c,{format:pe?"NHWC":"NCHW",autoPad:b,dilations:Array.from(u().subarray(x>>>0,x+2>>>0)),group:B,kernelShape:Array.from(u().subarray(G>>>0,G+2>>>0)),pads:Array.from(u().subarray(H>>>0,H+4>>>0)),strides:Array.from(u().subarray(J>>>0,J+2>>>0)),wIsConst:()=>!!e()[ce>>>0],outputPadding:0<de?Array.from(u().subarray(he>>>0,he+de>>>0)):[],outputShape:0<_e?Array.from(u().subarray(Se>>>0,Se+_e>>>0)):[]})},918285:(c,b)=>{o.Ea("GlobalAveragePool",c,{format:b?"NHWC":"NCHW"})},918376:(c,b,x,B,G,H,J,pe,ce,de,he,_e,Se,V,ve,Ee)=>{o.Ea("AveragePool",c,{format:Ee?"NHWC":"NCHW",auto_pad:b,ceil_mode:x,count_include_pad:B,storage_order:G,dilations:[H,J],kernel_shape:[pe,ce],pads:[de,he,_e,Se],strides:[V,ve]})},918660:(c,b)=>{o.Ea("GlobalAveragePool",c,{format:b?"NHWC":"NCHW"})},918751:(c,b,x,B,G,H,J,pe,ce,de,he,_e,Se,V,ve,Ee)=>{o.Ea("AveragePool",c,{format:Ee?"NHWC":"NCHW",auto_pad:b,ceil_mode:x,count_include_pad:B,storage_order:G,dilations:[H,J],kernel_shape:[pe,ce],pads:[de,he,_e,Se],strides:[V,ve]})},919035:(c,b)=>{o.Ea("GlobalMaxPool",c,{format:b?"NHWC":"NCHW"})},919122:(c,b,x,B,G,H,J,pe,ce,de,he,_e,Se,V,ve,Ee)=>{o.Ea("MaxPool",c,{format:Ee?"NHWC":"NCHW",auto_pad:b,ceil_mode:x,count_include_pad:B,storage_order:G,dilations:[H,J],kernel_shape:[pe,ce],pads:[de,he,_e,Se],strides:[V,ve]})},919402:(c,b)=>{o.Ea("GlobalMaxPool",c,{format:b?"NHWC":"NCHW"})},919489:(c,b,x,B,G,H,J,pe,ce,de,he,_e,Se,V,ve,Ee)=>{o.Ea("MaxPool",c,{format:Ee?"NHWC":"NCHW",auto_pad:b,ceil_mode:x,count_include_pad:B,storage_order:G,dilations:[H,J],kernel_shape:[pe,ce],pads:[de,he,_e,Se],strides:[V,ve]})},919769:(c,b,x,B,G)=>{o.Ea("Gemm",c,{alpha:b,beta:x,transA:B,transB:G})},919873:c=>{o.Ea("MatMul",c,void 0)},919927:(c,b,x,B)=>{o.Ea("ArgMax",c,{keepDims:!!b,selectLastIndex:!!x,axis:B})},920035:(c,b,x,B)=>{o.Ea("ArgMin",c,{keepDims:!!b,selectLastIndex:!!x,axis:B})},920143:(c,b)=>{o.Ea("Softmax",c,{axis:b})},920206:(c,b)=>{o.Ea("Concat",c,{axis:b})},920266:(c,b,x,B,G)=>{o.Ea("Split",c,{axis:b,numOutputs:x,splitSizes:B?Array.from(u().subarray(G>>>0,G+B>>>0)):[]})},920411:c=>{o.Ea("Expand",c,void 0)},920465:(c,b)=>{o.Ea("Gather",c,{axis:Number(b)})},920536:(c,b)=>{o.Ea("GatherElements",c,{axis:Number(b)})},920615:(c,b,x,B,G,H,J,pe,ce,de,he)=>{o.Ea("Resize",c,{antialias:b,axes:x?Array.from(u().subarray(B>>>0,B+x>>>0)):[],coordinateTransformMode:ht(G),cubicCoeffA:H,excludeOutside:J,extrapolationValue:pe,keepAspectRatioPolicy:ht(ce),mode:ht(de),nearestMode:ht(he)})},920966:(c,b,x,B,G,H,J)=>{o.Ea("Slice",c,{starts:b?Array.from(u().subarray(x>>>0,x+b>>>0)):[],ends:B?Array.from(u().subarray(G>>>0,G+B>>>0)):[],axes:H?Array.from(u().subarray(J>>>0,J+H>>>0)):[]})},921197:c=>{o.Ea("Tile",c,void 0)},921249:(c,b,x)=>{o.Ea("LayerNormalization",c,{axis:Number(b),epsilon:Number(x)})},921356:(c,b,x)=>{o.Ea("InstanceNormalization",c,{epsilon:b,format:x?"NHWC":"NCHW"})},921470:(c,b,x)=>{o.Ea("InstanceNormalization",c,{epsilon:b,format:x?"NHWC":"NCHW"})},921584:c=>{o.Ea("Range",c,void 0)},921637:(c,b)=>{o.Ea("Einsum",c,{equation:ht(b)})},921718:(c,b,x,B,G)=>{o.Ea("Pad",c,{mode:b,value:x,pads:B?Array.from(u().subarray(G>>>0,G+B>>>0)):[]})},921850:c=>{o.Ea("Gelu",c,void 0)},921902:c=>{o.Ea("BiasAdd",c,void 0)},921957:c=>{o.Ea("BiasSplitGelu",c,void 0)},922018:(c,b)=>{o.Ea("SkipLayerNormalization",c,{epsilon:b})},922099:c=>{o.zb(c)},922133:(c,b)=>o.Ab(c,b,o.bb.Fb,o.bb.errors),922245:c=>o.wb(c),922278:c=>o.yb(c),922310:(c,b,x)=>{o.jb(c,b,x,!0)},922349:(c,b,x)=>{o.jb(c,b,x)}};function zt(c){this.name="ExitStatus",this.message=`Program terminated with exit(${c})`,this.status=c}function ir(c){c.terminate(),c.onmessage=()=>{}}function Ar(c){(c=me.Qa[c])||Qe(),me.Eb(c)}function nr(c){var b=me.tb();if(!b)return 6;me.Ya.push(b),me.Qa[c.Xa]=b,b.Xa=c.Xa;var x={cmd:"run",start_routine:c.Gb,arg:c.rb,pthread_ptr:c.Xa};return k&&b.unref(),b.postMessage(x,c.Mb),0}var Er=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,ar=(c,b,x)=>{b>>>=0;var B=b+x;for(x=b;c[x]&&!(x>=B);)++x;if(16<x-b&&c.buffer&&Er)return Er.decode(c.buffer instanceof SharedArrayBuffer?c.slice(b,x):c.subarray(b,x));for(B="";b<x;){var G=c[b++];if(G&128){var H=c[b++]&63;if((G&224)==192)B+=String.fromCharCode((G&31)<<6|H);else{var J=c[b++]&63;G=(G&240)==224?(G&15)<<12|H<<6|J:(G&7)<<18|H<<12|J<<6|c[b++]&63,65536>G?B+=String.fromCharCode(G):(G-=65536,B+=String.fromCharCode(55296|G>>10,56320|G&1023))}}else B+=String.fromCharCode(G)}return B},ht=(c,b)=>(c>>>=0)?ar(d(),c,b):"";function or(c){if(P)return je(1,1,c);Le=c,Be()||(me.Hb(),o.onExit&&o.onExit(c),Ae=!0),O(c,new zt(c))}var Or=c=>{if(Le=c,P)throw _i(c),"unwind";or(c)},me={ab:[],Ya:[],mb:[],Qa:{},gb:function(){P?me.vb():me.ub()},ub:function(){Oe.unshift(()=>{Mt(),me.Bb(()=>Dt())})},vb:function(){me.receiveObjectTransfer=me.Db,me.threadInitTLS=me.lb,me.setExitStatus=me.kb,Pe=!1},kb:function(c){Le=c},Sb:["$terminateWorker"],Hb:function(){for(var c of me.Ya)ir(c);for(c of me.ab)ir(c);me.ab=[],me.Ya=[],me.Qa=[]},Eb:function(c){var b=c.Xa;delete me.Qa[b],me.ab.push(c),me.Ya.splice(me.Ya.indexOf(c),1),c.Xa=0,gr(b)},Db:function(){},lb:function(){me.mb.forEach(c=>c())},Cb:c=>new Promise(b=>{c.onmessage=H=>{H=H.data;var J=H.cmd;if(H.targetThread&&H.targetThread!=Ht()){var pe=me.Qa[H.Rb];pe?pe.postMessage(H,H.transferList):q('Internal error! Worker sent a message "'+J+'" to target pthread '+H.targetThread+", but that thread no longer exists!")}else J==="checkMailbox"?Gt():J==="spawnThread"?nr(H):J==="cleanupThread"?Ar(H.thread):J==="killThread"?(H=H.thread,J=me.Qa[H],delete me.Qa[H],ir(J),gr(H),me.Ya.splice(me.Ya.indexOf(J),1),J.Xa=0):J==="cancelThread"?me.Qa[H.thread].postMessage({cmd:"cancel"}):J==="loaded"?(c.loaded=!0,b(c)):J==="alert"?alert("Thread "+H.threadId+": "+H.text):H.target==="setimmediate"?c.postMessage(H):J==="callHandler"?o[H.handler](...H.args):J&&q("worker sent an unknown command "+J)},c.onerror=H=>{throw q("worker sent an error! "+H.filename+":"+H.lineno+": "+H.message),H},k&&(c.on("message",function(H){c.onmessage({data:H})}),c.on("error",function(H){c.onerror(H)}));var x=[],B=["onExit","onAbort","print","printErr"],G;for(G of B)o.hasOwnProperty(G)&&x.push(G);c.postMessage({cmd:"load",handlers:x,urlOrBlob:o.mainScriptUrlOrBlob||t,wasmMemory:ue,wasmModule:et})}),Bb:function(c){c()},qb:function(){var c=F("ort-wasm-simd-threaded.worker.js");c=new Worker(c),me.ab.push(c)},tb:function(){return me.ab.length==0&&(me.qb(),me.Cb(me.ab[0])),me.ab.pop()}};o.PThread=me;var Wt=c=>{for(;0<c.length;)c.shift()(o)};o.establishStackSpace=function(){var c=Ht(),b=u()[c+52>>2>>>0];c=u()[c+56>>2>>>0],ii(b,b-c),Lt(b)};function _i(c){if(P)return je(2,0,c);Or(c)}o.invokeEntryPoint=function(c,b){c=ni.apply(null,[c,b]),Be()?me.kb(c):yr(c)};function xi(c){this.fb=c-24,this.pb=function(b){h()[this.fb+4>>2>>>0]=b},this.ob=function(b){h()[this.fb+8>>2>>>0]=b},this.gb=function(b,x){this.nb(),this.pb(b),this.ob(x)},this.nb=function(){h()[this.fb+16>>2>>>0]=0}}var Nt=0,On=0;function mt(c,b,x,B){return P?je(3,1,c,b,x,B):at(c,b,x,B)}function at(c,b,x,B){if(c>>>=0,b>>>=0,x>>>=0,B>>>=0,typeof SharedArrayBuffer>"u")return q("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var G=[];return P&&G.length===0?mt(c,b,x,B):(c={Gb:x,Xa:c,rb:B,Mb:G},P?(c.Ob="spawnThread",postMessage(c,G),0):nr(c))}function Tr(c,b,x){return P?je(4,1,c,b,x):0}function Ut(c,b){if(P)return je(5,1,c,b)}var sr=c=>{for(var b=0,x=0;x<c.length;++x){var B=c.charCodeAt(x);127>=B?b++:2047>=B?b+=2:55296<=B&&57343>=B?(b+=4,++x):b+=3}return b},Rr=(c,b,x,B)=>{if(x>>>=0,!(0<B))return 0;var G=x;B=x+B-1;for(var H=0;H<c.length;++H){var J=c.charCodeAt(H);if(55296<=J&&57343>=J){var pe=c.charCodeAt(++H);J=65536+((J&1023)<<10)|pe&1023}if(127>=J){if(x>=B)break;b[x++>>>0]=J}else{if(2047>=J){if(x+1>=B)break;b[x++>>>0]=192|J>>6}else{if(65535>=J){if(x+2>=B)break;b[x++>>>0]=224|J>>12}else{if(x+3>=B)break;b[x++>>>0]=240|J>>18,b[x++>>>0]=128|J>>12&63}b[x++>>>0]=128|J>>6&63}b[x++>>>0]=128|J&63}}return b[x>>>0]=0,x-G},Si=(c,b,x)=>Rr(c,d(),b,x);function ur(c,b){if(P)return je(6,1,c,b)}function Ii(c,b,x){if(P)return je(7,1,c,b,x)}function Ai(c,b,x){return P?je(8,1,c,b,x):0}function Ei(c,b){if(P)return je(9,1,c,b)}function Oi(c,b,x){if(P)return je(10,1,c,b,x)}function Ti(c,b,x,B){if(P)return je(11,1,c,b,x,B)}function Ri(c,b,x,B){if(P)return je(12,1,c,b,x,B)}function lr(c,b,x,B){if(P)return je(13,1,c,b,x,B)}function kr(c){if(P)return je(14,1,c)}function W(c,b){if(P)return je(15,1,c,b)}function Tt(c,b,x){if(P)return je(16,1,c,b,x)}var N=c=>{if(!Ae)try{if(c(),!Be())try{P?yr(Le):Or(Le)}catch(b){b instanceof zt||b=="unwind"||O(1,b)}}catch(b){b instanceof zt||b=="unwind"||O(1,b)}};function z(c){c>>>=0,typeof Atomics.Nb=="function"&&(Atomics.Nb(u(),c>>2,c).value.then(Gt),c+=128,Atomics.store(u(),c>>2,1))}o.__emscripten_thread_mailbox_await=z;function Gt(){var c=Ht();c&&(z(c),N(()=>ti()))}o.checkMailbox=Gt;var Rt=c=>c%4===0&&(c%100!==0||c%400===0),jr=[0,31,60,91,121,152,182,213,244,274,305,335],Pr=[0,31,59,90,120,151,181,212,243,273,304,334];function Br(c,b,x,B,G,H,J,pe){return P?je(17,1,c,b,x,B,G,H,J,pe):-52}function Mr(c,b,x,B,G,H,J){if(P)return je(18,1,c,b,x,B,G,H,J)}var Dr=c=>{var b=sr(c)+1,x=mr(b);return x&&Si(c,x,b),x},dr=[],zr=(c,b)=>{dr.length=0;var x;for(b>>=2;x=d()[c++>>>0];)b+=x!=105&b,dr.push(x==105?u()[b>>>0]:m()[b++>>>1]),++b;return dr},ki=c=>{var b=vr();return c=c(),Lt(b),c};function je(c,b){var x=arguments.length-2,B=arguments;return ki(()=>{for(var G=br(8*x),H=G>>3,J=0;J<x;J++){var pe=B[2+J];m()[H+J>>>0]=pe}return ei(c,x,G,b)})}var cr=[],fr={},Wr=()=>{if(!pr){var c={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:T||"./this.program"},b;for(b in fr)fr[b]===void 0?delete c[b]:c[b]=fr[b];var x=[];for(b in c)x.push(`${b}=${c[b]}`);pr=x}return pr},pr;function Nr(c,b){if(P)return je(19,1,c,b);c>>>=0,b>>>=0;var x=0;return Wr().forEach(function(B,G){var H=b+x;for(G=h()[c+4*G>>2>>>0]=H,H=0;H<B.length;++H)e()[G++>>0>>>0]=B.charCodeAt(H);e()[G>>0>>>0]=0,x+=B.length+1}),0}function Ur(c,b){if(P)return je(20,1,c,b);c>>>=0,b>>>=0;var x=Wr();h()[c>>2>>>0]=x.length;var B=0;return x.forEach(function(G){B+=G.length+1}),h()[b>>2>>>0]=B,0}function Gr(c){return P?je(21,1,c):52}function Vr(c,b,x,B){return P?je(22,1,c,b,x,B):52}function Fr(c,b,x,B,G){return P?je(23,1,c,b,x,B,G):70}var ji=[null,[],[]];function Hr(c,b,x,B){if(P)return je(24,1,c,b,x,B);b>>>=0,x>>>=0,B>>>=0;for(var G=0,H=0;H<x;H++){var J=h()[b>>2>>>0],pe=h()[b+4>>2>>>0];b+=8;for(var ce=0;ce<pe;ce++){var de=d()[J+ce>>>0],he=ji[c];de===0||de===10?((c===1?$e:q)(ar(he,0)),he.length=0):he.push(de)}G+=pe}return h()[B>>2>>>0]=G,0}var Lr=[31,29,31,30,31,30,31,31,30,31,30,31],qr=[31,28,31,30,31,30,31,31,30,31,30,31];function Pi(c){var b=Array(sr(c)+1);return Rr(c,b,0,b.length),b}var Bi=(c,b)=>{e().set(c,b>>>0)};function Kr(c,b,x,B){function G(V,ve,Ee){for(V=typeof V=="number"?V.toString():V||"";V.length<ve;)V=Ee[0]+V;return V}function H(V,ve){return G(V,ve,"0")}function J(V,ve){function Ee(di){return 0>di?-1:0<di?1:0}var _t;return(_t=Ee(V.getFullYear()-ve.getFullYear()))===0&&(_t=Ee(V.getMonth()-ve.getMonth()))===0&&(_t=Ee(V.getDate()-ve.getDate())),_t}function pe(V){switch(V.getDay()){case 0:return new Date(V.getFullYear()-1,11,29);case 1:return V;case 2:return new Date(V.getFullYear(),0,3);case 3:return new Date(V.getFullYear(),0,2);case 4:return new Date(V.getFullYear(),0,1);case 5:return new Date(V.getFullYear()-1,11,31);case 6:return new Date(V.getFullYear()-1,11,30)}}function ce(V){var ve=V.Za;for(V=new Date(new Date(V.$a+1900,0,1).getTime());0<ve;){var Ee=V.getMonth(),_t=(Rt(V.getFullYear())?Lr:qr)[Ee];if(ve>_t-V.getDate())ve-=_t-V.getDate()+1,V.setDate(1),11>Ee?V.setMonth(Ee+1):(V.setMonth(0),V.setFullYear(V.getFullYear()+1));else{V.setDate(V.getDate()+ve);break}}return Ee=new Date(V.getFullYear()+1,0,4),ve=pe(new Date(V.getFullYear(),0,4)),Ee=pe(Ee),0>=J(ve,V)?0>=J(Ee,V)?V.getFullYear()+1:V.getFullYear():V.getFullYear()-1}c>>>=0,b>>>=0,x>>>=0,B>>>=0;var de=u()[B+40>>2>>>0];B={Kb:u()[B>>2>>>0],Jb:u()[B+4>>2>>>0],cb:u()[B+8>>2>>>0],ib:u()[B+12>>2>>>0],eb:u()[B+16>>2>>>0],$a:u()[B+20>>2>>>0],Wa:u()[B+24>>2>>>0],Za:u()[B+28>>2>>>0],Tb:u()[B+32>>2>>>0],Ib:u()[B+36>>2>>>0],Lb:de?ht(de):""},x=ht(x),de={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var he in de)x=x.replace(new RegExp(he,"g"),de[he]);var _e="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Se="January February March April May June July August September October November December".split(" ");de={"%a":V=>_e[V.Wa].substring(0,3),"%A":V=>_e[V.Wa],"%b":V=>Se[V.eb].substring(0,3),"%B":V=>Se[V.eb],"%C":V=>H((V.$a+1900)/100|0,2),"%d":V=>H(V.ib,2),"%e":V=>G(V.ib,2," "),"%g":V=>ce(V).toString().substring(2),"%G":V=>ce(V),"%H":V=>H(V.cb,2),"%I":V=>(V=V.cb,V==0?V=12:12<V&&(V-=12),H(V,2)),"%j":V=>{for(var ve=0,Ee=0;Ee<=V.eb-1;ve+=(Rt(V.$a+1900)?Lr:qr)[Ee++]);return H(V.ib+ve,3)},"%m":V=>H(V.eb+1,2),"%M":V=>H(V.Jb,2),"%n":()=>`
`,"%p":V=>0<=V.cb&&12>V.cb?"AM":"PM","%S":V=>H(V.Kb,2),"%t":()=>"	","%u":V=>V.Wa||7,"%U":V=>H(Math.floor((V.Za+7-V.Wa)/7),2),"%V":V=>{var ve=Math.floor((V.Za+7-(V.Wa+6)%7)/7);if(2>=(V.Wa+371-V.Za-2)%7&&ve++,ve)ve==53&&(Ee=(V.Wa+371-V.Za)%7,Ee==4||Ee==3&&Rt(V.$a)||(ve=1));else{ve=52;var Ee=(V.Wa+7-V.Za-1)%7;(Ee==4||Ee==5&&Rt(V.$a%400-1))&&ve++}return H(ve,2)},"%w":V=>V.Wa,"%W":V=>H(Math.floor((V.Za+7-(V.Wa+6)%7)/7),2),"%y":V=>(V.$a+1900).toString().substring(2),"%Y":V=>V.$a+1900,"%z":V=>{V=V.Ib;var ve=0<=V;return V=Math.abs(V)/60,(ve?"+":"-")+("0000"+(V/60*100+V%60)).slice(-4)},"%Z":V=>V.Lb,"%%":()=>"%"},x=x.replace(/%%/g,"\0\0");for(he in de)x.includes(he)&&(x=x.replace(new RegExp(he,"g"),de[he](B)));return x=x.replace(/\0\0/g,"%"),he=Pi(x),he.length>b?0:(Bi(he,c),he.length-1)}function Vt(c){try{c()}catch(b){Qe(b)}}function Mi(c){var b={},x;for(x in c)(function(B){var G=c[B];b[B]=typeof G=="function"?function(){Ft.push(B);try{return G.apply(null,arguments)}finally{Ae||(Ft.pop()===B||Qe(),ot&&gt===1&&Ft.length===0&&(gt=0,Ue+=1,Vt(oi),typeof Fibers<"u"&&Fibers.Ub()))}}:G})(x);return b}var gt=0,ot=null,Yr=0,Ft=[],Xr={},Qr={},Di=0,hr=null,zi=[];function Wi(){return new Promise((c,b)=>{hr={resolve:c,reject:b}})}function Ni(){var c=mr(65548),b=c+12;h()[c>>2>>>0]=b,h()[c+4>>2>>>0]=b+65536,b=Ft[0];var x=Xr[b];return x===void 0&&(x=Di++,Xr[b]=x,Qr[x]=b),b=x,u()[c+8>>2>>>0]=b,c}function Ui(){var c=u()[ot+8>>2>>>0];return c=oe[Qr[c]],--Ue,c()}function Gi(c){if(!Ae){if(gt===0){var b=!1,x=!1;c((B=0)=>{if(!Ae&&(Yr=B,b=!0,x)){gt=2,Vt(()=>si(ot)),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),B=!1;try{var G=Ui()}catch(pe){G=pe,B=!0}var H=!1;if(!ot){var J=hr;J&&(hr=null,(B?J.reject:J.resolve)(G),H=!0)}if(B&&!H)throw G}}),x=!0,b||(gt=1,ot=Ni(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),Vt(()=>ai(ot)))}else gt===2?(gt=0,Vt(ui),Jr(ot),ot=null,zi.forEach(B=>N(B))):Qe(`invalid state: ${gt}`);return Yr}}function Vi(c){return Gi(b=>{c().then(b)})}me.gb();var Fi=[null,or,_i,mt,Tr,Ut,ur,Ii,Ai,Ei,Oi,Ti,Ri,lr,kr,W,Tt,Br,Mr,Nr,Ur,Gr,Vr,Fr,Hr],Hi={r:function(c,b,x){return Vi(async()=>{await o.xb(c,b,x)})},b:function(c,b,x){throw c>>>=0,new xi(c).gb(b>>>0,x>>>0),Nt=c,On++,Nt},O:function(c){Zr(c>>>0,!j,1,!R,131072,!1),me.lb()},l:function(c){c>>>=0,P?postMessage({cmd:"cleanupThread",thread:c}):Ar(c)},I:at,i:Tr,U:Ut,E:ur,G:Ii,V:Ai,S:Ei,K:Oi,R:Ti,p:Ri,F:lr,C:kr,T:W,D:Tt,q:()=>!0,A:function(c,b){c>>>=0,c==b>>>0?setTimeout(()=>Gt()):P?postMessage({targetThread:c,cmd:"checkMailbox"}):(c=me.Qa[c])&&c.postMessage({cmd:"checkMailbox"})},M:function(){return-1},N:z,X:function(c){k&&me.Qa[c>>>0].ref()},u:function(c,b,x){c=b+2097152>>>0<4194305-!!c?(c>>>0)+4294967296*b:NaN,x>>>=0,c=new Date(1e3*c),u()[x>>2>>>0]=c.getUTCSeconds(),u()[x+4>>2>>>0]=c.getUTCMinutes(),u()[x+8>>2>>>0]=c.getUTCHours(),u()[x+12>>2>>>0]=c.getUTCDate(),u()[x+16>>2>>>0]=c.getUTCMonth(),u()[x+20>>2>>>0]=c.getUTCFullYear()-1900,u()[x+24>>2>>>0]=c.getUTCDay(),c=(c.getTime()-Date.UTC(c.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,u()[x+28>>2>>>0]=c},v:function(c,b,x){c=b+2097152>>>0<4194305-!!c?(c>>>0)+4294967296*b:NaN,x>>>=0,c=new Date(1e3*c),u()[x>>2>>>0]=c.getSeconds(),u()[x+4>>2>>>0]=c.getMinutes(),u()[x+8>>2>>>0]=c.getHours(),u()[x+12>>2>>>0]=c.getDate(),u()[x+16>>2>>>0]=c.getMonth(),u()[x+20>>2>>>0]=c.getFullYear()-1900,u()[x+24>>2>>>0]=c.getDay(),b=(Rt(c.getFullYear())?jr:Pr)[c.getMonth()]+c.getDate()-1|0,u()[x+28>>2>>>0]=b,u()[x+36>>2>>>0]=-(60*c.getTimezoneOffset()),b=new Date(c.getFullYear(),6,1).getTimezoneOffset();var B=new Date(c.getFullYear(),0,1).getTimezoneOffset();c=(b!=B&&c.getTimezoneOffset()==Math.min(B,b))|0,u()[x+32>>2>>>0]=c},w:function(c){c>>>=0;var b=new Date(u()[c+20>>2>>>0]+1900,u()[c+16>>2>>>0],u()[c+12>>2>>>0],u()[c+8>>2>>>0],u()[c+4>>2>>>0],u()[c>>2>>>0],0),x=u()[c+32>>2>>>0],B=b.getTimezoneOffset(),G=new Date(b.getFullYear(),6,1).getTimezoneOffset(),H=new Date(b.getFullYear(),0,1).getTimezoneOffset(),J=Math.min(H,G);return 0>x?u()[c+32>>2>>>0]=+(G!=H&&J==B):0<x!=(J==B)&&(G=Math.max(H,G),b.setTime(b.getTime()+6e4*((0<x?J:G)-B))),u()[c+24>>2>>>0]=b.getDay(),x=(Rt(b.getFullYear())?jr:Pr)[b.getMonth()]+b.getDate()-1|0,u()[c+28>>2>>>0]=x,u()[c>>2>>>0]=b.getSeconds(),u()[c+4>>2>>>0]=b.getMinutes(),u()[c+8>>2>>>0]=b.getHours(),u()[c+12>>2>>>0]=b.getDate(),u()[c+16>>2>>>0]=b.getMonth(),u()[c+20>>2>>>0]=b.getYear(),c=b.getTime()/1e3,ri(($t=c,1<=+Math.abs($t)?0<$t?+Math.floor($t/4294967296)>>>0:~~+Math.ceil(($t-+(~~$t>>>0))/4294967296)>>>0:0)),c>>>0},s:Br,t:Mr,z:function(c,b,x){function B(de){return(de=de.toTimeString().match(/\(([A-Za-z ]+)\)$/))?de[1]:"GMT"}c>>>=0,b>>>=0,x>>>=0;var G=new Date().getFullYear(),H=new Date(G,0,1),J=new Date(G,6,1);G=H.getTimezoneOffset();var pe=J.getTimezoneOffset(),ce=Math.max(G,pe);h()[c>>2>>>0]=60*ce,u()[b>>2>>>0]=+(G!=pe),c=B(H),b=B(J),c=Dr(c),b=Dr(b),pe<G?(h()[x>>2>>>0]=c,h()[x+4>>2>>>0]=b):(h()[x>>2>>>0]=b,h()[x+4>>2>>>0]=c)},d:()=>{Qe("")},c:function(c,b,x){return c>>>=0,b=zr(b>>>0,x>>>0),Ct[c].apply(null,b)},k:function(c,b,x){return c>>>=0,b=zr(b>>>0,x>>>0),Ct[c].apply(null,b)},m:function(){},j:function(){return Date.now()},W:()=>{throw Ue+=1,"unwind"},B:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:function(){return k?(Ns(),kt(Ws)).cpus().length:navigator.hardwareConcurrency},L:function(c,b,x,B){for(me.Pb=b>>>0,cr.length=x,b=B>>>0>>3,B=0;B<x;B++)cr[B]=m()[b+B>>>0];return(0>c?Ct[-c-1]:Fi[c]).apply(null,cr)},y:function(c){c>>>=0;var b=d().length;if(c<=b||4294901760<c)return!1;for(var x=1;4>=x;x*=2){var B=b*(1+.2/x);B=Math.min(B,c+100663296);var G=Math;B=Math.max(c,B);e:{G=G.min.call(G,4294901760,B+(65536-B%65536)%65536)-ue.buffer.byteLength+65535>>>16;try{ue.grow(G),ee();var H=1;break e}catch{}H=void 0}if(H)return!0}return!1},P:Nr,Q:Ur,H:Or,h:Gr,o:Vr,x:Fr,n:Hr,a:ue||o.wasmMemory,J:Kr,e:function(c,b,x,B){return Kr(c>>>0,b>>>0,x>>>0,B>>>0)}};(function(){function c(x,B){return x=x.exports,x=Mi(x),oe=x=Li(x),me.mb.push(oe.Da),tt.unshift(oe.Y),et=B,Dt(),x}var b={a:Hi};if(Mt(),o.instantiateWasm)try{return o.instantiateWasm(b,c)}catch(x){q("Module.instantiateWasm callback failed with error: "+x),$(x)}return Ir(b,function(x){c(x.instance,x.module)}).catch($),{}})(),o._OrtInit=(c,b)=>(o._OrtInit=oe.Z)(c,b),o._OrtGetLastError=(c,b)=>(o._OrtGetLastError=oe._)(c,b),o._OrtCreateSessionOptions=(c,b,x,B,G,H,J,pe,ce,de)=>(o._OrtCreateSessionOptions=oe.$)(c,b,x,B,G,H,J,pe,ce,de),o._OrtAppendExecutionProvider=(c,b)=>(o._OrtAppendExecutionProvider=oe.aa)(c,b),o._OrtAddFreeDimensionOverride=(c,b,x)=>(o._OrtAddFreeDimensionOverride=oe.ba)(c,b,x),o._OrtAddSessionConfigEntry=(c,b,x)=>(o._OrtAddSessionConfigEntry=oe.ca)(c,b,x),o._OrtReleaseSessionOptions=c=>(o._OrtReleaseSessionOptions=oe.da)(c),o._OrtCreateSession=(c,b,x)=>(o._OrtCreateSession=oe.ea)(c,b,x),o._OrtReleaseSession=c=>(o._OrtReleaseSession=oe.fa)(c),o._OrtGetInputOutputCount=(c,b,x)=>(o._OrtGetInputOutputCount=oe.ga)(c,b,x),o._OrtGetInputName=(c,b)=>(o._OrtGetInputName=oe.ha)(c,b),o._OrtGetOutputName=(c,b)=>(o._OrtGetOutputName=oe.ia)(c,b),o._OrtFree=c=>(o._OrtFree=oe.ja)(c),o._OrtCreateTensor=(c,b,x,B,G,H)=>(o._OrtCreateTensor=oe.ka)(c,b,x,B,G,H),o._OrtGetTensorData=(c,b,x,B,G)=>(o._OrtGetTensorData=oe.la)(c,b,x,B,G),o._OrtReleaseTensor=c=>(o._OrtReleaseTensor=oe.ma)(c),o._OrtCreateRunOptions=(c,b,x,B)=>(o._OrtCreateRunOptions=oe.na)(c,b,x,B),o._OrtAddRunConfigEntry=(c,b,x)=>(o._OrtAddRunConfigEntry=oe.oa)(c,b,x),o._OrtReleaseRunOptions=c=>(o._OrtReleaseRunOptions=oe.pa)(c),o._OrtCreateBinding=c=>(o._OrtCreateBinding=oe.qa)(c),o._OrtBindInput=(c,b,x)=>(o._OrtBindInput=oe.ra)(c,b,x),o._OrtBindOutput=(c,b,x,B)=>(o._OrtBindOutput=oe.sa)(c,b,x,B),o._OrtClearBoundOutputs=c=>(o._OrtClearBoundOutputs=oe.ta)(c),o._OrtReleaseBinding=c=>(o._OrtReleaseBinding=oe.ua)(c),o._OrtRunWithBinding=(c,b,x,B,G)=>(o._OrtRunWithBinding=oe.va)(c,b,x,B,G),o._OrtRun=(c,b,x,B,G,H,J,pe)=>(o._OrtRun=oe.wa)(c,b,x,B,G,H,J,pe),o._OrtEndProfiling=c=>(o._OrtEndProfiling=oe.xa)(c),o._JsepOutput=(c,b,x)=>(o._JsepOutput=oe.ya)(c,b,x),o._JsepGetNodeName=c=>(o._JsepGetNodeName=oe.za)(c);var Ht=o._pthread_self=()=>(Ht=o._pthread_self=oe.Aa)(),mr=o._malloc=c=>(mr=o._malloc=oe.Ba)(c),Jr=o._free=c=>(Jr=o._free=oe.Ca)(c);o.__emscripten_tls_init=()=>(o.__emscripten_tls_init=oe.Da)();var Zr=o.__emscripten_thread_init=(c,b,x,B,G,H)=>(Zr=o.__emscripten_thread_init=oe.Fa)(c,b,x,B,G,H);o.__emscripten_thread_crashed=()=>(o.__emscripten_thread_crashed=oe.Ga)();var ei=(c,b,x,B)=>(ei=oe.Ha)(c,b,x,B),gr=c=>(gr=oe.Ia)(c),yr=o.__emscripten_thread_exit=c=>(yr=o.__emscripten_thread_exit=oe.Ja)(c),ti=o.__emscripten_check_mailbox=()=>(ti=o.__emscripten_check_mailbox=oe.Ka)(),ri=c=>(ri=oe.La)(c),ii=(c,b)=>(ii=oe.Ma)(c,b),vr=()=>(vr=oe.Na)(),Lt=c=>(Lt=oe.Oa)(c),br=c=>(br=oe.Pa)(c),ni=o.dynCall_ii=(c,b)=>(ni=o.dynCall_ii=oe.Ra)(c,b),ai=c=>(ai=oe.Sa)(c),oi=()=>(oi=oe.Ta)(),si=c=>(si=oe.Ua)(c),ui=()=>(ui=oe.Va)();o.___start_em_js=922382,o.___stop_em_js=922543;function Li(c){c=Object.assign({},c);var b=B=>()=>B()>>>0,x=B=>G=>B(G)>>>0;return c.__errno_location=b(c.__errno_location),c.pthread_self=b(c.pthread_self),c.malloc=x(c.malloc),c.stackSave=b(c.stackSave),c.stackAlloc=x(c.stackAlloc),c}o.keepRuntimeAlive=Be,o.wasmMemory=ue,o.stackAlloc=br,o.stackSave=vr,o.stackRestore=Lt,o.UTF8ToString=ht,o.stringToUTF8=Si,o.lengthBytesUTF8=sr,o.ExitStatus=zt,o.PThread=me;var qt;ct=function c(){qt||li(),qt||(ct=c)};function li(){function c(){if(!qt&&(qt=!0,o.calledRun=!0,!Ae)&&(P||Wt(tt),y(o),o.onRuntimeInitialized&&o.onRuntimeInitialized(),!P)){if(o.postRun)for(typeof o.postRun=="function"&&(o.postRun=[o.postRun]);o.postRun.length;){var b=o.postRun.shift();it.unshift(b)}Wt(it)}}if(!(0<nt))if(P)y(o),P||Wt(tt),startWorker(o);else{if(o.preRun)for(typeof o.preRun=="function"&&(o.preRun=[o.preRun]);o.preRun.length;)Oe.unshift(o.preRun.shift());Wt(Oe),0<nt||(o.setStatus?(o.setStatus("Running..."),setTimeout(function(){setTimeout(function(){o.setStatus("")},1),c()},1)):c())}}if(o.preInit)for(typeof o.preInit=="function"&&(o.preInit=[o.preInit]);0<o.preInit.length;)o.preInit.pop()();return li(),r.ready}})();typeof Gs=="object"&&typeof Nn=="object"?Nn.exports=Us:typeof define=="function"&&define.amd&&define([],()=>Us)});var Fs=wr((G0,Bh)=>{Bh.exports='"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\n'});var Ls,Mh,Un,Gn,Zi,Hs,Dh,zh,Wh,qs,Ve,Cr=ie(()=>{"use strict";Ls=Ms();Mh=Vs(),Gn=!1,Zi=!1,Hs=!1,Dh=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},zh=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Wh=(t,r)=>t?r?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":r?"ort-wasm-threaded.wasm":"ort-wasm.wasm",qs=async t=>{if(Gn)return Promise.resolve();if(Zi)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Hs)throw new Error("previous call to 'initializeWebAssembly()' failed.");Zi=!0;let r=t.initTimeout,e=t.numThreads,d=t.simd,u=e>1&&Dh(),h=d&&zh(),m=t.wasmPaths,o=typeof m=="string"?m:void 0,y=Wh(h,u),$=typeof m=="object"?m[y]:void 0,A=!1,T=[];if(r>0&&T.push(new Promise(O=>{setTimeout(()=>{A=!0,O()},r)})),T.push(new Promise((O,R)=>{let j=u?Mh:Ls,k={locateFile:(P,D)=>{if(u&&P.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Fs()],{type:"text/javascript"}));if(P.endsWith(".wasm")){if($)return $;let F=o??D;return y==="ort-wasm-simd.wasm"?F+"ort-wasm-simd.jsep.wasm":y==="ort-wasm-simd-threaded.wasm"?F+"ort-wasm-simd-threaded.jsep.wasm":F+y}return D+P}};if(u)if(typeof Blob>"u")k.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let P=`var ortWasmThreaded=${j.toString()};`;k.mainScriptUrlOrBlob=new Blob([P],{type:"text/javascript"})}j(k).then(P=>{Zi=!1,Gn=!0,Un=P,O()},P=>{Zi=!1,Hs=!0,R(P)})})),await Promise.race(T),A)throw new Error(`WebAssembly backend initializing failed due to timeout: ${r}ms`)},Ve=()=>{if(Gn&&Un)return Un;throw new Error("WebAssembly is not initialized yet.")}});var Ke,fi,We,en=ie(()=>{"use strict";Cr();Ke=(t,r)=>{let e=Ve(),d=e.lengthBytesUTF8(t)+1,u=e._malloc(d);return e.stringToUTF8(t,u,d),r.push(u),u},fi=(t,r,e,d)=>{if(typeof t=="object"&&t!==null){if(e.has(t))throw new Error("Circular reference in options");e.add(t)}Object.entries(t).forEach(([u,h])=>{let m=r?r+u:u;if(typeof h=="object")fi(h,m+".",e,d);else if(typeof h=="string"||typeof h=="number")d(m,h.toString());else if(typeof h=="boolean")d(m,h?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof h}`)})},We=t=>{let r=Ve(),e=r.stackSave();try{let d=r.stackAlloc(8);r._OrtGetLastError(d,d+4);let u=r.HEAP32[d/4],h=r.HEAPU32[d/4+1],m=h?r.UTF8ToString(h):"";throw new Error(`${t} ERROR_CODE: ${u}, ERROR_MESSAGE: ${m}`)}finally{r.stackRestore(e)}}});var Ks,Ys=ie(()=>{"use strict";Cr();en();Ks=t=>{let r=Ve(),e=0,d=[],u=t||{};try{if(t?.logSeverityLevel===void 0)u.logSeverityLevel=2;else if(typeof t.logSeverityLevel!="number"||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(t?.logVerbosityLevel===void 0)u.logVerbosityLevel=0;else if(typeof t.logVerbosityLevel!="number"||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);t?.terminate===void 0&&(u.terminate=!1);let h=0;return t?.tag!==void 0&&(h=Ke(t.tag,d)),e=r._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,h),e===0&&We("Can't create run options."),t?.extra!==void 0&&fi(t.extra,"",new WeakSet,(m,o)=>{let y=Ke(m,d),$=Ke(o,d);r._OrtAddRunConfigEntry(e,y,$)!==0&&We(`Can't set a run config entry: ${m} - ${o}.`)}),[e,d]}catch(h){throw e!==0&&r._OrtReleaseRunOptions(e),d.forEach(m=>r._free(m)),h}}});var Nh,Uh,Gh,Vh,Xs,Qs=ie(()=>{"use strict";Cr();en();Nh=t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}},Uh=t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}},Gh=t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});let r=t.extra.session;r.use_ort_model_bytes_directly||(r.use_ort_model_bytes_directly="1"),t.executionProviders&&t.executionProviders.some(e=>(typeof e=="string"?e:e.name)==="webgpu")&&(t.enableMemPattern=!1)},Vh=(t,r,e)=>{for(let d of r){let u=typeof d=="string"?d:d.name;switch(u){case"xnnpack":u="XNNPACK";break;case"webnn":if(u="WEBNN",typeof d!="string"){let m=d;if(m?.deviceType){let o=Ke("deviceType",e),y=Ke(m.deviceType,e);Ve()._OrtAddSessionConfigEntry(t,o,y)!==0&&We(`Can't set a session config entry: 'deviceType' - ${m.deviceType}.`)}if(m?.powerPreference){let o=Ke("powerPreference",e),y=Ke(m.powerPreference,e);Ve()._OrtAddSessionConfigEntry(t,o,y)!==0&&We(`Can't set a session config entry: 'powerPreference' - ${m.powerPreference}.`)}}break;case"webgpu":if(u="JS",typeof d!="string"){let m=d;if(m?.preferredLayout){if(m.preferredLayout!=="NCHW"&&m.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${m.preferredLayout}`);let o=Ke("preferredLayout",e),y=Ke(m.preferredLayout,e);Ve()._OrtAddSessionConfigEntry(t,o,y)!==0&&We(`Can't set a session config entry: 'preferredLayout' - ${m.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${u}`)}let h=Ke(u,e);Ve()._OrtAppendExecutionProvider(t,h)!==0&&We(`Can't append execution provider: ${u}.`)}},Xs=t=>{let r=Ve(),e=0,d=[],u=t||{};Gh(u);try{let h=Nh(u.graphOptimizationLevel??"all"),m=Uh(u.executionMode??"sequential"),o=typeof u.logId=="string"?Ke(u.logId,d):0,y=u.logSeverityLevel??2;if(!Number.isInteger(y)||y<0||y>4)throw new Error(`log serverity level is not valid: ${y}`);let $=u.logVerbosityLevel??0;if(!Number.isInteger($)||$<0||$>4)throw new Error(`log verbosity level is not valid: ${$}`);let A=typeof u.optimizedModelFilePath=="string"?Ke(u.optimizedModelFilePath,d):0;if(e=r._OrtCreateSessionOptions(h,!!u.enableCpuMemArena,!!u.enableMemPattern,m,!!u.enableProfiling,0,o,y,$,A),e===0&&We("Can't create session options."),u.executionProviders&&Vh(e,u.executionProviders,d),u.freeDimensionOverrides)for(let[T,O]of Object.entries(u.freeDimensionOverrides)){if(typeof T!="string")throw new Error(`free dimension override name must be a string: ${T}`);if(typeof O!="number"||!Number.isInteger(O)||O<0)throw new Error(`free dimension override value must be a non-negative integer: ${O}`);let R=Ke(T,d);r._OrtAddFreeDimensionOverride(e,R,O)!==0&&We(`Can't set a free dimension override: ${T} - ${O}.`)}return u.extra!==void 0&&fi(u.extra,"",new WeakSet,(T,O)=>{let R=Ke(T,d),j=Ke(O,d);r._OrtAddSessionConfigEntry(e,R,j)!==0&&We(`Can't set a session config entry: ${T} - ${O}.`)}),[e,d]}catch(h){throw e!==0&&r._OrtReleaseSessionOptions(e),d.forEach(m=>r._free(m)),h}}});var Vn,pi,hi,tn,mi,rn,Fn,Ye=ie(()=>{"use strict";Vn=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},pi=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},hi=t=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][t],tn=t=>{switch(t){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}},mi=t=>{switch(t){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${t}`)}},rn=t=>t==="float32"||t==="int32"||t==="int64"||t==="bool"||t==="float16"||t==="uint32",Fn=t=>{switch(t){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${t}`)}}});var Fh,Hh,Js,Zs,eu,Lh,Ne,Pt=ie(()=>{"use strict";Ye();Fh=["V","I","W","E","F"],Hh=(t,r)=>{console.log(`[${Fh[t]},${new Date().toISOString()}]${r}`)},eu=(t,r)=>{Js=t,Zs=r},Lh=(t,r)=>{let e=mi(t),d=mi(Js);e>=d&&Hh(e,typeof r=="function"?r():r)},Ne=(...t)=>{Zs&&Lh(...t)}});var tu,ru=ie(()=>{"use strict";Ye();tu=(t,r)=>new(tn(r))(t)});var iu=ie(()=>{"use strict"});var nn,qh,nu,Ln,Hn,au,ou=ie(()=>{"use strict";Pt();iu();nn=t=>Math.ceil(t/16)*16,qh=1,nu=()=>qh++,Ln=async(t,r,e,d)=>{let u=nn(e),h=t.device.createBuffer({size:u,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let m=t.getCommandEncoder();t.endComputePass(),m.copyBufferToBuffer(r,0,h,0,u),t.flush(),await h.mapAsync(GPUMapMode.READ);let o=h.getMappedRange();if(d){let y=d();return y.set(new Uint8Array(o,0,e)),y}else return new Uint8Array(o.slice(0,e))}finally{h.destroy()}},Hn=class{constructor(r){this.backend=r;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(r,e){let d=e.buffer,u=e.byteOffset,h=e.byteLength,m=nn(h),o=this.storageCache.get(r);if(!o)throw new Error("gpu data for uploading does not exist");if(o.originalSize!==h)throw new Error(`inconsistent data size. gpu data size=${o.originalSize}, data size=${h}`);let y=this.backend.device.createBuffer({mappedAtCreation:!0,size:m,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),$=y.getMappedRange();new Uint8Array($).set(new Uint8Array(d,u,h)),y.unmap();let A=this.backend.getCommandEncoder();this.backend.endComputePass(),A.copyBufferToBuffer(y,0,o.gpuData.buffer,0,m),Ne("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${r})`),this.buffersForUploadingPending.push(y)}memcpy(r,e){let d=this.storageCache.get(r);if(!d)throw new Error("source gpu data for memcpy does not exist");let u=this.storageCache.get(e);if(!u)throw new Error("destination gpu data for memcpy does not exist");if(d.originalSize!==u.originalSize)throw new Error("inconsistent source and destination gpu data size");let h=nn(d.originalSize),m=this.backend.getCommandEncoder();this.backend.endComputePass(),m.copyBufferToBuffer(d.gpuData.buffer,0,u.gpuData.buffer,0,h)}registerExternalBuffer(r,e,d){let u;if(d){if(u=this.externalBuffers.get(d),u===void 0)throw new Error("previous buffer is not registered");if(r===d)return Ne("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${u}, buffer is the same, skip.`),u;this.externalBuffers.delete(d)}else u=nu();return this.storageCache.set(u,{gpuData:{id:u,type:0,buffer:r},originalSize:e}),this.externalBuffers.set(r,u),Ne("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${u}, registered.`),u}unregisterExternalBuffer(r){let e=this.externalBuffers.get(r);e!==void 0&&(this.storageCache.delete(e),this.externalBuffers.delete(r),Ne("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${e}`))}create(r,e=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let d=nn(r),u,h=(e&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,m=(e&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(h||m){let y=h?this.freeBuffers:this.freeUniformBuffers,$=y.get(d);$||($=[],y.set(d,$)),$.length>0?u=$.pop():u=this.backend.device.createBuffer({size:d,usage:e})}else u=this.backend.device.createBuffer({size:d,usage:e});let o={id:nu(),type:0,buffer:u};return this.storageCache.set(o.id,{gpuData:o,originalSize:r}),Ne("verbose",()=>`[WebGPU] GpuDataManager.create(size=${r}) => id=${o.id}`),o}get(r){return this.storageCache.get(r)?.gpuData}release(r){let e=this.storageCache.get(r);if(!e)throw new Error("releasing data does not exist");return Ne("verbose",()=>`[WebGPU] GpuDataManager.release(id=${r}), gpuDataId=${e.gpuData.id}`),this.storageCache.delete(r),this.buffersPending.push(e.gpuData.buffer),e.originalSize}async download(r,e){let d=this.storageCache.get(r);if(!d)throw new Error("data does not exist");await Ln(this.backend,d.gpuData.buffer,d.originalSize,e)}refreshPendingBuffers(){for(let r of this.buffersForUploadingPending)r.destroy();this.buffersForUploadingPending=[];for(let r of this.buffersPending)(r.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(r.size).push(r):(r.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(r.size).push(r):r.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(r=>{r.forEach(e=>{e.destroy()})}),this.freeUniformBuffers.forEach(r=>{r.forEach(e=>{e.destroy()})}),this.storageCache.forEach(r=>{r.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},au=(...t)=>new Hn(...t)});var qn,ye,Fe=ie(()=>{"use strict";qn=class{constructor(r){Object.assign(this,r)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(r=>`${this[r]}`).join(";")),this._cacheKey}},ye=t=>new qn(t)});var Kn,St,Q,Jt,an,on,sn,Ie=ie(()=>{"use strict";Kn=class{static calcMatMulShape(r,e){return r[1]!==e[0]?void 0:[r[0],e[1]]}},St=class{static calcShape(r,e,d=!1){let u=r.length,h=e.length;if(u===0)return e;if(h===0)return r;let m=Math.max(r.length,e.length),o=new Array(m);if(d){if(u<2||h<2)return;let y=Kn.calcMatMulShape([r[u-2],r[u-1]],[e[h-2],e[h-1]]);if(y===void 0)return;[o[m-2],o[m-1]]=y}for(let y=d?3:1;y<=m;y++){let $=u-y<0?1:r[u-y],A=h-y<0?1:e[h-y];if($!==A&&$>1&&A>1)return;o[m-y]=Math.max($,A)}return o}static isValidBroadcast(r,e){let d=r.length,u=e.length;if(d>u)return!1;for(let h=1;h<=d;h++)if(r[d-h]!==1&&r[d-h]!==e[u-h])return!1;return!0}},Q=class t{static size(r){return t.getSizeFromDimensionRange(r,0,r.length)}static sizeFromDimension(r,e){if(e<0||e>r.length)throw new Error(`invalid dimension of ${e} for sizeFromDimension as Tensor has ${r.length} dimensions.`);return t.getSizeFromDimensionRange(r,e,r.length)}static sizeToDimension(r,e){if(e<0||e>r.length)throw new Error(`invalid dimension of ${e} for sizeToDimension as Tensor has ${r.length} dimensions.`);return t.getSizeFromDimensionRange(r,0,e)}static getSizeFromDimensionRange(r,e,d){let u=1;for(let h=e;h<d;h++){if(r[h]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");u*=r[h]}return u}static computeStrides(r){let e=r.length;if(e===0)return[];if(e===1)return[1];let d=new Array(e);d[e-1]=1,d[e-2]=r[e-1];for(let u=e-3;u>=0;--u)d[u]=d[u+1]*r[u+1];return d}static normalizeAxis(r,e){if(r<-e&&r>=e)throw new Error("unsupported axis for this operation.");return r<0?r+e:r}static normalizeAxes(r,e){return r.map(d=>this.normalizeAxis(d,e??r.length))}static sortBasedOnPerm(r,e){return e?e.map(d=>r[d]):r.slice().reverse()}static padShape(r,e){let d=r.length;return r.map((u,h)=>u+e[h]+e[h+d])}static areEqual(r,e){return r.length!==e.length?!1:r.every((d,u)=>d===e[u])}},Jt=class t{static adjustPoolAttributes(r,e,d,u,h,m){if(!r&&d.length!==e.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(r)for(let o=0;o<e.length-2;o++)o>=d.length?d.push(e[o+2]):d[o]=e[o+2];for(let o=0;o<d.length;o++)if(o<u.length){if(u[o]<0)throw new Error("strides should be greater than or equal to 1")}else u.push(1);for(let o=0;o<d.length;o++)if(o<h.length){if(h[o]<0)throw new Error("dilations should be greater than or equal to 1")}else h.push(1);for(let o=0;o<d.length*2;o++)if(o<m.length){if(m[o]<0)throw new Error("pad should be greater than or equal to 1")}else m.push(0);for(let o=0;o<d.length;o++){if(d[o]<=0)throw new Error("kernel shapes need to be greater than 0");if(m[o]>=d[o]||m[o+d.length]>=d[o])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(r,e,d,u,h,m,o){if(o){if(h.length!==2*(r.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(e.length!==r.length-2)throw new Error("length of strides should be the length of data dimensions");if(u.length!==r.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let y=0;y<r.length-2;y++)t.adjustPadAndReturnShape(r[y+(m?1:2)],e[y],d[y],u[y],h,y,y+r.length-2,o)}}static computePoolOutputShape(r,e,d,u,h,m,o){if(e.length<=0)throw new Error("input shape must be of size greater than 0");let y=[e[0],e[1]];return t.computeShapeHelper(r,e,y,d,u,h,m,o),y}static computeConvOutputShape(r,e,d,u,h,m,o){if(r.length<=0||e.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let y=[r[0],e[0]];return t.computeShapeHelper(!1,r,y,d,u,h,m,o),y}static computeShapeHelper(r,e,d,u,h,m,o,y){if(r)for(let $=0;$<e.length-2;$++)d.push(1);else for(let $=0;$<e.length-2;$++)d.push(t.adjustPadAndReturnShape(e[$+2],u[$],h[$],m[$],o,$,$+e.length-2,y))}static adjustPadAndReturnShape(r,e,d,u,h,m,o,y){let $=d*(u-1)+1;if(y&&y!=="NOTSET")switch(y){case"VALID":return h[m]=0,h[o]=0,Math.floor((r-$)/e+1);case"SAME_LOWER":case"SAME_UPPER":if(d!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let T=((r+e-1)/e-1)*e+u-r;return h[m]=Math.floor(y==="SAME_LOWER"?(T+1)/2:T/2),h[o]=T-h[m],Math.floor((r+T-u)/e+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((r+h[m]+h[o]-$)/e+1)}},an=class{static getShapeOfGemmResult(r,e,d,u,h){if(r.length!==2||d.length!==2)throw new Error("shape need to be of size 2");let m,o,y;e?(m=r[1],o=r[0]):(m=r[0],o=r[1]);let $=-1;if(u?(y=d[0],$=1):(y=d[1],$=0),d[$]!==o)throw new Error("dimension mismatch");if(m<=0||y<=0||o<=0)throw new Error("invalid shape specified");if(h&&!St.isValidBroadcast(h,[m,y]))throw new Error("gemm: invalid bias shape for broadcast");return[m,y,o]}},on=-34028234663852886e22,sn=34028234663852886e22});var Kh,su,He,Xn,Zt,yt,er,_r,uu,ne,fe,Yn,lu,Qn,Re=ie(()=>{"use strict";Ye();Ie();Kh=64,su=(t,r)=>{if(r===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(t){case 10:return r>1?`vec${r}<f16>`:"f16";case 1:return r>1?`vec${r}<f32>`:"f32";case 6:return r>1?`vec${r}<i32>`:"i32";case 12:return r>1?`vec${r}<u32>`:"u32";case 7:if(r>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(r>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(r!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${t}`)}},He=(t,r=1)=>{let e=su(t,r);return typeof e=="string"?e:e[0]},Xn=t=>[{type:"uint32",data:t},{type:"uint32",data:Q.computeStrides(t)}],Zt=t=>t%4===0?4:t%2===0?2:1,yt=(t="f32",r,e="0")=>!r||r===1?`${t}(${e})`:`vec${r}<${t}>(${e})`,er=(t,r,e)=>t==="f32"?e:r===1?`f32(${e})`:`vec${r}f(${e})`,_r=(t,r)=>r===4?`(${t}.x + ${t}.y + ${t}.z + ${t}.w)`:r===2?`(${t}.x + ${t}.y)`:r===3?`(${t}.x + ${t}.y + ${t}.z)`:t,uu=(t,r,e,d,u)=>{let h=typeof e=="number",m=h?e:e.length,o=[...new Array(m).keys()],y=m<2?"u32":m<=4?`vec${m}<u32>`:`array<u32, ${m}>`,$=su(r,u),A=typeof $=="string"?$:$[1],T=typeof $=="string"?$:$[0],O={indices:y,value:A,storage:T,tensor:r},R=ee=>typeof ee=="string"?ee:`${ee}u`,j={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},k=h?"uniforms.":"",P=`${k}${t}_shape`,D=`${k}${t}_strides`,F="";for(let ee=0;ee<m-1;ee++)F+=`
    let dim${ee} = current / ${D}[${ee}];
    let rest${ee} = current % ${D}[${ee}];
    indices[${ee}] = dim${ee};
    current = rest${ee};
    `;F+=`indices[${m-1}] = current;`;let Y=m<2?"":`
  fn o2i_${t}(offset: u32) -> ${O.indices} {
    var indices: ${O.indices};
    var current = offset;
    ${F}
    return indices;
  }`,L=ee=>(j.offsetToIndices=!0,m<2?ee:`o2i_${t}(${ee})`),X=[];if(m>=2)for(let ee=m-1;ee>=0;ee--)X.push(`${D}[${ee}] * (indices[${ee}])`);let I=m<2?"":`
  fn i2o_${t}(indices: ${O.indices}) -> u32 {
    return ${X.join("+")};
  }`,Z=ee=>(j.indicesToOffset=!0,m<2?ee:`i2o_${t}(${ee})`),re=(...ee)=>m===0?"0u":`${O.indices}(${ee.map(R).join(",")})`,ae=(ee,Ce)=>m<2?`${ee}`:`${ee}[${Ce}]`,$e=(ee,Ce,Oe)=>m<2?`${ee}=${Oe};`:`${ee}[${Ce}]=${Oe};`,q={},le=(ee,Ce)=>{j.broadcastedIndicesToOffset=!0;let Oe=`${Ce.name}broadcastedIndicesTo${t}Offset`;if(Oe in q)return`${Oe}(${ee})`;let tt=[];for(let it=m-1;it>=0;it--){let Ue=Ce.indicesGet("outputIndices",it+Ce.rank-m);tt.push(`${ae(D,it)} * (${Ue} % ${ae(P,it)})`)}return q[Oe]=`fn ${Oe}(outputIndices: ${Ce.type.indices}) -> u32 {
             return ${tt.length>0?tt.join("+"):"0u"};
           }`,`${Oe}(${ee})`},Pe=(ee,Ce)=>(()=>{if(O.storage===O.value)return`${t}[${ee}]=${Ce};`;if(O.storage==="vec2<u32>"&&O.value==="i32")return`${t}[${ee}]=vec2<u32>(u32(${Ce}), select(0u, 0xFFFFFFFFu, ${Ce} < 0));`;if(O.storage==="vec2<u32>"&&O.value==="u32")return`${t}[${ee}]=vec2<u32>(u32(${Ce}), 0u);`;if(O.storage==="u32"&&O.value==="vec4<bool>")return`${t}[${ee}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${Ce}));`;throw new Error(`not supported combination of storage type ${O.storage} and value type ${O.value} yet`)})(),ue=ee=>(()=>{if(O.storage===O.value)return`${t}[${ee}]`;if(O.storage==="vec2<u32>"&&O.value==="i32")return`i32(${t}[${ee}].x)`;if(O.storage==="vec2<u32>"&&O.value==="u32")return`u32(${t}[${ee}].x)`;if(O.storage==="u32"&&O.value==="vec4<bool>")return`vec4<bool>(bool(${t}[${ee}] & 0xFFu), bool(${t}[${ee}] & 0xFF00u), bool(${t}[${ee}] & 0xFF0000u), bool(${t}[${ee}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${O.storage} and value type ${O.value} yet`)})(),oe=m<2?"":`
  fn get_${t}ByIndices(indices: ${O.indices}) -> ${A} {
    return ${ue(`i2o_${t}(indices)`)};
  }`,et=m<2?"":(()=>{let ee=o.map(Oe=>`d${Oe}: u32`).join(", "),Ce=o.map(Oe=>`d${Oe}`).join(", ");return`
  fn get_${t}(${ee}) -> ${A} {
    return get_${t}ByIndices(${re(Ce)});
  }`})(),Ae=(...ee)=>{if(ee.length!==m)throw new Error(`indices length must be ${m}`);let Ce=ee.map(R).join(",");return m===0?ue("0u"):m===1?ue(Ce[0]):(j.get=!0,j.getByIndices=!0,j.indicesToOffset=!0,`get_${t}(${Ce})`)},Le=ee=>m<2?ue(ee):(j.getByIndices=!0,j.indicesToOffset=!0,`get_${t}ByIndices(${ee})`),Te=m<2?"":`
  fn set_${t}ByIndices(indices: ${O.indices}, value: ${A}) {
    ${Pe(`i2o_${t}(indices)`,"value")}
  }`,Xe=m<2?"":(()=>{let ee=o.map(Oe=>`d${Oe}: u32`).join(", "),Ce=o.map(Oe=>`d${Oe}`).join(", ");return`
  fn set_${t}(${ee}, value: ${A}) {
    set_${t}ByIndices(${re(Ce)}, value);
  }`})();return{impl:()=>{let ee=[];return h||(ee.push(`const ${P} = ${O.indices}(${e.join(",")});`),ee.push(`const ${D} = ${O.indices}(${Q.computeStrides(e).join(",")});`)),j.offsetToIndices&&ee.push(Y),j.indicesToOffset&&ee.push(I),j.broadcastedIndicesToOffset&&Object.values(q).forEach(Ce=>ee.push(Ce)),j.set&&ee.push(Xe),j.setByIndices&&ee.push(Te),j.get&&ee.push(et),j.getByIndices&&ee.push(oe),ee.join(`
`)},type:O,offsetToIndices:L,indicesToOffset:Z,broadcastedIndicesToOffset:le,indices:re,indicesGet:ae,indicesSet:$e,set:(...ee)=>{if(ee.length!==m+1)throw new Error(`indices length must be ${m}`);let Ce=ee[m];if(typeof Ce!="string")throw new Error("value must be string");let Oe=ee.slice(0,m).map(R).join(",");return m===0?Pe("0u",Ce):m===1?Pe(Oe[0],Ce):(j.set=!0,j.setByIndices=!0,j.indicesToOffset=!0,`set_${t}(${Oe}, ${Ce})`)},setByOffset:Pe,setByIndices:(ee,Ce)=>m<2?Pe(ee,Ce):(j.setByIndices=!0,j.indicesToOffset=!0,`set_${t}ByIndices(${ee}, ${Ce});`),get:Ae,getByOffset:ue,getByIndices:Le,usage:d?"input":"output",name:t,strides:D,shape:P,rank:m}},ne=(t,r,e,d=1)=>uu(t,r,e,!0,d),fe=(t,r,e,d=1)=>uu(t,r,e,!1,d),Yn=class{constructor(r){this.normalizedDispatchGroup=r;this.indicesHelpers=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(r){return`if (global_idx >= ${typeof r=="number"?`${r}u`:r}) { return; }`}mainStart(r=Kh){let e=typeof r=="number"?r:r[0],d=typeof r=="number"?1:r[1],u=typeof r=="number"?1:r[2],h=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,m=h?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>`,o=h?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +
          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${e*d*u}u + local_index;`;return`@compute @workgroup_size(${e}, ${d}, ${u})
  fn main(${m}) {
    ${o}
  `}declareVariable(r,e){this.indicesHelpers.push(r),r.shape.startsWith("uniforms.")&&this.uniforms.push({name:r.shape.replace("uniforms.",""),type:r.type.indices}),r.strides.startsWith("uniforms.")&&this.uniforms.push({name:r.strides.replace("uniforms.",""),type:r.type.indices});let d=r.usage==="input"?"read":"read_write",u=r.type.storage;return`@group(0) @binding(${e}) var<storage, ${d}> ${r.name}: array<${u}>;`}declareVariables(...r){return r.map(e=>this.declareVariable(e,this.variableIndex++)).join(`
`)}registerUniform(r,e){return this.uniforms.push({name:r,type:e}),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let r=[];for(let{name:e,type:d}of this.uniforms)r.push(`${e}:${d}`);return`
      struct Uniforms { ${r.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.indicesHelpers.map(r=>r.impl()).join(`
`)}},lu=t=>new Yn(t),Qn=(t,r)=>{let e=t.length,d=[];for(let u=0;u<e;u++){let h=e-1-u,m=t[h]||1;(r[r.length-1-u]||1)>1&&m===1&&d.unshift(h)}return d}});var It,Yh,un,Xh,At,du,cu,fu,pu,hu,mu,gu,yu,vu,bu,vt,Jn=ie(()=>{"use strict";Ie();Fe();Re();It=t=>{if(!t||t.length===0||t.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(t.length===2&&t[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Yh=t=>["","",`var value = ${t.getByOffset("inputOffset")};`,""],un=(t,r,e,d,u,h,m=!1,o=!1)=>{let y=[],$=e[0].dims,A=Q.normalizeAxes(u,e[0].dims.length),T=!o&&A.length===0;$.forEach((Z,re)=>{T||A.indexOf(re)>=0?m&&y.push(1):y.push(Z)});let O=[],R=ne("_A",e[0].dataType,$),j=fe("output",h,y),k=d(R,j,A),P=`inputOffset = ${R.indicesToOffset("inputIndices")};`,D=`let ${P};`,F=`var ${P};`,Y=k[1]===""?"":F,L=(k[1]===""?D:P)+`
`+k[2];for(let Z=0,re=0;Z<e[0].dims.length;Z++)T||A.indexOf(Z)>=0?(m&&re++,L=`for(var j${Z}: u32 = 0; j${Z} < ${e[0].dims[Z]}; j${Z}++) {
                ${k[2].includes("lastIndex")?`let lastIndex = j${Z};`:""}
                ${R.indicesSet("inputIndices",Z,`j${Z}`)}
                ${L}
              }`):(O.push(`${R.indicesSet("inputIndices",Z,j.indicesGet("outputIndices",re))};`),re++);let X=Q.size(y);return{name:t,shaderCache:r,getShaderSource:Z=>`
        ${Z.declareVariables(R,j)}

        ${Z.mainStart()}
          ${Z.guardAgainstOutOfBoundsWorkgroupSizes(X)}
          var inputIndices: ${R.type.indices};
          let outputIndices = ${j.offsetToIndices("global_idx")};

          ${O.join(`
`)}
          ${k[0]}       // init ops for reduce max/min
          ${Y}
          ${k[1]}
          ${L}
          ${k[3]}
          ${k.length===4?j.setByOffset("global_idx","value"):k.slice(4).join(`
`)}
        }`,getRunData:()=>({outputs:[{dims:y,dataType:h}],dispatchGroup:{x:Math.ceil(X/64)}})}},Xh=(t,r)=>{let e=[];return t[1].dims[0]>0&&t[1].getBigInt64Array().forEach(d=>e.push(Number(d))),ye({axes:e,keepDims:r.keepDims,noopWithEmptyAxes:r.noopWithEmptyAxes})},At=(t,r,e,d)=>{let u=t.inputs,h=u.length===1?e:Xh(u,e);t.compute(un(r,{hint:h.cacheKey},[u[0]],h.noopWithEmptyAxes&&h.axes.length===0?Yh:d,h.axes,u[0].dataType,h.keepDims,h.noopWithEmptyAxes),{inputs:[0]})},du=(t,r)=>{It(t.inputs),At(t,"ReduceLogSum",r,(d,u)=>[`var value = ${u.type.storage}(0);`,"",`value += ${d.getByOffset("inputOffset")};`,"value = log(value);"])},cu=(t,r)=>{It(t.inputs),At(t,"ReduceL1",r,(d,u)=>[`var value = ${u.type.storage}(0);`,"",`value += abs(${d.getByOffset("inputOffset")});`,""])},fu=(t,r)=>{It(t.inputs),At(t,"ReduceL2",r,(d,u)=>[`var t = ${u.type.value}(0); var value = ${u.type.value}(0);`,"",`t = ${d.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])},pu=(t,r)=>{It(t.inputs),At(t,"ReduceLogSumExp",r,(d,u)=>[`var value = ${u.type.storage}(0);`,"",`value += exp(${d.getByOffset("inputOffset")});`,"value = log(value);"])},hu=(t,r)=>{It(t.inputs),At(t,"ReduceMax",r,(d,u,h)=>{let m=[];for(let o=0;o<d.rank;o++)(h.indexOf(o)>=0||h.length===0)&&m.push(d.indicesSet("inputIndices",o,0));return[`${m.join(`
`)}`,`var value = ${d.getByOffset("inputOffset")};`,`value = max(value, ${d.getByOffset("inputOffset")});`,""]})},mu=(t,r)=>{It(t.inputs),At(t,"ReduceMean",r,(d,u,h)=>{let m=1;for(let o=0;o<d.rank;o++)(h.indexOf(o)>=0||h.length===0)&&(m*=t.inputs[0].dims[o]);return["var sum = f32(0);","",`sum += f32(${d.getByOffset("inputOffset")});`,`let value = ${u.type.value}(sum / ${m});`]})},gu=(t,r)=>{It(t.inputs),At(t,"ReduceMin",r,(d,u,h)=>{let m=[];for(let o=0;o<d.rank;o++)(h.indexOf(o)>=0||h.length===0)&&m.push(`inputIndices[${o}] = 0;`);return[`${m.join(`
`)}`,`var value = ${d.getByOffset("inputOffset")};`,`value = min(value, ${d.getByOffset("inputOffset")});`,""]})},yu=(t,r)=>{It(t.inputs),At(t,"ReduceProd",r,(d,u)=>[`var value = ${u.type.storage}(1);`,"",`value *= ${d.getByOffset("inputOffset")};`,""])},vu=(t,r)=>{It(t.inputs),At(t,"ReduceSum",r,(d,u)=>[`var value = ${u.type.storage}(0);`,"",`value += ${d.getByOffset("inputOffset")};`,""])},bu=(t,r)=>{It(t.inputs),At(t,"ReduceSumSquare",r,(d,u)=>[`var t = ${u.type.value}(0); var value = ${u.type.value}(0);`,"",`t = ${d.getByOffset("inputOffset")}; value += t * t;`,""])},vt=t=>ye(t)});var wu,$u,Cu,_u,Zn,xu=ie(()=>{"use strict";Ye();Fe();Jn();wu=t=>{if(!t||t.length===0||t.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(t[0].dataType!==1)throw new Error("Invalid input type.")},$u=(t,r)=>ye({axis:r.axis,keepDims:r.keepDims,selectLastIndex:r.selectLastIndex}),Cu=(t,r)=>{wu(t.inputs);let e=(u,h,m)=>{let o=[];for(let y=0;y<u.rank;y++)(m.indexOf(y)>=0||m.length===0)&&o.push(`inputIndices[${y}] = 0;`);return[`${o.join(`
`)}`,`var value = ${u.getByOffset("inputOffset")};
var bestIndex : i32 = 0;`,`if (${u.getByOffset("inputOffset")} ${r.selectLastIndex>0?"<=":"<"} value) {
         value = ${u.getByOffset("inputOffset")};
         bestIndex = i32(lastIndex);
       }`,"",h.setByOffset("global_idx","bestIndex")]},d=t.inputs.length===1?r:$u(t.inputs,r);t.compute(un("ArgMin",{hint:d.cacheKey},[t.inputs[0]],e,[d.axis],7,d.keepDims),{inputs:[0]})},_u=(t,r)=>{wu(t.inputs);let e=(u,h,m)=>{let o=[];for(let y=0;y<u.rank;y++)(m.indexOf(y)>=0||m.length===0)&&o.push(`inputIndices[${y}] = 0;`);return[`${o.join(`
`)}`,`var value = ${u.getByOffset("inputOffset")};
var bestIndex : i32 = 0;`,`if (${u.getByOffset("inputOffset")} ${r.selectLastIndex>0?">=":">"} value) {
         value = ${u.getByOffset("inputOffset")};
         bestIndex = i32(lastIndex);
       }`,"",h.setByOffset("global_idx","bestIndex")]},d=t.inputs.length===1?r:$u(t.inputs,r);t.compute(un("argMax",{hint:d.cacheKey},[t.inputs[0]],e,[d.axis],7,d.keepDims),{inputs:[0]})},Zn=t=>ye(t)});var Qh,Jh,Su,Iu=ie(()=>{"use strict";Ie();Re();Qh=t=>{if(t[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(t[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(t[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(t[0].dims[2]!==t[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Jh=t=>{let r=t[0].dims,e=t[0].dims[2],d=Q.size(r)/4,u=t[0].dataType,h=ne("input",u,r,4),m=ne("bias",u,[e],4),o=ne("residual",u,r,4),y=fe("output",u,r,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:r,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)}}),getShaderSource:A=>`
  const channels = ${e}u / 4;
  ${A.declareVariables(h,m,o,y)}

  ${A.mainStart()}
    ${A.guardAgainstOutOfBoundsWorkgroupSizes(d)}
    let value = ${h.getByOffset("global_idx")}
      + ${m.getByOffset("global_idx % channels")} + ${o.getByOffset("global_idx")};
    ${y.setByOffset("global_idx","value")}
  }`}},Su=t=>{Qh(t.inputs),t.compute(Jh(t.inputs))}});var Zh,ke,Au,Eu,Ou,Tu,Ru,ku,ju,Pu,Bu,ea,em,Mu,Du,zu,Wu,ln,Nu,dn,Uu,Gu,Vu,Fu,Hu,Lu,qu,Ku,Yu,Xu,Qu,Ju,Zu,el,tl,rl,il,ta=ie(()=>{"use strict";Ye();Ie();Fe();Re();Zh=(t,r,e,d,u,h)=>{let m=Math.ceil(r/4),o="";typeof u=="string"?o=`${u}(a)`:o=u("a");let y=ne("inputData",e,[m],4),$=fe("outputData",d,[m],4);return`
  ${t.declareVariables(y,$)}

  ${h??""}

  ${t.mainStart()}
    ${t.guardAgainstOutOfBoundsWorkgroupSizes(m)}

    let a = ${y.getByOffset("global_idx")};
    ${$.setByOffset("global_idx",o)}
  }`},ke=(t,r,e,d,u,h=t.dataType)=>({name:r,shaderCache:{hint:u},getShaderSource:m=>Zh(m,Q.size(t.dims),t.dataType,h,e,d),getRunData:m=>({outputs:[{dims:t.dims,dataType:h}],dispatchGroup:{x:Math.ceil(Q.size(m[0].dims)/64/4)}})}),Au=t=>{t.compute(ke(t.inputs[0],"Abs","abs"))},Eu=t=>{t.compute(ke(t.inputs[0],"Acos","acos"))},Ou=t=>{t.compute(ke(t.inputs[0],"Acosh","acosh"))},Tu=t=>{t.compute(ke(t.inputs[0],"Asin","asin"))},Ru=t=>{t.compute(ke(t.inputs[0],"Asinh","asinh"))},ku=t=>{t.compute(ke(t.inputs[0],"Atan","atan"))},ju=t=>{t.compute(ke(t.inputs[0],"Atanh","atanh"))},Pu=t=>ye(t),Bu=(t,r)=>{let e;switch(r.to){case 10:e="vec4<f16>";break;case 1:e="vec4<f32>";break;case 12:e="vec4<u32>";break;case 6:e="vec4<i32>";break;case 9:e="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${r.to}`)}t.compute(ke(t.inputs[0],"Cast",e,void 0,r.cacheKey,r.to))},ea=(t,r)=>{let e=He(t.inputs[0].dataType);t.compute(ke(t.inputs[0],"Clip",d=>`clamp(${d}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<${e}> = vec4(${e}(${r.min}));
    const clip_max_: vec4<${e}> = vec4(${e}(${r.max}));
`,r.cacheKey),{inputs:[0]})},em=t=>{let r=t.length>=2?t[1].getFloat32Array()[0]:on,e=t.length>=3?t[2].getFloat32Array()[0]:sn;return ye({min:r,max:e})},Mu=t=>{let r=em(t.inputs);ea(t,r)},Du=t=>{t.compute(ke(t.inputs[0],"Ceil","ceil"))},zu=t=>{t.compute(ke(t.inputs[0],"Cos","cos"))},Wu=t=>{t.compute(ke(t.inputs[0],"Cosh","cosh"))},ln=t=>ye(t),Nu=(t,r)=>{t.compute(ke(t.inputs[0],"Elu",e=>`elu_vf32(${e})`,`
  const elu_alpha_: f32 = f32(${r.alpha});

  fn elu_f32(a: f32) -> f32 {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,r.cacheKey))},dn=(t,r="f32")=>`
const r0: ${r} = 0.3275911;
const r1: ${r} = 0.254829592;
const r2: ${r} = -0.284496736;
const r3: ${r} = 1.421413741;
const r4: ${r} = -1.453152027;
const r5: ${r} = 1.061405429;

fn erf_vf32(v: ${t}) -> ${t} {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,Uu=t=>{let r=He(t.inputs[0].dataType);t.compute(ke(t.inputs[0],"Erf",e=>`erf_vf32(${e})`,dn(`vec4<${r}>`,r)))},Gu=t=>{t.compute(ke(t.inputs[0],"Exp","exp"))},Vu=t=>{t.compute(ke(t.inputs[0],"Floor","floor"))},Fu=t=>{let r=He(t.inputs[0].dataType);t.compute(ke(t.inputs[0],"Gelu",e=>`0.5 * ${e} * (1.0 + erf_vf32(${e} * 0.7071067811865475))`,dn(`vec4<${r}>`,r)))},Hu=(t,r)=>{t.compute(ke(t.inputs[0],"LeakyRelu",e=>`select(leaky_relu_alpha_ * ${e}, ${e}, ${e} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${r.alpha});`,r.cacheKey))},Lu=t=>{t.compute(ke(t.inputs[0],"Not",r=>`!${r}`))},qu=t=>{t.compute(ke(t.inputs[0],"Neg",r=>`-${r}`))},Ku=t=>{t.compute(ke(t.inputs[0],"Reciprocal",r=>`1.0/${r}`))},Yu=t=>{t.compute(ke(t.inputs[0],"Relu",r=>`select(vec4<f32>(0.0), ${r}, ${r} > vec4<f32>(0.0))`))},Xu=t=>{t.compute(ke(t.inputs[0],"Sigmoid",r=>`(1.0 / (1.0 + exp(-${r})))`))},Qu=t=>{t.compute(ke(t.inputs[0],"Sin","sin"))},Ju=t=>{t.compute(ke(t.inputs[0],"Sinh","sinh"))},Zu=t=>{t.compute(ke(t.inputs[0],"Sqrt","sqrt"))},el=t=>{t.compute(ke(t.inputs[0],"Tan","tan"))},tl=t=>{t.compute(ke(t.inputs[0],"Tanh","tanh"))},rl=(t,r)=>(t.compute(ke(t.inputs[0],"ThresholdedRelu",e=>`select(vec4<f32>(0.0), ${e}, ${e} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${r.alpha});`,r.cacheKey)),0),il=t=>{t.compute(ke(t.inputs[0],"Log","log"))}});var rm,im,nl,al=ie(()=>{"use strict";Ie();Re();ta();rm=t=>{if(t[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(t[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(t[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(t[0].dims[2]!==t[1].dims[0])throw new Error("last dimension of input and bias are not the same")},im=t=>{let r=t[0].dims.slice();r[2]=r[2]/2;let e=ne("input",t[0].dataType,t[0].dims,4),d=ne("bias",t[0].dataType,[t[0].dims[2]],4),u=fe("output",t[0].dataType,r,4),h=Q.size(r)/4;return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:r,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)}}),getShaderSource:o=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${t[0].dims[2]/4/2}u;

  ${o.declareVariables(e,d,u)}

  ${dn("vec4f")}

  ${o.mainStart()}
    ${o.guardAgainstOutOfBoundsWorkgroupSizes(h)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${u.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},nl=t=>{rm(t.inputs),t.compute(im(t.inputs))}});var nm,am,Et,ol,sl,ul,ll,dl,cl,fl,pl,hl,ml,gl=ie(()=>{"use strict";Ye();Ie();Re();nm=(t,r,e,d,u,h,m,o,y,$,A)=>{let T=Q.size(d),O=Math.ceil(T/4),R,j;typeof m=="string"?R=j=(L,X)=>`${m}((${L}),(${X}))`:typeof m=="function"?R=j=m:(R=m.scalar,j=m.vector);let k="",P=fe("outputData",$,d,4),D=ne("aData",o,r,4),F=ne("bData",y,e,4);if(h){let L=X=>{let I=Q.computeStrides(X),Z=[];for(let re=X.length-1;re>=0;re--){let ae=P.indicesGet("outputIndices",re+d.length-X.length);Z.push(`${I[re]}u * (${ae} % ${X[re]}u)`)}return Z.length>0?Z.join("+"):"0u"};k=`
          fn calcOffsetA(outputIndices: ${P.type.indices}) -> u32 {
            return ${L(r)};
          }

          fn calcOffsetB(outputIndices: ${P.type.indices}) -> u32 {
            return ${L(e)};
          }
        `}let Y;if(u)if(h){let L=Q.size(r)===1,X=Q.size(e)===1;L||X?Y=P.setByOffset("global_idx",j(L?`${D.type.value}(${D.getByOffset("0")}.x)`:D.getByOffset("global_idx"),X?`${F.type.value}(${F.getByOffset("0")}.x)`:F.getByOffset("global_idx"))):Y=`
            let outputIndices = ${P.offsetToIndices("global_idx * 4u")};
            let offsetA = calcOffsetA(outputIndices);
            let offsetB = calcOffsetB(outputIndices);
            ${P.setByOffset("global_idx",j(D.getByOffset("offsetA / 4u"),F.getByOffset("offsetB / 4u")))}
          `}else Y=P.setByOffset("global_idx",j(D.getByOffset("global_idx"),F.getByOffset("global_idx")));else{if(!h)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let L=(X,I,Z="")=>{let re=`aData[indexA${I}][componentA${I}]`,ae=`bData[indexB${I}][componentB${I}]`;return`
            let outputIndices${I} = ${P.offsetToIndices(`global_idx * 4u + ${I}u`)};
            let offsetA${I} = calcOffsetA(outputIndices${I});
            let offsetB${I} = calcOffsetB(outputIndices${I});
            let indexA${I} = offsetA${I} / 4u;
            let indexB${I} = offsetB${I} / 4u;
            let componentA${I} = offsetA${I} % 4u;
            let componentB${I} = offsetB${I} % 4u;
            ${X}[${I}] = ${Z}(${R(re,ae)});
          `};$===9?Y=`
            var data = vec4<u32>(0);
            ${L("data",0,"u32")}
            ${L("data",1,"u32")}
            ${L("data",2,"u32")}
            ${L("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:Y=`
            ${L("outputData[global_idx]",0)}
            ${L("outputData[global_idx]",1)}
            ${L("outputData[global_idx]",2)}
            ${L("outputData[global_idx]",3)}
          `}return`
        ${t.declareVariables(D,F,P)}

        ${A??""}
        ${k}

        ${t.mainStart()}
        ${t.guardAgainstOutOfBoundsWorkgroupSizes(O)}
        ${Y}
      }`},am=(t,r,e,d,u,h,m=e.dataType)=>{let o=!Q.areEqual(e.dims,d.dims),y=e.dims,$=Q.size(e.dims),A=!1;if(o){let T=St.calcShape(e.dims,d.dims,!1);if(!T)throw new Error("Can't perform binary op on the given tensors");y=T,$=Q.size(y);let O=Q.size(e.dims)===1,R=Q.size(d.dims)===1,j=1;for(let k=1;k<y.length;k++){let P=e.dims[e.dims.length-k]??1,D=d.dims[d.dims.length-k]??1;if(P===D)j*=P;else break}(j%4===0||O||R)&&(A=!0)}else A=!0;return{name:t,shaderCache:{hint:r},getShaderSource:T=>nm(T,e.dims,d.dims,y,A,o,u,e.dataType,d.dataType,m,h),getRunData:()=>({outputs:[{dims:y,dataType:m}],dispatchGroup:{x:Math.ceil($/64/4)}})}},Et=(t,r,e,d,u,h)=>{t.compute(am(r,u??"",t.inputs[0],t.inputs[1],e,d,h))},ol=t=>{Et(t,"Add",(r,e)=>`${r}+${e}`)},sl=t=>{Et(t,"Div",(r,e)=>`${r}/${e}`)},ul=t=>{Et(t,"Equal",{scalar:(r,e)=>`u32(${r}==${e})`,vector:(r,e)=>`vec4<u32>(${r}==${e})`},void 0,void 0,9)},ll=t=>{Et(t,"Mul",(r,e)=>`${r}*${e}`)},dl=t=>{let r=ne("input",t.inputs[0].dataType,t.inputs[0].dims).type.value;Et(t,"Pow",{scalar:(d,u)=>`pow_custom(${d},${u})`,vector:(d,u)=>`pow_vector_custom(${d},${u})`},`
    fn pow_custom(a : ${r}, b : ${r}) -> ${r} {
      if (b == ${r}(0.0)) {
        return ${r}(1.0);
      } else if (a < ${r}(0.0) && f32(b) != floor(f32(b))) {
        return ${r}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${r}(1.0), round(f32(abs(b) % ${r}(2.0))) != 1.0) * ${r}(${r==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${r}>, b : vec4<${r}>) -> vec4<${r}> {
      // TODO: implement vectorized pow
      return vec4<${r}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},cl=t=>{Et(t,"Sub",(r,e)=>`${r}-${e}`)},fl=t=>{Et(t,"Greater",{scalar:(r,e)=>`u32(${r}>${e})`,vector:(r,e)=>`vec4<u32>(${r}>${e})`},void 0,void 0,9)},pl=t=>{Et(t,"Less",{scalar:(r,e)=>`u32(${r}<${e})`,vector:(r,e)=>`vec4<u32>(${r}<${e})`},void 0,void 0,9)},hl=t=>{Et(t,"GreaterOrEqual",{scalar:(r,e)=>`u32(${r}>=${e})`,vector:(r,e)=>`vec4<u32>(${r}>=${e})`},void 0,void 0,9)},ml=t=>{Et(t,"LessOrEqual",{scalar:(r,e)=>`u32(${r}<=${e})`,vector:(r,e)=>`vec4<u32>(${r}<=${e})`},void 0,void 0,9)}});var sm,um,lm,dm,yl,vl,bl=ie(()=>{"use strict";Ie();Fe();Re();sm=t=>{if(!t||t.length<1)throw new Error("too few inputs");let r=t[0].dataType,e=t[0].dims.length;for(let d of t){if(d.dataType!==r)throw new Error("input tensors should be one type");if(d.dims.length!==e)throw new Error("input tensors should have the same shape")}},um=t=>`
  fn calculateInputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${t}u; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${t}u;
  }`,lm=(t,r)=>{let e=t.length,d=[];for(let u=0;u<e;++u){let h=r.setByOffset("global_idx",t[u].getByIndices("indices"));e===1?d.push(h):u===0?d.push(`if (inputIndex == ${u}u) { ${h} }`):u===e-1?d.push(`else { ${h} }`):d.push(`else if (inputIndex == ${u}) { ${h} }`)}return d.join(`
`)},dm=(t,r)=>{let e=t[0].dims.slice();if(r>=e.length||r<-1*e.length)throw new Error("axis specified for concat doesn't match input dimensionality");let d=r<0?e.length+r:r,u=e.slice(0);for(let R=1;R<t.length;R++){let j=t[R].dims.slice();for(let k=0;k<e.length;k++)if(k===d)u[d]+=j[k];else if(e[k]!==j[k])throw new Error("non concat dimensions must match")}let h=Q.size(u),m=new Array(t.length),o=new Array(t.length),y=t[0].dataType,$=0;for(let R=0;R<t.length;++R)$+=t[R].dims[d],m[R]=$,o[R]=ne(`input${R}`,y,t[R].dims);let A=fe("output",y,u),T=A.indicesGet("indices",d),O=R=>`
  ${R.declareVariables(...o,A)}

  const sizeInConcatAxis = array<u32, ${m.length}>(${m.map(j=>`${j}u`).join(",")});
  ${um(m.length)}

  ${R.mainStart()}
    ${R.guardAgainstOutOfBoundsWorkgroupSizes(h)}

    var indices = ${A.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${T});
    if (inputIndex != 0u) {
      ${T} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${lm(o,A)}
  }`;return{name:"Concat",shaderCache:{hint:`${r}`},getRunData:()=>({outputs:[{dims:u,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)}}),getShaderSource:O}},yl=(t,r)=>{sm(t.inputs),t.compute(dm(t.inputs,r.axis))},vl=t=>ye({axis:t.axis})});var Je,cn,fn,pn=ie(()=>{"use strict";Je=(t,r)=>{switch(t){case 1:return r;case 2:return`vec2<${r}>`;case 3:return`vec3<${r}>`;case 4:return`vec4<${r}>`;default:throw new Error(`${t}-component is not supported.`)}},cn=(t,r=!1,e=!1,d=3)=>"",fn=(t,r)=>`
      ${t?"value = value + getBiasByOutputCoords(coords);":""}
      ${r?"value = activation(value, coords);":""}
      `});var hn,ra=ie(()=>{"use strict";hn=`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));
}
`});var mn,gn,gi=ie(()=>{"use strict";Ie();mn=t=>{switch(t.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${t.clipMin});const clip_max_=f32(${t.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},gn=t=>{let r=t?.activation||"";if(r==="Clip"){let[e,d]=t?.activation_params||[on,sn];return{activation:r,clipMax:d,clipMin:e,activationCacheKey:`${r}:${e},${d}`}}return{activation:r,activationCacheKey:r}}});var cm,fm,yi,wl,pm,vi,hm,yn,bi=ie(()=>{"use strict";Ie();Re();gi();pn();cm=(t,r)=>t?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${r?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${r?", batchIndices":""});
        `,fm=(t,r)=>t?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${r===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${r===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${r===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,yi=(t,r,e="f32",d,u=!1,h=32,m=!1,o=32)=>{let y=r[1]*t[1],$=r[0]*t[0],A=u?y:h,T=u?h:y,O=A/r[0],R=h/r[1];if(!((u&&O===4&&t[1]===4||!u&&(O===3||O===4))&&A%r[0]===0&&h%r[1]===0&&t[0]===4))throw new Error(`If transposeA ${u} is true, innerElementSize ${O} and workPerThread[1] ${t[1]} must be 4.
      Otherwise, innerElementSize ${O} must be 3 or 4.
  tileAWidth ${A} must be divisible by workgroupSize[0]${r[0]}. tileInner ${h} must be divisible by workgroupSize[1] ${r[1]}. colPerThread ${t[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${O}<${e}>, ${A/O}>, ${T}>;
var<workgroup> mm_Bsub: array<array<vec4<${e}>, ${$/t[0]}>, ${h}>;

const rowPerThread = ${t[1]};
const colPerThread = ${t[0]};
const innerElementSize = ${O};
const tileInner = ${h};

@compute @workgroup_size(${r[0]}, ${r[1]}, ${r[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${m?"0":"i32(globalId.z)"};
  ${d?`let batchIndices = ${d.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${y};

  let numTiles = ${m?`${Math.ceil(o/h)}`:"(dimInner - 1) / tileInner + 1"};
  var kStart = ${m?`i32(globalId.z) * ${o}`:"0"};

  var acc: array<vec4<${e}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${R};
  for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${cm(u,d)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${R}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${d?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${O===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${fm(u,O)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},wl=(t,r)=>t?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${r?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${r?", batchIndices":""});
            `,pm=t=>t?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",vi=(t,r,e="f32",d,u=!1,h=32,m=!1,o=32,y=!1)=>{let $=t[1]*r[1],A=t[0]*r[0],T=u?$:h,O=u?h:$;if(!(O%r[1]===0&&T%r[0]===0&&h%r[1]===0))throw new Error(`tileAHight ${O} must be divisible by workgroupSize[1]${r[1]}, tileAWidth ${T} must be divisible by workgroupSize[0]${r[0]}, tileInner ${h} must be divisible by workgroupSize[1]${r[1]}`);let R=O/r[1],j=T/r[0],k=h/r[1],P=y?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${$};
    let globalColStart = i32(workgroupId.x) * ${A};

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${O}; inputRow = inputRow + ${r[1]}) {
        for (var inputCol = localCol; inputCol < ${T}; inputCol = inputCol + ${r[0]}) {
          ${wl(u,d)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${r[1]}) {
            for (var inputCol = localCol; inputCol < ${A}; inputCol = inputCol + ${r[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${d?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${e}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${r[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${u?`mm_Asub[k][localRow + innerRow * ${r[1]}];`:`mm_Asub[localRow + innerRow * ${r[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${r[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${r[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${$};

let tileRowA = i32(localId.y) * ${R};
let tileColA = i32(localId.x) * ${j};
let tileRowB = i32(localId.y) * ${k};
// Loop over shared dimension.
for (var t = 0; t < numTiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${R}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${j}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${wl(u,d)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${k}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${d?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${e}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${pm(u)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${e}, ${T}>, ${O}>;
  var<workgroup> mm_Bsub : array<array<${e}, ${A}>, ${h}>;
  const rowPerThread = ${t[1]};
  const colPerThread = ${t[0]};
  const tileInner = ${h};

@compute @workgroup_size(${r[0]}, ${r[1]}, ${r[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${m?"0":"i32(globalId.z)"};
    ${d?`let batchIndices = ${d.offsetToIndices("u32(batch)")};`:""}
    let numTiles = ${m?`${Math.ceil(o/h)}`:"(dimInner - 1) / tileInner + 1"};
    var kStart = ${m?`i32(globalId.z) * ${o}`:"0"};

    var acc : array<array<${e}, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${P}
  }
`},hm=(t,r,e,d,u,h=!1)=>{let m=u[0],o=u[1],y=u[2],$=d[0],A=d[1],T=d[2],O=d[3],R=Qn(m,y),j=Qn(o,y),k=He(d[0].type.tensor),P=()=>{let Y=A.rank,L=$.rank,X=`var aIndices: ${A.type.indices};`;for(let I=Y-2-1,Z=L-1;I>=0;I--,Z--)X+=`
aIndices[${I}] = ${L>1?`batchIndices[${Z}]`:"batchIndices"};`;return R.forEach(I=>{X+=`
aIndices[${I}] = 0;`}),X+=`
aIndices[${Y-2}] = u32(row);
                   aIndices[${Y-1}] = u32(colIn);`,X},D=()=>{let Y=T.rank,L=$.rank,X=`var bIndices: ${T.type.indices};`;for(let I=Y-2-1,Z=L-1;I>=0;I--,Z--)X+=`
bIndices[${I}] = ${L>1?`batchIndices[${Z}]`:"batchIndices"};`;return j.forEach(I=>{X+=`
bIndices[${I}] = 0;`}),X+=`
bIndices[${Y-2}] = u32(row);
                   bIndices[${Y-1}] = u32(colIn);`,X};return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${$.type.indices}) -> ${Je(t,k)} {
      var value = ${Je(t,k)}(0.0);
      let col = colIn * ${t};
      if(row < dimAOuter && col < dimInner)
      {
        ${P()}
        value = ${A.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${$.type.indices}) -> ${Je(t,k)} {
      var value = ${Je(t,k)}(0.0);
      let col = colIn * ${t};
      if(row < dimInner && col < dimBOuter)
      {
        ${D()}
        value = ${T.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Je(t,k)}) {
      let col = colIn * ${t};
      if (row < dimAOuter && col < dimBOuter) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${r?`value = value + ${h?"bias[colIn]":`${Je(t,k)}(bias[row])`};`:""}
        ${e}
        ${O.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},yn=(t,r,e,d,u=!1)=>{let h=t[0].dims,m=t[1].dims,o=h.slice(0,-2),y=m.slice(0,-2),$=d?d.slice(0,-2):e.slice(0,-2),A=ne("batchDims",t[0].dataType,$),T=[A],O=[o,y,$],R=Q.size($),j=h[h.length-2],k=h[h.length-1],P=m[m.length-1],D=k%4===0&&P%4===0,{activationFunction:F,applyActivation:Y}=mn(r),L=j<=8?[4,1,1]:[4,4,1],X=[8,8,1],I=[Math.ceil(P/X[0]/L[0]),Math.ceil(j/X[1]/L[1]),Math.ceil(R/X[2]/L[2])],Z=He(t[0].dataType),re=D?4:1,ae=ne("a",t[0].dataType,[...o,j,k/re],re),$e=ne("b",t[1].dataType,[...y,k,P/re],re),q=fe("result",t[0].dataType,[R,j,P/re],re);T.push(ae),T.push($e),T.push(q);let le=[ae,$e],Pe=t.length>2,ue=hm(re,Pe,Y,T,O,u);if(Pe){let et=u?re:1;le.push(ne("bias",t[2].dataType,t[2].dims,et))}let oe=et=>`
  const dimAOuter: i32 = ${j};
  const dimBOuter: i32 = ${P};
  const dimInner: i32 = ${k};
  ${et.declareVariables(...le,q)}
  ${ue}
  ${F}
  ${D?yi(L,X,Z,A):vi(L,X,Z,A)}
                   ${A.impl()}`;return{name:"MatMul",shaderCache:{hint:r.activationCacheKey},getRunData:()=>({outputs:[{dims:e,dataType:t[0].dataType}],dispatchGroup:{x:I[0],y:I[1],z:I[2]}}),getShaderSource:oe}}});var mm,$l,Cl=ie(()=>{"use strict";Pt();Ie();Re();pn();ra();bi();mm=(t,r,e,d,u=!1,h,m=!1,o=4,y=4,$=4,A="f32")=>{let T=$e=>{switch($e){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${A}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${$e} is not supported.`)}},O=$e=>{switch($e){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${$e} is not supported.`)}},R=t?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,j=t?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,k=t?"xShape[1]":"xShape[2]",P=t?"xShape[2]":"xShape[3]",D=t?"row":"col",F=t?"col":"row",Y=`
    let inChannels = wShape[2];
    let outWidth = ${t?"outShape[2]":"outShape[3]"};
    let outRow = ${D} / outWidth;
    let outCol = ${D} % outWidth;

    let WRow = ${F} / (filterDims[1] * inChannels);
    let WCol = ${F} / inChannels % filterDims[1];
    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];
    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];
    let xCh = ${F} % inChannels;
    var resData = ${Je(o,A)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${k} && xCol >= 0 && xCol < ${P}) {
      ${R}
      let xIndex = getIndexFromCoords4D(coord, xShape);
      ${T(o)}
    }
    return resData;`,L=t?r&&d?`
    let col = colIn * ${o};
    ${Y}`:`
    let col = colIn * ${o};
    if (row < dimAOuter && col < dimInner) {
      ${Y}
    }
    return ${Je(o,A)}(0.0);`:d&&e?`
    let col = colIn * ${o};
    ${Y}`:`
    let col = colIn * ${o};
    if (row < dimInner && col < dimBOuter) {
      ${Y}
    }
    return ${Je(o,A)}(0.0);`,X=`${O(y)}`,I=Je($,A),Z=t?Je(o,A):Je(y,A),re=t?Je(y,A):Je(o,A);return`
    ${cn(h,m,$===4,4)}
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${Z} {
      ${t?L:X}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${re} {
      ${t?X:L}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${I}) {
      let col = colIn * ${$};
      if (row < dimAOuter && col < dimBOuter)
      {
      var value = valueIn;
      let outWidth = ${t?"outShape[2]":"outShape[3]"};
      ${j}
      ${fn(u,h)}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},$l=(t,r,e,d,u,h,m,o)=>{let y=r.format==="NHWC",$=y?t[0].dims[3]:t[0].dims[1],A=e[0],T=y?e[2]:e[3],O=y?e[1]:e[2],R=y?e[3]:e[1],j=y&&($%4===0||$%3===0)&&R%4===0,k=y?R:T*O,P=y?T*O:R,D=[8,8,1],F=d<=8?[4,1,1]:[4,4,1],Y=[Math.ceil(k/D[0]/F[0]),Math.ceil(P/D[1]/F[1]),Math.ceil(A/D[2]/F[2])];Ne("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${Y}`);let L=j?y&&$%4!==0?3:4:F[0],X=D[1]*F[1],I=D[0]*F[0],Z=Math.max(D[0]*L,D[1]),re=d%X===0,ae=u%I===0,$e=h%Z===0,q=j?[L,4,4]:[1,1,1],le=He(t[0].dataType),Pe=[`@group(0) @binding(0) var<storage, read> x: array<${j&&L===4?`vec4<${le}>`:le}>;`,`@group(0) @binding(1) var<storage, read> w: array<${j?`vec4<${le}>`:le}>;`],ue=`
      fn setOutputAtIndex(flatIndex : i32, value : ${j?`vec4<${le}>`:le}) {
        result[flatIndex] = ${j?`vec4<${le}>`:le}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${j?`vec4<${le}>`:le}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${j?"/ 4":""}, value);
      }`;return m&&(Pe.push(`@group(0) @binding(2) var<storage, read> bias: array<${j?`vec4<${le}>`:le}>;`),ue+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${j?`vec4<${le}>`:le} {
          return bias[coords.${y?"w":"y"}${j?"/ 4":""}];
        }`),{name:"Conv2DMatMul",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:e,dataType:t[0].dataType}],dispatchGroup:{x:Y[0],y:Y[1],z:Y[2]}}),getShaderSource:()=>`
        ${hn}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${Pe.join("")}
        @group(0) @binding(${Pe.length}) var<storage, read_write> result: array<${j?`vec4<${le}>`:le}>;
        //@group(0) @binding(${Pe.length+1}) var<uniform> uniforms: Uniforms;

        const xShape : vec4<i32> = vec4<i32>(${t[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${t[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${e.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${Q.computeStrides(e).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${r.kernelShape[0]}, ${r.kernelShape[1]});
        const pad : vec2<i32> = vec2<i32>(${r.pads[0]}, ${r.pads[1]});
        const stride : vec2<i32> = vec2<i32>(${r.strides[0]}, ${r.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${r.dilations[0]}, ${r.dilations[1]});
        const dimAOuter : i32 = ${d};
        const dimBOuter : i32 = ${u};
        const dimInner : i32 = ${h};
        ${ue}
        ${mm(y,re,ae,$e,m,void 0,!1,q[0],q[1],q[2],le)}
            ${j?yi(F,D,le,void 0,!y,Z):vi(F,D,le,void 0,!y,Z,!1,void 0,o)}`}}});var ia,_l=ie(()=>{"use strict";Ie();Re();aa();gi();ia=(t,r,e)=>{let d=t.length>2,u=d?"value += b[output_channel];":"",h=t[0].dims,m=t[1].dims,o=m[0]/r.group,{activationFunction:y,applyActivation:$}=mn(r),A=r.format==="NHWC",T=na(h,m,r.dilations,r.pads,r.strides,A),O=Q.size(T),R=fe("output",t[0].dataType,T),j=ne("x",t[0].dataType,h),k=ne("w",t[1].dataType,m),P=[j,k];d&&P.push(ne("b",t[2].dataType,t[2].dims));let D=F=>`
  const strides: vec2<u32> = vec2(${r.strides[0]}u, ${r.strides[1]}u);
  const pads: vec2<u32> = vec2(${r.pads[0]}u, ${r.pads[1]}u);

  ${F.declareVariables(...P,R)}

  ${y}

  ${F.mainStart()}
    ${F.guardAgainstOutOfBoundsWorkgroupSizes(O)}

    let outputIndices = ${R.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${A?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${A?1:2}], outputIndices[${A?2:3}]) * strides - pads;
    let group_id: u32 = output_channel / ${o}u;

    var value: ${R.type.value} = ${R.type.value}(0);
    for (var wInChannel: u32 = 0u; wInChannel < ${m[1]}u; wInChannel++) {
      let input_channel = group_id * ${m[1]}u + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < ${m[2]}u; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * ${r.dilations[0]}u;

        if (xHeight < 0u || xHeight >= ${h[A?1:2]}u) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < ${m[3]}u; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * ${r.dilations[1]}u;
          if (xWidth < 0u || xWidth >= ${h[A?2:3]}u) {
            continue;
          }

          let xVal = ${A?j.get("batch","xHeight","xWidth","input_channel"):j.get("batch","input_channel","xHeight","xWidth")};
          let wVal = ${k.get("output_channel","wInChannel","wHeight","wWidth")};
          value += xVal*wVal;
        }
      }
    }
    ${u}
    ${$}
    ${R.setByOffset("global_idx","value")}
  }`;return{name:"GroupedConv",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:e?e(T):T,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(O/64)}}),getShaderSource:D}}});var gm,xl,ym,vm,xr,Sl,Il,vn=ie(()=>{"use strict";Ie();Fe();Re();gm=t=>{if(!t||t.length!==1)throw new Error("Transpose requires 1 input.")},xl=(t,r)=>r&&r.length!==t?[...new Array(t).keys()].reverse():r,ym=(t,r)=>Q.sortBasedOnPerm(t,xl(t.length,r)),vm=(t,r,e,d)=>{let u=[];u.push(`fn perm(i: ${d.type.indices}) -> ${e.type.indices} {
    var a: ${e.type.indices};`);for(let h=0;h<r;++h)u.push(e.indicesSet("a",t[h],`i[${h}]`));return u.push("return a;}"),u.join(`
`)},xr=(t,r,e)=>{let d=xl(r,e),u=fe("output",t,e&&e.length||r),h=ne("a",t,r),m=o=>`
  ${o.registerUniform("output_size","u32").declareVariables(h,u)}

  ${vm(d,r,h,u)}

  ${o.mainStart()}
    ${o.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${u.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${u.setByOffset("global_idx",h.getByIndices("aIndices"))}
  }`;return{name:"Transpose",shaderCache:{hint:`${e}`,inputDependencies:["rank"]},getRunData:o=>{let y=ym(o[0].dims,d),$=Q.size(y);return{outputs:[{dims:y,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil($/64)},programUniforms:[{type:"uint32",data:$},...Xn(o[0].dims),...Xn(y)]}},getShaderSource:m}},Sl=(t,r)=>{gm(t.inputs),t.compute(xr(t.inputs[0].dataType,t.inputs[0].dims.length,r.perm))},Il=t=>ye({perm:t.perm})});var na,Al,bm,El,Ol,wm,$m,Tl,aa=ie(()=>{"use strict";Ie();Fe();Cl();bi();_l();gi();vn();na=(t,r,e,d,u,h)=>{let m=t[0],o=t.slice(h?1:2,h?3:4),y=o.length,$=r[0],T=r.slice(2).map((j,k)=>j+(j-1)*(e[k]-1)),R=o.map((j,k)=>j+d[k]+d[k+y]).map((j,k)=>Math.floor((j-T[k]+u[k])/u[k]));return R.splice(0,0,m),R.splice(h?3:1,0,$),R},Al=[2,3,1,0],bm=(t,r)=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(t[0].dims.length!==4&&t[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(t[0].dims.length!==t[1].dims.length)throw new Error("filter does not have same dimension as input");let e=t[0].dims[r.format==="NHWC"?t[0].dims.length-1:1],d=t[1].dims[1]*r.group;if(e!==d)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(t.length===3&&(t[2].dims.length!==1||t[1].dims[0]!==t[2].dims[0]))throw new Error("invalid bias");let u=t[0].dims.length-2;if(r.dilations.length!==u)throw new Error(`dilations should be ${u}D`);if(r.strides.length!==u)throw new Error(`strides should be ${u}D`);if(r.pads.length!==u*2)throw new Error(`pads should be ${u*2}D`);if(r.kernelShape.length!==0&&r.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape")},El=(t,r)=>{let e=t.kernelShape.slice();for(let h=2;h<r[1].dims.length;++h)e[h-2]===0&&(e[h-2]=r[1].dims[h]);let d=t.pads.slice();Jt.adjustPadsBasedOnAutoPad(r[0].dims,t.strides,t.dilations,e,d,t.format==="NHWC",t.autoPad);let u=Object.assign({},t);return Object.assign(u,{kernelShape:e,pads:d,cacheKey:t.cacheKey}),u},Ol=t=>{let r=gn(t),e=t.format,d=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][t.auto_pad],u=t.dilations,h=t.group,m=t.kernel_shape,o=t.pads,y=t.strides,$=t.w_is_const();return ye({autoPad:d,format:e,dilations:u,group:h,kernelShape:m,pads:o,strides:y,wIsConst:$,...r})},wm=(t,r,e)=>{let d=El(e,r);if(e.group!==1){t.compute(ia(r,d));return}let u=e.format==="NHWC",h=r.length===3,m=r[0].dims[u?1:2],o=r[0].dims[u?2:3],y=r[0].dims[u?3:1],$=r[1].dims[2],A=r[1].dims[3],T=na(r[0].dims,r[1].dims,e.dilations,d.pads,e.strides,u),O=T[u?1:2],R=T[u?2:3],j=T[u?3:1],k=u&&$===m&&A===o&&e.pads[0]===0&&e.pads[1]===0;if(k||$===1&&A===1&&e.dilations[0]===1&&e.dilations[1]===1&&e.strides[0]===1&&e.strides[1]===1&&e.pads[0]===0&&e.pads[1]===0){let I=T[0],Z,re,ae,$e=[];if(u){let q=t.kernelCustomData.wT??t.compute(xr(r[1].dataType,r[1].dims.length,Al),{inputs:[1],outputs:[e.wIsConst?-2:-1]})[0];if(e.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=q),k){let le=m*o*y;Z=r[0].reshape([1,I,le]),re=q.reshape([1,le,j]),ae=[1,I,j]}else Z=r[0].reshape([I,m*o,y]),re=q.reshape([1,y,j]),ae=[I,O*R,j];$e.push(Z),$e.push(re)}else Z=r[0].reshape([I,y,m*o]),re=r[1].reshape([1,j,y]),ae=[I,j,O*R],$e.push(re),$e.push(Z);h&&$e.push(r[2]),t.compute(yn($e,d,T,ae,u),{inputs:$e});return}let P=!0,D=t.kernelCustomData.wT??t.compute(xr(r[1].dataType,r[1].dims.length,Al),{inputs:[1],outputs:[e.wIsConst?-2:-1]})[0];e.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=D);let F=[r[0],D];h&&F.push(r[2]);let Y=u?O*R:j,L=u?j:O*R,X=$*A*y;t.compute($l(F,d,T,Y,L,X,h,P),{inputs:F})},$m=(t,r)=>{let e=r.format==="NHWC",d=[t.inputs[0].reshape(e?[t.inputs[0].dims[0],1,t.inputs[0].dims[1],t.inputs[0].dims[2]]:[t.inputs[0].dims[0],t.inputs[0].dims[1],1,t.inputs[0].dims[2]]),t.inputs[1].reshape([t.inputs[1].dims[0],t.inputs[1].dims[1],1,t.inputs[1].dims[2]])];t.inputs.length===3&&d.push(t.inputs[2]);let u=[0,r.pads[0],0,r.pads[1]],h=[1].concat(r.strides),m=[1].concat(r.dilations),o=[1].concat(r.kernelShape),y=El({...r,pads:u,strides:h,dilations:m,kernelShape:o},d);t.compute(ia(d,y,$=>e?[$[0],$[2],$[3]]:[]))},Tl=(t,r)=>{bm(t.inputs,r),t.inputs[0].dims.length===3?$m(t,r):wm(t,t.inputs,r)}});var Cm,Rl,kl=ie(()=>{"use strict";Pt();Ie();pn();ra();bi();Cm=(t,r=!1,e,d=!1,u=4)=>{let h=Je(u,"f32"),m=D=>{switch(D){case 1:return"return W[getIndexFromCoords4D(coord, wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${D} is not supported.`)}},o=t?`
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `,y=t?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,$=t?"outBackprop[1]":"outBackprop[2]",A=t?"outBackprop[2]":"outBackprop[3]",T=t?"row":"col",O=t?"col":"row",R=`
      let inChannels = ${t?"outBackprop[3]":"outBackprop[1]"};
      let outWidth = ${t?"outShape[2]":"outShape[3]"};
      let outRow = ${T} / outWidth;
      let outCol = ${T} % outWidth;

      let WRow = ${O} / (filterDims[1] * inChannels);
      let WCol = ${O} / inChannels % filterDims[1];
      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);
      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);
      if (xR < 0.0 || xR >= f32(${$}) || fract(xR) > 0.0) {
        return ${h}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${A}) || fract(xC) > 0.0) {
        return ${h}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${O} % inChannels;
      ${o}
      return x[getIndexFromCoords4D(coord, xShape)/${u}];`,j=t?`
      let col = colIn * ${u};
      if (row < dimAOuter && col < dimInner) {
        ${R}
      }
      return ${h}(0.0);`:`
      let col = colIn * ${u};
      if (row < dimInner && col < dimBOuter) {
        ${R}
      }
      return ${h}(0.0);`,k=`
      let col = colIn * ${u};
      let inChannels = ${t?"outBackprop[3]":"outBackprop[1]"};
      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);
      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];
      if (${t?"row < dimInner && col < dimBOuter":"row < dimInner && col < dimAOuter"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${m(u)}
      }
      return ${h}(0.0);
      `;return`
  ${cn(e,d,u===4,4)}
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${h} {
    ${t?j:k}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${h} {
    ${t?k:j}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${h}) {
    let col = colIn * ${u};
    if (row < dimAOuter && col < dimBOuter) {
      var value = valueInput;
      let outWidth = ${t?"outShape[2]":"outShape[3]"};
      ${y}
      ${fn(r,e)}
      result[getIndexFromCoords4D(coords, outShape)/${u}] = value;
    }
  }`},Rl=(t,r,e,d,u,h,m,o)=>{let y=r.format==="NHWC",$=y?t[0].dims[3]:t[0].dims[1],A=e[0],T=y?e[2]:e[3],O=y?e[1]:e[2],R=y?e[3]:e[1],j=y?$%4===0&&R%4===0:T%4===0&&R%4===0,k=y?R:T*O,P=y?T*O:R,D=j?[8,8,1]:[k<=4||P<=4?4:16,k>4&&P<=4?4:16,1],F=j?[4,4,1]:[k<=4?1:4,k>4&&P<=4?1:4,1],Y=[Math.ceil(k/D[0]/F[0]),Math.ceil(P/D[1]/F[1]),Math.ceil(A/D[2]/F[2])];Ne("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${Y}`);let L=j?4:1,X=Math.max(D[0]*L,D[1]),I=[`@group(0) @binding(0) var<storage, read> x: array<${j?"vec4<f32>":"f32"}>;`,"@group(0) @binding(1) var<storage, read> W: array<f32>;"],Z="";return m&&(I.push(`@group(0) @binding(2) var<storage, read> bias: array<${j?"vec4<f32>":"f32"}>;`),Z+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${j?"vec4<f32>":"f32"} {
          return bias[coords.${y?"w":"y"}${j?"/ 4":""}];
        }`),{name:"Conv2DTransposeMatMul",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:e,dataType:t[0].dataType}],dispatchGroup:{x:Y[0],y:Y[1],z:Y[2]}}),getShaderSource:()=>`
        ${hn}
        ${I.join(`
`)}
        @group(0) @binding(${I.length}) var<storage, read_write> result: array<${j?"vec4<f32>":"f32"}>;
        const outBackprop : vec4<i32> = vec4<i32>(${t[0].dims.join(",")});
        const xShape : vec4<i32> = vec4<i32>(${t[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${t[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${e.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${Q.computeStrides(e).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${r.kernelShape[y?1:2]}, ${r.kernelShape[y?2:3]});
        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(
              ${r.dilations[0]<=1?0:(r.kernelShape[y?1:2]-1)*(r.dilations[0]-1)},
              ${r.dilations[1]<=1?0:(r.kernelShape[y?2:3]-1)*(r.dilations[1]-1)});
        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,
                                         i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);
        const strides : vec2<i32> = vec2<i32>(${r.strides[0]}, ${r.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${r.dilations[0]}, ${r.dilations[1]});
        const dimAOuter : i32 = ${d};
        const dimBOuter : i32 = ${u};
        const dimInner : i32 = ${h};
        ${Z}
        ${Cm(y,m,void 0,!1,L)}
        ${j?yi(F,D,"f32",void 0,!y,X):vi(F,D,"f32",void 0,!y,X,!1,void 0,o)}`}}});var _m,oa,jl=ie(()=>{"use strict";Pt();Ie();Re();_m=(t,r,e,d,u,h,m=!1,o)=>{let y=e.format==="NHWC",$=y?1:2,A=y?2:3,T=y?3:1,O=Q.size(d),R=m?2:1,j=e.group,k=r[1].dims,P=k[0]/j,D=k[1],F=`
  fn setOutputAtIndex(flatIndex : u32, value : ${m?`vec4<${o}>`:o}) {
    result[flatIndex] = ${m?`vec4<${o}>`:o}(value);
  }`;u&&(F+=`
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${m?`vec4<${o}>`:o} {
      return bias[coords.${y?"w":"y"}${m?"/ 4":""}];
    }`);let Y=m?4:1,L=ne("W",r[1].dataType,r[1].dims,Y),X=ne("Dy",r[0].dataType,r[0].dims,Y),I=[X,L];u&&I.push(ne("bias",r[2].dataType,[d[T]],Y));let Z=fe("result",r[0].dataType,d,Y),re=`{
        let batch: u32 = ${h?"global_id.z":"workgroup_id.z"} / outShape[1];
        let r = ${h?"global_id.z":"workgroup_id.z"} % outShape[1];
        let c = ${h?"global_id.y":"workgroup_id.y"} * ${R};
        let d1: u32 = ${h?"global_id.x":"workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${o}>, ${R}>;
        for (var i = 0; i < ${R}; i++) {
          dotProd[i] = vec4<${o}>(0.0);
        }
        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {
          var dyR = (${o}(dyCorner.x) + ${o}(wR)) / ${o}(strides.x);
          let wRPerm = filterDims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${o}(outBackprop[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {
            let dyC = (${o}(dyCorner.y) + ${o}(wC)) / ${o}(strides.y);
            let dyC2 = (${o}(dyCorner.y) + 1.0 + ${o}(wC)) / ${o}(strides.y);
            let wCPerm = filterDims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${o}(outBackprop[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${o}(outBackprop[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${X.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${o}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${X.get("batch","idyR","idyC2","d2")};

                dotProd[1] = dotProd[1] + vec4<${o}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = outBackprop[${T}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${X.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${o}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${X.get("batch","idyR","idyC2","d2")};
                let tmpval = vec4<${o}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${R}; i = i + 1) {
          let value = dotProd[i] + ${u?"bias[c+i]":"0.0"};
          ${Z.set("batch","r","c + i","d1","value")};
        }
      }`,ae=`
          let outputIndices = ${Z.offsetToIndices("global_idx")};
          let batch = ${Z.indicesGet("outputIndices",0)};
          let d1 = ${Z.indicesGet("outputIndices",T)};
          let r = ${Z.indicesGet("outputIndices",$)};
          let c = ${Z.indicesGet("outputIndices",A)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / ${D};
          let wOutChannel = d1 - groupId * ${D};
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = 0.0;
          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {
            if (wR % dilations.x != 0) {
              continue;
            }
            let dyR = (${o}(dyRCorner) + ${o}(wR)) / ${o}(strides[0]);
            let wRPerm = filterDims.x - 1 - wR / dilations.x;
            if (dyR < 0.0 || dyR >= ${o}(outBackprop[${$}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {
              if (wC % dilations.y != 0) {
                continue;
              }
              let dyC = (${o}(dyCCorner) + ${o}(wC)) / ${o}(strides.y);
              let wCPerm = filterDims.y - 1 - wC / dilations.y;
              if (dyC < 0.0 || dyC >= ${o}(outBackprop[${A}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * ${P};
              for (var d2: u32 = 0; d2 < ${P}; d2 = d2 + 1) {
                let xValue = ${y?X.get("batch","idyR","idyC","inputChannel"):X.get("batch","inputChannel","idyR","idyC")};
                let wValue = ${L.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${u?"bias[d1]":"0.0"};
          ${Z.setByOffset("global_idx","value")};
        `;return`
  ${t.declareVariables(...I,Z)}
  ${F}
  const outShape : vec4<u32> = vec4<u32>(${d.join(",")});
  const outBackprop : vec4<u32> = vec4<u32>(${r[0].dims.join(",")});
  const strides : vec2<u32> = vec2<u32>(${e.strides[0]}, ${e.strides[1]});
  const filterDims : vec2<u32> = vec2<u32>(${e.kernelShape[y?1:2]}, ${e.kernelShape[y?2:3]});
  const dilations : vec2<u32> = vec2<u32>(${e.dilations[0]}, ${e.dilations[1]});
  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(
          ${e.dilations[0]<=1?0:(e.kernelShape[y?1:2]-1)*(e.dilations[0]-1)},
          ${e.dilations[1]<=1?0:(e.kernelShape[y?2:3]-1)*(e.dilations[1]-1)});
  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${e.pads[0]+e.pads[2]})/2,
                                     i32(effectiveFilterDims[1]) - 1 - (${e.pads[1]+e.pads[3]})/2);
    ${t.mainStart()}
    ${t.guardAgainstOutOfBoundsWorkgroupSizes(O)};
  ${m?re:ae}}`},oa=(t,r,e)=>{let d=t.length>2,u=r.outputShape,h=Q.size(u),m=[Math.ceil(h/64),1,1];Ne("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${m}`);let o=He(t[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:r.cacheKey},getRunData:()=>({dispatchGroup:{x:m[0],y:m[1],z:m[2]},outputs:[{dims:e?e(u):u,dataType:t[0].dataType}]}),getShaderSource:y=>_m(y,t,r,u,d,m[1]===1&&m[2]===1,!1,o)}}});var xm,Sm,Im,Pl,Bl,Am,Em,Om,Tm,Ml,Dl=ie(()=>{"use strict";Fe();kl();jl();gi();vn();xm=(t,r,e,d,u,h)=>(t-1)*r+e+(d-1)*u+1-h,Sm=(t,r,e,d,u)=>{let h=Math.floor(t/2);r==="SAME_UPPER"?(e[d]=h,e[u]=t-h):r==="SAME_LOWER"&&(e[d]=t-h,e[u]=h)},Im=(t,r,e,d,u,h,m,o,y,$)=>{let A=t.length-2,T=$.length===0;if(y.length===0)for(let j=0;j<A;++j)y.push(0);let O=t[0],R=r[o?3:1]*u;for(let j=0,k=t.length-A-(o?1:0);j<A;++j,++k){let P=t[k],D=T?P*m[j]:$[j],F=xm(P,m[j],h[j],r[k],e[j],D);Sm(F,d,h,j,j+A),T&&$.push(m[j]*(P-1)+y[j]+(r[k]-1)*e[j]+1-h[j]-h[j+A])}$.splice(0,0,O),$.splice(o?3:1,0,R)},Pl=(t,r)=>{let e=t.kernelShape.slice();if(t.kernelShape.length===0||t.kernelShape.reduce((O,R)=>O*R,1)===0){e.length=0;for(let O=2;O<r[1].dims.length;++O)e.push(r[1].dims[O])}let d=t.format==="NHWC";e.splice(0,0,r[1].dims[0]),e.splice(d?3:1,0,r[1].dims[1]);let u=t.pads.slice(),h=t.outputShape.slice(),m=t.outputPadding.slice(),o=r[0].dims,y=t.dilations.slice();if(y.reduce((O,R)=>O+R,0)===0){let O=r[0].dims.length-2;y=new Array(O).fill(1)}let $=t.strides.slice();if($.reduce((O,R)=>O+R,0)===0){let O=r[0].dims.length-2;$=new Array(O).fill(1)}Im(o,e,y,t.autoPad,t.group,u,$,d,m,h);let A=Object.assign({},t),T=t.cacheKey+[e.join("n,"),u.join(","),$.join(","),m.join(","),h.join(","),y.join(",")].join("_");return Object.assign(A,{kernelShape:e,pads:u,outputPadding:m,outputShape:h,dilations:y,strides:$,cacheKey:T}),A},Bl=t=>{let r=gn(t),e=t.format,d=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof t.autoPad>"u"?0:t.autoPad],u=t.dilations,h=t.group,m=t.kernelShape,o=t.pads,y=t.strides,$=t.wIsConst(),A=t.outputPadding,T=t.outputShape;return ye({autoPad:d,format:e,dilations:u,group:h,kernelShape:m,outputPadding:A,outputShape:T,pads:o,strides:y,wIsConst:$,...r})},Am=(t,r)=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(t[0].dims.length!==4&&t[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(t[0].dims.length!==t[1].dims.length)throw new Error("filter does not have same dimension as input");let e=t[0].dims[r.format==="NHWC"?t[0].dims.length-1:1],d=t[1].dims[0];if(e!==d)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let u=t[1].dims[1]*r.group;if(t.length===3&&(t[2].dims.length!==1||t[2].dims[0]!==u))throw new Error("invalid bias");let h=t[0].dims.length-2;if(r.dilations.reduce((A,T)=>A+T,0)>0&&r.dilations.length!==h)throw new Error(`dilations should be ${h}D`);if(r.strides.reduce((A,T)=>A+T,0)>0&&r.strides.length!==h)throw new Error(`strides should be ${h}D`);if(r.pads.reduce((A,T)=>A+T,0)>0&&r.pads.length!==h*2)throw new Error(`pads should be ${h*2}D`);if(r.outputPadding.length!==h&&r.outputPadding.length!==0)throw new Error(`output_padding should be ${h}D`);if(r.kernelShape.reduce((A,T)=>A+T,0)>0&&r.kernelShape.length!==0&&r.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape");if(r.outputShape.length!==0&&r.outputShape.length!==t[0].dims.length-2)throw new Error("invalid output shape")},Em=[2,3,1,0],Om=(t,r,e)=>{let d=Pl(e,r),u=e.format==="NHWC",h=r.length===3;if(d.group!==1){t.compute(oa(r,d));return}let m=d.outputShape,o=m[u?1:2],y=m[u?2:3],$=m[u?3:1],A=r[1].dims[2],T=r[1].dims[3],O=r[0].dims[u?3:1],R=u?o*y:$,j=u?$:o*y,k=A*T*O,P=!0,D=t.kernelCustomData.wT??t.compute(xr(r[1].dataType,r[1].dims.length,Em),{inputs:[1],outputs:[e.wIsConst?-2:-1]})[0];e.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=D);let F=[r[0],D];h&&(!u&&r[2].dims.length===1?F.push(r[2].reshape([r[2].dims[0],1,1])):F.push(r[2])),t.compute(Rl(F,d,m,R,j,k,h,P),{inputs:F})},Tm=(t,r)=>{let e=r.format==="NHWC",d=[t.inputs[0].reshape(e?[t.inputs[0].dims[0],1,t.inputs[0].dims[1],t.inputs[0].dims[2]]:[t.inputs[0].dims[0],t.inputs[0].dims[1],1,t.inputs[0].dims[2]]),t.inputs[1].reshape([t.inputs[1].dims[0],t.inputs[1].dims[1],1,t.inputs[1].dims[2]])];d.length===3&&d.push(t.inputs[2]);let u=r.kernelShape;(u.length===0||u[0]===0)&&(u=[t.inputs[1].dims[2]]);let h=r.dilations;(h.length===0||h[0]===0)&&(h=[1]);let m=r.strides;(m.length===0||m[0]===0)&&(m=[1]);let o=r.pads;o.length===0&&(o=[0,0]),o=[0,o[0],0,o[1]],m=[1].concat(m),h=[1].concat(h),u=[1].concat(u);let y=Pl({...r,pads:o,strides:m,dilations:h,kernelShape:u},d);t.compute(oa(d,y,$=>e?[$[0],$[2],$[3]]:[$[0],$[1],$[3]]))},Ml=(t,r)=>{Am(t.inputs,r),t.inputs[0].dims.length===3?Tm(t,r):Om(t,t.inputs,r)}});var sa,bn,zl,Rm,km,ua,la,jm,Wl,Nl,Ul=ie(()=>{"use strict";Ie();Fe();Re();sa="[a-zA-Z]|\\.\\.\\.",bn="("+sa+")+",zl="^"+bn+"$",Rm="("+bn+",)*"+bn,km="^"+Rm+"$",ua=class{constructor(r=-1){this.symbolToIndices=new Map,this.inputIndex=r}addSymbol(r,e){let d=this.symbolToIndices.get(r);d===void 0?d=[e]:d.push(e),this.symbolToIndices.set(r,d)}},la=class{constructor(r,e){this.equation=e;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[d,u]=e.includes("->")?e.split("->",2):[e,""];if(!d.match(RegExp(km)))throw new Error("Invalid LHS term");if(d.split(",").forEach((o,y)=>{let $=r[y].dims.slice();if(!o.match(RegExp(zl)))throw new Error("Invalid LHS term");let A=this.processTerm(o,!0,$,y);this.lhs.push(A)}),u==="")u+=[...this.symbolToInfo.entries()].filter(([o,y])=>y.count===1||o==="...").map(([o])=>o).join("");else if(!u.match(RegExp(bn)))throw new Error("Invalid RHS");u.match(RegExp(sa,"g"))?.forEach(o=>{if(o==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let y=this.symbolToInfo.get(o);if(y===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(y.dimValue)}}),this.rhs=this.processTerm(u,!0,this.outputDims)}addSymbol(r,e,d){let u=this.symbolToInfo.get(r);if(u!==void 0){if(u.dimValue!==e&&u.count!==1)throw new Error("Dimension mismatch");u.count++,u.inputIndices.push(d)}else u={count:1,dimValue:e,inputIndices:[d]};this.symbolToInfo.set(r,u)}processTerm(r,e,d,u=-1){let h=d.length,m=!1,o=[],y=0;if(!r.match(RegExp(zl))&&!e&&r!=="")throw new Error("Invalid LHS term");let $=r.match(RegExp(sa,"g")),A=new ua(u);return $?.forEach((T,O)=>{if(T==="..."){if(m)throw new Error("Only one ellipsis is allowed per input term");m=!0;let R=h-$.length+1;if(R<0)throw new Error("Ellipsis out of bounds");if(o=d.slice(y,y+R),this.hasEllipsis){if(this.ellipsisDims.length!==o.length||this.ellipsisDims.toString()!==o.toString())throw new Error("Ellipsis dimensions mismatch")}else if(e)this.hasEllipsis=!0,this.ellipsisDims=o;else throw new Error("Ellipsis must be specified in the LHS");for(let j=0;j<o.length;j++){let k=String.fromCharCode("0".charCodeAt(0)+O);A.addSymbol(k,O+j),this.addSymbol(k,d[y++],u)}}else A.addSymbol(T,O),this.addSymbol(T,d[y++],u)}),A}},jm=(t,r)=>{let e=t[0].dataType,d=new Array(t.length);for(let Y=0;Y<t.length;++Y)d[Y]=ne(`input${Y}`,e,t[Y].dims);let u=r.outputDims,h=Q.size(u),m=fe("output",e,u),o=[],y=Array.from(r.rhs.symbolToIndices.keys()),$="var prod = 1.0;",A="var sum = 0.0;",T="sum += prod;",O=[],R=[],j=[],k=[],P=r.symbolToInfo.size===y.length;r.symbolToInfo.forEach((Y,L)=>{if(y.includes(L)){let X=y.indexOf(L);r.lhs.forEach((I,Z)=>{if(Y.inputIndices.includes(Z)){let re=I.symbolToIndices.get(L);if(re===void 0)throw new Error("Invalid symbol error");re.forEach(ae=>{o.push(`${d[Z].indicesSet(`input${Z}Indices`,ae,m.indicesGet("outputIndices",X))}`)})}})}else r.lhs.forEach((X,I)=>{let Z=r.symbolToInfo.get(L);if(Z===void 0)throw new Error("Invalid symbol error");if(Z.inputIndices.includes(I)){let re=X.symbolToIndices.get(L);if(re===void 0)throw new Error("Invalid symbol error");re.forEach(ae=>{O.push(`${d[I].indicesSet(`input${I}Indices`,ae,`${L}`)}`)}),k.push(`prod *= ${d[I].getByIndices(`input${I}Indices`)};`)}}),R.push(`for(var ${L}: u32 = 0; ${L} < ${r.symbolToInfo.get(L)?.dimValue}; ${L}++) {`),j.push("}")});let D=P?[...o,`let sum = ${d.map((Y,L)=>Y.getByIndices(`input${L}Indices`)).join(" * ")};`]:[...o,A,...R,...O,$,...k,T,...j],F=Y=>`
      ${Y.declareVariables(...d,m)}

      ${Y.mainStart()}
        ${Y.guardAgainstOutOfBoundsWorkgroupSizes(h)}
        var outputIndices = ${m.offsetToIndices("global_idx")};
        ${d.map((L,X)=>`var input${X}Indices: ${d[X].type.indices};`).join(`
`)}
        ${D.join(`
`)};
        ${m.setByOffset("global_idx","sum")};
      }`;return{name:"Einsum",shaderCache:{hint:r.equation},getRunData:()=>({outputs:[{dims:u,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)}}),getShaderSource:F}},Wl=(t,r)=>{let e=new la(t.inputs,r.equation);t.compute(jm(t.inputs,e))},Nl=t=>{let r=t.equation.replace(/\s+/g,"");return ye({equation:r})}});var Pm,Gl,Bm,Mm,Vl,Fl=ie(()=>{"use strict";Ie();Re();Pm=t=>{if(!t||t.length!==2)throw new Error("Expand requires 2 input.");let r=t[0].dims,e=Array.from(t[1].getBigInt64Array(),Number),d=e.length<r.length?0:e.length-r.length,u=r.length<e.length?0:r.length-e.length;for(;d<e.length&&u<r.length;++d,++u)if(e[d]!==r[u]&&e[d]!==1&&r[u]!==1)throw new Error("Expand requires shape to be broadcastable to input")},Gl=(t,r)=>{let e=t.length-r.length,d=[];for(let u=0;u<e;++u)d.push(t[u]);for(let u=0;u<r.length;++u)d.push(r[u]===1?t[u+e]:r[u]);return d},Bm=(t,r)=>t.length>r.length?Gl(t,r):Gl(r,t),Mm=t=>{let r=t[0].dims,e=Array.from(t[1].getBigInt64Array(),Number),d=Bm(r,e),u=Q.size(d),h=t[0].dataType,m=ne("input",h,r),o=fe("output",h,d),y=$=>`
  const inputShape = ${m.indices(...r)};
  ${$.declareVariables(m,o)}
  ${$.mainStart()}
  ${$.guardAgainstOutOfBoundsWorkgroupSizes(u)}
    let outputIndices = ${o.offsetToIndices("global_idx")};
    var inputIndices: ${m.type.indices};
    for (var i = 0; i < ${r.length}; i++) {
      if (${m.indicesGet("inputShape","i")} == 1) {
        ${m.indicesSet("inputIndices","i",0)}
      } else {
        ${m.indicesSet("inputIndices","i",o.indicesGet("outputIndices",`i + ${d.length-r.length}`))}
      }
    }
    ${o.setByOffset("global_idx",m.getByIndices("inputIndices"))}
  }`;return{name:"Expand",shaderCache:{hint:`${d}`},getShaderSource:y,getRunData:()=>({outputs:[{dims:d,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}})}},Vl=t=>{Pm(t.inputs),t.compute(Mm(t.inputs),{inputs:[0]})}});var Dm,zm,Hl,Ll,ql=ie(()=>{"use strict";Ie();Fe();Re();Dm=t=>{if(!t||t.length!==2)throw new Error("Gather requires 2 inputs.")},zm=(t,r)=>{let e=t[0].dims,d=t[1].dims,u=e.length,h=Q.normalizeAxis(r.axis,u),m=e.slice(0);m.splice(h,1,...d);let o=e[h],y=Q.size(m),$=ne("data",t[0].dataType,t[0].dims),A=ne("inputIndices",t[1].dataType,t[1].dims),T=fe("output",t[0].dataType,m),O=()=>{let j=d.length,k=`var indicesIndices  = ${A.type.indices}(0);`;for(let P=0;P<j;P++)k+=`${j>1?`indicesIndices[${P}]`:"indicesIndices"} = ${m.length>1?`outputIndices[${h+P}]`:"outputIndices"};`;k+=`
        var idx = ${A.getByIndices("indicesIndices")};
        if (idx < 0) {
          idx = idx + ${o};
        }
        var dataIndices = ${$.type.indices}(0);
      `;for(let P=0,D=0;P<u;P++)P===h?(k+=`${u>1?`dataIndices[${P}]`:"dataIndices"} = u32(idx);`,D+=j):(k+=`${u>1?`dataIndices[${P}]`:"dataIndices"} = ${m.length>1?`outputIndices[${D}]`:"outputIndices"};`,D++);return k},R=j=>`
      ${j.declareVariables($,A,T)}
      ${j.mainStart()}
        ${j.guardAgainstOutOfBoundsWorkgroupSizes(y)}
        let outputIndices = ${T.offsetToIndices("global_idx")};
        ${O()};
        let value = ${$.getByIndices("dataIndices")};
        ${T.setByOffset("global_idx","value")};
      }`;return{name:"Gather",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:m,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)}}),getShaderSource:R}},Hl=t=>ye({axis:t.axis}),Ll=(t,r)=>{let e=t.inputs;Dm(e),t.compute(zm(t.inputs,r))}});var Wm,Nm,Kl,Yl,Xl=ie(()=>{"use strict";Ie();Fe();Re();Wm=t=>{if(!t||t.length!==2)throw new Error("GatherElements requires 2 inputs.");if(t[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(t[0].dims.length!==t[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},Nm=(t,r)=>{let e=t[0].dims,d=t[0].dataType,u=e.length,h=Q.computeStrides(e),m=Q.size(e),o=t[1].dims,y=t[1].dataType,$=Q.size(o),A=Q.normalizeAxis(r.axis,u),T=e[A],O=o.slice(0),R=Q.size(O),j=ne("input",d,e),k=ne("indices",y,[$]),P=fe("output",d,O),D=F=>`
      const inputStrides = array<u32, ${h.length}>(${h.map(Y=>`${Y}u`).join(",")});
      ${F.declareVariables(j,k,P)}
      ${F.mainStart()}
      ${F.guardAgainstOutOfBoundsWorkgroupSizes(R)}

      let outputIndices = ${P.offsetToIndices("global_idx")};

      var idx = ${k.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + ${T};
      }

      var srcOffset = u32(0);

      for (var i = 0; i < ${e.length}; i++) {
        if (i == ${A}) {
          srcOffset +=  u32(idx) * inputStrides[i];
        } else {
          srcOffset += ${P.indicesGet("outputIndices","i")} * inputStrides[i];
        }
      }

      // Should never hit this with valid values in indices
      // This is a guard against malicious data in the indices input
      if (srcOffset < 0 || srcOffset >= ${m}) {
        return;
      }

      output[global_idx] = input[srcOffset];
  }`;return{name:"GatherElements",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:O,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(R/64)}}),getShaderSource:D}},Kl=t=>ye({axis:t.axis}),Yl=(t,r)=>{let e=t.inputs;Wm(e),t.compute(Nm(t.inputs,r))}});var Um,Gm,Vm,Ql,Jl,Zl=ie(()=>{"use strict";Ie();Fe();Re();Um=t=>{if(!t)throw new Error("Input is missing");if(t.length<2||t.length>3)throw new Error("Invaid input number.");if(t.length===3&&t[2].dims.length>2)throw new Error("Invalid input shape of C");if(t[0].dataType!==t[1].dataType||t.length===3&&t[0].dataType!==t[2].dataType)throw new Error("Input types are mismatched")},Gm=(t,r,e)=>{if(e.length===0)return"0u";let d=e.length===1&&t!==1||e.length===2&&e[0]!==t,u=e[e.length-1]!==r,h="0u";return d||(h+=`+ m * ${e[e.length-1]}u`),u||(h+="+n"),h},Vm=(t,r)=>{let e=t[0].dims.slice(),d=t[1].dims.slice(),[u,h,m]=an.getShapeOfGemmResult(e,r.transA,d,r.transB,t.length===3?t[2].dims:void 0),o=[u,h];if(!o)throw new Error("Can't use gemm on the given tensors");let y=Q.size(o),$="";r.transA&&r.transB?$="value += a[k * M + m] * b[n * K + k];":r.transA&&!r.transB?$="value += a[k * M + m] * b[k * N + n];":!r.transA&&r.transB?$="value += a[m * K + k] * b[n * K + k];":!r.transA&&!r.transB&&($="value += a[m * K + k] * b[k * N + n];");let A=He(t[0].dataType),T=r.alpha===1?"":"value *= alpha;",O=t.length===3?`value += beta * c[${Gm(u,h,t[2].dims)}];`:"",R=[`@group(0) @binding(0) var<storage, read> a : array<${A}>;`,`@group(0) @binding(1) var<storage, read> b : array<${A}>;`];t.length===3&&R.push(`@group(0) @binding(2) var<storage, read> c : array<${A}>;`);let j=k=>`
  const M: u32 = ${u}u;
  const N: u32 = ${h}u;
  const K: u32 = ${m}u;
  const alpha = ${A}(${r.alpha});
  const beta = ${A}(${r.beta});

  ${R.join(`
`)}
  @group(0) @binding(${t.length}) var<storage, read_write> output : array<${A}>;

  ${k.mainStart()}
    ${k.guardAgainstOutOfBoundsWorkgroupSizes(y)}

    let m = global_id.x / N;
    let n = global_id.x % N;

    var value = ${A}(0);
    for (var k: u32 = 0u; k<${m}u; k++) {
      ${$}
    }

    ${T}
    ${O}
    output[global_id.x] = value;

  }`;return{name:"Gemm",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:o,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)}}),getShaderSource:j}},Ql=(t,r)=>{Um(t.inputs),t.compute(Vm(t.inputs,r))},Jl=t=>ye(t)});var Fm,Hm,Lm,qm,ed,td,rd=ie(()=>{"use strict";Ye();Ie();Fe();Re();Fm={name:"InstanceNormalization"},Hm=(t,r)=>{let e=t[0].dims,d=e,u=2,h=Q.sizeToDimension(e,u),m=Q.sizeFromDimension(e,u),o=e[1],y=ne("x",t[0].dataType,[e[0],e[1],m]),$=ne("scale",t[1].dataType,t[1].dims),A=ne("bias",t[2].dataType,t[2].dims),T=fe("output",t[0].dataType,[e[0],e[1],m]),O=[y,$,A,T],R=y.type.value,j=64,k=P=>`

  const C: u32 = ${o};
  const normSize: u32 = ${m};
  const epsilon: f32 = ${r.epsilon};
  var<workgroup> meanShared : ${R};
  var<workgroup> squaredNormShared : ${R};
  var<workgroup> workgroupShared : array<${R}, ${j}>;
  const workgroupSize = ${j}u;
  ${P.declareVariables(...O)}
  ${P.mainStart(j)}
    let norm = global_idx / workgroupSize;
    let batch = norm / C;
    let channel = norm % C;
    let localIndex = local_id.x;

    // initialize workgroup memory
    var initial: ${R} = 0;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      initial = initial + ${y.get("batch","channel","h")};
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the mean of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      meanShared = workgroupShared[0] / ${R}(normSize);
    }
    workgroupBarrier();

    // reinitialize workgroup memory.
    initial = 0;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      let deviation =  ${y.get("batch","channel","h")} - meanShared;
      initial = initial + deviation * deviation;
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the sum of square of deviation of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      squaredNormShared = workgroupShared[0];
    }
    workgroupBarrier();

    let invStdDev = 1 / sqrt(squaredNormShared / ${R}(normSize) + epsilon);
    let channelScale = invStdDev * ${$.getByOffset("channel")};
    let channelShift = ${A.getByOffset("channel")} - meanShared * channelScale;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      let value = ${y.get("batch","channel","h")} * channelScale + channelShift;
      ${T.set("batch","channel","h","value")};
    }
  }`;return{...Fm,shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:d,dataType:t[0].dataType}],dispatchGroup:{x:h}}),getShaderSource:k}},Lm=(t,r,e,d,u,h,m,o)=>{let y=Zt(m),$=ne("input",r.dataType,r.dims,y),A=ne("scale",e.dataType,e.dims,y),T=ne("bias",d.dataType,d.dims,y),O=64,R=y===1?"vec2f":`mat2x${y}f`,j=y===1?"f32":`vec${y}f`,k=(X,I)=>`${R}(${X}, ${I})`,P=u*m/y,D=Math.ceil(h/O),F=X=>`
  const H: u32 = ${h};
  const C: u32 = ${m/y};
  const imageSize: u32 = ${h*m/y};

  ${X.declareVariables($)}
  @group(0) @binding(1) var<storage, read_write> output : array<${R}>;

  ${X.mainStart(O)}
    let currentImageNumber = global_idx / ${O} / C;
    let currentChannelNumber = (global_idx / ${O}) % C;
    let wgId = global_idx % ${O};
    let wgOffset = wgId * ${D};
    if (wgOffset >= H) {
        return;
    }
    let wgMax = min(wgOffset + ${D}, H);

    let offset = currentImageNumber * imageSize + currentChannelNumber;
    var sum = ${yt("f32",y)};
    var squaredSum = ${yt("f32",y)};
    for (var i: u32 = wgOffset; i < wgMax; i++) {
        let value = ${j}(input[offset + i * C]);
        sum += value;
        squaredSum += value * value;
    }
    output[global_idx] = ${k("sum","squaredSum")};
  }`,Y=t.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:y,n:u,h,c:m})},getRunData:()=>({outputs:[{dims:[u,m,O,2],dataType:1}],dispatchGroup:{x:u*m/y}}),getShaderSource:F},{inputs:[r],outputs:[-1]})[0],L=X=>`
  const H: u32 = ${h};
  const C: u32 = ${m/y};
  const imageSize: u32 = ${O*m/y};
  const epsilon: f32 = ${o};

  @group(0) @binding(0) var<storage, read> input : array<${R}>;
  @group(0) @binding(1) var<storage, read> scale : array<${A.type.storage}>;
  @group(0) @binding(2) var<storage, read> bias : array<${T.type.storage}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${R}>;

  ${X.mainStart()}
    ${X.guardAgainstOutOfBoundsWorkgroupSizes(P)}
    let currentImageNumber = global_idx / C;
    let currentChannelNumber = global_idx % C;

    let offset = currentImageNumber * imageSize;
    var sum = ${yt("f32",y)};
    var squaredSum = ${yt("f32",y)};
    for (var i: u32 = 0; i < ${O}; i++) {
        let value = input[offset + i + currentChannelNumber * ${O}];
        sum += value[0];
        squaredSum += value[1];
    }
    sum = sum / f32(H);
    squaredSum = squaredSum / f32(H);
    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);
    let channelScale = invStdDev * ${j}(scale[currentChannelNumber]);
    let channelShift = ${j}(bias[currentChannelNumber]) - sum * channelScale;

    output[global_idx] = ${k("channelScale","channelShift")};
  }`;return t.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:y,n:u,h,c:m,epsilon:o})},getRunData:()=>({outputs:[{dims:[u,m,2],dataType:1}],dispatchGroup:{x:Math.ceil(P/64)}}),getShaderSource:L},{inputs:[Y,e,d],outputs:[-1]})[0]},qm=(t,r,e)=>{let d=r[0].dims,u=d,h=d[0],m=d[d.length-1],o=Q.sizeFromDimension(d,1)/m,y=Zt(m),$=Q.size(u)/y,A=ne("input",r[0].dataType,r[0].dims,y),T=fe("output",r[0].dataType,u,y),O=He(r[0].dataType),R=y===1?"vec2f":`mat2x${y}f`,j=y===1?O:`vec${y}<${O}>`,k=Lm(t,r[0],r[1],r[2],h,o,m,e.epsilon),P=D=>`
  const H: u32 = ${o};
  const C: u32 = ${m/y};

  @group(0) @binding(0) var<storage, read> input : array<${A.type.storage}>;
  @group(0) @binding(1) var<storage, read> scaleInput : array<${R}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${T.type.storage}>;

  ${D.mainStart()}
    let currentImageNumber = global_idx / (C * H);
    let currentChannelNumber = global_idx % C;

    let scaleOffset = currentImageNumber * C + currentChannelNumber;
    let scale = scaleInput[scaleOffset];
    output[global_idx] = fma(input[global_idx], ${j}(scale[0]), ${j}(scale[1]));
  }`;t.compute({name:"InstanceNormalization",shaderCache:{hint:`${e.cacheKey}`},getRunData:()=>({outputs:[{dims:u,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil($/64)}}),getShaderSource:P},{inputs:[r[0],k]})},ed=t=>ye({epsilon:t.epsilon,format:t.format}),td=(t,r)=>{r.format==="NHWC"?qm(t,t.inputs,r):t.compute(Hm(t.inputs,r))}});var Km,Ym,id,nd,ad=ie(()=>{"use strict";Ye();Ie();Fe();Re();Km=t=>{if(!t||t.length<2)throw new Error("layerNorm requires at least 2 inputs.")},Ym=(t,r,e)=>{let d=t[0].dims,u=t[1],h=t[2],m=d,o=Q.normalizeAxis(r.axis,d.length),y=Q.sizeToDimension(d,o),$=Q.sizeFromDimension(d,o),A=Q.size(u.dims),T=h?Q.size(h.dims):0;if(A!==$||h&&T!==$)throw new Error(`Size of X.shape()[axis:] == ${$}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${A} and bias size of ${T}`);let O=[];for(let L=0;L<d.length;++L)L<o?O.push(d[L]):O.push(1);let R=Zt($),j=He(t[0].dataType),k=[ne("x",t[0].dataType,t[0].dims,R),ne("scale",u.dataType,u.dims,R)];h&&k.push(ne("bias",h.dataType,h.dims,R)),k.push(fe("output",t[0].dataType,m,R));let P=e>1,D=e>2;P&&k.push(fe("meanDataOutput",1,O)),D&&k.push(fe("invStdOutput",1,O));let F=L=>`
  const normSize: f32 = ${$};
  const normSizeVectorized: u32 = ${$/R};
  const epsilon: f32 = ${r.epsilon};

  ${L.declareVariables(...k)}
  ${L.mainStart()}
    ${L.guardAgainstOutOfBoundsWorkgroupSizes(y)}
    let offset = global_idx * normSizeVectorized;
    var meanVector = ${yt("f32",R)};
    var meanSquareVector = ${yt("f32",R)};

    for (var h: u32 = 0u; h < normSizeVectorized; h++) {
      let value = ${er(j,R,"x[h + offset]")};
      meanVector += value;
      meanSquareVector += value * value;
    }
    let mean = ${_r("meanVector",R)} / normSize;
    let meanSquare = sqrt(${_r("meanSquareVector",R)} 
      / normSize - mean * mean + epsilon);

    for (var j: u32 = 0; j < normSizeVectorized; j++) {
      let f32input = ${er(j,R,"x[j + offset]")};
      let f32scale = ${er(j,R,"scale[j]")};
      output[j + offset] = ${k[0].type.value}((f32input - mean) / meanSquare * f32scale
        ${h?`+ ${er(j,R,"bias[j]")}`:""}
      );
    }

    ${P?"meanDataOutput[global_idx] = mean":""};
    ${D?"invStdOutput[global_idx] = 1 / meanSquare":""};
  }`,Y=[{dims:m,dataType:t[0].dataType}];return P&&Y.push({dims:O,dataType:1}),D&&Y.push({dims:O,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${r.cacheKey}|${e}|${t.length}`},getRunData:()=>({outputs:Y,dispatchGroup:{x:Math.ceil(y/64)}}),getShaderSource:F}},id=t=>ye({axis:t.axis,epsilon:t.epsilon}),nd=(t,r)=>{Km(t.inputs),t.compute(Ym(t.inputs,r,t.outputCount))}});var Xm,od,sd=ie(()=>{"use strict";Ie();bi();Xm=t=>{if(!t||t.length!==2)throw new Error("MatMul requires 2 inputs.");if(t[0].dims[t[0].dims.length-1]!==t[1].dims[t[1].dims.length-2])throw new Error("shared dimension does not match.")},od=t=>{Xm(t.inputs);let r=St.calcShape(t.inputs[0].dims,t.inputs[1].dims,!0);if(!r)throw new Error("Can't use matmul on the given tensors");t.compute(yn(t.inputs,{activation:"",activationCacheKey:""},r))}});var Qm,Jm,Zm,eg,tg,rg,ig,ng,ag,ud,ld,dd=ie(()=>{"use strict";Ye();Ie();Fe();Re();Qm=t=>{if(!t||t.length<1)throw new Error("Too few inputs");if(t[0].dataType!==1)throw new Error("Input type must be float.");if(t.length>=2){let r=t[0].dims.length*2===t[1].dims[0];if(t.length===4&&(r=t[3].dims[0]*2===t[1].dims[0]),!r)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},Jm=(t,r,e,d,u,h,m)=>{let o=e.length,y="";for(let $=o-1;$>=0;--$)y+=`
            k = i32(${t.indicesGet("indices",$)}) - ${u[$]};
            if (k < 0) {
              break;
            }
            if (k >= ${e[$]}) {
              break;
            }
            offset += k * ${d[$]};
        `;return`
          value = ${h}(${m});
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${y}
            value = x[offset];
          }
      `},Zm=(t,r,e,d,u)=>{let h=e.length,m="";for(let o=h-1;o>=0;--o)m+=`
                k = i32(${t.indicesGet("indices",o)}) - ${u[o]};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = ${2*(e[o]-1)};
                  k = k % _2n_1;
                  if(k >= ${e[o]}) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * ${d[o]};
            `;return`
              var offset = 0;
              var k = 0;
              ${m}
              value = x[offset];
          `},eg=(t,r,e,d,u)=>{let h=e.length,m="";for(let o=h-1;o>=0;--o)m+=`
                k = i32(${t.indicesGet("indices",o)}) - ${u[o]};
                if (k < 0) {
                  k = 0;
                }
                if (k >= ${e[o]}) {
                  k = ${e[o]-1};
                }
                offset += k * ${d[o]};
            `;return`
              var offset = 0;
              var k = 0;
              ${m}
              value = x[offset];
          `},tg=(t,r,e,d,u)=>{let h=e.length,m="";for(let o=h-1;o>=0;--o)m+=`
                k = i32(${t.indicesGet("indices",o)}) - ${u[o]};
                if (k < 0)  {
                  k += ${e[o]};
                }
                if (k >= ${e[o]}) {
                  k -= ${e[o]};
                }
                offset += k * ${d[o]};
            `;return`
              var offset = 0;
              var k = 0;
              ${m}
              value = x[offset];
          `},rg=(t,r,e,d,u,h)=>{switch(u.mode){case 0:return Jm(t,r,e,d,u.pads,h,u.value);case 1:return Zm(t,r,e,d,u.pads);case 2:return eg(t,r,e,d,u.pads);case 3:return tg(t,r,e,d,u.pads);default:throw new Error("Invalid mode")}},ig=(t,r,e,d)=>{let u=r[0].dims,h=Q.padShape(u.slice(),e.pads),m=Q.size(h),o=Q.computeStrides(u),y=fe("output",r[0].dataType,h),$=ne("x",r[0].dataType,u),A=rg(y,h,u,o,e,d);return`
              ${t.declareVariables($,y)}
              ${t.mainStart()}
              ${t.guardAgainstOutOfBoundsWorkgroupSizes(m)}

              let indices = ${y.offsetToIndices("global_idx")};

              var value = ${d}(0);
              ${A}
              output[global_idx] = value;
          }`},ng=(t,r)=>{let e=Q.padShape(t[0].dims.slice(),r.pads);return{name:"Pad",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:e,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(Q.size(e)/64)}}),getShaderSource:d=>ig(d,t,r,"f32")}},ag=(t,r)=>{if(t.length>1){let e=t[1].getBigInt64Array(),d=t.length>=3&&t[2].data?t[2].getFloat32Array()[0]:0,u=t[0].dims.length,h=new Int32Array(2*u).fill(0);if(t.length>=4){let o=t[3].getBigInt64Array();for(let y=0;y<o.length;y++)h[Number(o[y])]=Number(e[y]),h[Number(o[y])+u]=Number(e[y+o.length])}else e.forEach((o,y)=>h[Number(y)]=Number(o));let m=[];return h.forEach(o=>m.push(o)),ye({mode:r.mode,value:d,pads:m})}else return r},ud=(t,r)=>{Qm(t.inputs);let e=ag(t.inputs,r);t.compute(ng(t.inputs,e),{inputs:[0]})},ld=t=>{let r=t.mode,e=t.value,d=t.pads;return ye({mode:r,value:e,pads:d})}});var wn,cd,fd,pd,hd,md,gd,yd,vd,bd,wd,$d,Cd,_d,xd,Sd=ie(()=>{"use strict";Ie();Fe();Re();wn=t=>{if(!t||t.length!==1)throw new Error("Pool ops requires 1 input.");if(t[0].dims.length!==4)throw new Error("Pool ops supports 2-D inputs only for now.")},cd=(t,r,e)=>{let d=r.format==="NHWC",u=d?[t.dims[0],t.dims[3],t.dims[1],t.dims[2]]:t.dims.slice(),h=Object.hasOwnProperty.call(r,"dilations"),m=r.kernelShape.slice(),o=r.strides.slice(),y=h?r.dilations.slice():[],$=r.pads.slice();Jt.adjustPoolAttributes(e,u,m,o,y,$);let A=Jt.computePoolOutputShape(e,u,o,y,m,$,r.autoPad),T=Object.assign({},r);return h?Object.assign(T,{kernelShape:m,strides:o,pads:$,dilations:y,cacheKey:r.cacheKey}):Object.assign(T,{kernelShape:m,strides:o,pads:$,cacheKey:r.cacheKey}),[T,d?[A[0],A[2],A[3],A[1]]:A]},fd=(t,r,e,d,u,h,m,o)=>{let y=u.format==="NHWC",$=e,A=r.type.value,T=$.length,O=Q.size(d),R=fe("output",r.type.tensor,d);if(u.kernelShape.length<=2){let j=u.kernelShape[u.kernelShape.length-1],k=u.strides[u.strides.length-1],P=u.pads[u.pads.length/2-1],D=u.pads[u.pads.length-1],F=T-(y?2:1),Y="",L="",X="";if(P+D!==0?Y=`
              for (var i: u32 = 0u; i < ${j}u; i++) {
                xIndices[${F}] = indices[${F}] * ${k} - ${P} + i;
                if (xIndices[${F}] < 0 || xIndices[${F}] >= ${$[F]}) {
                  pad++;
                  continue;
                }
                let x_val = x[${r.indicesToOffset("xIndices")}];
                ${h}
              }`:Y=`
              for (var i: u32 = 0u; i < ${j}u; i++) {
                xIndices[${F}] = indices[${F}] * ${k} - ${P} + i;
                let x_val = x[${r.indicesToOffset("xIndices")}];
                ${h}
              }`,u.kernelShape.length===2){let Z=u.kernelShape[u.kernelShape.length-2],re=u.strides[u.strides.length-2],ae=u.pads[u.pads.length/2-2],$e=u.pads[u.pads.length-2],q=T-(y?3:2),le=$[q];ae+$e!==0?L=`
                for (var j: u32 = 0u; j < ${Z}u; j++) {
                  xIndices[${q}] = indices[${q}] * ${re} - ${ae} + j;
                  if (xIndices[${q}] < 0 || xIndices[${q}] >= ${le}) {
                    pad+= ${j};
                    continue;
                  }
              `:L=`
                for (var j: u32 = 0u; j < ${Z}u; j++) {
                  xIndices[${q}] = indices[${q}] * ${re} - ${ae} + j;
                `,X=`
              }
            `}return`
            ${t.declareVariables(r,R)}

            ${t.mainStart()}
              ${t.guardAgainstOutOfBoundsWorkgroupSizes(O)}

              let indices = ${R.offsetToIndices("global_idx")};
              var xIndices = ${R.offsetToIndices("global_idx")};

              var value: ${A} = ${A}(${o});
              var pad = 0;
              ${L}
              ${Y}
              ${X}
              ${m}

              output[global_idx] = value;
            }`}else{if(y)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let j=Q.size(u.kernelShape),k=Q.computeStrides(u.kernelShape),P=k.length,D=u.pads.length,F=u.pads.reduce((X,I)=>X+I),Y="";return F?Y=`
                if (xIndices[j] >= inputDims[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${r.indicesToOffset("xIndices")}];
                ${h}
              }`:Y=`
              }
              let x_val = x[${r.indicesToOffset("xIndices")}];
              ${h}
            `,`
            ${t.declareVariables(r,R)}

            const pads = array<u32, ${D}>(${u.pads.map(X=>`${X}u`).join(",")});
            const inputDims = array<u32, ${T}>(${$.map(X=>`${X}u`).join(",")});
            const kernelStrides = array<u32, ${P}>(${k.map(X=>`${X}u`).join(",")});
            const strides = array<u32, ${P}>(${u.strides.map(X=>`${X}u`).join(",")});

            ${t.mainStart()}
              ${t.guardAgainstOutOfBoundsWorkgroupSizes(O)}

              let indices = ${R.offsetToIndices("global_idx")};
              let xIndices = ${R.offsetToIndices("global_idx")};

              var offsets: array<u32, ${P}>;

              var value = ${R.type.value}(${o});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < ${j}u; i++) {
                var offset = i;
                for (var j = 0u; j < ${P-1}u; j++) {
                  offsets[j] = offset / kernelStrides[j];
                  offset -= offsets[j] * kernelStrides[j];
                }
                offsets[${P-1}] = offset;

                isPad = false;
                for (var j = ${T-P}u; j < ${T}u; j++) {
                  xIndices[j] = indices[j] * strides[j - ${T-P}u]
                    + offsets[j - ${T-P}u] - pads[j - 2u];
                  ${Y}
              }
              ${m}

              output[global_idx] = value;
            }`}},pd=t=>({format:t.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][t.auto_pad],ceilMode:t.ceil_mode,kernelShape:t.kernel_shape,strides:t.strides,pads:t.pads}),hd=(t,r,e,d)=>{let[u,h]=cd(r,d,e),m=Q.size(u.kernelShape),o=ne("x",r.dataType,r.dims),y=o.type.value,$="value += x_val;",A="";return u.countIncludePad?A+=`value /= ${y}(${m});`:A+=`value /= ${y}(${m} - pad);`,{name:t,shaderCache:{hint:d.cacheKey},getRunData:()=>({outputs:[{dims:h,dataType:r.dataType}],dispatchGroup:{x:Math.ceil(Q.size(h)/64)}}),getShaderSource:T=>fd(T,o,r.dims,h,u,$,A,"0.0")}},md=t=>{let r=t.count_include_pad!==0,e=pd(t);if(e.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return ye({countIncludePad:r,...e})},gd=(t,r)=>{wn(t.inputs),t.compute(hd("AveragePool",t.inputs[0],!1,r))},yd={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},vd=t=>{let r=t.format;return{format:r,...yd,cacheKey:r}},bd=(t,r)=>{wn(t.inputs),t.compute(hd("GlobalAveragePool",t.inputs[0],!0,r))},wd=(t,r,e,d)=>{let[u,h]=cd(r,d,e),m=`
      value = max(x_val, value);
    `,o="",y=ne("x",r.dataType,r.dims);return{name:t,shaderCache:{hint:d.cacheKey},getRunData:()=>({outputs:[{dims:h,dataType:r.dataType}],dispatchGroup:{x:Math.ceil(Q.size(h)/64)}}),getShaderSource:$=>fd($,y,r.dims,h,u,m,o,"-1e5")}},$d=(t,r)=>{wn(t.inputs),t.compute(wd("MaxPool",t.inputs[0],!1,r))},Cd=t=>{let r=t.storage_order,e=t.dilations,d=pd(t);if(r!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(d.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return ye({storageOrder:r,dilations:e,...d})},_d=t=>{let r=t.format;return{format:r,...yd,cacheKey:r}},xd=(t,r)=>{wn(t.inputs),t.compute(wd("GlobalMaxPool",t.inputs[0],!0,r))}});var sg,ug,Id,Ad=ie(()=>{"use strict";Qt();Ye();Re();sg=(t,r,e)=>{let d=t===r,u=t<r&&e<0,h=t>r&&e>0;if(d||u||h)throw new Error("Range these inputs' contents are invalid.")},ug=(t,r,e,d)=>{let u=Math.abs(Math.ceil((r-t)/e)),h=[u],m=u,o=fe("output",d,h),y=o.type.storage,$=A=>`
        ${A.declareVariables(o)}
        ${A.mainStart()}
        ${A.guardAgainstOutOfBoundsWorkgroupSizes(m)}
        output[global_idx] = ${y}(${t}) + ${y}(global_idx) * ${y}(${e});
      }`;return{name:"Range",shaderCache:{hint:[t,r,e].map(A=>A.toString()).join("_")},getShaderSource:$,getRunData:()=>({outputs:[{dims:h,dataType:d}],dispatchGroup:{x:Math.ceil(m/64)}})}},Id=t=>{let r=0,e=0,d=0;t.inputs[0].dataType===6?(r=t.inputs[0].getInt32Array()[0],e=t.inputs[1].getInt32Array()[0],d=t.inputs[2].getInt32Array()[0]):t.inputs[0].dataType===1&&(r=t.inputs[0].getFloat32Array()[0],e=t.inputs[1].getFloat32Array()[0],d=t.inputs[2].getFloat32Array()[0]),ze.webgpu.validateInputContent&&sg(r,e,d),t.compute(ug(r,e,d,t.inputs[0].dataType),{inputs:[]})}});var lg,dg,cg,fg,pg,hg,mg,gg,yg,vg,bg,wg,$g,Cg,_g,Ed,Od,Td=ie(()=>{"use strict";Ie();Fe();Re();lg=(t,r)=>{if(t.every(e=>e>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),t.length>0){if(r.mode==="linear"){if(!(t.length===2||t.length===4&&t[0]===1&&t[1]===1||t.length===4&&t[0]===1&&t[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(r.mode==="cubic"&&!(t.length===2||t.length===4&&t[0]===1&&t[1]===1||t.length===4&&t[0]===1&&t[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},dg=(t,r,e)=>{r.every(u=>u>=0&&u<e||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let d=new Array(e).fill(1);return r.forEach((u,h)=>d[u]=t[h]),d},cg=(t,r,e,d,u,h)=>{let[m,o,y]=e>10?[1,2,3]:[-1,t.length>1?1:-1,-1],$=t[0].dims.length;if(m>0&&t.length>m&&t[m].dims.length>0)t[m].getFloat32Array().forEach(A=>h.push(A));else if(r.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(o>0&&t.length>o&&t[o].dims.length>0){if(t[o].getFloat32Array().forEach(A=>d.push(A)),d.length!==0&&d.length!==$&&e>=18&&d.length!==r.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");lg(d,r),r.axes.length>0&&dg(d,r.axes,$).forEach((A,T)=>d[T]=A)}if(y>0&&t.length>y&&(t[y].getBigInt64Array().forEach(A=>u.push(Number(A))),u.length!==$||e>=18&&u.length===r.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(r.axes.length>0){if(d.length!==r.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(u.length!==r.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof d<"u"&&typeof u<"u"&&d.length>0&&u.length>$)throw new Error("Resize requires only of scales or sizes to be specified")},fg=t=>"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(t){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`
`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${t} is not supported`)}})()+"}",pg=(t,r)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(t){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(r<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${t} is not supported`)}})()+"}",hg=(t,r,e)=>{let d=new Array(e).fill(0).concat(new Array(e).fill(1)),u=t.length===0?d:t.slice();return r.length>0?(r.forEach((h,m)=>{d[h]=u[m],d[m+e]=u[r.length+m]}),d):u},mg=(t,r,e,d)=>{let u=[];if(e.length>0)if(d.length>0){if(t.forEach(h=>u.push(h)),Math.max(...d)>t.length)throw new Error("axes is out of bound");d.forEach((h,m)=>u[h]=e[m])}else e.forEach(h=>u.push(h));else{if(r.length===0)throw new Error("Resize requires either scales or sizes.");u=t.map((h,m)=>Math.round(h*r[m]))}return u},gg=(t,r,e,d)=>{let u=(()=>{switch(d.keepAspectRatioPolicy){case"not_larger":return d.axes.length>0?Math.min(...d.axes.map(m=>e[m]),Number.MAX_VALUE):Math.min(...e,Number.MAX_VALUE);case"not_smaller":return d.axes.length>0?Math.max(...d.axes.map(m=>e[m]),Number.MIN_VALUE):Math.max(...e,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${d.keepAspectRatioPolicy} is not supported`)}})();e.fill(1,0,e.length);let h=t.slice();return d.axes.length>0?(d.axes.forEach(m=>e[m]=u),d.axes.forEach(m=>h[m]=Math.round(t[m]*e[m]))):(e.fill(u,0,e.length),h.forEach((m,o)=>h[o]=Math.round(m*e[o]))),h},yg=(t,r,e,d,u)=>`
    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${t.type.indices}) -> array<f32, ${e.length}> {
      const inputShape = array<u32, ${r.length}>(${r.map(h=>`${h}u`).join(",")});
      const outputShape = array<u32, ${e.length}>(${e.map(h=>`${h}u`).join(",")});
      const scales = array<f32, ${d.length}>(${d.map(h=>`${h}f`).join(",")});
      const roi = array<f32, ${u.length}>(${u.map(h=>`${h}f`).join(",")});
      var originalIndices: array<f32, ${e.length}>;
      for (var i:u32 = 0; i < ${e.length}; i++) {
        var outputIndex = ${e.length===1?"outputIndices":"outputIndices[i]"};
        if (scales[i] == 1.0) {
          originalIndices[i] = f32(outputIndex);
        } else {
          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],
                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${r.length}]);
        }
      }
      return originalIndices;
    }`,vg=(t,r,e,d,u,h,m)=>`
    fn calculateInputIndicesFromOutputIndices(outputIndices: ${r.type.indices}) -> ${t.type.indices} {
        const inputShape = array<u32, ${e.length}>(${e.map(o=>`${o}u`).join(",")});
        const outputShape = array<u32, ${d.length}>(${d.map(o=>`${o}u`).join(",")});
        const scales = array<f32, ${u.length}>(${u.map(o=>`${o}f`).join(",")});
        const roi = array<f32, ${h.length}>(${h.map(o=>`${o}f`).join(",")});
        var inputIndices: ${t.type.indices};
        for (var i:u32 = 0; i < ${d.length}; i++) {
          var outputIndex = ${d.length===1?"outputIndices":"outputIndices[i]"};
          var inputIndex: u32;
          if (scales[i] == 1.0) {
            inputIndex = outputIndex;
          } else {
            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],
                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${e.length}]);
            if (!${m} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {
              if (original_idx < 0) {
                inputIndex = 0;
              } else if (original_idx > (f32(inputShape[i]) - 1)) {
                inputIndex = inputShape[i] - 1;
              } else {
                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));
              }
            } else {
              inputIndex = u32(original_idx);
            }
          }
          ${t.indicesSet("inputIndices","i","inputIndex")}
        }
        return inputIndices;
    }`,bg=(t,r)=>`
    fn checkInputIndices(inputIndices: ${t.type.indices}) -> bool {
      const inputShape = array<u32, ${r.length}>(${r.map(e=>`${e}u`).join(",")});
      for (var i:u32 = 0; i < ${r.length}; i++) {
        var inputIndex = ${r.length===1?"inputIndices":"inputIndices[i]"};
        if (inputIndex < 0 || inputIndex >= inputShape[i]) {
          return false;
        }
      }
      return true;
    }`,wg=(t,r,e,d,u,h,m)=>{let[o,y,$,A]=e.length===2?[-1,0,1,-1]:u[1]===1?[0,2,3,1]:[0,1,2,3];return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {
      var inputIndices: ${t.type.indices};
      inputIndices[${y}] = max(0, min(row, ${e[y]} - 1));
      inputIndices[${$}] = max(0, min(col, ${e[$]} - 1));
      if (${e.length} > 2) {
        inputIndices[${A}] = channel;
        inputIndices[${o}] = batch;
      };
      return input[${t.indicesToOffset("inputIndices")}];
    }

    fn bilinearInterpolation(outputIndices: ${r.type.indices}) -> f32 {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);
      var row:f32 = originalIndices[${y}];
      var col:f32 = originalIndices[${$}];
      if (${h} && (row < 0 || row > (${e[y]} - 1) || col < 0 || col > ${e[$]} - 1)) {
        return ${m};
      }
      row = max(0, min(row, ${e[y]} - 1));
      col = max(0, min(col, ${e[$]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = 0;
      var batch: u32 = 0;
      if (${e.length>2}) {
        channel = u32(originalIndices[${A}]);
        batch = u32(originalIndices[${o}]);
      }
      var x11: f32 = getInputValue(batch, channel, row1, col1);
      var x12: f32 = getInputValue(batch, channel, row1, col2);
      var x21: f32 = getInputValue(batch, channel, row2, col1);
      var x22: f32 = getInputValue(batch, channel, row2, col2);
      var dx1: f32 = row - f32(row1);
      var dx2: f32 = f32(row2 ) - row;
      var dy1 = col - f32(col1);
      var dy2 = f32(col2) - col;
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},$g=(t,r,e,d,u,h,m,o,y,$)=>{let[A,T]=e.length===2?[0,1]:u[1]===1?[2,3]:[1,2],O=R=>{let j=R===A?"row":"col";return`
      fn ${j}CubicInterpolation(inputIndices: ${t.type.indices}, outputIndices: ${r.type.indices}) -> f32 {
        var outputIndex = ${d.length===1?"outputIndices":`outputIndices[${R}]`};
        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${u[R]},
        f32(${d[R]}), f32(${e[R]}), ${h[R]}, ${h[R]} + ${e.length});
        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${o} && (originalIdx < 0 || originalIdx > (${e[R]} - 1))) {
          return ${y};
        }
        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${j}: f32 = originalIdx + f32(i);
          if (${j} < 0 || ${j} >= ${e[R]}) {
            if (${$}) {
              coefs[i + 1] = 0.0;
              continue;
            } else if (${o}) {
              return ${y};
            } else {
              ${j} = max(0, min(${j}, ${e[R]} - 1));
            }
          }
          var inputIndicesCopy: ${t.type.indices} = inputIndices;
          inputIndicesCopy[${R}] = u32(${j});
          data[i + 1] = ${R===A?`input[${t.indicesToOffset("inputIndicesCopy")}];`:`
                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);`}
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${O(A)};
    ${O(T)};
  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {
    var absS = abs(s);
    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: f32 = 1.0 - absS;
    var twoMinusAbsS: f32 = 2.0 - absS;
    var onePlusAbsS: f32 = 1.0 + absS;
    coeffs[0] = ((${m} * onePlusAbsS - 5 * ${m}) * onePlusAbsS + 8 * ${m}) * onePlusAbsS - 4 * ${m};
    coeffs[1] = ((${m} + 2) * absS - (${m} + 3)) * absS * absS + 1;
    coeffs[2] = ((${m} + 2) * oneMinusAbsS - (${m} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${m} * twoMinusAbsS - 5 * ${m}) * twoMinusAbsS + 8 * ${m}) * twoMinusAbsS - 4 * ${m};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {
    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(outputIndices: ${r.type.indices}) -> f32 {
    var inputIndices: ${t.type.indices} = outputIndices;
    return colCubicInterpolation(inputIndices, outputIndices);
  }
    `},Cg=(t,r,e,d,u,h)=>{let m=t.dims,o=hg(h,r.axes,m.length),y=mg(m,d,u,r.axes),$=d.slice();d.length===0&&($=m.map((P,D)=>P===0?1:y[D]/P),r.keepAspectRatioPolicy!=="stretch"&&(y=gg(m,y,$,r)));let A=fe("output",t.dataType,y),T=ne("input",t.dataType,m),O=Q.size(y),R=m.length===y.length&&m.every((P,D)=>P===y[D]),j=r.coordinateTransformMode==="tf_crop_and_resize",k=P=>`
      ${fg(r.coordinateTransformMode)};
      ${(()=>{switch(r.mode){case"nearest":return`
              ${bg(T,m)};
              ${pg(r.nearestMode,e)};
              ${vg(T,A,m,y,$,o,j)};
              `;case"linear":return`
              ${yg(A,m,y,$,o)};
              ${wg(T,A,m,y,$,j,r.extrapolationValue)};
              `;case"cubic":return`
            ${$g(T,A,m,y,$,o,r.cubicCoeffA,j,r.extrapolationValue,r.excludeOutside)};
            `;default:throw Error("Invalid resize mode")}})()};
      ${P.declareVariables(T,A)}
      ${P.mainStart()}
        ${P.guardAgainstOutOfBoundsWorkgroupSizes(O)}
        if (${R}) {
          output[global_idx] = input[global_idx];
        } else {
          let outputIndices = ${A.offsetToIndices("global_idx")};
          var inputIndices: ${T.type.indices};
          ${(()=>{switch(r.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);
                  if (checkInputIndices(inputIndices)) {
                    output[global_idx] = input[${T.indicesToOffset("inputIndices")}];
                  } else {
                    output[global_idx] = ${r.extrapolationValue};
                  }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${r.mode}`)}})()};
        }
      }`;return{name:"Resize",shaderCache:{hint:`${r.cacheKey}|${e}|${$.length>0?$:""}|${u.length>0?u:""}`},getShaderSource:k,getRunData:()=>({outputs:[{dims:y,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(O/64)}})}},_g=t=>{let r=t.customDataBuffer;return new Uint32Array(r,r.byteOffset,1)[0]},Ed=(t,r)=>{let e=[],d=[],u=[],h=_g(t);cg(t.inputs,r,h,e,d,u),t.compute(Cg(t.inputs[0],r,h,e,d,u),{inputs:[0]})},Od=t=>{let r=t.antialias,e=t.axes,d=t.coordinateTransformMode,u=t.cubicCoeffA,h=t.excludeOutside!==0,m=t.extrapolationValue,o=t.keepAspectRatioPolicy,y=t.mode,$=t.nearestMode===""?"simple":t.nearestMode;return ye({antialias:r,axes:e,coordinateTransformMode:d,cubicCoeffA:u,excludeOutside:h,extrapolationValue:m,keepAspectRatioPolicy:o,mode:y,nearestMode:$})}});var xg,Sg,Rd,kd,jd=ie(()=>{"use strict";Ye();Ie();Fe();Re();xg=t=>{if(!t||t.length<3)throw new Error("layerNorm requires at least 3 inputs.");let r=t[0],e=t[1],d=t[2];if(r.dataType!==e.dataType||r.dataType!==d.dataType)throw new Error("All inputs must have the same data type");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Input must be 2D or 3D");if(e.dims.length!==3&&e.dims.length!==2)throw new Error("Skip must be 2D or 3D");let u=r.dims[r.dims.length-1],h=r.dims[r.dims.length-2];if(e.dims[e.dims.length-1]!==u)throw new Error("Skip must have the same hidden size as input");if(e.dims[e.dims.length-2]!==h)throw new Error("Skip must have the same sequence length as input");if(d.dims.length!==1)throw new Error("Gamma must be 1D");if(d.dims[d.dims.length-1]!==u)throw new Error("Gamma must have the same hidden size as input");if(t.length>3){let m=t[3];if(m.dims.length!==1)throw new Error("Beta must be 1D");if(m.dims[m.dims.length-1]!==u)throw new Error("Beta must have the same hidden size as input")}if(t.length>4){let m=t[4];if(m.dims.length!==1)throw new Error("Bias must be 1D");if(m.dims[m.dims.length-1]!==u)throw new Error("Bias must have the same hidden size as input")}},Sg=(t,r,e,d)=>{let u=t[0].dims,h=Q.size(u),m=u,o=h,y=u.slice(-1)[0],$=d?u.slice(0,-1).concat(1):[],A=t.length>3,T=t.length>4,O=d&&e>1,R=d&&e>2,j=e>3,k=Zt(y),P=[ne("x",t[0].dataType,t[0].dims,k),ne("skip",t[1].dataType,t[1].dims,k),ne("gamma",t[2].dataType,t[2].dims,k)];A&&P.push(ne("beta",t[3].dataType,t[3].dims,k)),T&&P.push(ne("bias",t[4].dataType,t[4].dims,k)),P.push(fe("output",t[0].dataType,m,k)),O&&P.push(fe("meanOutput",1,$)),R&&P.push(fe("invStdOutput",1,$)),j&&P.push(fe("inputSkipBiasSum",t[0].dataType,m,k));let D=He(t[0].dataType),F=L=>`
      const hiddenSize: f32 = ${y};
      const hiddenSizeVectorized: u32 = ${y/k};
      const epsilon: f32 = ${r.epsilon};

      ${L.declareVariables(...P)}

      ${L.mainStart()}
        ${L.guardAgainstOutOfBoundsWorkgroupSizes(o/y)}
        let offset = global_idx * hiddenSizeVectorized;
        var sum = ${yt("f32",k)};
        var squareSum = ${yt("f32",k)};
        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {
          let skipValue = skip[offset + i];
          let biasValue = ${T?"bias[i]":"0.0"};
          let inputValue = x[offset + i];
          let value = inputValue + skipValue + biasValue;
          ${j?"inputSkipBiasSum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32Value = ${er(D,k,"value")};
          sum += f32Value;
          squareSum += f32Value * f32Value;
        }
        let mean = ${_r("sum",k)} / hiddenSize;
        let variance = sqrt(${_r("squareSum",k)} / hiddenSize - mean * mean + epsilon);
        ${O?"meanOutput[global_idx] = mean;":""}
        ${R?"invStdOutput[global_idx] = 1.0 / variance;":""}
        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {
          output[offset + i] = (output[offset + i] - ${D}(mean)) / ${D}(variance) * gamma[i]
           + ${A?"beta[i]":"0.0"};
        }
      }`,Y=[{dims:m,dataType:t[0].dataType}];return e>1&&Y.push({dims:$,dataType:1}),e>2&&Y.push({dims:$,dataType:1}),e>3&&Y.push({dims:u,dataType:t[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:r.cacheKey},getShaderSource:F,getRunData:()=>({outputs:Y,dispatchGroup:{x:Math.ceil(o/y/64)}})}},Rd=(t,r)=>{xg(t.inputs);let d=[0];t.outputCount>1&&d.push(-3),t.outputCount>2&&d.push(-3),t.outputCount>3&&d.push(3),t.compute(Sg(t.inputs,r,t.outputCount,!1),{outputs:d})},kd=t=>{let r=t.epsilon;return ye({epsilon:r})}});var Ig,$n,Ag,Pd,Eg,Og,Bd,Md,Dd=ie(()=>{"use strict";Ye();Ie();Fe();Re();Ig=(t,r)=>{if(!t||t.length<1)throw new Error("too few inputs");if(r.axes.length!==0){if(r.axes.length!==r.starts.length||r.axes.length!==r.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(r.starts.length!==r.ends.length)throw new Error("starts and ends must have the same length");t.slice(1).forEach((e,d)=>{if(t[d+1].dataType!==6&&t[d+1].dataType!==7)throw new Error(`Input ${d} must be an array of int32 or int64`)})},$n=(t,r)=>{let e=[];if(t.length>r)if(t[r].dataType===7)t[r].getBigInt64Array().forEach(d=>e.push(Number(d)));else if(t[r].dataType===6)t[r].getInt32Array().forEach(d=>e.push(Number(d)));else throw new Error(`Input ${r} must be an array of int32 or int64`);return e},Ag=(t,r)=>{if(t.length>1){let e=$n(t,1),d=$n(t,2),u=$n(t,3);return u.length===0&&(u=[...Array(t[0].dims.length).keys()]),ye({starts:e,ends:d,axes:u})}else return r},Pd=(t,r,e,d,u)=>{let h=t;return t<0&&(h+=e[d[r]]),u[r]<0?Math.max(0,Math.min(h,e[d[r]]-1)):Math.max(0,Math.min(h,e[d[r]]))},Eg=(t,r,e,d)=>`fn calculateInputIndices(outputIndices: ${r.type.indices}) -> ${t.type.indices} {
          var inputIndices: ${t.type.indices};
          var carry = 0u;
          for (var i = ${e.length}; i >= 0; i--) {
            var outputIndex = ${d.length===1?"outputIndices":"outputIndices[i]"};
            var inputIndex = outputIndex * steps[i] + starts[i] + carry;
            carry = inputIndex / inputShape[i];
            inputIndex = inputIndex % inputShape[i];
            if (signs[i] < 0) {
              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];
            }
            ${e.length===1?"inputIndices":"inputIndices[i]"} = inputIndex;
          }
          return inputIndices;
      }`,Og=(t,r)=>{let e=t[0].dims,d=Q.size(e),u=r.axes.length>0?Q.normalizeAxes(r.axes,e.length):[...Array(e.length).keys()],h=$n(t,4);h.forEach(k=>k!==0||(()=>{throw new Error("step cannot be 0")})),h.length===0&&(h=Array(u.length).fill(1));let m=r.starts.map((k,P)=>Pd(k,P,e,u,h)),o=r.ends.map((k,P)=>Pd(k,P,e,u,h));if(u.length!==e.length)for(let k=0;k<e.length;++k)u.includes(k)||(m.splice(k,0,0),o.splice(k,0,e[k]),h.splice(k,0,1));let y=h.map(k=>Math.sign(k));h.forEach((k,P,D)=>{if(k<0){let F=(o[P]-m[P])/k,Y=m[P],L=Y+F*h[P];m[P]=L,o[P]=Y,D[P]=-k}});let $=e.slice(0);u.forEach((k,P)=>{$[k]=Math.ceil((o[k]-m[k])/h[k])});let A={dims:$,dataType:t[0].dataType},T=fe("output",t[0].dataType,$),O=ne("input",t[0].dataType,e),R=Q.size($),j=k=>`
      ${k.declareVariables(O,T)}
        const signs = array<i32, ${y.length}>(${y.map(P=>`${P}i`).join(",")});
        const starts = array<u32, ${m.length}>(${m.map(P=>`${P}u`).join(",")});
        const ends = array<u32, ${o.length}>(${o.map(P=>`${P}u`).join(",")});
        const steps = array<u32, ${h.length}>(${h.map(P=>`${P}u`).join(",")});
        const inputShape = array<u32, ${e.length}>(${e.map(P=>`${P}u`).join(",")});

        ${Eg(O,T,e,$)}
        ${k.mainStart()}
          ${k.guardAgainstOutOfBoundsWorkgroupSizes(R)}
          let outputIndices = ${T.offsetToIndices("global_idx")};
          let inputIndices = calculateInputIndices(outputIndices);
          ${T.setByOffset("global_idx",O.getByIndices("inputIndices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${r.cacheKey}|${t[4]?.dims??""}`},getShaderSource:j,getRunData:()=>({outputs:[A],dispatchGroup:{x:Math.ceil(d/64)}})}},Bd=(t,r)=>{Ig(t.inputs,r);let e=Ag(t.inputs,r);t.compute(Og(t.inputs,e),{inputs:[0]})},Md=t=>{let r=t.starts,e=t.ends,d=t.axes;return ye({starts:r,ends:e,axes:d})}});var Tg,Rg,zd,Wd,Nd=ie(()=>{"use strict";Ie();Fe();Re();Tg=t=>{if(!t||t.length!==1)throw new Error("Softmax op requires 1 input.")},Rg=(t,r)=>{let e=He(t.dataType),d=t.dims,u=Q.size(d),h=64,m=r.axis;if(m<0&&(m=d.length+m),m<d.length-1)throw new Error("softmax only supports last axis for now.");let o=d[m],y=u/o,$=e==="f32"?"var threadMax: f32 = -3.402823e+38f;":"var threadMax: f16 = -65504.0h;";return{name:"Softmax",getRunData:()=>({outputs:[{dims:d,dataType:t.dataType}],dispatchGroup:{x:y}}),getShaderSource:T=>`
      var<workgroup> rowMaxShared : ${e};
      var<workgroup> rowSumShared : ${e};
      var<workgroup> threadShared : array<${e}, ${h}>;

      @group(0) @binding(0) var<storage, read> x : array<${e}>;
      @group(0) @binding(1) var<storage, read_write> result : array<${e}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${e} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${e}) {
        let index = row * row_stride + col;
        result[index] = value;
      }

      @compute @workgroup_size(${h}, 1, 1)
      fn main(@builtin(local_invocation_id) local_id : vec3<u32>, @builtin(global_invocation_id) global_id : vec3u) {
        let gindex = i32(global_id.x);
        let lindex = i32(local_id.x);
        const wg = ${h};
        let row = gindex / wg;
        let cols = ${o};
        let row_stride : i32 = ${o};

        // find the rows max
        ${$}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = threadShared[0];
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum: ${e} = 0.0;
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = threadShared[0];
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`}},zd=(t,r)=>{Tg(t.inputs),t.compute(Rg(t.inputs[0],r))},Wd=t=>ye({axis:t.axis})});var kg,jg,Pg,Bg,Mg,Ud,Gd,Vd=ie(()=>{"use strict";Ie();Fe();Re();kg=t=>{if(!t||t.length<1)throw new Error("too few inputs")},jg=(t,r)=>{let e=[],d=r.numOutputs;return t[1].dims[0]>0&&(t[1].getBigInt64Array().forEach(u=>e.push(Number(u))),d=e.length),ye({numOutputs:d,axis:r.axis,splitSizes:e})},Pg=t=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${t}u; i += 1u ) {
    if (index < sizeInConcatAxis[i]) {
        return i;
    }
    }
    return ${t}u;
}`,Bg=t=>{let r=t.length,e=[];for(let d=0;d<r;++d){let u=t[d].setByIndices("indices","input[global_idx]");r===1?e.push(u):d===0?e.push(`if (outputNumber == ${d}u) { ${u} }`):d===r-1?e.push(`else { ${u} }`):e.push(`else if (outputNumber == ${d}) { ${u} }`)}return`
      fn writeBufferData(outputNumber: u32, indices: ${t[0].type.indices}, global_idx: u32) {
        ${e.join(`
`)}
      }`},Mg=(t,r)=>{let e=t[0].dims,d=Q.size(e),u=t[0].dataType,h=e.length,m=r.axis,o=m<0?e.length+m:m,y=new Array(r.numOutputs),$=ne("input",u,e),A=new Array(r.numOutputs),T=[],O=[],R=0;for(let P=0;P<r.numOutputs;P++){R+=r.splitSizes[P],A[P]=R;let D=e.slice();D[r.axis]=r.splitSizes[P],O.push(D),y[P]=fe(`output${P}`,u,O[P]),T.push({dims:O[P],dataType:t[0].dataType})}let j=h<2?"indices":`indices[${o}]`,k=P=>`
  ${P.declareVariables($,...y)}
  const sizeInConcatAxis = array<u32, ${A.length}>(${A.map(D=>`${D}u`).join(",")});
  ${Pg(A.length)}
  ${Bg(y)}

  ${P.mainStart()}
    ${P.guardAgainstOutOfBoundsWorkgroupSizes(d)}

    var indices = ${$.offsetToIndices("global_idx")};
    let outputNumber = calculateOutputIndex(${j});
    if (outputNumber != 0) {
        ${j} -= sizeInConcatAxis[outputNumber - 1u];
    }
    writeBufferData(outputNumber, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:r.cacheKey},getShaderSource:k,getRunData:()=>({outputs:T,dispatchGroup:{x:Math.ceil(d/64)}})}},Ud=(t,r)=>{kg(t.inputs);let e=t.inputs.length===1?r:jg(t.inputs,r);t.compute(Mg(t.inputs,e),{inputs:[0]})},Gd=t=>{let r=t.axis,e=t.splitSizes,d=t.numOutputs<0?e.length:t.numOutputs;if(d!==e.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ye({axis:r,numOutputs:d,splitSizes:e})}});var Fd,Dg,zg,Wg,Hd,Ld=ie(()=>{"use strict";Ye();Ie();Re();Fd=t=>Array.from(t.getBigInt64Array(),Number),Dg=t=>{if(!t||t.length!==2)throw new Error("Tile requires 2 inputs.");if(t[0].dataType!==1&&t[0].dataType!==6&&t[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(t[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(t[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(Fd(t[1]).length!==t[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},zg=(t,r)=>{let e=[];for(let d=0;d<t.length;++d)e.push(t[d]*r[d]);return e},Wg=t=>{let r=t[0].dims,e=Fd(t[1]),d=zg(r,e),u=Q.size(d),h=t[0].dataType,m=ne("input",h,r),o=fe("output",h,d),y=$=>`
      const inputShape = ${m.indices(...r)};
      ${$.declareVariables(m,o)}
      ${$.mainStart()}
      ${$.guardAgainstOutOfBoundsWorkgroupSizes(u)}
      let outputIndices = ${o.offsetToIndices("global_idx")};
      var inputIndices: ${m.type.indices};
      for (var i = 0; i < ${r.length}; i++) {
        let inputDimValue = ${o.indicesGet("outputIndices","i")}  % ${m.indicesGet("inputShape","i")};

        ${m.indicesSet("inputIndices","i","inputDimValue")}
      }
      ${o.setByOffset("global_idx",m.getByIndices("inputIndices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${e}`},getRunData:()=>({outputs:[{dims:d,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:y}},Hd=t=>{Dg(t.inputs),t.compute(Wg(t.inputs),{inputs:[0]})}});var Ng,Ug,qd,Kd=ie(()=>{"use strict";Ye();Ie();Re();Ng=(t,r,e,d,u)=>{let h=Q.size(e),m=Math.ceil(h/4),o=fe("outputData",u,e,4),y=ne("aData",r[1].dataType,r[1].dims,4),$=ne("bData",r[2].dataType,r[2].dims,4),A=ne("cData",r[0].dataType,r[0].dims,4),T,O=(R,j,k)=>`select(${j}, ${R}, ${k})`;if(!d)T=o.setByOffset("global_idx",O(y.getByOffset("global_idx"),$.getByOffset("global_idx"),A.getByOffset("global_idx")));else{let R=(j,k,P="")=>{let D=`aData[indexA${k}][componentA${k}]`,F=`bData[indexB${k}][componentB${k}]`,Y=`bool(cData[indexC${k}] & ${4278190080>>>(3-k)*8}u)`;return`
            let outputIndices${k} = ${o.offsetToIndices(`global_idx * 4u + ${k}u`)};
            let offsetA${k} = ${y.broadcastedIndicesToOffset(`outputIndices${k}`,o)};
            let offsetB${k} = ${$.broadcastedIndicesToOffset(`outputIndices${k}`,o)};
            let offsetC${k} = ${A.broadcastedIndicesToOffset(`outputIndices${k}`,o)};
            let indexA${k} = offsetA${k} / 4u;
            let indexB${k} = offsetB${k} / 4u;
            let indexC${k} = offsetC${k} / 4u;
            let componentA${k} = offsetA${k} % 4u;
            let componentB${k} = offsetB${k} % 4u;
            ${j}[${k}] = ${P}(${O(D,F,Y)});
          `};u===9?T=`
            var data = vec4<u32>(0);
            ${R("data",0,"u32")}
            ${R("data",1,"u32")}
            ${R("data",2,"u32")}
            ${R("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:T=`
            ${R("outputData[global_idx]",0)}
            ${R("outputData[global_idx]",1)}
            ${R("outputData[global_idx]",2)}
            ${R("outputData[global_idx]",3)}
          `}return`
        ${t.declareVariables(A,y,$,o)}
        ${t.mainStart()}
        ${t.guardAgainstOutOfBoundsWorkgroupSizes(m)}
        ${T}
      }`},Ug=t=>{let r=t[1].dims,e=t[2].dims,d=t[0].dims,u=t[1].dataType,h=!(Q.areEqual(r,e)&&Q.areEqual(e,d)),m=r,o=Q.size(r);if(h){let y=St.calcShape(St.calcShape(r,e,!1),d,!1);if(!y)throw new Error("Can't perform where op on the given tensors");m=y,o=Q.size(m)}return{name:"Where",getShaderSource:y=>Ng(y,t,m,h,u),getRunData:()=>({outputs:[{dims:m,dataType:u}],dispatchGroup:{x:Math.ceil(o/64/4)}})}},qd=t=>{t.compute(Ug(t.inputs))}});var Yd,Xd=ie(()=>{"use strict";xu();Iu();al();gl();bl();aa();Dl();Ul();Fl();ql();Xl();Zl();rd();ad();sd();dd();Sd();Ad();Jn();Td();jd();Dd();Nd();Vd();Ld();vn();ta();Kd();Yd=new Map([["Abs",[Au]],["Acos",[Eu]],["Acosh",[Ou]],["Add",[ol]],["ArgMax",[_u,Zn]],["ArgMin",[Cu,Zn]],["Asin",[Tu]],["Asinh",[Ru]],["Atan",[ku]],["Atanh",[ju]],["AveragePool",[gd,md]],["BiasAdd",[Su]],["BiasSplitGelu",[nl]],["Cast",[Bu,Pu]],["Ceil",[Du]],["ClipV10",[ea]],["Clip",[Mu]],["Concat",[yl,vl]],["Conv",[Tl,Ol]],["ConvTranspose",[Ml,Bl]],["Cos",[zu]],["Cosh",[Wu]],["Div",[sl]],["Einsum",[Wl,Nl]],["Elu",[Nu,ln]],["Equal",[ul]],["Erf",[Uu]],["Exp",[Gu]],["Expand",[Vl]],["Floor",[Vu]],["Gather",[Ll,Hl]],["GatherElements",[Yl,Kl]],["Gelu",[Fu]],["Gemm",[Ql,Jl]],["GlobalAveragePool",[bd,vd]],["GlobalMaxPool",[xd,_d]],["Greater",[fl]],["GreaterOrEqual",[hl]],["InstanceNormalization",[td,ed]],["LayerNormalization",[nd,id]],["LeakyRelu",[Hu,ln]],["Less",[pl]],["LessOrEqual",[ml]],["Log",[il]],["MatMul",[od]],["MaxPool",[$d,Cd]],["Mul",[ll]],["Neg",[qu]],["Not",[Lu]],["Pad",[ud,ld]],["Pow",[dl]],["Range",[Id]],["Reciprocal",[Ku]],["ReduceMin",[gu,vt]],["ReduceMean",[mu,vt]],["ReduceMax",[hu,vt]],["ReduceSum",[vu,vt]],["ReduceProd",[yu,vt]],["ReduceL1",[cu,vt]],["ReduceL2",[fu,vt]],["ReduceLogSum",[du,vt]],["ReduceLogSumExp",[pu,vt]],["ReduceSumSquare",[bu,vt]],["Relu",[Yu]],["Resize",[Ed,Od]],["Sigmoid",[Xu]],["Sin",[Qu]],["Sinh",[Ju]],["Slice",[Bd,Md]],["SkipLayerNormalization",[Rd,kd]],["Split",[Ud,Gd]],["Sqrt",[Zu]],["Softmax",[zd,Wd]],["Sub",[cl]],["Tan",[el]],["Tanh",[tl]],["ThresholdedRelu",[rl,ln]],["Tile",[Hd]],["Transpose",[Sl,Il]],["Where",[qd]]])});var Cn,Qd=ie(()=>{"use strict";Ye();Pt();Re();Cn=class{constructor(r){this.backend=r;this.repo=new Map,this.attributesBound=!1}getArtifact(r){return this.repo.get(r)}setArtifact(r,e){this.repo.set(r,e)}run(r,e,d,u,h,m,o){let y=this.backend.device,$=this.backend.getComputePassEncoder(),A=this.backend.supportTimestampQuery&&this.backend.env.webgpu.profilingMode==="default";A&&$.writeTimestamp(this.backend.profilingQuerySet,0),$.setPipeline(r.computePipeline);let T=[];for(let R of u)T.push({binding:T.length,resource:{buffer:R.buffer}});for(let R of h)T.push({binding:T.length,resource:{buffer:R.buffer}});o&&T.push({binding:T.length,resource:o});let O=y.createBindGroup({layout:r.computePipeline.getBindGroupLayout(0),entries:T,label:r.programInfo.name});if($.setBindGroup(0,O),$.dispatchWorkgroups(...m),this.backend.pendingDispatchNumber++,A){$.writeTimestamp(this.backend.profilingQuerySet,1),this.backend.profilingQueryData==null&&(this.backend.profilingQueryData=this.backend.gpuDataManager.create(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let R=this.backend.gpuDataManager.create(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.profilingQuerySet,0,2,this.backend.profilingQueryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.profilingQueryData.buffer,0,R.buffer,0,16),this.backend.flush();let j=this.backend.currentKernelId,k=this.backend.kernels.get(j),P=`[${k[0]}] ${k[1]}`;R.buffer.mapAsync(GPUMapMode.READ).then(()=>{let D=new BigUint64Array(R.buffer.getMappedRange()),F=D[0],Y=D[1];R.buffer.unmap(),typeof this.backend.profilingTimeBase>"u"&&(this.backend.profilingTimeBase=F);let L=Number(F-this.backend.profilingTimeBase),X=Number(Y-this.backend.profilingTimeBase);if(!Number.isSafeInteger(L)||!Number.isSafeInteger(X))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(R.id);let I="";e.forEach((re,ae)=>{I+=`input[${ae}]: [${re.dims}] | ${pi(re.dataType)}, `});let Z="";d.forEach((re,ae)=>{Z+=`output[${ae}]: [${re.dims}] | ${pi(re.dataType)}, `}),console.log(`[profiling] kernel "${j}|${P}" ${I}${Z}execution time: ${X-L} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(r,e){let d=this.backend.device,u=[];d.features.has("shader-f16")&&u.push("enable f16;");let h=lu(e),m=r.getShaderSource(h),o=`${u.join(`
`)}
${h.additionalImplementations}
${m}`,y=d.createShaderModule({code:o,label:r.name});Ne("verbose",()=>`[WebGPU] shader code: ${o}`);let $=d.createComputePipeline({compute:{module:y,entryPoint:"main"},layout:"auto",label:r.name});return{programInfo:r,computePipeline:$}}normalizeDispatchGroupSize(r){let e=typeof r=="number"?r:r.x,d=typeof r=="number"?1:r.y||1,u=typeof r=="number"?1:r.z||1,h=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(e<=h&&d<=h&&u<=h)return[e,d,u];let m=e*d*u,o=Math.ceil(Math.sqrt(m));if(o>h){if(o=Math.ceil(Math.cbrt(m)),o>h)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[o,o,o]}else return[o,o,1]}}});var Gg,Vg,_n,Jd=ie(()=>{"use strict";Pt();ru();ou();Xd();Qd();Gg=(t,r)=>{if(r.length!==t.length)throw new Error(`inputDependencies length ${r.length} is not equal to inputTensors length ${t.length}.`);let e=[];for(let d=0;d<t.length;++d){let u=t[d].dataType;switch(r[d]){case"none":{e.push("");break}case"type":{e.push(`${u}`);break}case"rank":{let h=t[d].dims.length;e.push(`${u};${h}`);break}case"dims":{let h=t[d].dims.join(",");e.push(`${u};${h}`);break}default:throw new Error(`unsupported input dependency: ${r[d]}`)}}return e.join("|")},Vg=(t,r)=>{let e=t.name;return t.shaderCache?.hint&&(e+="["+t.shaderCache.hint+"]"),e+=`:${Gg(r,t.shaderCache?.inputDependencies??new Array(r.length).fill("dims"))}`,e},_n=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.supportTimestampQuery=!1;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let r=this.kernelCustomData.get(this.currentKernelId);return r||(r={},this.kernelCustomData.set(this.currentKernelId,r)),r}async initialize(r){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let e=await navigator.gpu.requestAdapter();if(!e)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=r;let d=[],u={requiredLimits:{maxComputeWorkgroupStorageSize:e.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:e.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:e.limits.maxStorageBufferBindingSize,maxBufferSize:e.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:e.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:e.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:e.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:e.limits.maxComputeWorkgroupSizeZ},requiredFeatures:d};e.features.has("timestamp-query-inside-passes")&&(this.supportTimestampQuery=!0,d.push("timestamp-query-inside-passes")),e.features.has("shader-f16")&&d.push("shader-f16"),this.device=await e.requestDevice(u),this.gpuDataManager=au(this),this.programManager=new Cn(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,eu(r.logLevel,!!r.debug),this.device.onuncapturederror=h=>{h.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${h.error.message}`)},this.supportTimestampQuery&&(this.profilingQuerySet=this.device.createQuerySet({type:"timestamp",count:2})),Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){return this.computePassEncoder||(this.computePassEncoder=this.getCommandEncoder().beginComputePass()),this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}run(r,e,d,u,h){let m=[];for(let D=0;D<e.length;++D){let F=this.gpuDataManager.get(e[D].data);if(!F)throw new Error(`no GPU data for input: ${e[D].data}`);m[D]=F}let o=Vg(r,e),y=this.programManager.getArtifact(o),{outputs:$,dispatchGroup:A,programUniforms:T}=r.getRunData(e),O=d.length===0?$.map((D,F)=>F):d;if(O.length!==$.length)throw new Error(`Output size ${O.length} must be equal to ${$.length}.`);let R=[],j=[];for(let D=0;D<$.length;++D){if(!Number.isInteger(O[D])||O[D]<-3||O[D]>=$.length)throw new Error(`Invalid output index: ${O[D]}`);if(O[D]===-3)continue;let F=O[D]===-1,Y=O[D]===-2,L=F||Y?h($[D].dataType,$[D].dims):u(O[D],$[D].dataType,$[D].dims),X=this.gpuDataManager.get(L.data);if(!X)throw new Error(`no GPU data for output: ${L.data}`);if(F&&this.temporaryData.push(X),Y){let I=this.kernelPersistentData.get(this.currentKernelId);I||(I=[],this.kernelPersistentData.set(this.currentKernelId,I)),I.push(X)}R.push(L),j.push(X)}let k;if(T){let D=0,F=0,Y=[],L=1;T.forEach(Z=>{let re=typeof Z.data=="number"?[Z.data]:Z.data,ae;switch(re.length){case 1:ae=4;break;case 2:ae=8;break;case 3:ae=16;break;case 4:ae=16;break;case 5:ae=16;break;case 6:ae=16;break;default:throw new Error(`unsupported data length: ${re.length}`)}(F===5||F===6)&&(ae=16),ae>L&&(L=ae),D=Math.ceil(D/ae)*ae,F=re.length,Y.push(D),D+=re.length*4}),D=Math.ceil(D/L)*L;let X=new ArrayBuffer(D);T.forEach((Z,re)=>{let ae=Y[re],$e=typeof Z.data=="number"?[Z.data]:Z.data;Z.type==="int32"?new Int32Array(X,ae,$e.length).set($e):Z.type==="uint32"?new Uint32Array(X,ae,$e.length).set($e):new Float32Array(X,ae,$e.length).set($e)});let I=this.gpuDataManager.create(D,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(I.buffer,0,X,0,D),this.gpuDataManager.release(I.id),k={offset:0,size:D,buffer:I.buffer}}let P=this.programManager.normalizeDispatchGroupSize(A);return y||(y=this.programManager.build(r,P),this.programManager.setArtifact(o,y)),Ne("info",()=>`[ProgramManager] run "${r.name}" (key=${o}) with ${P[0]}x${P[1]}x${P[2]}`),this.programManager.run(y,e,R,m,j,P,k),R}upload(r,e){this.gpuDataManager.upload(r,e)}memcpy(r,e){this.gpuDataManager.memcpy(r,e)}async download(r,e){await this.gpuDataManager.download(r,e)}alloc(r){return this.gpuDataManager.create(r).id}free(r){return this.gpuDataManager.release(r)}createKernel(r,e,d,u){let h=Yd.get(r);if(!h)throw new Error(`kernel not implemented: ${r}`);this.kernels.set(e,[r,u,h[0],[h[1],d]])}releaseKernel(r){let e=this.kernelPersistentData.get(r);if(e){for(let d of e)this.gpuDataManager.release(d.id);this.kernelPersistentData.delete(r)}this.kernelCustomData.delete(r),this.kernels.delete(r)}computeKernel(r,e,d){let u=this.kernels.get(r);if(!u)throw new Error(`kernel not created: ${r}`);let[h,m,o,y]=u;if(this.currentKernelId!==null)throw new Error(`kernel "[${h}] ${m}" is not allowed to be called recursively`);this.currentKernelId=r,y[0]&&(y[1]=y[0](y[1]),y[0]=void 0),Ne("info",()=>`[WebGPU] Start to run kernel "[${h}] ${m}"...`);let $=this.env.debug;this.temporaryData=[];try{return $&&this.device.pushErrorScope("validation"),o(e,y[1]),0}catch(A){return d.push(Promise.resolve(`[WebGPU] Kernel "[${h}] ${m}" failed. ${A}`)),1}finally{$&&d.push(this.device.popErrorScope().then(A=>A?`GPU validation error for kernel "[${h}] ${m}": ${A.message}`:null));for(let A of this.temporaryData)this.gpuDataManager.release(A.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(r,e,d,u){let h=this.sessionExternalDataMapping.get(r);h||(h=new Map,this.sessionExternalDataMapping.set(r,h));let m=h.get(e),o=this.gpuDataManager.registerExternalBuffer(d,u,m?.[1]);return h.set(e,[o,d]),o}unregisterBuffers(r){let e=this.sessionExternalDataMapping.get(r);e&&(e.forEach(d=>this.gpuDataManager.unregisterExternalBuffer(d[1])),this.sessionExternalDataMapping.delete(r))}getBuffer(r){let e=this.gpuDataManager.get(r);if(!e)throw new Error(`no GPU data for buffer: ${r}`);return e.buffer}createDownloader(r,e,d){return async()=>{let u=await Ln(this,r,e);return tu(u.buffer,d)}}}});var Zd={};$r(Zd,{init:()=>Fg});var wi,da,Fg,ec=ie(()=>{"use strict";Ye();Jd();Pt();Ie();wi=class t{constructor(r,e,d,u){this.module=r;this.dataType=e;this.data=d;this.dims=u}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let r=Q.size(this.dims);return r===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,r)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let r=Q.size(this.dims);return r===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,r)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let r=Q.size(this.dims);return r===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,r)}reshape(r){if(Q.size(r)!==Q.size(this.dims))throw new Error("Invalid new shape");return new t(this.module,this.dataType,this.data,r)}},da=class{constructor(r,e,d){this.module=r;this.backend=e;this.customDataOffset=0;this.customDataSize=0;let u=r.HEAPU32,h=d>>2;this.opKernelContext=u[h++];let m=u[h++];this.outputCount=u[h++],this.customDataOffset=u[h++],this.customDataSize=u[h++];let o=[];for(let y=0;y<m;y++){let $=u[h++],A=u[h++],T=u[h++],O=[];for(let R=0;R<T;R++)O.push(u[h++]);o.push(new wi(r,$,A,O))}this.inputs=o}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(r,e){let d=e?.inputs?.map(o=>typeof o=="number"?this.inputs[o]:o)??this.inputs,u=e?.outputs??[],h=(o,y,$)=>new wi(this.module,y,this.output(o,$),$),m=(o,y)=>{let $=hi(o);if(!$)throw new Error(`Unsupported data type: ${o}`);let A=$*Q.size(y);return new wi(this.module,o,this.backend.gpuDataManager.create(A).id,y)};return this.backend.run(r,d,u,h,m)}output(r,e){let d=this.module.stackSave();try{let u=this.module.stackAlloc((1+e.length)*4),h=u>>2;this.module.HEAPU32[h++]=e.length;for(let m=0;m<e.length;m++)this.module.HEAPU32[h++]=e[m];return this.module._JsepOutput(this.opKernelContext,r,u)}catch(u){throw new Error(`Failed to generate kernel's output[${r}] with dims [${e}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${u}`)}finally{this.module.stackRestore(d)}}},Fg=async(t,r)=>{let e=t.jsepInit;if(e&&navigator.gpu){if(!r.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let d=new _n;await d.initialize(r),e(d,u=>d.alloc(u),u=>d.free(u),(u,h,m,o=!1)=>{if(o)Ne("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${u}, dst=${h}, size=${m}`),d.memcpy(u,h);else{Ne("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${u}, gpuDataId=${h}, size=${m}`);let y=t.HEAPU8.subarray(u,u+m);d.upload(h,y)}},async(u,h,m)=>{Ne("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${u}, dataOffset=${h}, size=${m}`),await d.download(u,()=>t.HEAPU8.subarray(h,h+m))},(u,h,m)=>d.createKernel(u,h,m,r.debug||r.webgpu.profilingMode==="default"?t.UTF8ToString(t._JsepGetNodeName(h)):`${h}`),u=>d.releaseKernel(u),(u,h,m,o)=>{Ne("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${m}, kernel=${u}, contextDataOffset=${h}`);let y=new da(t,d,h);return d.computeKernel(u,y,o)})}}});var Hg,Lg,rc,$i,ca,fa,ic,nc,tc,ac,oc,sc,uc=ie(()=>{"use strict";Ys();Qs();Ye();Cr();en();Hg=t=>{let r=Ve(),e=r.stackSave();try{let d=r.stackAlloc(8);return r._OrtGetInputOutputCount(t,d,d+4)!==0&&We("Can't get session input/output count."),[r.HEAP32[d/4],r.HEAP32[d/4+1]]}finally{r.stackRestore(e)}},Lg=(t,r)=>{Ve()._OrtInit(t,r)!==0&&We("Can't initialize onnxruntime.")},rc=async t=>{Lg(t.wasm.numThreads,mi(t.logLevel));{let r=(ec(),kt(Zd)).init;await r(Ve(),t)}},$i=new Map,ca=t=>{let r=Ve(),e=r._malloc(t.byteLength);if(e===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${t.byteLength}.`);return r.HEAPU8.set(t,e),[e,t.byteLength]},fa=(t,r)=>{let e=Ve(),d=0,u=0,h=0,m=[],o=[],y=[];try{[u,m]=Xs(r),d=e._OrtCreateSession(t[0],t[1],u),d===0&&We("Can't create a session.");let[$,A]=Hg(d),T=[],O=[],R=[];for(let k=0;k<$;k++){let P=e._OrtGetInputName(d,k);P===0&&We("Can't get an input name."),o.push(P),T.push(e.UTF8ToString(P))}for(let k=0;k<A;k++){let P=e._OrtGetOutputName(d,k);P===0&&We("Can't get an output name."),y.push(P);let D=e.UTF8ToString(P);O.push(D);{let F=typeof r?.preferredOutputLocation=="string"?r.preferredOutputLocation:r?.preferredOutputLocation?.[D]??"cpu";if(F!=="cpu"&&F!=="cpu-pinned"&&F!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${F}.`);R.push(F)}}let j=null;return R.some(k=>k==="gpu-buffer")&&(h=e._OrtCreateBinding(d),h===0&&We("Can't create IO binding."),j={handle:h,outputPreferredLocations:R,outputPreferredLocationsEncoded:R.map(k=>Fn(k))}),$i.set(d,[d,o,y,j]),[d,T,O]}catch($){throw o.forEach(A=>e._OrtFree(A)),y.forEach(A=>e._OrtFree(A)),h!==0&&e._OrtReleaseBinding(h),d!==0&&e._OrtReleaseSession(d),$}finally{e._free(t[0]),u!==0&&e._OrtReleaseSessionOptions(u),m.forEach($=>e._free($))}},ic=(t,r)=>{let e=ca(t);return fa(e,r)},nc=t=>{let r=Ve(),e=$i.get(t);if(!e)throw new Error(`cannot release session. invalid session id: ${t}`);let[d,u,h,m]=e;m&&r._OrtReleaseBinding(m.handle),r.jsepUnregisterBuffers?.(t),u.forEach(o=>r._OrtFree(o)),h.forEach(o=>r._OrtFree(o)),r._OrtReleaseSession(d),$i.delete(t)},tc=(t,r,e,d,u)=>{if(!t){r.push(0);return}let h=Ve(),m=t[0],o=t[1],y=t[3],$,A;if(m==="string"&&y==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(y==="gpu-buffer"){let R=t[2].gpuBuffer,j=hi(Vn(m));A=o.reduce((k,P)=>k*P,1)*j,$=h.jsepRegisterBuffer(d,u,R,A)}else{let R=t[2];if(Array.isArray(R)){A=4*R.length,$=h._malloc(A),e.push($);let j=$/4;for(let k=0;k<R.length;k++){if(typeof R[k]!="string")throw new TypeError(`tensor data at index ${k} is not a string`);h.HEAPU32[j++]=Ke(R[k],e)}}else A=R.byteLength,$=h._malloc(A),e.push($),h.HEAPU8.set(new Uint8Array(R.buffer,R.byteOffset,A),$)}let T=h.stackSave(),O=h.stackAlloc(4*o.length);try{let R=O/4;o.forEach(k=>h.HEAP32[R++]=k);let j=h._OrtCreateTensor(Vn(m),$,A,O,o.length,Fn(y));j===0&&We(`Can't create tensor for input/output. session=${d}, index=${u}.`),r.push(j)}finally{h.stackRestore(T)}},ac=async(t,r,e,d,u,h)=>{let m=Ve(),o=$i.get(t);if(!o)throw new Error(`cannot run inference. invalid session id: ${t}`);let[y,$,A,T]=o,O=r.length,R=d.length,j=0,k=[],P=[],D=[],F=[],Y=m.stackSave(),L=m.stackAlloc(O*4),X=m.stackAlloc(O*4),I=m.stackAlloc(R*4),Z=m.stackAlloc(R*4);try{[j,k]=Ks(h);for(let ue=0;ue<O;ue++)tc(e[ue],P,F,t,r[ue]);for(let ue=0;ue<R;ue++)tc(u[ue],D,F,t,O+d[ue]);let re=L/4,ae=X/4,$e=I/4,q=Z/4;for(let ue=0;ue<O;ue++)m.HEAPU32[re++]=P[ue],m.HEAPU32[ae++]=$[r[ue]];for(let ue=0;ue<R;ue++)m.HEAPU32[$e++]=D[ue],m.HEAPU32[q++]=A[d[ue]];if(T){let{handle:ue,outputPreferredLocations:oe,outputPreferredLocationsEncoded:et}=T;if($.length!==O)throw new Error(`input count from feeds (${O}) is expected to be always equal to model's input count (${$.length}).`);for(let Ae=0;Ae<O;Ae++){let Le=r[Ae];await m._OrtBindInput(ue,$[Le],P[Ae])!==0&&We(`Can't bind input[${Ae}] for session=${t}.`)}for(let Ae=0;Ae<R;Ae++){let Le=d[Ae];u[Ae]?.[3]?m._OrtBindOutput(ue,A[Le],D[Ae],0)!==0&&We(`Can't bind pre-allocated output[${Ae}] for session=${t}.`):m._OrtBindOutput(ue,A[Le],0,et[Le])!==0&&We(`Can't bind output[${Ae}] to ${oe[Ae]} for session=${t}.`)}}let le;T?le=await m._OrtRunWithBinding(y,T.handle,R,I,j):le=await m._OrtRun(y,X,L,O,Z,R,I,j),le!==0&&We("failed to call OrtRun().");let Pe=[];for(let ue=0;ue<R;ue++){let oe=m.HEAPU32[I/4+ue];if(oe===D[ue]){Pe.push(u[ue]);continue}let et=m.stackSave(),Ae=m.stackAlloc(4*4),Le=!1,Te,Xe=0;try{m._OrtGetTensorData(oe,Ae,Ae+4,Ae+8,Ae+12)!==0&&We(`Can't access output tensor data on index ${ue}.`);let Ze=Ae/4,Ot=m.HEAPU32[Ze++];Xe=m.HEAPU32[Ze++];let ee=m.HEAPU32[Ze++],Ce=m.HEAPU32[Ze++],Oe=[];for(let Ue=0;Ue<Ce;Ue++)Oe.push(m.HEAPU32[ee/4+Ue]);m._OrtFree(ee);let tt=Oe.reduce((Ue,Be)=>Ue*Be,1);Te=pi(Ot);let it=T?.outputPreferredLocations[d[ue]];if(Te==="string"){if(it==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Ue=[],Be=Xe/4;for(let nt=0;nt<tt;nt++){let wt=m.HEAPU32[Be++],ct=nt===tt-1?void 0:m.HEAPU32[Be]-wt;Ue.push(m.UTF8ToString(wt,ct))}Pe.push([Te,Oe,Ue,"cpu"])}else if(it==="gpu-buffer"&&tt>0){let Ue=m.jsepGetBuffer(Xe),Be=hi(Ot);if(Be===void 0||!rn(Te))throw new Error(`Unsupported data type: ${Te}`);Le=!0,Pe.push([Te,Oe,{gpuBuffer:Ue,download:m.jsepCreateDownloader(Ue,tt*Be,Te),dispose:()=>{m._OrtReleaseTensor(oe)}},"gpu-buffer"])}else{let Ue=tn(Te),Be=new Ue(tt);new Uint8Array(Be.buffer,Be.byteOffset,Be.byteLength).set(m.HEAPU8.subarray(Xe,Xe+Be.byteLength)),Pe.push([Te,Oe,Be,"cpu"])}}finally{m.stackRestore(et),Te==="string"&&Xe&&m._free(Xe),Le||m._OrtReleaseTensor(oe)}}return T&&m._OrtClearBoundOutputs(T.handle),Pe}finally{m.stackRestore(Y),P.forEach(re=>m._OrtReleaseTensor(re)),D.forEach(re=>m._OrtReleaseTensor(re)),F.forEach(re=>m._free(re)),j!==0&&m._OrtReleaseRunOptions(j),k.forEach(re=>m._free(re))}},oc=t=>{let r=Ve(),e=$i.get(t);if(!e)throw new Error("invalid session id");let d=e[0],u=r._OrtEndProfiling(d);u===0&&We("Can't get an profile file name."),r._OrtFree(u)},sc=t=>{let r=[];for(let e of t){let d=e[2];!Array.isArray(d)&&"buffer"in d&&r.push(d.buffer)}return r}});var lc=wr((a$,Kg)=>{Kg.exports='/*!\n * ONNX Runtime Web v1.17.0\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var ui=Object.defineProperty;var wp=Object.getOwnPropertyDescriptor;var Cp=Object.getOwnPropertyNames;var $p=Object.prototype.hasOwnProperty;var oe=(t,r)=>()=>(t&&(r=t(t=0)),r);var Zr=(t,r)=>()=>(r||t((r={exports:{}}).exports,r),r.exports),Dn=(t,r)=>{for(var e in r)ui(t,e,{get:r[e],enumerable:!0})},xp=(t,r,e,d)=>{if(r&&typeof r=="object"||typeof r=="function")for(let l of Cp(r))!$p.call(t,l)&&l!==e&&ui(t,l,{get:()=>r[l],enumerable:!(d=wp(r,l))||d.enumerable});return t};var cr=t=>xp(ui({},"__esModule",{value:!0}),t);var li={};Dn(li,{readFile:()=>Sp});var Sp,ci=oe(()=>{Sp=void 0});var di={};Dn(di,{join:()=>_p});var _p,fi=oe(()=>{_p=void 0});var Ta=Zr((Ia,pi)=>{"use strict";var Aa=(()=>{var t=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(t=t||__filename),function(r={}){var e=r,d,l;e.ready=new Promise((n,i)=>{d=n,l=i}),e.jsepInit=(n,i,o,a,s,f,p,g)=>{e.zh=n,e.ph=i,e.rh=o,e.eh=a,e.qh=s,e.Cd=f,e.sh=p,e.th=g,i=(y,v,C)=>(...S)=>{let I=nt,$=v?.();S=y(...S);let M=v?.();return $!==M&&(y=M,C($),v=C=null),nt!=I?gn():S},o=y=>async(...v)=>{try{if(e.Xg)throw Error("Session already started");let C=e.Xg={uh:v[0],errors:[]},S=await y(...v);if(e.Xg!==C)throw Error("Session mismatch");n.flush();let I=C.errors;if(0<I.length){let $=await Promise.all(I);if($=$.filter(M=>M),0<$.length)throw Error($.join(`\n`))}return S}finally{e.Xg=null}},e._OrtRun=o(i(e._OrtRun,()=>e._OrtRun,y=>e._OrtRun=y)),e._OrtRunWithBinding=o(i(e._OrtRunWithBinding,()=>e._OrtRunWithBinding,y=>e._OrtRunWithBinding=y)),e._OrtBindInput=i(e._OrtBindInput,()=>e._OrtBindInput,y=>e._OrtBindInput=y),e.jsepRegisterBuffer=(y,v,C,S)=>n.registerBuffer(y,v,C,S),e.jsepUnregisterBuffers=y=>{n.unregisterBuffers(y)},e.jsepGetBuffer=y=>n.getBuffer(y),e.jsepCreateDownloader=(y,v,C)=>n.createDownloader(y,v,C)};var m=Object.assign({},e),h="./this.program",u=(n,i)=>{throw i},w=typeof window=="object",_=typeof importScripts=="function",O=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",j="",B,P,R;if(O){var T=(ci(),cr(li)),k=(fi(),cr(di));j=_?k.dirname(j)+"/":__dirname+"/",B=(n,i)=>(n=n.startsWith("file://")?new URL(n):k.normalize(n),T.readFileSync(n,i?void 0:"utf8")),R=n=>(n=B(n,!0),n.buffer||(n=new Uint8Array(n)),n),P=(n,i,o,a=!0)=>{n=n.startsWith("file://")?new URL(n):k.normalize(n),T.readFile(n,a?void 0:"utf8",(s,f)=>{s?o(s):i(a?f.buffer:f)})},!e.thisProgram&&1<process.argv.length&&(h=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),u=(n,i)=>{throw process.exitCode=n,i},e.inspect=()=>"[Emscripten Module object]"}else(w||_)&&(_?j=self.location.href:typeof document<"u"&&document.currentScript&&(j=document.currentScript.src),t&&(j=t),j.indexOf("blob:")!==0?j=j.substr(0,j.replace(/[?#].*/,"").lastIndexOf("/")+1):j="",B=n=>{var i=new XMLHttpRequest;return i.open("GET",n,!1),i.send(null),i.responseText},_&&(R=n=>{var i=new XMLHttpRequest;return i.open("GET",n,!1),i.responseType="arraybuffer",i.send(null),new Uint8Array(i.response)}),P=(n,i,o)=>{var a=new XMLHttpRequest;a.open("GET",n,!0),a.responseType="arraybuffer",a.onload=()=>{a.status==200||a.status==0&&a.response?i(a.response):o()},a.onerror=o,a.send(null)});var U=e.print||console.log.bind(console),K=e.printErr||console.error.bind(console);Object.assign(e,m),m=null,e.thisProgram&&(h=e.thisProgram),e.quit&&(u=e.quit);var Q;e.wasmBinary&&(Q=e.wasmBinary);var L=e.noExitRuntime||!0;typeof WebAssembly!="object"&&Je("no native wasm support detected");var X,A,Z=!1,re,ie,Ce,H,le,Be;function ue(){var n=X.buffer;e.HEAP8=ie=new Int8Array(n),e.HEAP16=new Int16Array(n),e.HEAP32=H=new Int32Array(n),e.HEAPU8=Ce=new Uint8Array(n),e.HEAPU16=new Uint16Array(n),e.HEAPU32=le=new Uint32Array(n),e.HEAPF32=new Float32Array(n),e.HEAPF64=Be=new Float64Array(n)}var ae=[],Ze=[],Ie=[];function He(){var n=e.preRun.shift();ae.unshift(n)}var Ee=0,qe=null,gt=null;function Je(n){throw e.onAbort&&e.onAbort(n),n="Aborted("+n+")",K(n),Z=!0,re=1,n=new WebAssembly.RuntimeError(n+". Build with -sASSERTIONS for more info."),l(n),n}function _t(n){return n.startsWith("data:application/octet-stream;base64,")}var ee;if(ee="ort-wasm-simd.wasm",!_t(ee)){var $e=ee;ee=e.locateFile?e.locateFile($e,j):j+$e}function Oe(n){if(n==ee&&Q)return new Uint8Array(Q);if(R)return R(n);throw"both async and sync fetching of the wasm failed"}function et(n){if(!Q&&(w||_)){if(typeof fetch=="function"&&!n.startsWith("file://"))return fetch(n,{credentials:"same-origin"}).then(i=>{if(!i.ok)throw"failed to load wasm binary file at \'"+n+"\'";return i.arrayBuffer()}).catch(()=>Oe(n));if(P)return new Promise((i,o)=>{P(n,a=>i(new Uint8Array(a)),o)})}return Promise.resolve().then(()=>Oe(n))}function tt(n,i,o){return et(n).then(a=>WebAssembly.instantiate(a,i)).then(a=>a).then(o,a=>{K("failed to asynchronously prepare wasm: "+a),Je(a)})}function Ge(n,i){var o=ee;return Q||typeof WebAssembly.instantiateStreaming!="function"||_t(o)||o.startsWith("file://")||O||typeof fetch!="function"?tt(o,n,i):fetch(o,{credentials:"same-origin"}).then(a=>WebAssembly.instantiateStreaming(a,n).then(i,function(s){return K("wasm streaming compile failed: "+s),K("falling back to ArrayBuffer instantiation"),tt(o,n,i)}))}var Me,rt={1312944:n=>{e.Cd("Abs",n,void 0)},1312995:n=>{e.Cd("Neg",n,void 0)},1313046:n=>{e.Cd("Floor",n,void 0)},1313099:n=>{e.Cd("Ceil",n,void 0)},1313151:n=>{e.Cd("Reciprocal",n,void 0)},1313209:n=>{e.Cd("Sqrt",n,void 0)},1313261:n=>{e.Cd("Exp",n,void 0)},1313312:n=>{e.Cd("Erf",n,void 0)},1313363:n=>{e.Cd("Sigmoid",n,void 0)},1313418:n=>{e.Cd("Log",n,void 0)},1313469:n=>{e.Cd("Sin",n,void 0)},1313520:n=>{e.Cd("Cos",n,void 0)},1313571:n=>{e.Cd("Tan",n,void 0)},1313622:n=>{e.Cd("Asin",n,void 0)},1313674:n=>{e.Cd("Acos",n,void 0)},1313726:n=>{e.Cd("Atan",n,void 0)},1313778:n=>{e.Cd("Sinh",n,void 0)},1313830:n=>{e.Cd("Cosh",n,void 0)},1313882:n=>{e.Cd("Asinh",n,void 0)},1313935:n=>{e.Cd("Acosh",n,void 0)},1313988:n=>{e.Cd("Atanh",n,void 0)},1314041:n=>{e.Cd("Tanh",n,void 0)},1314093:n=>{e.Cd("Not",n,void 0)},1314144:(n,i,o)=>{e.Cd("ClipV10",n,{min:i,max:o})},1314216:n=>{e.Cd("Clip",n,void 0)},1314268:(n,i)=>{e.Cd("Elu",n,{alpha:i})},1314326:n=>{e.Cd("Relu",n,void 0)},1314378:(n,i)=>{e.Cd("LeakyRelu",n,{alpha:i})},1314442:(n,i)=>{e.Cd("ThresholdedRelu",n,{alpha:i})},1314512:(n,i)=>{e.Cd("Cast",n,{to:i})},1314570:n=>{e.Cd("Add",n,void 0)},1314621:n=>{e.Cd("Sub",n,void 0)},1314672:n=>{e.Cd("Mul",n,void 0)},1314723:n=>{e.Cd("Div",n,void 0)},1314774:n=>{e.Cd("Pow",n,void 0)},1314825:n=>{e.Cd("Equal",n,void 0)},1314878:n=>{e.Cd("Greater",n,void 0)},1314933:n=>{e.Cd("GreaterOrEqual",n,void 0)},1314995:n=>{e.Cd("Less",n,void 0)},1315047:n=>{e.Cd("LessOrEqual",n,void 0)},1315106:(n,i,o,a,s)=>{e.Cd("ReduceMean",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[]})},1315270:(n,i,o,a,s)=>{e.Cd("ReduceMax",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[]})},1315433:(n,i,o,a,s)=>{e.Cd("ReduceMin",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[]})},1315596:(n,i,o,a,s)=>{e.Cd("ReduceProd",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[]})},1315760:(n,i,o,a,s)=>{e.Cd("ReduceSum",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[]})},1315923:(n,i,o,a,s)=>{e.Cd("ReduceL1",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[]})},1316085:(n,i,o,a,s)=>{e.Cd("ReduceL2",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[]})},1316247:(n,i,o,a,s)=>{e.Cd("ReduceLogSum",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[]})},1316413:(n,i,o,a,s)=>{e.Cd("ReduceSumSquare",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[]})},1316582:(n,i,o,a,s)=>{e.Cd("ReduceLogSumExp",n,{keepDims:!!i,noopWithEmptyAxes:!!o,axes:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[]})},1316751:n=>{e.Cd("Where",n,void 0)},1316804:(n,i,o)=>{e.Cd("Transpose",n,{perm:i?Array.from(H.subarray(o>>>0,o+i>>>0)):[]})},1316917:(n,i,o,a,s,f,p,g,y,v)=>{e.Cd("Conv",n,{format:y?"NHWC":"NCHW",auto_pad:i,dilations:[o],group:a,kernel_shape:[s],pads:[f,p],strides:[g],w_is_const:()=>!!ie[v>>>0]})},1317145:(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)=>{e.Cd("Conv",n,{format:$?"NHWC":"NCHW",auto_pad:i,dilations:[o,a],group:s,kernel_shape:[f,p],pads:[g,y,v,C],strides:[S,I],w_is_const:()=>!!ie[M>>>0]})},1317404:(n,i,o,a,s,f,p,g,y,v)=>{e.Cd("Conv",n,{format:y?"NHWC":"NCHW",auto_pad:i,dilations:[o],group:a,kernel_shape:[s],pads:[f,p],strides:[g],w_is_const:()=>!!ie[v>>>0]})},1317632:(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)=>{e.Cd("Conv",n,{format:$?"NHWC":"NCHW",auto_pad:i,dilations:[o,a],group:s,kernel_shape:[f,p],pads:[g,y,v,C],strides:[S,I],w_is_const:()=>!!ie[M>>>0]})},1317891:(n,i,o,a,s,f,p,g,y,v,C,S,I,$)=>{e.Cd("ConvTranspose",n,{format:y?"NHWC":"NCHW",autoPad:i,dilations:[o],group:a,kernel_shape:[s],pads:[f,p],strides:[g],wIsConst:()=>!!ie[v>>>0],outputPadding:C?Array.from(H.subarray(S>>>0,S+C>>>0)):[],outputShape:I?Array.from(H.subarray($>>>0,$+I>>>0)):[]})},1318271:(n,i,o,a,s,f,p,g,y,v,C,S,I)=>{e.Cd("ConvTranspose",n,{format:g?"NHWC":"NCHW",autoPad:i,dilations:Array.from(H.subarray(o>>>0,o+2>>>0)),group:a,kernelShape:Array.from(H.subarray(s>>>0,s+2>>>0)),pads:Array.from(H.subarray(f>>>0,f+4>>>0)),strides:Array.from(H.subarray(p>>>0,p+2>>>0)),wIsConst:()=>!!ie[y>>>0],outputPadding:0<v?Array.from(H.subarray(C>>>0,C+v>>>0)):[],outputShape:0<S?Array.from(H.subarray(I>>>0,I+S>>>0)):[]})},1318794:(n,i,o,a,s,f,p,g,y,v,C,S,I,$)=>{e.Cd("ConvTranspose",n,{format:y?"NHWC":"NCHW",autoPad:i,dilations:[o],group:a,kernel_shape:[s],pads:[f,p],strides:[g],wIsConst:()=>!!ie[v>>>0],outputPadding:C?Array.from(H.subarray(S>>>0,S+C>>>0)):[],outputShape:I?Array.from(H.subarray($>>>0,$+I>>>0)):[]})},1319174:(n,i,o,a,s,f,p,g,y,v,C,S,I)=>{e.Cd("ConvTranspose",n,{format:g?"NHWC":"NCHW",autoPad:i,dilations:Array.from(H.subarray(o>>>0,o+2>>>0)),group:a,kernelShape:Array.from(H.subarray(s>>>0,s+2>>>0)),pads:Array.from(H.subarray(f>>>0,f+4>>>0)),strides:Array.from(H.subarray(p>>>0,p+2>>>0)),wIsConst:()=>!!ie[y>>>0],outputPadding:0<v?Array.from(H.subarray(C>>>0,C+v>>>0)):[],outputShape:0<S?Array.from(H.subarray(I>>>0,I+S>>>0)):[]})},1319697:(n,i)=>{e.Cd("GlobalAveragePool",n,{format:i?"NHWC":"NCHW"})},1319788:(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)=>{e.Cd("AveragePool",n,{format:G?"NHWC":"NCHW",auto_pad:i,ceil_mode:o,count_include_pad:a,storage_order:s,dilations:[f,p],kernel_shape:[g,y],pads:[v,C,S,I],strides:[$,M]})},1320072:(n,i)=>{e.Cd("GlobalAveragePool",n,{format:i?"NHWC":"NCHW"})},1320163:(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)=>{e.Cd("AveragePool",n,{format:G?"NHWC":"NCHW",auto_pad:i,ceil_mode:o,count_include_pad:a,storage_order:s,dilations:[f,p],kernel_shape:[g,y],pads:[v,C,S,I],strides:[$,M]})},1320447:(n,i)=>{e.Cd("GlobalMaxPool",n,{format:i?"NHWC":"NCHW"})},1320534:(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)=>{e.Cd("MaxPool",n,{format:G?"NHWC":"NCHW",auto_pad:i,ceil_mode:o,count_include_pad:a,storage_order:s,dilations:[f,p],kernel_shape:[g,y],pads:[v,C,S,I],strides:[$,M]})},1320814:(n,i)=>{e.Cd("GlobalMaxPool",n,{format:i?"NHWC":"NCHW"})},1320901:(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)=>{e.Cd("MaxPool",n,{format:G?"NHWC":"NCHW",auto_pad:i,ceil_mode:o,count_include_pad:a,storage_order:s,dilations:[f,p],kernel_shape:[g,y],pads:[v,C,S,I],strides:[$,M]})},1321181:(n,i,o,a,s)=>{e.Cd("Gemm",n,{alpha:i,beta:o,transA:a,transB:s})},1321285:n=>{e.Cd("MatMul",n,void 0)},1321339:(n,i,o,a)=>{e.Cd("ArgMax",n,{keepDims:!!i,selectLastIndex:!!o,axis:a})},1321447:(n,i,o,a)=>{e.Cd("ArgMin",n,{keepDims:!!i,selectLastIndex:!!o,axis:a})},1321555:(n,i)=>{e.Cd("Softmax",n,{axis:i})},1321618:(n,i)=>{e.Cd("Concat",n,{axis:i})},1321678:(n,i,o,a,s)=>{e.Cd("Split",n,{axis:i,numOutputs:o,splitSizes:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[]})},1321823:n=>{e.Cd("Expand",n,void 0)},1321877:(n,i)=>{e.Cd("Gather",n,{axis:Number(i)})},1321948:(n,i)=>{e.Cd("GatherElements",n,{axis:Number(i)})},1322027:(n,i,o,a,s,f,p,g,y,v,C)=>{e.Cd("Resize",n,{antialias:i,axes:o?Array.from(H.subarray(a>>>0,a+o>>>0)):[],coordinateTransformMode:ct(s),cubicCoeffA:f,excludeOutside:p,extrapolationValue:g,keepAspectRatioPolicy:ct(y),mode:ct(v),nearestMode:ct(C)})},1322378:(n,i,o,a,s,f,p)=>{e.Cd("Slice",n,{starts:i?Array.from(H.subarray(o>>>0,o+i>>>0)):[],ends:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[],axes:f?Array.from(H.subarray(p>>>0,p+f>>>0)):[]})},1322609:n=>{e.Cd("Tile",n,void 0)},1322661:(n,i,o)=>{e.Cd("LayerNormalization",n,{axis:Number(i),epsilon:Number(o)})},1322768:(n,i,o)=>{e.Cd("InstanceNormalization",n,{epsilon:i,format:o?"NHWC":"NCHW"})},1322882:(n,i,o)=>{e.Cd("InstanceNormalization",n,{epsilon:i,format:o?"NHWC":"NCHW"})},1322996:n=>{e.Cd("Range",n,void 0)},1323049:(n,i)=>{e.Cd("Einsum",n,{equation:ct(i)})},1323130:(n,i,o,a,s)=>{e.Cd("Pad",n,{mode:i,value:o,pads:a?Array.from(H.subarray(s>>>0,s+a>>>0)):[]})},1323262:n=>{e.Cd("Gelu",n,void 0)},1323314:n=>{e.Cd("BiasAdd",n,void 0)},1323369:n=>{e.Cd("BiasSplitGelu",n,void 0)},1323430:(n,i)=>{e.Cd("SkipLayerNormalization",n,{epsilon:i})},1323511:n=>{e.sh(n)},1323545:(n,i)=>e.th(n,i,e.Xg.uh,e.Xg.errors),1323657:n=>e.ph(n),1323690:n=>e.rh(n),1323722:(n,i,o)=>{e.eh(n,i,o,!0)},1323761:(n,i,o)=>{e.eh(n,i,o)}};function yt(n){this.name="ExitStatus",this.message=`Program terminated with exit(${n})`,this.status=n}var ut=n=>{for(;0<n.length;)n.shift()(e)},Ot=[],Et=0,Ye=0;function Lt(n){this.Wg=n,this.Sg=n-24,this.mh=function(i){le[this.Sg+4>>2>>>0]=i},this.bh=function(){return le[this.Sg+4>>2>>>0]},this.lh=function(i){le[this.Sg+8>>2>>>0]=i},this.fh=function(i){ie[this.Sg+12>>0>>>0]=i?1:0},this.ih=function(){return ie[this.Sg+12>>0>>>0]!=0},this.gh=function(i){ie[this.Sg+13>>0>>>0]=i?1:0},this.oh=function(){return ie[this.Sg+13>>0>>>0]!=0},this.kh=function(i,o){this.dh(0),this.mh(i),this.lh(o)},this.dh=function(i){le[this.Sg+16>>2>>>0]=i},this.hh=function(){return le[this.Sg+16>>2>>>0]},this.jh=function(){if(xr(this.bh()))return le[this.Wg>>2>>>0];var i=this.hh();return i!==0?i:this.Wg}}var lt=n=>{var i=Ye;if(!i)return At(0),0;var o=new Lt(i);o.dh(i);var a=o.bh();if(!a)return At(0),i;for(var s in n){var f=n[s];if(f===0||f===a)break;if($r(f,a,o.Sg+16))return At(f),i}return At(a),i},pr=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,dn=(n,i,o)=>{i>>>=0;var a=i+o;for(o=i;n[o]&&!(o>=a);)++o;if(16<o-i&&n.buffer&&pr)return pr.decode(n.subarray(i,o));for(a="";i<o;){var s=n[i++];if(s&128){var f=n[i++]&63;if((s&224)==192)a+=String.fromCharCode((s&31)<<6|f);else{var p=n[i++]&63;s=(s&240)==224?(s&15)<<12|f<<6|p:(s&7)<<18|f<<12|p<<6|n[i++]&63,65536>s?a+=String.fromCharCode(s):(s-=65536,a+=String.fromCharCode(55296|s>>10,56320|s&1023))}}else a+=String.fromCharCode(s)}return a},ct=(n,i)=>(n>>>=0)?dn(Ce,n,i):"",mr=n=>{for(var i=0,o=0;o<n.length;++o){var a=n.charCodeAt(o);127>=a?i++:2047>=a?i+=2:55296<=a&&57343>=a?(i+=4,++o):i+=3}return i},bt=(n,i,o,a)=>{if(o>>>=0,!(0<a))return 0;var s=o;a=o+a-1;for(var f=0;f<n.length;++f){var p=n.charCodeAt(f);if(55296<=p&&57343>=p){var g=n.charCodeAt(++f);p=65536+((p&1023)<<10)|g&1023}if(127>=p){if(o>=a)break;i[o++>>>0]=p}else{if(2047>=p){if(o+1>=a)break;i[o++>>>0]=192|p>>6}else{if(65535>=p){if(o+2>=a)break;i[o++>>>0]=224|p>>12}else{if(o+3>=a)break;i[o++>>>0]=240|p>>18,i[o++>>>0]=128|p>>12&63}i[o++>>>0]=128|p>>6&63}i[o++>>>0]=128|p&63}}return i[o>>>0]=0,o-s},vt=n=>n%4===0&&(n%100!==0||n%400===0),Pt=[0,31,60,91,121,152,182,213,244,274,305,335],Kt=[0,31,59,90,120,151,181,212,243,273,304,334],hr=n=>{var i=mr(n)+1,o=Zt(i);return o&&bt(n,Ce,o,i),o},qt=[],gr=(n,i)=>{qt.length=0;var o;for(i>>=2;o=Ce[n++>>>0];)i+=o!=105&i,qt.push(o==105?H[i>>>0]:Be[i++>>>1]),++i;return qt},Yt={},dt=()=>{if(!Xt){var n={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:h||"./this.program"},i;for(i in Yt)Yt[i]===void 0?delete n[i]:n[i]=Yt[i];var o=[];for(i in n)o.push(`${i}=${n[i]}`);Xt=o}return Xt},Xt,yr=[null,[],[]],he=[31,29,31,30,31,30,31,31,30,31,30,31],Rt=[31,28,31,30,31,30,31,31,30,31,30,31];function fn(n){var i=Array(mr(n)+1);return bt(n,i,0,i.length),i}function pn(n,i,o,a){function s($,M,G){for($=typeof $=="number"?$.toString():$||"";$.length<M;)$=G[0]+$;return $}function f($,M){return s($,M,"0")}function p($,M){function G(te){return 0>te?-1:0<te?1:0}var q;return(q=G($.getFullYear()-M.getFullYear()))===0&&(q=G($.getMonth()-M.getMonth()))===0&&(q=G($.getDate()-M.getDate())),q}function g($){switch($.getDay()){case 0:return new Date($.getFullYear()-1,11,29);case 1:return $;case 2:return new Date($.getFullYear(),0,3);case 3:return new Date($.getFullYear(),0,2);case 4:return new Date($.getFullYear(),0,1);case 5:return new Date($.getFullYear()-1,11,31);case 6:return new Date($.getFullYear()-1,11,30)}}function y($){var M=$.Ug;for($=new Date(new Date($.Vg+1900,0,1).getTime());0<M;){var G=$.getMonth(),q=(vt($.getFullYear())?he:Rt)[G];if(M>q-$.getDate())M-=q-$.getDate()+1,$.setDate(1),11>G?$.setMonth(G+1):($.setMonth(0),$.setFullYear($.getFullYear()+1));else{$.setDate($.getDate()+M);break}}return G=new Date($.getFullYear()+1,0,4),M=g(new Date($.getFullYear(),0,4)),G=g(G),0>=p(M,$)?0>=p(G,$)?$.getFullYear()+1:$.getFullYear():$.getFullYear()-1}n>>>=0,i>>>=0,o>>>=0,a>>>=0;var v=H[a+40>>2>>>0];a={xh:H[a>>2>>>0],wh:H[a+4>>2>>>0],Yg:H[a+8>>2>>>0],ah:H[a+12>>2>>>0],Zg:H[a+16>>2>>>0],Vg:H[a+20>>2>>>0],Tg:H[a+24>>2>>>0],Ug:H[a+28>>2>>>0],Ah:H[a+32>>2>>>0],vh:H[a+36>>2>>>0],yh:v?ct(v):""},o=ct(o),v={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var C in v)o=o.replace(new RegExp(C,"g"),v[C]);var S="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),I="January February March April May June July August September October November December".split(" ");v={"%a":$=>S[$.Tg].substring(0,3),"%A":$=>S[$.Tg],"%b":$=>I[$.Zg].substring(0,3),"%B":$=>I[$.Zg],"%C":$=>f(($.Vg+1900)/100|0,2),"%d":$=>f($.ah,2),"%e":$=>s($.ah,2," "),"%g":$=>y($).toString().substring(2),"%G":$=>y($),"%H":$=>f($.Yg,2),"%I":$=>($=$.Yg,$==0?$=12:12<$&&($-=12),f($,2)),"%j":$=>{for(var M=0,G=0;G<=$.Zg-1;M+=(vt($.Vg+1900)?he:Rt)[G++]);return f($.ah+M,3)},"%m":$=>f($.Zg+1,2),"%M":$=>f($.wh,2),"%n":()=>`\n`,"%p":$=>0<=$.Yg&&12>$.Yg?"AM":"PM","%S":$=>f($.xh,2),"%t":()=>"	","%u":$=>$.Tg||7,"%U":$=>f(Math.floor(($.Ug+7-$.Tg)/7),2),"%V":$=>{var M=Math.floor(($.Ug+7-($.Tg+6)%7)/7);if(2>=($.Tg+371-$.Ug-2)%7&&M++,M)M==53&&(G=($.Tg+371-$.Ug)%7,G==4||G==3&&vt($.Vg)||(M=1));else{M=52;var G=($.Tg+7-$.Ug-1)%7;(G==4||G==5&&vt($.Vg%400-1))&&M++}return f(M,2)},"%w":$=>$.Tg,"%W":$=>f(Math.floor(($.Ug+7-($.Tg+6)%7)/7),2),"%y":$=>($.Vg+1900).toString().substring(2),"%Y":$=>$.Vg+1900,"%z":$=>{$=$.vh;var M=0<=$;return $=Math.abs($)/60,(M?"+":"-")+("0000"+($/60*100+$%60)).slice(-4)},"%Z":$=>$.yh,"%%":()=>"%"},o=o.replace(/%%/g,"\\0\\0");for(C in v)o.includes(C)&&(o=o.replace(new RegExp(C,"g"),v[C](a)));return o=o.replace(/\\0\\0/g,"%"),C=fn(o),C.length>i?0:(ie.set(C,n>>>0),C.length-1)}function kt(n){try{n()}catch(i){Je(i)}}function si(n){var i={},o;for(o in n)(function(a){var s=n[a];i[a]=typeof s=="function"?function(){Bt.push(a);try{return s.apply(null,arguments)}finally{Z||(Bt.pop()===a||Je(),nt&&ft===1&&Bt.length===0&&(ft=0,kt($a),typeof Fibers<"u"&&Fibers.Bh()))}}:s})(o);return i}var ft=0,nt=null,br=0,Bt=[],Qt={},vr={},mn=0,Jt=null,hn=[];function gn(){return new Promise((n,i)=>{Jt={resolve:n,reject:i}})}function yn(){var n=Zt(65548),i=n+12;le[n>>2>>>0]=i,le[n+4>>2>>>0]=i+65536,i=Bt[0];var o=Qt[i];return o===void 0&&(o=mn++,Qt[i]=o,vr[o]=i),H[n+8>>2>>>0]=o,n}function bn(n){if(!Z){if(ft===0){var i=!1,o=!1;n((a=0)=>{if(!Z&&(br=a,i=!0,o)){ft=2,kt(()=>xa(nt)),typeof Browser<"u"&&Browser.$g.nh&&Browser.$g.resume(),a=!1;try{var s=(0,A[vr[H[nt+8>>2>>>0]]])()}catch(g){s=g,a=!0}var f=!1;if(!nt){var p=Jt;p&&(Jt=null,(a?p.reject:p.resolve)(s),f=!0)}if(a&&!f)throw s}}),o=!0,i||(ft=1,nt=yn(),typeof Browser<"u"&&Browser.$g.nh&&Browser.$g.pause(),kt(()=>Ca(nt)))}else ft===2?(ft=0,kt(Sa),wr(nt),nt=null,hn.forEach(a=>{if(!Z)try{if(a(),!L)try{re=re=a=re,L||(e.onExit&&e.onExit(a),Z=!0),u(a,new yt(a))}catch(s){s instanceof yt||s=="unwind"||u(1,s)}}catch(s){s instanceof yt||s=="unwind"||u(1,s)}})):Je(`invalid state: ${ft}`);return br}}function vn(n){return bn(i=>{n().then(i)})}var wn={Ha:function(n,i,o){return vn(async()=>{await e.qh(n,i,o)})},u:function(n){return n=new Lt(n>>>0),n.ih()||(n.fh(!0),Et--),n.gh(!1),Ot.push(n),Cr(n.Wg),n.jh()},B:function(){W(0,0);var n=Ot.pop();It(n.Wg),Ye=0},a:function(){return lt([])},k:function(n){return lt([n>>>0])},w:function(n,i){return lt([n>>>0,i>>>0])},q:function(n,i,o){return lt([n>>>0,i>>>0,o>>>0])},pa:function(){var n=Ot.pop();n||Je("no exception to throw");var i=n.Wg;throw n.oh()||(Ot.push(n),n.gh(!0),n.fh(!1),Et++),Ye=i,Ye},s:function(n,i,o){throw n>>>=0,new Lt(n).kh(i>>>0,o>>>0),Ye=n,Et++,Ye},$:function(){return Et},g:function(n){throw Ye||(Ye=n>>>0),Ye},qa:function(){return 0},oc:function(){},Pa:function(){},Ra:function(){},Ja:function(){return 0},Ub:function(){},Ta:function(){},Jb:function(){},Ca:function(){},Qa:function(){},Na:function(){},dc:function(){},Oa:function(){},Tc:()=>!0,Oc:function(n,i,o){n=i+2097152>>>0<4194305-!!n?(n>>>0)+4294967296*i:NaN,o>>>=0,n=new Date(1e3*n),H[o>>2>>>0]=n.getUTCSeconds(),H[o+4>>2>>>0]=n.getUTCMinutes(),H[o+8>>2>>>0]=n.getUTCHours(),H[o+12>>2>>>0]=n.getUTCDate(),H[o+16>>2>>>0]=n.getUTCMonth(),H[o+20>>2>>>0]=n.getUTCFullYear()-1900,H[o+24>>2>>>0]=n.getUTCDay(),H[o+28>>2>>>0]=(n.getTime()-Date.UTC(n.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Pc:function(n,i,o){n=i+2097152>>>0<4194305-!!n?(n>>>0)+4294967296*i:NaN,o>>>=0,n=new Date(1e3*n),H[o>>2>>>0]=n.getSeconds(),H[o+4>>2>>>0]=n.getMinutes(),H[o+8>>2>>>0]=n.getHours(),H[o+12>>2>>>0]=n.getDate(),H[o+16>>2>>>0]=n.getMonth(),H[o+20>>2>>>0]=n.getFullYear()-1900,H[o+24>>2>>>0]=n.getDay(),H[o+28>>2>>>0]=(vt(n.getFullYear())?Pt:Kt)[n.getMonth()]+n.getDate()-1|0,H[o+36>>2>>>0]=-(60*n.getTimezoneOffset()),i=new Date(n.getFullYear(),6,1).getTimezoneOffset();var a=new Date(n.getFullYear(),0,1).getTimezoneOffset();H[o+32>>2>>>0]=(i!=a&&n.getTimezoneOffset()==Math.min(a,i))|0},Qc:function(n){n>>>=0;var i=new Date(H[n+20>>2>>>0]+1900,H[n+16>>2>>>0],H[n+12>>2>>>0],H[n+8>>2>>>0],H[n+4>>2>>>0],H[n>>2>>>0],0),o=H[n+32>>2>>>0],a=i.getTimezoneOffset(),s=new Date(i.getFullYear(),6,1).getTimezoneOffset(),f=new Date(i.getFullYear(),0,1).getTimezoneOffset(),p=Math.min(f,s);return 0>o?H[n+32>>2>>>0]=+(s!=f&&p==a):0<o!=(p==a)&&(s=Math.max(f,s),i.setTime(i.getTime()+6e4*((0<o?p:s)-a))),H[n+24>>2>>>0]=i.getDay(),H[n+28>>2>>>0]=(vt(i.getFullYear())?Pt:Kt)[i.getMonth()]+i.getDate()-1|0,H[n>>2>>>0]=i.getSeconds(),H[n+4>>2>>>0]=i.getMinutes(),H[n+8>>2>>>0]=i.getHours(),H[n+12>>2>>>0]=i.getDate(),H[n+16>>2>>>0]=i.getMonth(),H[n+20>>2>>>0]=i.getYear(),n=i.getTime()/1e3,At((Me=n,1<=+Math.abs(Me)?0<Me?+Math.floor(Me/4294967296)>>>0:~~+Math.ceil((Me-+(~~Me>>>0))/4294967296)>>>0:0)),n>>>0},Mc:function(){return-52},Nc:function(){},La:function(n,i,o){function a(y){return(y=y.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?y[1]:"GMT"}o>>>=0;var s=new Date().getFullYear(),f=new Date(s,0,1),p=new Date(s,6,1);s=f.getTimezoneOffset();var g=p.getTimezoneOffset();le[n>>>0>>2>>>0]=60*Math.max(s,g),H[i>>>0>>2>>>0]=+(s!=g),n=a(f),i=a(p),n=hr(n),i=hr(i),g<s?(le[o>>2>>>0]=n,le[o+4>>2>>>0]=i):(le[o>>2>>>0]=i,le[o+4>>2>>>0]=n)},ja:()=>{Je("")},x:function(n,i,o){return n>>>=0,i=gr(i>>>0,o>>>0),rt[n].apply(null,i)},wa:function(n,i,o){return n>>>=0,i=gr(i>>>0,o>>>0),rt[n].apply(null,i)},Ea:function(){return Date.now()},Ma:function(){return 4294901760},I:()=>performance.now(),yb:function(n,i,o){return i>>>=0,Ce.copyWithin(n>>>0>>>0,i>>>0,i+(o>>>0)>>>0)},Ka:function(n){n>>>=0;var i=Ce.length;if(4294901760<n)return!1;for(var o=1;4>=o;o*=2){var a=i*(1+.2/o);a=Math.min(a,n+100663296);var s=Math;a=Math.max(n,a);e:{s=s.min.call(s,4294901760,a+(65536-a%65536)%65536)-X.buffer.byteLength+65535>>>16;try{X.grow(s),ue();var f=1;break e}catch{}f=void 0}if(f)return!0}return!1},cb:function(n,i){n>>>=0,i>>>=0;var o=0;return dt().forEach(function(a,s){var f=i+o;for(s=le[n+4*s>>2>>>0]=f,f=0;f<a.length;++f)ie[s++>>0>>>0]=a.charCodeAt(f);ie[s>>0>>>0]=0,o+=a.length+1}),0},nb:function(n,i){n>>>=0,i>>>=0;var o=dt();le[n>>2>>>0]=o.length;var a=0;return o.forEach(function(s){a+=s.length+1}),le[i>>2>>>0]=a,0},ma:()=>52,Ba:function(){return 52},Rc:function(){return 70},Aa:function(n,i,o,a){i>>>=0,o>>>=0,a>>>=0;for(var s=0,f=0;f<o;f++){var p=le[i>>2>>>0],g=le[i+4>>2>>>0];i+=8;for(var y=0;y<g;y++){var v=Ce[p+y>>>0],C=yr[n];v===0||v===10?((n===1?U:K)(dn(C,0)),C.length=0):C.push(v)}s+=g}return le[a>>2>>>0]=s,0},ia:Rc,Sc:Pd,M:od,K:Pc,Uc:Ed,Wc:Id,C:Lc,z:Tc,b:wc,Da:Sd,ca:pd,f:bc,ra:_d,h:yc,F:xd,i:_c,Vc:Td,j:Sc,t:xc,r:Ec,n:kc,W:jc,Y:bd,J:Gc,oa:Jc,aa:ed,la:vd,vb:Ff,gb:ip,zc:Fd,bb:up,eb:ap,Sa:bp,Sb:xf,Dc:Gd,jb:tp,Va:gp,Ob:If,fb:op,gc:lf,Lc:Rd,pc:ef,hb:np,db:sp,Bb:zf,kc:of,nc:tf,fc:cf,Kc:kd,_a:dp,ab:lp,qb:Yf,mb:Jf,$a:cp,ic:sf,Kb:Pf,lb:Zf,Ua:yp,Tb:$f,Ic:Md,Ac:Nd,tc:Xd,pb:Xf,lc:nf,Ib:Rf,Hb:kf,c:$c,_:qc,p:Cc,P:Ad,Z:ld,ha:Uc,e:vc,za:zc,G:$d,da:Xc,O:ad,ub:Hf,fa:Nc,d:Ac,xa:Hc,Fa:wd,l:Ic,va:Yc,m:Oc,ya:Fc,ua:Qc,Ga:md,o:Bc,V:nd,ga:rd,U:id,na:cd,y:Mc,A:Dc,E:Wc,X:Cd,ta:sd,ea:Kc,N:td,L:dd,D:Zc,ba:Vc,T:ud,ka:Od,R:hd,sa:yd,Q:gd,S:fd,jc:af,zb:Vf,rb:qf,Eb:jf,Ab:Gf,Bc:Ud,Nb:Tf,xb:Uf,Fb:Mf,Pb:Af,ec:df,ob:Qf,Mb:Of,sb:Kf,Ya:pp,rc:Jd,Fc:Wd,Za:fp,Qb:_f,xc:Ld,Cb:Wf,kb:ep,vc:qd,Hc:jd,wc:Kd,Cc:Vd,Xa:mp,Ec:zd,wb:Nf,Lb:Ef,yc:Hd,Jc:Bd,ib:rp,Db:Df,Yb:bf,tb:Lf,Gc:Dd,Zb:yf,Rb:Sf,hc:uf,qc:Zd,Gb:Bf,Xb:vf,sc:Qd,mc:rf,Wa:hp,uc:Yd,Vb:Cf,Wb:wf,$b:hf,ac:mf,cc:ff,_b:gf,bc:pf,v:function(n){return n>>>0},Ia:pn,H:function(n,i,o,a){return pn(n>>>0,i>>>0,o>>>0,a>>>0)}};(function(){function n(o){if(o=o.exports,o=si(o),A=o=vp(o),X=A.Xc,ue(),Ze.unshift(A.Yc),Ee--,e.monitorRunDependencies&&e.monitorRunDependencies(Ee),Ee==0&&(qe!==null&&(clearInterval(qe),qe=null),gt)){var a=gt;gt=null,a()}return o}var i={a:wn};if(Ee++,e.monitorRunDependencies&&e.monitorRunDependencies(Ee),e.instantiateWasm)try{return e.instantiateWasm(i,n)}catch(o){K("Module.instantiateWasm callback failed with error: "+o),l(o)}return Ge(i,function(o){n(o.instance)}).catch(l),{}})(),e._OrtInit=(n,i)=>(e._OrtInit=A.Zc)(n,i),e._OrtGetLastError=(n,i)=>(e._OrtGetLastError=A._c)(n,i),e._OrtCreateSessionOptions=(n,i,o,a,s,f,p,g,y,v)=>(e._OrtCreateSessionOptions=A.$c)(n,i,o,a,s,f,p,g,y,v),e._OrtAppendExecutionProvider=(n,i)=>(e._OrtAppendExecutionProvider=A.ad)(n,i),e._OrtAddFreeDimensionOverride=(n,i,o)=>(e._OrtAddFreeDimensionOverride=A.bd)(n,i,o),e._OrtAddSessionConfigEntry=(n,i,o)=>(e._OrtAddSessionConfigEntry=A.cd)(n,i,o),e._OrtReleaseSessionOptions=n=>(e._OrtReleaseSessionOptions=A.dd)(n),e._OrtCreateSession=(n,i,o)=>(e._OrtCreateSession=A.ed)(n,i,o),e._OrtReleaseSession=n=>(e._OrtReleaseSession=A.fd)(n),e._OrtGetInputOutputCount=(n,i,o)=>(e._OrtGetInputOutputCount=A.gd)(n,i,o),e._OrtGetInputName=(n,i)=>(e._OrtGetInputName=A.hd)(n,i),e._OrtGetOutputName=(n,i)=>(e._OrtGetOutputName=A.id)(n,i),e._OrtFree=n=>(e._OrtFree=A.jd)(n),e._OrtCreateTensor=(n,i,o,a,s,f)=>(e._OrtCreateTensor=A.kd)(n,i,o,a,s,f),e._OrtGetTensorData=(n,i,o,a,s)=>(e._OrtGetTensorData=A.ld)(n,i,o,a,s),e._OrtReleaseTensor=n=>(e._OrtReleaseTensor=A.md)(n),e._OrtCreateRunOptions=(n,i,o,a)=>(e._OrtCreateRunOptions=A.nd)(n,i,o,a),e._OrtAddRunConfigEntry=(n,i,o)=>(e._OrtAddRunConfigEntry=A.od)(n,i,o),e._OrtReleaseRunOptions=n=>(e._OrtReleaseRunOptions=A.pd)(n),e._OrtCreateBinding=n=>(e._OrtCreateBinding=A.qd)(n),e._OrtBindInput=(n,i,o)=>(e._OrtBindInput=A.rd)(n,i,o),e._OrtBindOutput=(n,i,o,a)=>(e._OrtBindOutput=A.sd)(n,i,o,a),e._OrtClearBoundOutputs=n=>(e._OrtClearBoundOutputs=A.td)(n),e._OrtReleaseBinding=n=>(e._OrtReleaseBinding=A.ud)(n),e._OrtRunWithBinding=(n,i,o,a,s)=>(e._OrtRunWithBinding=A.vd)(n,i,o,a,s),e._OrtRun=(n,i,o,a,s,f,p,g)=>(e._OrtRun=A.wd)(n,i,o,a,s,f,p,g),e._OrtEndProfiling=n=>(e._OrtEndProfiling=A.xd)(n),e._JsepOutput=(n,i,o)=>(e._JsepOutput=A.yd)(n,i,o),e._JsepGetNodeName=n=>(e._JsepGetNodeName=A.zd)(n);var Zt=e._malloc=n=>(Zt=e._malloc=A.Ad)(n),wr=e._free=n=>(wr=e._free=A.Bd)(n),W=(n,i)=>(W=A.Dd)(n,i),At=n=>(At=A.Ed)(n),z=()=>(z=A.Fd)(),D=n=>(D=A.Gd)(n),Mt=n=>(Mt=A.Hd)(n),It=n=>(It=A.Id)(n),Cr=n=>(Cr=A.Jd)(n),$r=(n,i,o)=>($r=A.Kd)(n,i,o),xr=n=>(xr=A.Ld)(n),Sr=e.dynCall_vi=(n,i)=>(Sr=e.dynCall_vi=A.Md)(n,i),_r=e.dynCall_vii=(n,i,o)=>(_r=e.dynCall_vii=A.Nd)(n,i,o),er=e.dynCall_iiii=(n,i,o,a)=>(er=e.dynCall_iiii=A.Od)(n,i,o,a),Ar=e.dynCall_iii=(n,i,o)=>(Ar=e.dynCall_iii=A.Pd)(n,i,o),Cn=e.dynCall_ii=(n,i)=>(Cn=e.dynCall_ii=A.Qd)(n,i),ke=e.dynCall_iiiiiii=(n,i,o,a,s,f,p)=>(ke=e.dynCall_iiiiiii=A.Rd)(n,i,o,a,s,f,p),tr=e.dynCall_v=n=>(tr=e.dynCall_v=A.Sd)(n),rr=e.dynCall_iiiiii=(n,i,o,a,s,f)=>(rr=e.dynCall_iiiiii=A.Td)(n,i,o,a,s,f),Ir=e.dynCall_iiij=(n,i,o,a,s)=>(Ir=e.dynCall_iiij=A.Ud)(n,i,o,a,s),nr=e.dynCall_iiiii=(n,i,o,a,s)=>(nr=e.dynCall_iiiii=A.Vd)(n,i,o,a,s),Tr=e.dynCall_viii=(n,i,o,a)=>(Tr=e.dynCall_viii=A.Wd)(n,i,o,a),Or=e.dynCall_j=n=>(Or=e.dynCall_j=A.Xd)(n),Er=e.dynCall_i=n=>(Er=e.dynCall_i=A.Yd)(n),Pr=e.dynCall_iij=(n,i,o,a)=>(Pr=e.dynCall_iij=A.Zd)(n,i,o,a),Rr=e.dynCall_iiiiij=(n,i,o,a,s,f,p)=>(Rr=e.dynCall_iiiiij=A._d)(n,i,o,a,s,f,p),$n=e.dynCall_vij=(n,i,o,a)=>($n=e.dynCall_vij=A.$d)(n,i,o,a),kr=e.dynCall_viiiii=(n,i,o,a,s,f)=>(kr=e.dynCall_viiiii=A.ae)(n,i,o,a,s,f),Br=e.dynCall_viiii=(n,i,o,a,s)=>(Br=e.dynCall_viiii=A.be)(n,i,o,a,s),Mr=e.dynCall_iiiiiiii=(n,i,o,a,s,f,p,g)=>(Mr=e.dynCall_iiiiiiii=A.ce)(n,i,o,a,s,f,p,g),xn=e.dynCall_fi=(n,i)=>(xn=e.dynCall_fi=A.de)(n,i),Sn=e.dynCall_fii=(n,i,o)=>(Sn=e.dynCall_fii=A.ee)(n,i,o),jr=e.dynCall_ji=(n,i)=>(jr=e.dynCall_ji=A.fe)(n,i),jt=e.dynCall_di=(n,i)=>(jt=e.dynCall_di=A.ge)(n,i),_n=e.dynCall_jii=(n,i,o)=>(_n=e.dynCall_jii=A.he)(n,i,o),pt=e.dynCall_dii=(n,i,o)=>(pt=e.dynCall_dii=A.ie)(n,i,o),it=e.dynCall_iiiiiiiii=(n,i,o,a,s,f,p,g,y)=>(it=e.dynCall_iiiiiiiii=A.je)(n,i,o,a,s,f,p,g,y),Dr=e.dynCall_viij=(n,i,o,a,s)=>(Dr=e.dynCall_viij=A.ke)(n,i,o,a,s),Dt=e.dynCall_viiiiii=(n,i,o,a,s,f,p)=>(Dt=e.dynCall_viiiiii=A.le)(n,i,o,a,s,f,p),Wr=e.dynCall_vijj=(n,i,o,a,s,f)=>(Wr=e.dynCall_vijj=A.me)(n,i,o,a,s,f),zr=e.dynCall_viiiiiii=(n,i,o,a,s,f,p,g)=>(zr=e.dynCall_viiiiiii=A.ne)(n,i,o,a,s,f,p,g),An=e.dynCall_iiiiiiiiii=(n,i,o,a,s,f,p,g,y,v)=>(An=e.dynCall_iiiiiiiiii=A.oe)(n,i,o,a,s,f,p,g,y,v),ir=e.dynCall_viiiiiiii=(n,i,o,a,s,f,p,g,y)=>(ir=e.dynCall_viiiiiiii=A.pe)(n,i,o,a,s,f,p,g,y),In=e.dynCall_iiiiijiiiii=(n,i,o,a,s,f,p,g,y,v,C,S)=>(In=e.dynCall_iiiiijiiiii=A.qe)(n,i,o,a,s,f,p,g,y,v,C,S),Tn=e.dynCall_viiji=(n,i,o,a,s,f)=>(Tn=e.dynCall_viiji=A.re)(n,i,o,a,s,f),On=e.dynCall_viijiii=(n,i,o,a,s,f,p,g)=>(On=e.dynCall_viijiii=A.se)(n,i,o,a,s,f,p,g),En=e.dynCall_viiiiij=(n,i,o,a,s,f,p,g)=>(En=e.dynCall_viiiiij=A.te)(n,i,o,a,s,f,p,g),Pn=e.dynCall_viiiiiiiii=(n,i,o,a,s,f,p,g,y,v)=>(Pn=e.dynCall_viiiiiiiii=A.ue)(n,i,o,a,s,f,p,g,y,v),Rn=e.dynCall_viid=(n,i,o,a)=>(Rn=e.dynCall_viid=A.ve)(n,i,o,a),kn=e.dynCall_iiiiiiiij=(n,i,o,a,s,f,p,g,y,v)=>(kn=e.dynCall_iiiiiiiij=A.we)(n,i,o,a,s,f,p,g,y,v),Bn=e.dynCall_iiiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S)=>(Bn=e.dynCall_iiiiiiiiiiii=A.xe)(n,i,o,a,s,f,p,g,y,v,C,S),Wt=e.dynCall_viiiiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$)=>(Wt=e.dynCall_viiiiiiiiiiiii=A.ye)(n,i,o,a,s,f,p,g,y,v,C,S,I,$),or=e.dynCall_viijjjiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)=>(or=e.dynCall_viijjjiiiiii=A.ze)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M),Gr=e.dynCall_viiijiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I)=>(Gr=e.dynCall_viiijiiiiiii=A.Ae)(n,i,o,a,s,f,p,g,y,v,C,S,I),Vr=e.dynCall_viffiii=(n,i,o,a,s,f,p)=>(Vr=e.dynCall_viffiii=A.Be)(n,i,o,a,s,f,p),Ur=e.dynCall_viiijjjii=(n,i,o,a,s,f,p,g,y,v,C,S)=>(Ur=e.dynCall_viiijjjii=A.Ce)(n,i,o,a,s,f,p,g,y,v,C,S),ar=e.dynCall_viifiii=(n,i,o,a,s,f,p)=>(ar=e.dynCall_viifiii=A.De)(n,i,o,a,s,f,p),sr=e.dynCall_viiiiidiidi=(n,i,o,a,s,f,p,g,y,v,C)=>(sr=e.dynCall_viiiiidiidi=A.Ee)(n,i,o,a,s,f,p,g,y,v,C),Nr=e.dynCall_viiiiiiiiidi=(n,i,o,a,s,f,p,g,y,v,C,S)=>(Nr=e.dynCall_viiiiiiiiidi=A.Fe)(n,i,o,a,s,f,p,g,y,v,C,S),Fr=e.dynCall_vjiiiiii=(n,i,o,a,s,f,p,g,y)=>(Fr=e.dynCall_vjiiiiii=A.Ge)(n,i,o,a,s,f,p,g,y),Hr=e.dynCall_jiii=(n,i,o,a)=>(Hr=e.dynCall_jiii=A.He)(n,i,o,a),ur=e.dynCall_viiid=(n,i,o,a,s)=>(ur=e.dynCall_viiid=A.Ie)(n,i,o,a,s),zt=e.dynCall_viiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S)=>(zt=e.dynCall_viiiiiiiiiii=A.Je)(n,i,o,a,s,f,p,g,y,v,C,S),lr=e.dynCall_vijjjjjjjjjjjjji=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le,ot,at)=>(lr=e.dynCall_vijjjjjjjjjjjjji=A.Ke)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le,ot,at),Lr=e.dynCall_viiiji=(n,i,o,a,s,f,p)=>(Lr=e.dynCall_viiiji=A.Le)(n,i,o,a,s,f,p),Kr=e.dynCall_vijjjiiji=(n,i,o,a,s,f,p,g,y,v,C,S,I)=>(Kr=e.dynCall_vijjjiiji=A.Me)(n,i,o,a,s,f,p,g,y,v,C,S,I),qr=e.dynCall_iiiji=(n,i,o,a,s,f)=>(qr=e.dynCall_iiiji=A.Ne)(n,i,o,a,s,f),Yr=e.dynCall_iiijiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)=>(Yr=e.dynCall_iiijiiiiiiiiii=A.Oe)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M),Xr=e.dynCall_vj=(n,i,o)=>(Xr=e.dynCall_vj=A.Pe)(n,i,o),Mn=e.dynCall_jjj=(n,i,o,a,s)=>(Mn=e.dynCall_jjj=A.Qe)(n,i,o,a,s),Gt=e.dynCall_iiijiiiiii=(n,i,o,a,s,f,p,g,y,v,C)=>(Gt=e.dynCall_iiijiiiiii=A.Re)(n,i,o,a,s,f,p,g,y,v,C),Qr=e.dynCall_viiff=(n,i,o,a,s)=>(Qr=e.dynCall_viiff=A.Se)(n,i,o,a,s),c=e.dynCall_viiiiiff=(n,i,o,a,s,f,p,g)=>(c=e.dynCall_viiiiiff=A.Te)(n,i,o,a,s,f,p,g),b=e.dynCall_vfiii=(n,i,o,a,s)=>(b=e.dynCall_vfiii=A.Ue)(n,i,o,a,s),x=e.dynCall_viiiiff=(n,i,o,a,s,f,p)=>(x=e.dynCall_viiiiff=A.Ve)(n,i,o,a,s,f,p),E=e.dynCall_viiiiiiiiifiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$)=>(E=e.dynCall_viiiiiiiiifiii=A.We)(n,i,o,a,s,f,p,g,y,v,C,S,I,$),V=e.dynCall_viiiiiiiijj=(n,i,o,a,s,f,p,g,y,v,C,S,I)=>(V=e.dynCall_viiiiiiiijj=A.Xe)(n,i,o,a,s,f,p,g,y,v,C,S,I),F=e.dynCall_iiiiiiiiiiiiiifii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q)=>(F=e.dynCall_iiiiiiiiiiiiiifii=A.Ye)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q),J=e.dynCall_viiiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I)=>(J=e.dynCall_viiiiiiiiiiii=A.Ze)(n,i,o,a,s,f,p,g,y,v,C,S,I),pe=e.dynCall_ij=(n,i,o)=>(pe=e.dynCall_ij=A._e)(n,i,o),de=e.dynCall_iiiiiiiiiiiiiiiiifii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge)=>(de=e.dynCall_iiiiiiiiiiiiiiiiifii=A.$e)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge),ce=e.dynCall_vijjiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S)=>(ce=e.dynCall_vijjiiiiii=A.af)(n,i,o,a,s,f,p,g,y,v,C,S),me=e.dynCall_iiiijjj=(n,i,o,a,s,f,p,g,y,v)=>(me=e.dynCall_iiiijjj=A.bf)(n,i,o,a,s,f,p,g,y,v),xe=e.dynCall_viiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C)=>(xe=e.dynCall_viiiiiiiiii=A.cf)(n,i,o,a,s,f,p,g,y,v,C),_e=e.dynCall_iiijjj=(n,i,o,a,s,f,p,g,y)=>(_e=e.dynCall_iiijjj=A.df)(n,i,o,a,s,f,p,g,y),N=e.dynCall_fffffff=(n,i,o,a,s,f,p)=>(N=e.dynCall_fffffff=A.ef)(n,i,o,a,s,f,p),be=e.dynCall_viiiij=(n,i,o,a,s,f,p)=>(be=e.dynCall_viiiij=A.ff)(n,i,o,a,s,f,p),Te=e.dynCall_viijj=(n,i,o,a,s,f,p)=>(Te=e.dynCall_viijj=A.gf)(n,i,o,a,s,f,p),wt=e.dynCall_vjjjjjjffiifiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je)=>(wt=e.dynCall_vjjjjjjffiifiiiiii=A.hf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je),Jr=e.dynCall_viiiiiiffiifiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q)=>(Jr=e.dynCall_viiiiiiffiifiiiii=A.jf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q),Fi=e.dynCall_viiiiiiffifiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)=>(Fi=e.dynCall_viiiiiiffifiiiii=A.kf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G),Hi=e.dynCall_viiiiiiffiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)=>(Hi=e.dynCall_viiiiiiffiiiiii=A.lf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M),Li=e.dynCall_vjjjjjjjjfffiifiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le,ot,at)=>(Li=e.dynCall_vjjjjjjjjfffiifiiiiii=A.mf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le,ot,at),Ki=e.dynCall_vjjjjjjfffifiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De)=>(Ki=e.dynCall_vjjjjjjfffifiiiiiii=A.nf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De),qi=e.dynCall_vjjjjjjfffifiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se)=>(qi=e.dynCall_vjjjjjjfffifiiiii=A.of)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se),Yi=e.dynCall_vjjjjjjjjfffiifiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le,ot)=>(Yi=e.dynCall_vjjjjjjjjfffiifiiiii=A.pf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le,ot),Xi=e.dynCall_vijjfffiii=(n,i,o,a,s,f,p,g,y,v,C,S)=>(Xi=e.dynCall_vijjfffiii=A.qf)(n,i,o,a,s,f,p,g,y,v,C,S),Qi=e.dynCall_vijiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S)=>(Qi=e.dynCall_vijiiiiiiii=A.rf)(n,i,o,a,s,f,p,g,y,v,C,S),Ji=e.dynCall_vijjjjjjifiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve)=>(Ji=e.dynCall_vijjjjjjifiiiii=A.sf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve),Zi=e.dynCall_vjjjjjiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)=>(Zi=e.dynCall_vjjjjjiiii=A.tf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M),eo=e.dynCall_vjjjjfiii=(n,i,o,a,s,f,p,g,y,v,C,S,I)=>(eo=e.dynCall_vjjjjfiii=A.uf)(n,i,o,a,s,f,p,g,y,v,C,S,I),to=e.dynCall_viifi=(n,i,o,a,s)=>(to=e.dynCall_viifi=A.vf)(n,i,o,a,s),ro=e.dynCall_iiiiiji=(n,i,o,a,s,f,p,g)=>(ro=e.dynCall_iiiiiji=A.wf)(n,i,o,a,s,f,p,g),no=e.dynCall_vijjii=(n,i,o,a,s,f,p,g)=>(no=e.dynCall_vijjii=A.xf)(n,i,o,a,s,f,p,g),io=e.dynCall_viiijiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S)=>(io=e.dynCall_viiijiiiiii=A.yf)(n,i,o,a,s,f,p,g,y,v,C,S),oo=e.dynCall_viiiiijjiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)=>(oo=e.dynCall_viiiiijjiiiii=A.zf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M),ao=e.dynCall_iiiiji=(n,i,o,a,s,f,p)=>(ao=e.dynCall_iiiiji=A.Af)(n,i,o,a,s,f,p),so=e.dynCall_viiiiijiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$)=>(so=e.dynCall_viiiiijiiiiii=A.Bf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$),uo=e.dynCall_viiiijii=(n,i,o,a,s,f,p,g,y)=>(uo=e.dynCall_viiiijii=A.Cf)(n,i,o,a,s,f,p,g,y),lo=e.dynCall_viijjiii=(n,i,o,a,s,f,p,g,y,v)=>(lo=e.dynCall_viijjiii=A.Df)(n,i,o,a,s,f,p,g,y,v),co=e.dynCall_ijii=(n,i,o,a,s)=>(co=e.dynCall_ijii=A.Ef)(n,i,o,a,s),fo=e.dynCall_jjjjjjj=(n,i,o,a,s,f,p,g,y,v,C,S,I)=>(fo=e.dynCall_jjjjjjj=A.Ff)(n,i,o,a,s,f,p,g,y,v,C,S,I),po=e.dynCall_jjjjjj=(n,i,o,a,s,f,p,g,y,v,C)=>(po=e.dynCall_jjjjjj=A.Gf)(n,i,o,a,s,f,p,g,y,v,C),mo=e.dynCall_vijjjjiij=(n,i,o,a,s,f,p,g,y,v,C,S,I,$)=>(mo=e.dynCall_vijjjjiij=A.Hf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$),ho=e.dynCall_viiiiijij=(n,i,o,a,s,f,p,g,y,v,C)=>(ho=e.dynCall_viiiiijij=A.If)(n,i,o,a,s,f,p,g,y,v,C),go=e.dynCall_viiiiiijij=(n,i,o,a,s,f,p,g,y,v,C,S)=>(go=e.dynCall_viiiiiijij=A.Jf)(n,i,o,a,s,f,p,g,y,v,C,S),yo=e.dynCall_vijiii=(n,i,o,a,s,f,p)=>(yo=e.dynCall_vijiii=A.Kf)(n,i,o,a,s,f,p),bo=e.dynCall_viiiiiiiiifi=(n,i,o,a,s,f,p,g,y,v,C,S)=>(bo=e.dynCall_viiiiiiiiifi=A.Lf)(n,i,o,a,s,f,p,g,y,v,C,S),vo=e.dynCall_viiijiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)=>(vo=e.dynCall_viiijiiiiiiiii=A.Mf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M),wo=e.dynCall_iiijiiii=(n,i,o,a,s,f,p,g,y)=>(wo=e.dynCall_iiijiiii=A.Nf)(n,i,o,a,s,f,p,g,y),Co=e.dynCall_viiiiiijjiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)=>(Co=e.dynCall_viiiiiijjiiiii=A.Of)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G),$o=e.dynCall_viiiiiiijiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)=>($o=e.dynCall_viiiiiiijiiiiii=A.Pf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G),xo=e.dynCall_vif=(n,i,o)=>(xo=e.dynCall_vif=A.Qf)(n,i,o),So=e.dynCall_viif=(n,i,o,a)=>(So=e.dynCall_viif=A.Rf)(n,i,o,a),_o=e.dynCall_viiiiiifii=(n,i,o,a,s,f,p,g,y,v)=>(_o=e.dynCall_viiiiiifii=A.Sf)(n,i,o,a,s,f,p,g,y,v),Ao=e.dynCall_viiiiijiiiiiiiiiiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le)=>(Ao=e.dynCall_viiiiijiiiiiiiiiiiiiiiiiii=A.Tf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le),Io=e.dynCall_viijji=(n,i,o,a,s,f,p,g)=>(Io=e.dynCall_viijji=A.Uf)(n,i,o,a,s,f,p,g),To=e.dynCall_iiiiiiiiiiiji=(n,i,o,a,s,f,p,g,y,v,C,S,I,$)=>(To=e.dynCall_iiiiiiiiiiiji=A.Vf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$),Oo=e.dynCall_viifiifijjjii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)=>(Oo=e.dynCall_viifiifijjjii=A.Wf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G),Eo=e.dynCall_viiiiiiiiiiiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve)=>(Eo=e.dynCall_viiiiiiiiiiiiiiiiiiii=A.Xf)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve),Po=e.dynCall_iif=(n,i,o)=>(Po=e.dynCall_iif=A.Yf)(n,i,o),Ro=e.dynCall_viiiiifiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I)=>(Ro=e.dynCall_viiiiifiiiiii=A.Zf)(n,i,o,a,s,f,p,g,y,v,C,S,I),ko=e.dynCall_vijiiiiiiijjii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q)=>(ko=e.dynCall_vijiiiiiiijjii=A._f)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q),Bo=e.dynCall_iiiiid=(n,i,o,a,s,f)=>(Bo=e.dynCall_iiiiid=A.$f)(n,i,o,a,s,f),Mo=e.dynCall_viiiijjj=(n,i,o,a,s,f,p,g,y,v,C)=>(Mo=e.dynCall_viiiijjj=A.ag)(n,i,o,a,s,f,p,g,y,v,C),jo=e.dynCall_viiiiiiiiiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se)=>(jo=e.dynCall_viiiiiiiiiiiiiiiiii=A.bg)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se),Do=e.dynCall_viiiiiiiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q)=>(Do=e.dynCall_viiiiiiiiiiiiiiii=A.cg)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q),Wo=e.dynCall_viiiiiiiiiiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge)=>(Wo=e.dynCall_viiiiiiiiiiiiiiiiiii=A.dg)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge),zo=e.dynCall_viiiiiiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)=>(zo=e.dynCall_viiiiiiiiiiiiiii=A.eg)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G),Go=e.dynCall_viiiiiiijjj=(n,i,o,a,s,f,p,g,y,v,C,S,I,$)=>(Go=e.dynCall_viiiiiiijjj=A.fg)(n,i,o,a,s,f,p,g,y,v,C,S,I,$),Vo=e.dynCall_iiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C)=>(Vo=e.dynCall_iiiiiiiiiii=A.gg)(n,i,o,a,s,f,p,g,y,v,C),Uo=e.dynCall_iiiiiiiiiiiiiiiiiifi=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge)=>(Uo=e.dynCall_iiiiiiiiiiiiiiiiiifi=A.hg)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge),No=e.dynCall_viiif=(n,i,o,a,s)=>(No=e.dynCall_viiif=A.ig)(n,i,o,a,s),Fo=e.dynCall_iijjj=(n,i,o,a,s,f,p,g)=>(Fo=e.dynCall_iijjj=A.jg)(n,i,o,a,s,f,p,g),Ho=e.dynCall_viiiiji=(n,i,o,a,s,f,p,g)=>(Ho=e.dynCall_viiiiji=A.kg)(n,i,o,a,s,f,p,g),Lo=e.dynCall_iijjji=(n,i,o,a,s,f,p,g,y)=>(Lo=e.dynCall_iijjji=A.lg)(n,i,o,a,s,f,p,g,y),Ko=e.dynCall_ijijji=(n,i,o,a,s,f,p,g,y)=>(Ko=e.dynCall_ijijji=A.mg)(n,i,o,a,s,f,p,g,y),qo=e.dynCall_viiijjiii=(n,i,o,a,s,f,p,g,y,v,C)=>(qo=e.dynCall_viiijjiii=A.ng)(n,i,o,a,s,f,p,g,y,v,C),Yo=e.dynCall_iiiiijji=(n,i,o,a,s,f,p,g,y,v)=>(Yo=e.dynCall_iiiiijji=A.og)(n,i,o,a,s,f,p,g,y,v),Xo=e.dynCall_viji=(n,i,o,a,s)=>(Xo=e.dynCall_viji=A.pg)(n,i,o,a,s),Qo=e.dynCall_iiiifi=(n,i,o,a,s,f)=>(Qo=e.dynCall_iiiifi=A.qg)(n,i,o,a,s,f),Jo=e.dynCall_iiijii=(n,i,o,a,s,f,p)=>(Jo=e.dynCall_iiijii=A.rg)(n,i,o,a,s,f,p),Zo=e.dynCall_iiiiiiiiijii=(n,i,o,a,s,f,p,g,y,v,C,S,I)=>(Zo=e.dynCall_iiiiiiiiijii=A.sg)(n,i,o,a,s,f,p,g,y,v,C,S,I),ea=e.dynCall_iiiijjii=(n,i,o,a,s,f,p,g,y,v)=>(ea=e.dynCall_iiiijjii=A.tg)(n,i,o,a,s,f,p,g,y,v),ta=e.dynCall_iiiiiijjjii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$)=>(ta=e.dynCall_iiiiiijjjii=A.ug)(n,i,o,a,s,f,p,g,y,v,C,S,I,$),ra=e.dynCall_iiijiii=(n,i,o,a,s,f,p,g)=>(ra=e.dynCall_iiijiii=A.vg)(n,i,o,a,s,f,p,g),na=e.dynCall_iiiiiiiijjjfi=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)=>(na=e.dynCall_iiiiiiiijjjfi=A.wg)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G),ia=e.dynCall_iijiiii=(n,i,o,a,s,f,p,g)=>(ia=e.dynCall_iijiiii=A.xg)(n,i,o,a,s,f,p,g),oa=e.dynCall_iijjjii=(n,i,o,a,s,f,p,g,y,v)=>(oa=e.dynCall_iijjjii=A.yg)(n,i,o,a,s,f,p,g,y,v),aa=e.dynCall_iiji=(n,i,o,a,s)=>(aa=e.dynCall_iiji=A.zg)(n,i,o,a,s),sa=e.dynCall_viiijiiiii=(n,i,o,a,s,f,p,g,y,v,C)=>(sa=e.dynCall_viiijiiiii=A.Ag)(n,i,o,a,s,f,p,g,y,v,C),ua=e.dynCall_iid=(n,i,o)=>(ua=e.dynCall_iid=A.Bg)(n,i,o),la=e.dynCall_iiif=(n,i,o,a)=>(la=e.dynCall_iiif=A.Cg)(n,i,o,a),ca=e.dynCall_vidi=(n,i,o,a)=>(ca=e.dynCall_vidi=A.Dg)(n,i,o,a),da=e.dynCall_vjiii=(n,i,o,a,s,f)=>(da=e.dynCall_vjiii=A.Eg)(n,i,o,a,s,f),fa=e.dynCall_iiiij=(n,i,o,a,s,f)=>(fa=e.dynCall_iiiij=A.Fg)(n,i,o,a,s,f),pa=e.dynCall_viiijii=(n,i,o,a,s,f,p,g)=>(pa=e.dynCall_viiijii=A.Gg)(n,i,o,a,s,f,p,g),ma=e.dynCall_viijiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$)=>(ma=e.dynCall_viijiiiiiiiii=A.Hg)(n,i,o,a,s,f,p,g,y,v,C,S,I,$),ha=e.dynCall_viiij=(n,i,o,a,s,f)=>(ha=e.dynCall_viiij=A.Ig)(n,i,o,a,s,f),ga=e.dynCall_fiiii=(n,i,o,a,s)=>(ga=e.dynCall_fiiii=A.Jg)(n,i,o,a,s),ya=e.dynCall_jfi=(n,i,o)=>(ya=e.dynCall_jfi=A.Kg)(n,i,o),ba=e.dynCall_viiiiiiiiiiiiii=(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)=>(ba=e.dynCall_viiiiiiiiiiiiii=A.Lg)(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M),va=e.dynCall_jiij=(n,i,o,a,s)=>(va=e.dynCall_jiij=A.Mg)(n,i,o,a,s),wa=e.dynCall_fiii=(n,i,o,a)=>(wa=e.dynCall_fiii=A.Ng)(n,i,o,a),Ca=n=>(Ca=A.Og)(n),$a=()=>($a=A.Pg)(),xa=n=>(xa=A.Qg)(n),Sa=()=>(Sa=A.Rg)();e.___start_em_js=1323794,e.___stop_em_js=1323955;function yc(n,i,o,a){var s=z();try{return er(n,i,o,a)}catch(f){if(D(s),f!==f+0)throw f;W(1,0)}}function bc(n,i,o){var a=z();try{return Ar(n,i,o)}catch(s){if(D(a),s!==s+0)throw s;W(1,0)}}function vc(n,i,o){var a=z();try{_r(n,i,o)}catch(s){if(D(a),s!==s+0)throw s;W(1,0)}}function wc(n,i){var o=z();try{return Cn(n,i)}catch(a){if(D(o),a!==a+0)throw a;W(1,0)}}function Cc(n,i){var o=z();try{Sr(n,i)}catch(a){if(D(o),a!==a+0)throw a;W(1,0)}}function $c(n){var i=z();try{tr(n)}catch(o){if(D(i),o!==o+0)throw o;W(1,0)}}function xc(n,i,o,a,s,f,p){var g=z();try{return ke(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function Sc(n,i,o,a,s,f){var p=z();try{return rr(n,i,o,a,s,f)}catch(g){if(D(p),g!==g+0)throw g;W(1,0)}}function _c(n,i,o,a,s){var f=z();try{return nr(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function Ac(n,i,o,a){var s=z();try{Tr(n,i,o,a)}catch(f){if(D(s),f!==f+0)throw f;W(1,0)}}function Ic(n,i,o,a,s){var f=z();try{Br(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function Tc(n){var i=z();try{return Er(n)}catch(o){if(D(i),o!==o+0)throw o;W(1,0)}}function Oc(n,i,o,a,s,f){var p=z();try{kr(n,i,o,a,s,f)}catch(g){if(D(p),g!==g+0)throw g;W(1,0)}}function Ec(n,i,o,a,s,f,p,g){var y=z();try{return Mr(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function Pc(n,i){var o=z();try{return xn(n,i)}catch(a){if(D(o),a!==a+0)throw a;W(1,0)}}function Rc(n,i){var o=z();try{return jt(n,i)}catch(a){if(D(o),a!==a+0)throw a;W(1,0)}}function kc(n,i,o,a,s,f,p,g,y){var v=z();try{return it(n,i,o,a,s,f,p,g,y)}catch(C){if(D(v),C!==C+0)throw C;W(1,0)}}function Bc(n,i,o,a,s,f,p){var g=z();try{Dt(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function Mc(n,i,o,a,s,f,p,g){var y=z();try{zr(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function jc(n,i,o,a,s,f,p,g,y,v){var C=z();try{return An(n,i,o,a,s,f,p,g,y,v)}catch(S){if(D(C),S!==S+0)throw S;W(1,0)}}function Dc(n,i,o,a,s,f,p,g,y){var v=z();try{ir(n,i,o,a,s,f,p,g,y)}catch(C){if(D(v),C!==C+0)throw C;W(1,0)}}function Wc(n,i,o,a,s,f,p,g,y,v){var C=z();try{Pn(n,i,o,a,s,f,p,g,y,v)}catch(S){if(D(C),S!==S+0)throw S;W(1,0)}}function zc(n,i,o,a){var s=z();try{Rn(n,i,o,a)}catch(f){if(D(s),f!==f+0)throw f;W(1,0)}}function Gc(n,i,o,a,s,f,p,g,y,v,C,S){var I=z();try{return Bn(n,i,o,a,s,f,p,g,y,v,C,S)}catch($){if(D(I),$!==$+0)throw $;W(1,0)}}function Vc(n,i,o,a,s,f,p,g,y,v,C,S,I,$){var M=z();try{Wt(n,i,o,a,s,f,p,g,y,v,C,S,I,$)}catch(G){if(D(M),G!==G+0)throw G;W(1,0)}}function Uc(n,i,o,a,s,f,p){var g=z();try{Vr(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function Nc(n,i,o,a,s,f,p){var g=z();try{ar(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function Fc(n,i,o,a,s,f,p,g,y,v,C){var S=z();try{sr(n,i,o,a,s,f,p,g,y,v,C)}catch(I){if(D(S),I!==I+0)throw I;W(1,0)}}function Hc(n,i,o,a,s){var f=z();try{ur(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function Lc(n,i,o,a,s){var f=z();try{return ga(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function Kc(n,i,o,a,s,f,p,g,y,v,C,S,I,$){var M=z();try{E(n,i,o,a,s,f,p,g,y,v,C,S,I,$)}catch(G){if(D(M),G!==G+0)throw G;W(1,0)}}function qc(n,i,o,a,s){var f=z();try{b(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function Yc(n,i,o,a,s,f,p){var g=z();try{x(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function Xc(n,i,o,a,s){var f=z();try{Qr(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function Qc(n,i,o,a,s,f,p,g){var y=z();try{c(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function Jc(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q){var te=z();try{return F(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q)}catch(se){if(D(te),se!==se+0)throw se;W(1,0)}}function Zc(n,i,o,a,s,f,p,g,y,v,C,S,I){var $=z();try{J(n,i,o,a,s,f,p,g,y,v,C,S,I)}catch(M){if(D($),M!==M+0)throw M;W(1,0)}}function ed(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge){var ve=z();try{return de(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge)}catch(we){if(D(ve),we!==we+0)throw we;W(1,0)}}function td(n,i,o,a,s,f,p,g,y,v,C){var S=z();try{xe(n,i,o,a,s,f,p,g,y,v,C)}catch(I){if(D(S),I!==I+0)throw I;W(1,0)}}function rd(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q){var te=z();try{Jr(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q)}catch(se){if(D(te),se!==se+0)throw se;W(1,0)}}function nd(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G){var q=z();try{Fi(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)}catch(te){if(D(q),te!==te+0)throw te;W(1,0)}}function id(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M){var G=z();try{Hi(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)}catch(q){if(D(G),q!==q+0)throw q;W(1,0)}}function od(n,i,o,a,s,f,p){var g=z();try{return N(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function ad(n,i,o,a,s){var f=z();try{to(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function sd(n,i,o,a,s,f,p,g,y,v,C,S){var I=z();try{bo(n,i,o,a,s,f,p,g,y,v,C,S)}catch($){if(D(I),$!==$+0)throw $;W(1,0)}}function ud(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M){var G=z();try{ba(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)}catch(q){if(D(G),q!==q+0)throw q;W(1,0)}}function ld(n,i,o){var a=z();try{xo(n,i,o)}catch(s){if(D(a),s!==s+0)throw s;W(1,0)}}function cd(n,i,o,a,s,f,p,g,y,v){var C=z();try{_o(n,i,o,a,s,f,p,g,y,v)}catch(S){if(D(C),S!==S+0)throw S;W(1,0)}}function dd(n,i,o,a,s,f,p,g,y,v,C,S){var I=z();try{zt(n,i,o,a,s,f,p,g,y,v,C,S)}catch($){if(D(I),$!==$+0)throw $;W(1,0)}}function fd(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve){var we=z();try{Eo(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve)}catch(Se){if(D(we),Se!==Se+0)throw Se;W(1,0)}}function pd(n,i,o){var a=z();try{return Po(n,i,o)}catch(s){if(D(a),s!==s+0)throw s;W(1,0)}}function md(n,i,o,a,s,f,p,g,y,v,C,S,I){var $=z();try{Ro(n,i,o,a,s,f,p,g,y,v,C,S,I)}catch(M){if(D($),M!==M+0)throw M;W(1,0)}}function hd(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q){var te=z();try{Do(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q)}catch(se){if(D(te),se!==se+0)throw se;W(1,0)}}function gd(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge){var ve=z();try{Wo(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge)}catch(we){if(D(ve),we!==we+0)throw we;W(1,0)}}function yd(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se){var ge=z();try{jo(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se)}catch(ve){if(D(ge),ve!==ve+0)throw ve;W(1,0)}}function bd(n,i,o,a,s,f,p,g,y,v,C){var S=z();try{return Vo(n,i,o,a,s,f,p,g,y,v,C)}catch(I){if(D(S),I!==I+0)throw I;W(1,0)}}function vd(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge){var ve=z();try{return Uo(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge)}catch(we){if(D(ve),we!==we+0)throw we;W(1,0)}}function wd(n,i,o,a,s){var f=z();try{No(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function Cd(n,i,o,a,s,f,p,g,y,v,C,S){var I=z();try{Nr(n,i,o,a,s,f,p,g,y,v,C,S)}catch($){if(D(I),$!==$+0)throw $;W(1,0)}}function $d(n,i,o,a){var s=z();try{So(n,i,o,a)}catch(f){if(D(s),f!==f+0)throw f;W(1,0)}}function xd(n,i,o,a,s,f){var p=z();try{return Qo(n,i,o,a,s,f)}catch(g){if(D(p),g!==g+0)throw g;W(1,0)}}function Sd(n,i,o){var a=z();try{return ua(n,i,o)}catch(s){if(D(a),s!==s+0)throw s;W(1,0)}}function _d(n,i,o,a){var s=z();try{return la(n,i,o,a)}catch(f){if(D(s),f!==f+0)throw f;W(1,0)}}function Ad(n,i,o,a){var s=z();try{ca(n,i,o,a)}catch(f){if(D(s),f!==f+0)throw f;W(1,0)}}function Id(n,i,o,a){var s=z();try{return wa(n,i,o,a)}catch(f){if(D(s),f!==f+0)throw f;W(1,0)}}function Td(n,i,o,a,s,f){var p=z();try{return Bo(n,i,o,a,s,f)}catch(g){if(D(p),g!==g+0)throw g;W(1,0)}}function Od(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G){var q=z();try{zo(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)}catch(te){if(D(q),te!==te+0)throw te;W(1,0)}}function Ed(n,i,o){var a=z();try{return Sn(n,i,o)}catch(s){if(D(a),s!==s+0)throw s;W(1,0)}}function Pd(n,i,o){var a=z();try{return pt(n,i,o)}catch(s){if(D(a),s!==s+0)throw s;W(1,0)}}function Rd(n,i,o,a,s){var f=z();try{return Ir(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function kd(n,i,o,a){var s=z();try{return Pr(n,i,o,a)}catch(f){if(D(s),f!==f+0)throw f;W(1,0)}}function Bd(n,i,o,a){var s=z();try{$n(n,i,o,a)}catch(f){if(D(s),f!==f+0)throw f;W(1,0)}}function Md(n,i){var o=z();try{return jr(n,i)}catch(a){if(D(o),a!==a+0)throw a;W(1,0)}}function jd(n,i,o,a,s){var f=z();try{Dr(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function Dd(n,i,o,a,s,f){var p=z();try{Wr(n,i,o,a,s,f)}catch(g){if(D(p),g!==g+0)throw g;W(1,0)}}function Wd(n,i,o,a,s,f,p,g){var y=z();try{pa(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function zd(n,i,o,a,s,f,p){var g=z();try{Te(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function Gd(n,i,o,a,s,f,p,g,y,v,C,S){var I=z();try{return In(n,i,o,a,s,f,p,g,y,v,C,S)}catch($){if(D(I),$!==$+0)throw $;W(1,0)}}function Vd(n,i,o,a,s,f,p,g){var y=z();try{On(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function Ud(n,i,o,a,s,f,p,g){var y=z();try{En(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function Nd(n,i,o){var a=z();try{return _n(n,i,o)}catch(s){if(D(a),s!==s+0)throw s;W(1,0)}}function Fd(n,i,o,a,s,f,p,g,y,v){var C=z();try{return kn(n,i,o,a,s,f,p,g,y,v)}catch(S){if(D(C),S!==S+0)throw S;W(1,0)}}function Hd(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M){var G=z();try{or(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)}catch(q){if(D(G),q!==q+0)throw q;W(1,0)}}function Ld(n,i,o,a,s,f,p,g,y,v,C,S,I){var $=z();try{Gr(n,i,o,a,s,f,p,g,y,v,C,S,I)}catch(M){if(D($),M!==M+0)throw M;W(1,0)}}function Kd(n,i,o,a,s,f){var p=z();try{Tn(n,i,o,a,s,f)}catch(g){if(D(p),g!==g+0)throw g;W(1,0)}}function qd(n,i,o,a,s,f,p,g,y,v,C,S){var I=z();try{Ur(n,i,o,a,s,f,p,g,y,v,C,S)}catch($){if(D(I),$!==$+0)throw $;W(1,0)}}function Yd(n,i,o,a,s,f,p,g,y){var v=z();try{Fr(n,i,o,a,s,f,p,g,y)}catch(C){if(D(v),C!==C+0)throw C;W(1,0)}}function Xd(n,i,o,a){var s=z();try{return Hr(n,i,o,a)}catch(f){if(D(s),f!==f+0)throw f;W(1,0)}}function Qd(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le,ot,at){var Vt=z();try{lr(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le,ot,at)}catch(Ut){if(D(Vt),Ut!==Ut+0)throw Ut;W(1,0)}}function Jd(n,i,o,a,s,f,p){var g=z();try{Lr(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function Zd(n,i,o,a,s,f,p,g,y,v,C,S,I){var $=z();try{Kr(n,i,o,a,s,f,p,g,y,v,C,S,I)}catch(M){if(D($),M!==M+0)throw M;W(1,0)}}function ef(n,i,o,a,s,f){var p=z();try{return qr(n,i,o,a,s,f)}catch(g){if(D(p),g!==g+0)throw g;W(1,0)}}function tf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M){var G=z();try{return Yr(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)}catch(q){if(D(G),q!==q+0)throw q;W(1,0)}}function rf(n,i,o){var a=z();try{Xr(n,i,o)}catch(s){if(D(a),s!==s+0)throw s;W(1,0)}}function nf(n,i,o,a,s){var f=z();try{return Mn(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function of(n,i,o,a,s,f,p,g,y,v,C){var S=z();try{return Gt(n,i,o,a,s,f,p,g,y,v,C)}catch(I){if(D(S),I!==I+0)throw I;W(1,0)}}function af(n,i,o,a,s,f,p,g,y,v,C,S,I){var $=z();try{V(n,i,o,a,s,f,p,g,y,v,C,S,I)}catch(M){if(D($),M!==M+0)throw M;W(1,0)}}function sf(n,i,o){var a=z();try{return pe(n,i,o)}catch(s){if(D(a),s!==s+0)throw s;W(1,0)}}function uf(n,i,o,a,s,f,p,g,y,v,C,S){var I=z();try{ce(n,i,o,a,s,f,p,g,y,v,C,S)}catch($){if(D(I),$!==$+0)throw $;W(1,0)}}function lf(n,i,o,a,s,f,p,g,y,v){var C=z();try{return me(n,i,o,a,s,f,p,g,y,v)}catch(S){if(D(C),S!==S+0)throw S;W(1,0)}}function cf(n,i,o,a,s,f,p,g,y){var v=z();try{return _e(n,i,o,a,s,f,p,g,y)}catch(C){if(D(v),C!==C+0)throw C;W(1,0)}}function df(n,i,o,a,s,f,p){var g=z();try{be(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function ff(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je){var De=z();try{wt(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je)}catch(Ve){if(D(De),Ve!==Ve+0)throw Ve;W(1,0)}}function pf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le,ot,at){var Vt=z();try{Li(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le,ot,at)}catch(Ut){if(D(Vt),Ut!==Ut+0)throw Ut;W(1,0)}}function mf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De){var Ve=z();try{Ki(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De)}catch(Le){if(D(Ve),Le!==Le+0)throw Le;W(1,0)}}function hf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se){var je=z();try{qi(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se)}catch(De){if(D(je),De!==De+0)throw De;W(1,0)}}function gf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le,ot){var at=z();try{Yi(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le,ot)}catch(Vt){if(D(at),Vt!==Vt+0)throw Vt;W(1,0)}}function yf(n,i,o,a,s,f,p,g,y,v,C,S){var I=z();try{Xi(n,i,o,a,s,f,p,g,y,v,C,S)}catch($){if(D(I),$!==$+0)throw $;W(1,0)}}function bf(n,i,o,a,s,f,p,g,y,v,C,S){var I=z();try{Qi(n,i,o,a,s,f,p,g,y,v,C,S)}catch($){if(D(I),$!==$+0)throw $;W(1,0)}}function vf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve){var we=z();try{Ji(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve)}catch(Se){if(D(we),Se!==Se+0)throw Se;W(1,0)}}function wf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M){var G=z();try{Zi(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)}catch(q){if(D(G),q!==q+0)throw q;W(1,0)}}function Cf(n,i,o,a,s,f,p,g,y,v,C,S,I){var $=z();try{eo(n,i,o,a,s,f,p,g,y,v,C,S,I)}catch(M){if(D($),M!==M+0)throw M;W(1,0)}}function $f(n,i,o){var a=z();try{return ya(n,i,o)}catch(s){if(D(a),s!==s+0)throw s;W(1,0)}}function xf(n,i,o,a,s,f,p,g){var y=z();try{return ro(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function Sf(n,i,o,a,s,f,p,g){var y=z();try{no(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function _f(n,i,o,a,s,f,p,g,y,v,C,S){var I=z();try{io(n,i,o,a,s,f,p,g,y,v,C,S)}catch($){if(D(I),$!==$+0)throw $;W(1,0)}}function Af(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M){var G=z();try{oo(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)}catch(q){if(D(G),q!==q+0)throw q;W(1,0)}}function If(n,i,o,a,s,f,p){var g=z();try{return ao(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function Tf(n,i,o,a,s,f,p,g,y,v,C,S,I,$){var M=z();try{so(n,i,o,a,s,f,p,g,y,v,C,S,I,$)}catch(G){if(D(M),G!==G+0)throw G;W(1,0)}}function Of(n,i,o,a,s,f,p,g,y){var v=z();try{uo(n,i,o,a,s,f,p,g,y)}catch(C){if(D(v),C!==C+0)throw C;W(1,0)}}function Ef(n,i,o,a,s,f,p,g,y,v){var C=z();try{lo(n,i,o,a,s,f,p,g,y,v)}catch(S){if(D(C),S!==S+0)throw S;W(1,0)}}function Pf(n,i,o,a,s){var f=z();try{return co(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function Rf(n,i,o,a,s,f,p,g,y,v,C){var S=z();try{return po(n,i,o,a,s,f,p,g,y,v,C)}catch(I){if(D(S),I!==I+0)throw I;W(1,0)}}function kf(n,i,o,a,s,f,p,g,y,v,C,S,I){var $=z();try{return fo(n,i,o,a,s,f,p,g,y,v,C,S,I)}catch(M){if(D($),M!==M+0)throw M;W(1,0)}}function Bf(n,i,o,a,s,f,p,g,y,v,C,S,I,$){var M=z();try{mo(n,i,o,a,s,f,p,g,y,v,C,S,I,$)}catch(G){if(D(M),G!==G+0)throw G;W(1,0)}}function Mf(n,i,o,a,s,f,p,g,y,v,C){var S=z();try{ho(n,i,o,a,s,f,p,g,y,v,C)}catch(I){if(D(S),I!==I+0)throw I;W(1,0)}}function jf(n,i,o,a,s,f,p,g,y,v,C,S){var I=z();try{go(n,i,o,a,s,f,p,g,y,v,C,S)}catch($){if(D(I),$!==$+0)throw $;W(1,0)}}function Df(n,i,o,a,s,f,p){var g=z();try{yo(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function Wf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M){var G=z();try{vo(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M)}catch(q){if(D(G),q!==q+0)throw q;W(1,0)}}function zf(n,i,o,a,s,f,p,g,y){var v=z();try{return wo(n,i,o,a,s,f,p,g,y)}catch(C){if(D(v),C!==C+0)throw C;W(1,0)}}function Gf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G){var q=z();try{Co(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)}catch(te){if(D(q),te!==te+0)throw te;W(1,0)}}function Vf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G){var q=z();try{$o(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)}catch(te){if(D(q),te!==te+0)throw te;W(1,0)}}function Uf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le){var ot=z();try{Ao(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q,te,se,ge,ve,we,Se,je,De,Ve,Le)}catch(at){if(D(ot),at!==at+0)throw at;W(1,0)}}function Nf(n,i,o,a,s,f,p,g){var y=z();try{Io(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function Ff(n,i,o,a,s,f,p,g,y,v,C,S,I,$){var M=z();try{return To(n,i,o,a,s,f,p,g,y,v,C,S,I,$)}catch(G){if(D(M),G!==G+0)throw G;W(1,0)}}function Hf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G){var q=z();try{Oo(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)}catch(te){if(D(q),te!==te+0)throw te;W(1,0)}}function Lf(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q){var te=z();try{ko(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G,q)}catch(se){if(D(te),se!==se+0)throw se;W(1,0)}}function Kf(n,i,o,a,s,f,p,g,y,v,C){var S=z();try{Mo(n,i,o,a,s,f,p,g,y,v,C)}catch(I){if(D(S),I!==I+0)throw I;W(1,0)}}function qf(n,i,o,a,s,f,p,g,y,v,C,S,I,$){var M=z();try{Go(n,i,o,a,s,f,p,g,y,v,C,S,I,$)}catch(G){if(D(M),G!==G+0)throw G;W(1,0)}}function Yf(n,i,o,a,s,f,p,g){var y=z();try{return Fo(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function Xf(n,i,o,a,s){var f=z();try{return va(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function Qf(n,i,o,a,s,f,p,g){var y=z();try{Ho(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function Jf(n,i,o,a,s,f,p,g,y){var v=z();try{return Lo(n,i,o,a,s,f,p,g,y)}catch(C){if(D(v),C!==C+0)throw C;W(1,0)}}function Zf(n,i,o,a,s,f,p,g,y){var v=z();try{return Ko(n,i,o,a,s,f,p,g,y)}catch(C){if(D(v),C!==C+0)throw C;W(1,0)}}function ep(n,i,o,a,s,f,p,g,y,v,C){var S=z();try{qo(n,i,o,a,s,f,p,g,y,v,C)}catch(I){if(D(S),I!==I+0)throw I;W(1,0)}}function tp(n,i,o,a,s,f,p,g,y,v){var C=z();try{return Yo(n,i,o,a,s,f,p,g,y,v)}catch(S){if(D(C),S!==S+0)throw S;W(1,0)}}function rp(n,i,o,a,s){var f=z();try{Xo(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function np(n,i,o,a,s,f,p){var g=z();try{return Jo(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function ip(n,i,o,a,s,f,p,g,y,v,C,S,I){var $=z();try{return Zo(n,i,o,a,s,f,p,g,y,v,C,S,I)}catch(M){if(D($),M!==M+0)throw M;W(1,0)}}function op(n,i,o,a,s,f,p,g,y,v){var C=z();try{return ea(n,i,o,a,s,f,p,g,y,v)}catch(S){if(D(C),S!==S+0)throw S;W(1,0)}}function ap(n,i,o,a,s,f,p,g,y,v,C,S,I,$){var M=z();try{return ta(n,i,o,a,s,f,p,g,y,v,C,S,I,$)}catch(G){if(D(M),G!==G+0)throw G;W(1,0)}}function sp(n,i,o,a,s,f,p,g){var y=z();try{return ra(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function up(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G){var q=z();try{return na(n,i,o,a,s,f,p,g,y,v,C,S,I,$,M,G)}catch(te){if(D(q),te!==te+0)throw te;W(1,0)}}function lp(n,i,o,a,s,f,p,g){var y=z();try{return ia(n,i,o,a,s,f,p,g)}catch(v){if(D(y),v!==v+0)throw v;W(1,0)}}function cp(n,i,o,a,s,f,p,g,y,v){var C=z();try{return oa(n,i,o,a,s,f,p,g,y,v)}catch(S){if(D(C),S!==S+0)throw S;W(1,0)}}function dp(n,i,o,a,s){var f=z();try{return aa(n,i,o,a,s)}catch(p){if(D(f),p!==p+0)throw p;W(1,0)}}function fp(n,i,o,a,s,f,p,g,y,v,C){var S=z();try{sa(n,i,o,a,s,f,p,g,y,v,C)}catch(I){if(D(S),I!==I+0)throw I;W(1,0)}}function pp(n,i,o,a,s,f){var p=z();try{ha(n,i,o,a,s,f)}catch(g){if(D(p),g!==g+0)throw g;W(1,0)}}function mp(n,i,o,a,s,f,p,g,y,v,C,S,I,$){var M=z();try{ma(n,i,o,a,s,f,p,g,y,v,C,S,I,$)}catch(G){if(D(M),G!==G+0)throw G;W(1,0)}}function hp(n,i,o,a,s,f){var p=z();try{da(n,i,o,a,s,f)}catch(g){if(D(p),g!==g+0)throw g;W(1,0)}}function gp(n,i,o,a,s,f){var p=z();try{return fa(n,i,o,a,s,f)}catch(g){if(D(p),g!==g+0)throw g;W(1,0)}}function yp(n){var i=z();try{return Or(n)}catch(o){if(D(i),o!==o+0)throw o;W(1,0)}}function bp(n,i,o,a,s,f,p){var g=z();try{return Rr(n,i,o,a,s,f,p)}catch(y){if(D(g),y!==y+0)throw y;W(1,0)}}function vp(n){n=Object.assign({},n);var i=a=>()=>a()>>>0,o=a=>s=>a(s)>>>0;return n.__errno_location=i(n.__errno_location),n.malloc=o(n.malloc),n.stackSave=i(n.stackSave),n.stackAlloc=o(n.stackAlloc),n}e.stackAlloc=Mt,e.stackSave=z,e.stackRestore=D,e.UTF8ToString=ct,e.stringToUTF8=(n,i,o)=>bt(n,Ce,i,o),e.lengthBytesUTF8=mr;var jn;gt=function n(){jn||_a(),jn||(gt=n)};function _a(){function n(){if(!jn&&(jn=!0,e.calledRun=!0,!Z)){if(ut(Ze),d(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for(typeof e.postRun=="function"&&(e.postRun=[e.postRun]);e.postRun.length;){var i=e.postRun.shift();Ie.unshift(i)}ut(Ie)}}if(!(0<Ee)){if(e.preRun)for(typeof e.preRun=="function"&&(e.preRun=[e.preRun]);e.preRun.length;)He();ut(ae),0<Ee||(e.setStatus?(e.setStatus("Running..."),setTimeout(function(){setTimeout(function(){e.setStatus("")},1),n()},1)):n())}}if(e.preInit)for(typeof e.preInit=="function"&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return _a(),r.ready}})();typeof Ia=="object"&&typeof pi=="object"?pi.exports=Aa:typeof define=="function"&&define.amd&&define([],()=>Aa)});var Oa=Zr(()=>{});var Ea=Zr(()=>{});var Pa={};Dn(Pa,{cpus:()=>Ap});var Ap,Ra=oe(()=>{Ap=void 0});var Ma=Zr((Ba,mi)=>{"use strict";var ka=(()=>{var t=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(t=t||__filename),function(r={}){function e(){return ue.buffer!=Ee.buffer&&ee(),Ee}function d(){return ue.buffer!=Ee.buffer&&ee(),qe}function l(){return ue.buffer!=Ee.buffer&&ee(),gt}function m(){return ue.buffer!=Ee.buffer&&ee(),Je}function h(){return ue.buffer!=Ee.buffer&&ee(),_t}var u=r,w,_;u.ready=new Promise((c,b)=>{w=c,_=b}),u.jsepInit=(c,b,x,E,V,F,J,pe)=>{u.Qb=c,u.wb=b,u.yb=x,u.jb=E,u.xb=V,u.Ea=F,u.zb=J,u.Ab=pe,b=(de,ce,me)=>(...xe)=>{let _e=it,N=ce?.();xe=de(...xe);let be=ce?.();return N!==be&&(de=be,me(N),ce=me=null),it!=_e?Tn():xe},x=de=>async(...ce)=>{try{if(u.bb)throw Error("Session already started");let me=u.bb={Fb:ce[0],errors:[]},xe=await de(...ce);if(u.bb!==me)throw Error("Session mismatch");c.flush();let _e=me.errors;if(0<_e.length){let N=await Promise.all(_e);if(N=N.filter(be=>be),0<N.length)throw Error(N.join(`\n`))}return xe}finally{u.bb=null}},u._OrtRun=x(b(u._OrtRun,()=>u._OrtRun,de=>u._OrtRun=de)),u._OrtRunWithBinding=x(b(u._OrtRunWithBinding,()=>u._OrtRunWithBinding,de=>u._OrtRunWithBinding=de)),u._OrtBindInput=b(u._OrtBindInput,()=>u._OrtBindInput,de=>u._OrtBindInput=de),u.jsepRegisterBuffer=(de,ce,me,xe)=>c.registerBuffer(de,ce,me,xe),u.jsepUnregisterBuffers=de=>{c.unregisterBuffers(de)},u.jsepGetBuffer=de=>c.getBuffer(de),u.jsepCreateDownloader=(de,ce,me)=>c.createDownloader(de,ce,me)};var O=Object.assign({},u),j="./this.program",B=(c,b)=>{throw b},P=typeof window=="object",R=typeof importScripts=="function",T=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",k=u.ENVIRONMENT_IS_PTHREAD||!1,U="";function K(c){return u.locateFile?u.locateFile(c,U):U+c}var Q,L,X;if(T){var A=(ci(),cr(li)),Z=(fi(),cr(di));U=R?Z.dirname(U)+"/":__dirname+"/",Q=(b,x)=>(b=b.startsWith("file://")?new URL(b):Z.normalize(b),A.readFileSync(b,x?void 0:"utf8")),X=b=>(b=Q(b,!0),b.buffer||(b=new Uint8Array(b)),b),L=(b,x,E,V=!0)=>{b=b.startsWith("file://")?new URL(b):Z.normalize(b),A.readFile(b,V?void 0:"utf8",(F,J)=>{F?E(F):x(V?J.buffer:J)})},!u.thisProgram&&1<process.argv.length&&(j=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),B=(b,x)=>{throw process.exitCode=b,x},u.inspect=()=>"[Emscripten Module object]";let c;try{c=Oa()}catch(b){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),b}global.Worker=c.Worker}else(P||R)&&(R?U=self.location.href:typeof document<"u"&&document.currentScript&&(U=document.currentScript.src),typeof t<"u"&&t&&(U=t),U.indexOf("blob:")!==0?U=U.substr(0,U.replace(/[?#].*/,"").lastIndexOf("/")+1):U="",T||(Q=c=>{var b=new XMLHttpRequest;return b.open("GET",c,!1),b.send(null),b.responseText},R&&(X=c=>{var b=new XMLHttpRequest;return b.open("GET",c,!1),b.responseType="arraybuffer",b.send(null),new Uint8Array(b.response)}),L=(c,b,x)=>{var E=new XMLHttpRequest;E.open("GET",c,!0),E.responseType="arraybuffer",E.onload=()=>{E.status==200||E.status==0&&E.response?b(E.response):x()},E.onerror=x,E.send(null)}));T&&typeof performance>"u"&&(global.performance=Ea().performance);var re=console.log.bind(console),ie=console.error.bind(console);T&&(re=(...c)=>A.writeSync(1,c.join(" ")+`\n`),ie=(...c)=>A.writeSync(2,c.join(" ")+`\n`));var Ce=u.print||re,H=u.printErr||ie;Object.assign(u,O),O=null,u.thisProgram&&(j=u.thisProgram),u.quit&&(B=u.quit);var le;u.wasmBinary&&(le=u.wasmBinary);var Be=u.noExitRuntime||!0;typeof WebAssembly!="object"&&Ye("no native wasm support detected");var ue,ae,Ze,Ie=!1,He,Ee,qe,gt,Je,_t;function ee(){var c=ue.buffer;u.HEAP8=Ee=new Int8Array(c),u.HEAP16=new Int16Array(c),u.HEAP32=gt=new Int32Array(c),u.HEAPU8=qe=new Uint8Array(c),u.HEAPU16=new Uint16Array(c),u.HEAPU32=Je=new Uint32Array(c),u.HEAPF32=new Float32Array(c),u.HEAPF64=_t=new Float64Array(c)}var $e=u.INITIAL_MEMORY||16777216;if(5242880<=$e||Ye("INITIAL_MEMORY should be larger than STACK_SIZE, was "+$e+"! (STACK_SIZE=5242880)"),k)ue=u.wasmMemory;else if(u.wasmMemory)ue=u.wasmMemory;else if(ue=new WebAssembly.Memory({initial:$e/65536,maximum:65536,shared:!0}),!(ue.buffer instanceof SharedArrayBuffer))throw H("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),T&&H("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");ee(),$e=ue.buffer.byteLength;var Oe=[],et=[],tt=[],Ge=0;function Me(){return Be||0<Ge}var rt=0,yt=null,ut=null;function Ot(){rt++,u.monitorRunDependencies&&u.monitorRunDependencies(rt)}function Et(){if(rt--,u.monitorRunDependencies&&u.monitorRunDependencies(rt),rt==0&&(yt!==null&&(clearInterval(yt),yt=null),ut)){var c=ut;ut=null,c()}}function Ye(c){throw u.onAbort&&u.onAbort(c),c="Aborted("+c+")",H(c),Ie=!0,He=1,c=new WebAssembly.RuntimeError(c+". Build with -sASSERTIONS for more info."),_(c),c}function Lt(c){return c.startsWith("data:application/octet-stream;base64,")}var lt;lt="ort-wasm-simd-threaded.wasm",Lt(lt)||(lt=K(lt));function pr(c){if(c==lt&&le)return new Uint8Array(le);if(X)return X(c);throw"both async and sync fetching of the wasm failed"}function dn(c){if(!le&&(P||R)){if(typeof fetch=="function"&&!c.startsWith("file://"))return fetch(c,{credentials:"same-origin"}).then(b=>{if(!b.ok)throw"failed to load wasm binary file at \'"+c+"\'";return b.arrayBuffer()}).catch(()=>pr(c));if(L)return new Promise((b,x)=>{L(c,E=>b(new Uint8Array(E)),x)})}return Promise.resolve().then(()=>pr(c))}function ct(c,b,x){return dn(c).then(E=>WebAssembly.instantiate(E,b)).then(E=>E).then(x,E=>{H("failed to asynchronously prepare wasm: "+E),Ye(E)})}function mr(c,b){var x=lt;return le||typeof WebAssembly.instantiateStreaming!="function"||Lt(x)||x.startsWith("file://")||T||typeof fetch!="function"?ct(x,c,b):fetch(x,{credentials:"same-origin"}).then(E=>WebAssembly.instantiateStreaming(E,c).then(b,function(V){return H("wasm streaming compile failed: "+V),H("falling back to ArrayBuffer instantiation"),ct(x,c,b)}))}var bt,vt={911532:c=>{u.Ea("Abs",c,void 0)},911583:c=>{u.Ea("Neg",c,void 0)},911634:c=>{u.Ea("Floor",c,void 0)},911687:c=>{u.Ea("Ceil",c,void 0)},911739:c=>{u.Ea("Reciprocal",c,void 0)},911797:c=>{u.Ea("Sqrt",c,void 0)},911849:c=>{u.Ea("Exp",c,void 0)},911900:c=>{u.Ea("Erf",c,void 0)},911951:c=>{u.Ea("Sigmoid",c,void 0)},912006:c=>{u.Ea("Log",c,void 0)},912057:c=>{u.Ea("Sin",c,void 0)},912108:c=>{u.Ea("Cos",c,void 0)},912159:c=>{u.Ea("Tan",c,void 0)},912210:c=>{u.Ea("Asin",c,void 0)},912262:c=>{u.Ea("Acos",c,void 0)},912314:c=>{u.Ea("Atan",c,void 0)},912366:c=>{u.Ea("Sinh",c,void 0)},912418:c=>{u.Ea("Cosh",c,void 0)},912470:c=>{u.Ea("Asinh",c,void 0)},912523:c=>{u.Ea("Acosh",c,void 0)},912576:c=>{u.Ea("Atanh",c,void 0)},912629:c=>{u.Ea("Tanh",c,void 0)},912681:c=>{u.Ea("Not",c,void 0)},912732:(c,b,x)=>{u.Ea("ClipV10",c,{min:b,max:x})},912804:c=>{u.Ea("Clip",c,void 0)},912856:(c,b)=>{u.Ea("Elu",c,{alpha:b})},912914:c=>{u.Ea("Relu",c,void 0)},912966:(c,b)=>{u.Ea("LeakyRelu",c,{alpha:b})},913030:(c,b)=>{u.Ea("ThresholdedRelu",c,{alpha:b})},913100:(c,b)=>{u.Ea("Cast",c,{to:b})},913158:c=>{u.Ea("Add",c,void 0)},913209:c=>{u.Ea("Sub",c,void 0)},913260:c=>{u.Ea("Mul",c,void 0)},913311:c=>{u.Ea("Div",c,void 0)},913362:c=>{u.Ea("Pow",c,void 0)},913413:c=>{u.Ea("Equal",c,void 0)},913466:c=>{u.Ea("Greater",c,void 0)},913521:c=>{u.Ea("GreaterOrEqual",c,void 0)},913583:c=>{u.Ea("Less",c,void 0)},913635:c=>{u.Ea("LessOrEqual",c,void 0)},913694:(c,b,x,E,V)=>{u.Ea("ReduceMean",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[]})},913858:(c,b,x,E,V)=>{u.Ea("ReduceMax",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[]})},914021:(c,b,x,E,V)=>{u.Ea("ReduceMin",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[]})},914184:(c,b,x,E,V)=>{u.Ea("ReduceProd",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[]})},914348:(c,b,x,E,V)=>{u.Ea("ReduceSum",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[]})},914511:(c,b,x,E,V)=>{u.Ea("ReduceL1",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[]})},914673:(c,b,x,E,V)=>{u.Ea("ReduceL2",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[]})},914835:(c,b,x,E,V)=>{u.Ea("ReduceLogSum",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[]})},915001:(c,b,x,E,V)=>{u.Ea("ReduceSumSquare",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[]})},915170:(c,b,x,E,V)=>{u.Ea("ReduceLogSumExp",c,{keepDims:!!b,noopWithEmptyAxes:!!x,axes:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[]})},915339:c=>{u.Ea("Where",c,void 0)},915392:(c,b,x)=>{u.Ea("Transpose",c,{perm:b?Array.from(l().subarray(x>>>0,x+b>>>0)):[]})},915505:(c,b,x,E,V,F,J,pe,de,ce)=>{u.Ea("Conv",c,{format:de?"NHWC":"NCHW",auto_pad:b,dilations:[x],group:E,kernel_shape:[V],pads:[F,J],strides:[pe],w_is_const:()=>!!e()[ce>>>0]})},915733:(c,b,x,E,V,F,J,pe,de,ce,me,xe,_e,N,be)=>{u.Ea("Conv",c,{format:N?"NHWC":"NCHW",auto_pad:b,dilations:[x,E],group:V,kernel_shape:[F,J],pads:[pe,de,ce,me],strides:[xe,_e],w_is_const:()=>!!e()[be>>>0]})},915992:(c,b,x,E,V,F,J,pe,de,ce)=>{u.Ea("Conv",c,{format:de?"NHWC":"NCHW",auto_pad:b,dilations:[x],group:E,kernel_shape:[V],pads:[F,J],strides:[pe],w_is_const:()=>!!e()[ce>>>0]})},916220:(c,b,x,E,V,F,J,pe,de,ce,me,xe,_e,N,be)=>{u.Ea("Conv",c,{format:N?"NHWC":"NCHW",auto_pad:b,dilations:[x,E],group:V,kernel_shape:[F,J],pads:[pe,de,ce,me],strides:[xe,_e],w_is_const:()=>!!e()[be>>>0]})},916479:(c,b,x,E,V,F,J,pe,de,ce,me,xe,_e,N)=>{u.Ea("ConvTranspose",c,{format:de?"NHWC":"NCHW",autoPad:b,dilations:[x],group:E,kernel_shape:[V],pads:[F,J],strides:[pe],wIsConst:()=>!!e()[ce>>>0],outputPadding:me?Array.from(l().subarray(xe>>>0,xe+me>>>0)):[],outputShape:_e?Array.from(l().subarray(N>>>0,N+_e>>>0)):[]})},916859:(c,b,x,E,V,F,J,pe,de,ce,me,xe,_e)=>{u.Ea("ConvTranspose",c,{format:pe?"NHWC":"NCHW",autoPad:b,dilations:Array.from(l().subarray(x>>>0,x+2>>>0)),group:E,kernelShape:Array.from(l().subarray(V>>>0,V+2>>>0)),pads:Array.from(l().subarray(F>>>0,F+4>>>0)),strides:Array.from(l().subarray(J>>>0,J+2>>>0)),wIsConst:()=>!!e()[de>>>0],outputPadding:0<ce?Array.from(l().subarray(me>>>0,me+ce>>>0)):[],outputShape:0<xe?Array.from(l().subarray(_e>>>0,_e+xe>>>0)):[]})},917382:(c,b,x,E,V,F,J,pe,de,ce,me,xe,_e,N)=>{u.Ea("ConvTranspose",c,{format:de?"NHWC":"NCHW",autoPad:b,dilations:[x],group:E,kernel_shape:[V],pads:[F,J],strides:[pe],wIsConst:()=>!!e()[ce>>>0],outputPadding:me?Array.from(l().subarray(xe>>>0,xe+me>>>0)):[],outputShape:_e?Array.from(l().subarray(N>>>0,N+_e>>>0)):[]})},917762:(c,b,x,E,V,F,J,pe,de,ce,me,xe,_e)=>{u.Ea("ConvTranspose",c,{format:pe?"NHWC":"NCHW",autoPad:b,dilations:Array.from(l().subarray(x>>>0,x+2>>>0)),group:E,kernelShape:Array.from(l().subarray(V>>>0,V+2>>>0)),pads:Array.from(l().subarray(F>>>0,F+4>>>0)),strides:Array.from(l().subarray(J>>>0,J+2>>>0)),wIsConst:()=>!!e()[de>>>0],outputPadding:0<ce?Array.from(l().subarray(me>>>0,me+ce>>>0)):[],outputShape:0<xe?Array.from(l().subarray(_e>>>0,_e+xe>>>0)):[]})},918285:(c,b)=>{u.Ea("GlobalAveragePool",c,{format:b?"NHWC":"NCHW"})},918376:(c,b,x,E,V,F,J,pe,de,ce,me,xe,_e,N,be,Te)=>{u.Ea("AveragePool",c,{format:Te?"NHWC":"NCHW",auto_pad:b,ceil_mode:x,count_include_pad:E,storage_order:V,dilations:[F,J],kernel_shape:[pe,de],pads:[ce,me,xe,_e],strides:[N,be]})},918660:(c,b)=>{u.Ea("GlobalAveragePool",c,{format:b?"NHWC":"NCHW"})},918751:(c,b,x,E,V,F,J,pe,de,ce,me,xe,_e,N,be,Te)=>{u.Ea("AveragePool",c,{format:Te?"NHWC":"NCHW",auto_pad:b,ceil_mode:x,count_include_pad:E,storage_order:V,dilations:[F,J],kernel_shape:[pe,de],pads:[ce,me,xe,_e],strides:[N,be]})},919035:(c,b)=>{u.Ea("GlobalMaxPool",c,{format:b?"NHWC":"NCHW"})},919122:(c,b,x,E,V,F,J,pe,de,ce,me,xe,_e,N,be,Te)=>{u.Ea("MaxPool",c,{format:Te?"NHWC":"NCHW",auto_pad:b,ceil_mode:x,count_include_pad:E,storage_order:V,dilations:[F,J],kernel_shape:[pe,de],pads:[ce,me,xe,_e],strides:[N,be]})},919402:(c,b)=>{u.Ea("GlobalMaxPool",c,{format:b?"NHWC":"NCHW"})},919489:(c,b,x,E,V,F,J,pe,de,ce,me,xe,_e,N,be,Te)=>{u.Ea("MaxPool",c,{format:Te?"NHWC":"NCHW",auto_pad:b,ceil_mode:x,count_include_pad:E,storage_order:V,dilations:[F,J],kernel_shape:[pe,de],pads:[ce,me,xe,_e],strides:[N,be]})},919769:(c,b,x,E,V)=>{u.Ea("Gemm",c,{alpha:b,beta:x,transA:E,transB:V})},919873:c=>{u.Ea("MatMul",c,void 0)},919927:(c,b,x,E)=>{u.Ea("ArgMax",c,{keepDims:!!b,selectLastIndex:!!x,axis:E})},920035:(c,b,x,E)=>{u.Ea("ArgMin",c,{keepDims:!!b,selectLastIndex:!!x,axis:E})},920143:(c,b)=>{u.Ea("Softmax",c,{axis:b})},920206:(c,b)=>{u.Ea("Concat",c,{axis:b})},920266:(c,b,x,E,V)=>{u.Ea("Split",c,{axis:b,numOutputs:x,splitSizes:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[]})},920411:c=>{u.Ea("Expand",c,void 0)},920465:(c,b)=>{u.Ea("Gather",c,{axis:Number(b)})},920536:(c,b)=>{u.Ea("GatherElements",c,{axis:Number(b)})},920615:(c,b,x,E,V,F,J,pe,de,ce,me)=>{u.Ea("Resize",c,{antialias:b,axes:x?Array.from(l().subarray(E>>>0,E+x>>>0)):[],coordinateTransformMode:dt(V),cubicCoeffA:F,excludeOutside:J,extrapolationValue:pe,keepAspectRatioPolicy:dt(de),mode:dt(ce),nearestMode:dt(me)})},920966:(c,b,x,E,V,F,J)=>{u.Ea("Slice",c,{starts:b?Array.from(l().subarray(x>>>0,x+b>>>0)):[],ends:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[],axes:F?Array.from(l().subarray(J>>>0,J+F>>>0)):[]})},921197:c=>{u.Ea("Tile",c,void 0)},921249:(c,b,x)=>{u.Ea("LayerNormalization",c,{axis:Number(b),epsilon:Number(x)})},921356:(c,b,x)=>{u.Ea("InstanceNormalization",c,{epsilon:b,format:x?"NHWC":"NCHW"})},921470:(c,b,x)=>{u.Ea("InstanceNormalization",c,{epsilon:b,format:x?"NHWC":"NCHW"})},921584:c=>{u.Ea("Range",c,void 0)},921637:(c,b)=>{u.Ea("Einsum",c,{equation:dt(b)})},921718:(c,b,x,E,V)=>{u.Ea("Pad",c,{mode:b,value:x,pads:E?Array.from(l().subarray(V>>>0,V+E>>>0)):[]})},921850:c=>{u.Ea("Gelu",c,void 0)},921902:c=>{u.Ea("BiasAdd",c,void 0)},921957:c=>{u.Ea("BiasSplitGelu",c,void 0)},922018:(c,b)=>{u.Ea("SkipLayerNormalization",c,{epsilon:b})},922099:c=>{u.zb(c)},922133:(c,b)=>u.Ab(c,b,u.bb.Fb,u.bb.errors),922245:c=>u.wb(c),922278:c=>u.yb(c),922310:(c,b,x)=>{u.jb(c,b,x,!0)},922349:(c,b,x)=>{u.jb(c,b,x)}};function Pt(c){this.name="ExitStatus",this.message=`Program terminated with exit(${c})`,this.status=c}function Kt(c){c.terminate(),c.onmessage=()=>{}}function hr(c){(c=he.Qa[c])||Ye(),he.Eb(c)}function qt(c){var b=he.tb();if(!b)return 6;he.Ya.push(b),he.Qa[c.Xa]=b,b.Xa=c.Xa;var x={cmd:"run",start_routine:c.Gb,arg:c.rb,pthread_ptr:c.Xa};return T&&b.unref(),b.postMessage(x,c.Mb),0}var gr=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Yt=(c,b,x)=>{b>>>=0;var E=b+x;for(x=b;c[x]&&!(x>=E);)++x;if(16<x-b&&c.buffer&&gr)return gr.decode(c.buffer instanceof SharedArrayBuffer?c.slice(b,x):c.subarray(b,x));for(E="";b<x;){var V=c[b++];if(V&128){var F=c[b++]&63;if((V&224)==192)E+=String.fromCharCode((V&31)<<6|F);else{var J=c[b++]&63;V=(V&240)==224?(V&15)<<12|F<<6|J:(V&7)<<18|F<<12|J<<6|c[b++]&63,65536>V?E+=String.fromCharCode(V):(V-=65536,E+=String.fromCharCode(55296|V>>10,56320|V&1023))}}else E+=String.fromCharCode(V)}return E},dt=(c,b)=>(c>>>=0)?Yt(d(),c,b):"";function Xt(c){if(k)return ke(1,1,c);He=c,Me()||(he.Hb(),u.onExit&&u.onExit(c),Ie=!0),B(c,new Pt(c))}var yr=c=>{if(He=c,k)throw fn(c),"unwind";Xt(c)},he={ab:[],Ya:[],mb:[],Qa:{},gb:function(){k?he.vb():he.ub()},ub:function(){Oe.unshift(()=>{Ot(),he.Bb(()=>Et())})},vb:function(){he.receiveObjectTransfer=he.Db,he.threadInitTLS=he.lb,he.setExitStatus=he.kb,Be=!1},kb:function(c){He=c},Sb:["$terminateWorker"],Hb:function(){for(var c of he.Ya)Kt(c);for(c of he.ab)Kt(c);he.ab=[],he.Ya=[],he.Qa=[]},Eb:function(c){var b=c.Xa;delete he.Qa[b],he.ab.push(c),he.Ya.splice(he.Ya.indexOf(c),1),c.Xa=0,ar(b)},Db:function(){},lb:function(){he.mb.forEach(c=>c())},Cb:c=>new Promise(b=>{c.onmessage=F=>{F=F.data;var J=F.cmd;if(F.targetThread&&F.targetThread!=Wt()){var pe=he.Qa[F.Rb];pe?pe.postMessage(F,F.transferList):H(\'Internal error! Worker sent a message "\'+J+\'" to target pthread \'+F.targetThread+", but that thread no longer exists!")}else J==="checkMailbox"?Mt():J==="spawnThread"?qt(F):J==="cleanupThread"?hr(F.thread):J==="killThread"?(F=F.thread,J=he.Qa[F],delete he.Qa[F],Kt(J),ar(F),he.Ya.splice(he.Ya.indexOf(J),1),J.Xa=0):J==="cancelThread"?he.Qa[F.thread].postMessage({cmd:"cancel"}):J==="loaded"?(c.loaded=!0,b(c)):J==="alert"?alert("Thread "+F.threadId+": "+F.text):F.target==="setimmediate"?c.postMessage(F):J==="callHandler"?u[F.handler](...F.args):J&&H("worker sent an unknown command "+J)},c.onerror=F=>{throw H("worker sent an error! "+F.filename+":"+F.lineno+": "+F.message),F},T&&(c.on("message",function(F){c.onmessage({data:F})}),c.on("error",function(F){c.onerror(F)}));var x=[],E=["onExit","onAbort","print","printErr"],V;for(V of E)u.hasOwnProperty(V)&&x.push(V);c.postMessage({cmd:"load",handlers:x,urlOrBlob:u.mainScriptUrlOrBlob||t,wasmMemory:ue,wasmModule:Ze})}),Bb:function(c){c()},qb:function(){var c=K("ort-wasm-simd-threaded.worker.js");c=new Worker(c),he.ab.push(c)},tb:function(){return he.ab.length==0&&(he.qb(),he.Cb(he.ab[0])),he.ab.pop()}};u.PThread=he;var Rt=c=>{for(;0<c.length;)c.shift()(u)};u.establishStackSpace=function(){var c=Wt(),b=l()[c+52>>2>>>0];c=l()[c+56>>2>>>0],Hr(b,b-c),zt(b)};function fn(c){if(k)return ke(2,0,c);yr(c)}u.invokeEntryPoint=function(c,b){c=Lr.apply(null,[c,b]),Me()?he.kb(c):sr(c)};function pn(c){this.fb=c-24,this.pb=function(b){m()[this.fb+4>>2>>>0]=b},this.ob=function(b){m()[this.fb+8>>2>>>0]=b},this.gb=function(b,x){this.nb(),this.pb(b),this.ob(x)},this.nb=function(){m()[this.fb+16>>2>>>0]=0}}var kt=0,si=0;function ft(c,b,x,E){return k?ke(3,1,c,b,x,E):nt(c,b,x,E)}function nt(c,b,x,E){if(c>>>=0,b>>>=0,x>>>=0,E>>>=0,typeof SharedArrayBuffer>"u")return H("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var V=[];return k&&V.length===0?ft(c,b,x,E):(c={Gb:x,Xa:c,rb:E,Mb:V},k?(c.Ob="spawnThread",postMessage(c,V),0):qt(c))}function br(c,b,x){return k?ke(4,1,c,b,x):0}function Bt(c,b){if(k)return ke(5,1,c,b)}var Qt=c=>{for(var b=0,x=0;x<c.length;++x){var E=c.charCodeAt(x);127>=E?b++:2047>=E?b+=2:55296<=E&&57343>=E?(b+=4,++x):b+=3}return b},vr=(c,b,x,E)=>{if(x>>>=0,!(0<E))return 0;var V=x;E=x+E-1;for(var F=0;F<c.length;++F){var J=c.charCodeAt(F);if(55296<=J&&57343>=J){var pe=c.charCodeAt(++F);J=65536+((J&1023)<<10)|pe&1023}if(127>=J){if(x>=E)break;b[x++>>>0]=J}else{if(2047>=J){if(x+1>=E)break;b[x++>>>0]=192|J>>6}else{if(65535>=J){if(x+2>=E)break;b[x++>>>0]=224|J>>12}else{if(x+3>=E)break;b[x++>>>0]=240|J>>18,b[x++>>>0]=128|J>>12&63}b[x++>>>0]=128|J>>6&63}b[x++>>>0]=128|J&63}}return b[x>>>0]=0,x-V},mn=(c,b,x)=>vr(c,d(),b,x);function Jt(c,b){if(k)return ke(6,1,c,b)}function hn(c,b,x){if(k)return ke(7,1,c,b,x)}function gn(c,b,x){return k?ke(8,1,c,b,x):0}function yn(c,b){if(k)return ke(9,1,c,b)}function bn(c,b,x){if(k)return ke(10,1,c,b,x)}function vn(c,b,x,E){if(k)return ke(11,1,c,b,x,E)}function wn(c,b,x,E){if(k)return ke(12,1,c,b,x,E)}function Zt(c,b,x,E){if(k)return ke(13,1,c,b,x,E)}function wr(c){if(k)return ke(14,1,c)}function W(c,b){if(k)return ke(15,1,c,b)}function At(c,b,x){if(k)return ke(16,1,c,b,x)}var z=c=>{if(!Ie)try{if(c(),!Me())try{k?sr(He):yr(He)}catch(b){b instanceof Pt||b=="unwind"||B(1,b)}}catch(b){b instanceof Pt||b=="unwind"||B(1,b)}};function D(c){c>>>=0,typeof Atomics.Nb=="function"&&(Atomics.Nb(l(),c>>2,c).value.then(Mt),c+=128,Atomics.store(l(),c>>2,1))}u.__emscripten_thread_mailbox_await=D;function Mt(){var c=Wt();c&&(D(c),z(()=>Nr()))}u.checkMailbox=Mt;var It=c=>c%4===0&&(c%100!==0||c%400===0),Cr=[0,31,60,91,121,152,182,213,244,274,305,335],$r=[0,31,59,90,120,151,181,212,243,273,304,334];function xr(c,b,x,E,V,F,J,pe){return k?ke(17,1,c,b,x,E,V,F,J,pe):-52}function Sr(c,b,x,E,V,F,J){if(k)return ke(18,1,c,b,x,E,V,F,J)}var _r=c=>{var b=Qt(c)+1,x=or(b);return x&&mn(c,x,b),x},er=[],Ar=(c,b)=>{er.length=0;var x;for(b>>=2;x=d()[c++>>>0];)b+=x!=105&b,er.push(x==105?l()[b>>>0]:h()[b++>>>1]),++b;return er},Cn=c=>{var b=ur();return c=c(),zt(b),c};function ke(c,b){var x=arguments.length-2,E=arguments;return Cn(()=>{for(var V=lr(8*x),F=V>>3,J=0;J<x;J++){var pe=E[2+J];h()[F+J>>>0]=pe}return Ur(c,x,V,b)})}var tr=[],rr={},Ir=()=>{if(!nr){var c={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:j||"./this.program"},b;for(b in rr)rr[b]===void 0?delete c[b]:c[b]=rr[b];var x=[];for(b in c)x.push(`${b}=${c[b]}`);nr=x}return nr},nr;function Tr(c,b){if(k)return ke(19,1,c,b);c>>>=0,b>>>=0;var x=0;return Ir().forEach(function(E,V){var F=b+x;for(V=m()[c+4*V>>2>>>0]=F,F=0;F<E.length;++F)e()[V++>>0>>>0]=E.charCodeAt(F);e()[V>>0>>>0]=0,x+=E.length+1}),0}function Or(c,b){if(k)return ke(20,1,c,b);c>>>=0,b>>>=0;var x=Ir();m()[c>>2>>>0]=x.length;var E=0;return x.forEach(function(V){E+=V.length+1}),m()[b>>2>>>0]=E,0}function Er(c){return k?ke(21,1,c):52}function Pr(c,b,x,E){return k?ke(22,1,c,b,x,E):52}function Rr(c,b,x,E,V){return k?ke(23,1,c,b,x,E,V):70}var $n=[null,[],[]];function kr(c,b,x,E){if(k)return ke(24,1,c,b,x,E);b>>>=0,x>>>=0,E>>>=0;for(var V=0,F=0;F<x;F++){var J=m()[b>>2>>>0],pe=m()[b+4>>2>>>0];b+=8;for(var de=0;de<pe;de++){var ce=d()[J+de>>>0],me=$n[c];ce===0||ce===10?((c===1?Ce:H)(Yt(me,0)),me.length=0):me.push(ce)}V+=pe}return m()[E>>2>>>0]=V,0}var Br=[31,29,31,30,31,30,31,31,30,31,30,31],Mr=[31,28,31,30,31,30,31,31,30,31,30,31];function xn(c){var b=Array(Qt(c)+1);return vr(c,b,0,b.length),b}var Sn=(c,b)=>{e().set(c,b>>>0)};function jr(c,b,x,E){function V(N,be,Te){for(N=typeof N=="number"?N.toString():N||"";N.length<be;)N=Te[0]+N;return N}function F(N,be){return V(N,be,"0")}function J(N,be){function Te(Jr){return 0>Jr?-1:0<Jr?1:0}var wt;return(wt=Te(N.getFullYear()-be.getFullYear()))===0&&(wt=Te(N.getMonth()-be.getMonth()))===0&&(wt=Te(N.getDate()-be.getDate())),wt}function pe(N){switch(N.getDay()){case 0:return new Date(N.getFullYear()-1,11,29);case 1:return N;case 2:return new Date(N.getFullYear(),0,3);case 3:return new Date(N.getFullYear(),0,2);case 4:return new Date(N.getFullYear(),0,1);case 5:return new Date(N.getFullYear()-1,11,31);case 6:return new Date(N.getFullYear()-1,11,30)}}function de(N){var be=N.Za;for(N=new Date(new Date(N.$a+1900,0,1).getTime());0<be;){var Te=N.getMonth(),wt=(It(N.getFullYear())?Br:Mr)[Te];if(be>wt-N.getDate())be-=wt-N.getDate()+1,N.setDate(1),11>Te?N.setMonth(Te+1):(N.setMonth(0),N.setFullYear(N.getFullYear()+1));else{N.setDate(N.getDate()+be);break}}return Te=new Date(N.getFullYear()+1,0,4),be=pe(new Date(N.getFullYear(),0,4)),Te=pe(Te),0>=J(be,N)?0>=J(Te,N)?N.getFullYear()+1:N.getFullYear():N.getFullYear()-1}c>>>=0,b>>>=0,x>>>=0,E>>>=0;var ce=l()[E+40>>2>>>0];E={Kb:l()[E>>2>>>0],Jb:l()[E+4>>2>>>0],cb:l()[E+8>>2>>>0],ib:l()[E+12>>2>>>0],eb:l()[E+16>>2>>>0],$a:l()[E+20>>2>>>0],Wa:l()[E+24>>2>>>0],Za:l()[E+28>>2>>>0],Tb:l()[E+32>>2>>>0],Ib:l()[E+36>>2>>>0],Lb:ce?dt(ce):""},x=dt(x),ce={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var me in ce)x=x.replace(new RegExp(me,"g"),ce[me]);var xe="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),_e="January February March April May June July August September October November December".split(" ");ce={"%a":N=>xe[N.Wa].substring(0,3),"%A":N=>xe[N.Wa],"%b":N=>_e[N.eb].substring(0,3),"%B":N=>_e[N.eb],"%C":N=>F((N.$a+1900)/100|0,2),"%d":N=>F(N.ib,2),"%e":N=>V(N.ib,2," "),"%g":N=>de(N).toString().substring(2),"%G":N=>de(N),"%H":N=>F(N.cb,2),"%I":N=>(N=N.cb,N==0?N=12:12<N&&(N-=12),F(N,2)),"%j":N=>{for(var be=0,Te=0;Te<=N.eb-1;be+=(It(N.$a+1900)?Br:Mr)[Te++]);return F(N.ib+be,3)},"%m":N=>F(N.eb+1,2),"%M":N=>F(N.Jb,2),"%n":()=>`\n`,"%p":N=>0<=N.cb&&12>N.cb?"AM":"PM","%S":N=>F(N.Kb,2),"%t":()=>"	","%u":N=>N.Wa||7,"%U":N=>F(Math.floor((N.Za+7-N.Wa)/7),2),"%V":N=>{var be=Math.floor((N.Za+7-(N.Wa+6)%7)/7);if(2>=(N.Wa+371-N.Za-2)%7&&be++,be)be==53&&(Te=(N.Wa+371-N.Za)%7,Te==4||Te==3&&It(N.$a)||(be=1));else{be=52;var Te=(N.Wa+7-N.Za-1)%7;(Te==4||Te==5&&It(N.$a%400-1))&&be++}return F(be,2)},"%w":N=>N.Wa,"%W":N=>F(Math.floor((N.Za+7-(N.Wa+6)%7)/7),2),"%y":N=>(N.$a+1900).toString().substring(2),"%Y":N=>N.$a+1900,"%z":N=>{N=N.Ib;var be=0<=N;return N=Math.abs(N)/60,(be?"+":"-")+("0000"+(N/60*100+N%60)).slice(-4)},"%Z":N=>N.Lb,"%%":()=>"%"},x=x.replace(/%%/g,"\\0\\0");for(me in ce)x.includes(me)&&(x=x.replace(new RegExp(me,"g"),ce[me](E)));return x=x.replace(/\\0\\0/g,"%"),me=xn(x),me.length>b?0:(Sn(me,c),me.length-1)}function jt(c){try{c()}catch(b){Ye(b)}}function _n(c){var b={},x;for(x in c)(function(E){var V=c[E];b[E]=typeof V=="function"?function(){Dt.push(E);try{return V.apply(null,arguments)}finally{Ie||(Dt.pop()===E||Ye(),it&&pt===1&&Dt.length===0&&(pt=0,Ge+=1,jt(qr),typeof Fibers<"u"&&Fibers.Ub()))}}:V})(x);return b}var pt=0,it=null,Dr=0,Dt=[],Wr={},zr={},An=0,ir=null,In=[];function Tn(){return new Promise((c,b)=>{ir={resolve:c,reject:b}})}function On(){var c=or(65548),b=c+12;m()[c>>2>>>0]=b,m()[c+4>>2>>>0]=b+65536,b=Dt[0];var x=Wr[b];return x===void 0&&(x=An++,Wr[b]=x,zr[x]=b),b=x,l()[c+8>>2>>>0]=b,c}function En(){var c=l()[it+8>>2>>>0];return c=ae[zr[c]],--Ge,c()}function Pn(c){if(!Ie){if(pt===0){var b=!1,x=!1;c((E=0)=>{if(!Ie&&(Dr=E,b=!0,x)){pt=2,jt(()=>Yr(it)),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),E=!1;try{var V=En()}catch(pe){V=pe,E=!0}var F=!1;if(!it){var J=ir;J&&(ir=null,(E?J.reject:J.resolve)(V),F=!0)}if(E&&!F)throw V}}),x=!0,b||(pt=1,it=On(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),jt(()=>Kr(it)))}else pt===2?(pt=0,jt(Xr),Gr(it),it=null,In.forEach(E=>z(E))):Ye(`invalid state: ${pt}`);return Dr}}function Rn(c){return Pn(b=>{c().then(b)})}he.gb();var kn=[null,Xt,fn,ft,br,Bt,Jt,hn,gn,yn,bn,vn,wn,Zt,wr,W,At,xr,Sr,Tr,Or,Er,Pr,Rr,kr],Bn={r:function(c,b,x){return Rn(async()=>{await u.xb(c,b,x)})},b:function(c,b,x){throw c>>>=0,new pn(c).gb(b>>>0,x>>>0),kt=c,si++,kt},O:function(c){Vr(c>>>0,!R,1,!P,131072,!1),he.lb()},l:function(c){c>>>=0,k?postMessage({cmd:"cleanupThread",thread:c}):hr(c)},I:nt,i:br,U:Bt,E:Jt,G:hn,V:gn,S:yn,K:bn,R:vn,p:wn,F:Zt,C:wr,T:W,D:At,q:()=>!0,A:function(c,b){c>>>=0,c==b>>>0?setTimeout(()=>Mt()):k?postMessage({targetThread:c,cmd:"checkMailbox"}):(c=he.Qa[c])&&c.postMessage({cmd:"checkMailbox"})},M:function(){return-1},N:D,X:function(c){T&&he.Qa[c>>>0].ref()},u:function(c,b,x){c=b+2097152>>>0<4194305-!!c?(c>>>0)+4294967296*b:NaN,x>>>=0,c=new Date(1e3*c),l()[x>>2>>>0]=c.getUTCSeconds(),l()[x+4>>2>>>0]=c.getUTCMinutes(),l()[x+8>>2>>>0]=c.getUTCHours(),l()[x+12>>2>>>0]=c.getUTCDate(),l()[x+16>>2>>>0]=c.getUTCMonth(),l()[x+20>>2>>>0]=c.getUTCFullYear()-1900,l()[x+24>>2>>>0]=c.getUTCDay(),c=(c.getTime()-Date.UTC(c.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,l()[x+28>>2>>>0]=c},v:function(c,b,x){c=b+2097152>>>0<4194305-!!c?(c>>>0)+4294967296*b:NaN,x>>>=0,c=new Date(1e3*c),l()[x>>2>>>0]=c.getSeconds(),l()[x+4>>2>>>0]=c.getMinutes(),l()[x+8>>2>>>0]=c.getHours(),l()[x+12>>2>>>0]=c.getDate(),l()[x+16>>2>>>0]=c.getMonth(),l()[x+20>>2>>>0]=c.getFullYear()-1900,l()[x+24>>2>>>0]=c.getDay(),b=(It(c.getFullYear())?Cr:$r)[c.getMonth()]+c.getDate()-1|0,l()[x+28>>2>>>0]=b,l()[x+36>>2>>>0]=-(60*c.getTimezoneOffset()),b=new Date(c.getFullYear(),6,1).getTimezoneOffset();var E=new Date(c.getFullYear(),0,1).getTimezoneOffset();c=(b!=E&&c.getTimezoneOffset()==Math.min(E,b))|0,l()[x+32>>2>>>0]=c},w:function(c){c>>>=0;var b=new Date(l()[c+20>>2>>>0]+1900,l()[c+16>>2>>>0],l()[c+12>>2>>>0],l()[c+8>>2>>>0],l()[c+4>>2>>>0],l()[c>>2>>>0],0),x=l()[c+32>>2>>>0],E=b.getTimezoneOffset(),V=new Date(b.getFullYear(),6,1).getTimezoneOffset(),F=new Date(b.getFullYear(),0,1).getTimezoneOffset(),J=Math.min(F,V);return 0>x?l()[c+32>>2>>>0]=+(V!=F&&J==E):0<x!=(J==E)&&(V=Math.max(F,V),b.setTime(b.getTime()+6e4*((0<x?J:V)-E))),l()[c+24>>2>>>0]=b.getDay(),x=(It(b.getFullYear())?Cr:$r)[b.getMonth()]+b.getDate()-1|0,l()[c+28>>2>>>0]=x,l()[c>>2>>>0]=b.getSeconds(),l()[c+4>>2>>>0]=b.getMinutes(),l()[c+8>>2>>>0]=b.getHours(),l()[c+12>>2>>>0]=b.getDate(),l()[c+16>>2>>>0]=b.getMonth(),l()[c+20>>2>>>0]=b.getYear(),c=b.getTime()/1e3,Fr((bt=c,1<=+Math.abs(bt)?0<bt?+Math.floor(bt/4294967296)>>>0:~~+Math.ceil((bt-+(~~bt>>>0))/4294967296)>>>0:0)),c>>>0},s:xr,t:Sr,z:function(c,b,x){function E(ce){return(ce=ce.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?ce[1]:"GMT"}c>>>=0,b>>>=0,x>>>=0;var V=new Date().getFullYear(),F=new Date(V,0,1),J=new Date(V,6,1);V=F.getTimezoneOffset();var pe=J.getTimezoneOffset(),de=Math.max(V,pe);m()[c>>2>>>0]=60*de,l()[b>>2>>>0]=+(V!=pe),c=E(F),b=E(J),c=_r(c),b=_r(b),pe<V?(m()[x>>2>>>0]=c,m()[x+4>>2>>>0]=b):(m()[x>>2>>>0]=b,m()[x+4>>2>>>0]=c)},d:()=>{Ye("")},c:function(c,b,x){return c>>>=0,b=Ar(b>>>0,x>>>0),vt[c].apply(null,b)},k:function(c,b,x){return c>>>=0,b=Ar(b>>>0,x>>>0),vt[c].apply(null,b)},m:function(){},j:function(){return Date.now()},W:()=>{throw Ge+=1,"unwind"},B:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:function(){return T?(Ra(),cr(Pa)).cpus().length:navigator.hardwareConcurrency},L:function(c,b,x,E){for(he.Pb=b>>>0,tr.length=x,b=E>>>0>>3,E=0;E<x;E++)tr[E]=h()[b+E>>>0];return(0>c?vt[-c-1]:kn[c]).apply(null,tr)},y:function(c){c>>>=0;var b=d().length;if(c<=b||4294901760<c)return!1;for(var x=1;4>=x;x*=2){var E=b*(1+.2/x);E=Math.min(E,c+100663296);var V=Math;E=Math.max(c,E);e:{V=V.min.call(V,4294901760,E+(65536-E%65536)%65536)-ue.buffer.byteLength+65535>>>16;try{ue.grow(V),ee();var F=1;break e}catch{}F=void 0}if(F)return!0}return!1},P:Tr,Q:Or,H:yr,h:Er,o:Pr,x:Rr,n:kr,a:ue||u.wasmMemory,J:jr,e:function(c,b,x,E){return jr(c>>>0,b>>>0,x>>>0,E>>>0)}};(function(){function c(x,E){return x=x.exports,x=_n(x),ae=x=Mn(x),he.mb.push(ae.Da),et.unshift(ae.Y),Ze=E,Et(),x}var b={a:Bn};if(Ot(),u.instantiateWasm)try{return u.instantiateWasm(b,c)}catch(x){H("Module.instantiateWasm callback failed with error: "+x),_(x)}return mr(b,function(x){c(x.instance,x.module)}).catch(_),{}})(),u._OrtInit=(c,b)=>(u._OrtInit=ae.Z)(c,b),u._OrtGetLastError=(c,b)=>(u._OrtGetLastError=ae._)(c,b),u._OrtCreateSessionOptions=(c,b,x,E,V,F,J,pe,de,ce)=>(u._OrtCreateSessionOptions=ae.$)(c,b,x,E,V,F,J,pe,de,ce),u._OrtAppendExecutionProvider=(c,b)=>(u._OrtAppendExecutionProvider=ae.aa)(c,b),u._OrtAddFreeDimensionOverride=(c,b,x)=>(u._OrtAddFreeDimensionOverride=ae.ba)(c,b,x),u._OrtAddSessionConfigEntry=(c,b,x)=>(u._OrtAddSessionConfigEntry=ae.ca)(c,b,x),u._OrtReleaseSessionOptions=c=>(u._OrtReleaseSessionOptions=ae.da)(c),u._OrtCreateSession=(c,b,x)=>(u._OrtCreateSession=ae.ea)(c,b,x),u._OrtReleaseSession=c=>(u._OrtReleaseSession=ae.fa)(c),u._OrtGetInputOutputCount=(c,b,x)=>(u._OrtGetInputOutputCount=ae.ga)(c,b,x),u._OrtGetInputName=(c,b)=>(u._OrtGetInputName=ae.ha)(c,b),u._OrtGetOutputName=(c,b)=>(u._OrtGetOutputName=ae.ia)(c,b),u._OrtFree=c=>(u._OrtFree=ae.ja)(c),u._OrtCreateTensor=(c,b,x,E,V,F)=>(u._OrtCreateTensor=ae.ka)(c,b,x,E,V,F),u._OrtGetTensorData=(c,b,x,E,V)=>(u._OrtGetTensorData=ae.la)(c,b,x,E,V),u._OrtReleaseTensor=c=>(u._OrtReleaseTensor=ae.ma)(c),u._OrtCreateRunOptions=(c,b,x,E)=>(u._OrtCreateRunOptions=ae.na)(c,b,x,E),u._OrtAddRunConfigEntry=(c,b,x)=>(u._OrtAddRunConfigEntry=ae.oa)(c,b,x),u._OrtReleaseRunOptions=c=>(u._OrtReleaseRunOptions=ae.pa)(c),u._OrtCreateBinding=c=>(u._OrtCreateBinding=ae.qa)(c),u._OrtBindInput=(c,b,x)=>(u._OrtBindInput=ae.ra)(c,b,x),u._OrtBindOutput=(c,b,x,E)=>(u._OrtBindOutput=ae.sa)(c,b,x,E),u._OrtClearBoundOutputs=c=>(u._OrtClearBoundOutputs=ae.ta)(c),u._OrtReleaseBinding=c=>(u._OrtReleaseBinding=ae.ua)(c),u._OrtRunWithBinding=(c,b,x,E,V)=>(u._OrtRunWithBinding=ae.va)(c,b,x,E,V),u._OrtRun=(c,b,x,E,V,F,J,pe)=>(u._OrtRun=ae.wa)(c,b,x,E,V,F,J,pe),u._OrtEndProfiling=c=>(u._OrtEndProfiling=ae.xa)(c),u._JsepOutput=(c,b,x)=>(u._JsepOutput=ae.ya)(c,b,x),u._JsepGetNodeName=c=>(u._JsepGetNodeName=ae.za)(c);var Wt=u._pthread_self=()=>(Wt=u._pthread_self=ae.Aa)(),or=u._malloc=c=>(or=u._malloc=ae.Ba)(c),Gr=u._free=c=>(Gr=u._free=ae.Ca)(c);u.__emscripten_tls_init=()=>(u.__emscripten_tls_init=ae.Da)();var Vr=u.__emscripten_thread_init=(c,b,x,E,V,F)=>(Vr=u.__emscripten_thread_init=ae.Fa)(c,b,x,E,V,F);u.__emscripten_thread_crashed=()=>(u.__emscripten_thread_crashed=ae.Ga)();var Ur=(c,b,x,E)=>(Ur=ae.Ha)(c,b,x,E),ar=c=>(ar=ae.Ia)(c),sr=u.__emscripten_thread_exit=c=>(sr=u.__emscripten_thread_exit=ae.Ja)(c),Nr=u.__emscripten_check_mailbox=()=>(Nr=u.__emscripten_check_mailbox=ae.Ka)(),Fr=c=>(Fr=ae.La)(c),Hr=(c,b)=>(Hr=ae.Ma)(c,b),ur=()=>(ur=ae.Na)(),zt=c=>(zt=ae.Oa)(c),lr=c=>(lr=ae.Pa)(c),Lr=u.dynCall_ii=(c,b)=>(Lr=u.dynCall_ii=ae.Ra)(c,b),Kr=c=>(Kr=ae.Sa)(c),qr=()=>(qr=ae.Ta)(),Yr=c=>(Yr=ae.Ua)(c),Xr=()=>(Xr=ae.Va)();u.___start_em_js=922382,u.___stop_em_js=922543;function Mn(c){c=Object.assign({},c);var b=E=>()=>E()>>>0,x=E=>V=>E(V)>>>0;return c.__errno_location=b(c.__errno_location),c.pthread_self=b(c.pthread_self),c.malloc=x(c.malloc),c.stackSave=b(c.stackSave),c.stackAlloc=x(c.stackAlloc),c}u.keepRuntimeAlive=Me,u.wasmMemory=ue,u.stackAlloc=lr,u.stackSave=ur,u.stackRestore=zt,u.UTF8ToString=dt,u.stringToUTF8=mn,u.lengthBytesUTF8=Qt,u.ExitStatus=Pt,u.PThread=he;var Gt;ut=function c(){Gt||Qr(),Gt||(ut=c)};function Qr(){function c(){if(!Gt&&(Gt=!0,u.calledRun=!0,!Ie)&&(k||Rt(et),w(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!k)){if(u.postRun)for(typeof u.postRun=="function"&&(u.postRun=[u.postRun]);u.postRun.length;){var b=u.postRun.shift();tt.unshift(b)}Rt(tt)}}if(!(0<rt))if(k)w(u),k||Rt(et),startWorker(u);else{if(u.preRun)for(typeof u.preRun=="function"&&(u.preRun=[u.preRun]);u.preRun.length;)Oe.unshift(u.preRun.shift());Rt(Oe),0<rt||(u.setStatus?(u.setStatus("Running..."),setTimeout(function(){setTimeout(function(){u.setStatus("")},1),c()},1)):c())}}if(u.preInit)for(typeof u.preInit=="function"&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return Qr(),r.ready}})();typeof Ba=="object"&&typeof mi=="object"?mi.exports=ka:typeof define=="function"&&define.amd&&define([],()=>ka)});var ja=Zr((Fh,Ip)=>{Ip.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\\n\'});var yi,tn,rn,zn,nn,Ua,bi,Xe=oe(()=>{"use strict";yi=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},tn=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},rn=t=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][t],zn=t=>{switch(t){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}},nn=t=>{switch(t){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${t}`)}},Ua=t=>t==="float32"||t==="int32"||t==="int64"||t==="bool"||t==="float16"||t==="uint32",bi=t=>{switch(t){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${t}`)}}});var jp,Dp,Na,Fa,Ha,Wp,ze,Tt=oe(()=>{"use strict";Xe();jp=["V","I","W","E","F"],Dp=(t,r)=>{console.log(`[${jp[t]},${new Date().toISOString()}]${r}`)},Ha=(t,r)=>{Na=t,Fa=r},Wp=(t,r)=>{let e=nn(t),d=nn(Na);e>=d&&Dp(e,typeof r=="function"?r():r)},ze=(...t)=>{Fa&&Wp(...t)}});var La,Ka=oe(()=>{"use strict";Xe();La=(t,r)=>new(zn(r))(t)});var qa=oe(()=>{"use strict"});var Gn,zp,Ya,wi,vi,Xa,Qa=oe(()=>{"use strict";Tt();qa();Gn=t=>Math.ceil(t/16)*16,zp=1,Ya=()=>zp++,wi=async(t,r,e,d)=>{let l=Gn(e),m=t.device.createBuffer({size:l,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let h=t.getCommandEncoder();t.endComputePass(),h.copyBufferToBuffer(r,0,m,0,l),t.flush(),await m.mapAsync(GPUMapMode.READ);let u=m.getMappedRange();if(d){let w=d();return w.set(new Uint8Array(u,0,e)),w}else return new Uint8Array(u.slice(0,e))}finally{m.destroy()}},vi=class{constructor(r){this.backend=r;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(r,e){let d=e.buffer,l=e.byteOffset,m=e.byteLength,h=Gn(m),u=this.storageCache.get(r);if(!u)throw new Error("gpu data for uploading does not exist");if(u.originalSize!==m)throw new Error(`inconsistent data size. gpu data size=${u.originalSize}, data size=${m}`);let w=this.backend.device.createBuffer({mappedAtCreation:!0,size:h,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),_=w.getMappedRange();new Uint8Array(_).set(new Uint8Array(d,l,m)),w.unmap();let O=this.backend.getCommandEncoder();this.backend.endComputePass(),O.copyBufferToBuffer(w,0,u.gpuData.buffer,0,h),ze("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${r})`),this.buffersForUploadingPending.push(w)}memcpy(r,e){let d=this.storageCache.get(r);if(!d)throw new Error("source gpu data for memcpy does not exist");let l=this.storageCache.get(e);if(!l)throw new Error("destination gpu data for memcpy does not exist");if(d.originalSize!==l.originalSize)throw new Error("inconsistent source and destination gpu data size");let m=Gn(d.originalSize),h=this.backend.getCommandEncoder();this.backend.endComputePass(),h.copyBufferToBuffer(d.gpuData.buffer,0,l.gpuData.buffer,0,m)}registerExternalBuffer(r,e,d){let l;if(d){if(l=this.externalBuffers.get(d),l===void 0)throw new Error("previous buffer is not registered");if(r===d)return ze("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${l}, buffer is the same, skip.`),l;this.externalBuffers.delete(d)}else l=Ya();return this.storageCache.set(l,{gpuData:{id:l,type:0,buffer:r},originalSize:e}),this.externalBuffers.set(r,l),ze("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${l}, registered.`),l}unregisterExternalBuffer(r){let e=this.externalBuffers.get(r);e!==void 0&&(this.storageCache.delete(e),this.externalBuffers.delete(r),ze("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${e}`))}create(r,e=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let d=Gn(r),l,m=(e&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,h=(e&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(m||h){let w=m?this.freeBuffers:this.freeUniformBuffers,_=w.get(d);_||(_=[],w.set(d,_)),_.length>0?l=_.pop():l=this.backend.device.createBuffer({size:d,usage:e})}else l=this.backend.device.createBuffer({size:d,usage:e});let u={id:Ya(),type:0,buffer:l};return this.storageCache.set(u.id,{gpuData:u,originalSize:r}),ze("verbose",()=>`[WebGPU] GpuDataManager.create(size=${r}) => id=${u.id}`),u}get(r){return this.storageCache.get(r)?.gpuData}release(r){let e=this.storageCache.get(r);if(!e)throw new Error("releasing data does not exist");return ze("verbose",()=>`[WebGPU] GpuDataManager.release(id=${r}), gpuDataId=${e.gpuData.id}`),this.storageCache.delete(r),this.buffersPending.push(e.gpuData.buffer),e.originalSize}async download(r,e){let d=this.storageCache.get(r);if(!d)throw new Error("data does not exist");await wi(this.backend,d.gpuData.buffer,d.originalSize,e)}refreshPendingBuffers(){for(let r of this.buffersForUploadingPending)r.destroy();this.buffersForUploadingPending=[];for(let r of this.buffersPending)(r.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(r.size).push(r):(r.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(r.size).push(r):r.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(r=>{r.forEach(e=>{e.destroy()})}),this.freeUniformBuffers.forEach(r=>{r.forEach(e=>{e.destroy()})}),this.storageCache.forEach(r=>{r.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},Xa=(...t)=>new vi(...t)});var Ci,ye,Ne=oe(()=>{"use strict";Ci=class{constructor(r){Object.assign(this,r)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(r=>`${this[r]}`).join(";")),this._cacheKey}},ye=t=>new Ci(t)});var $i,Ct,Y,Nt,Vn,Un,Nn,Ae=oe(()=>{"use strict";$i=class{static calcMatMulShape(r,e){return r[1]!==e[0]?void 0:[r[0],e[1]]}},Ct=class{static calcShape(r,e,d=!1){let l=r.length,m=e.length;if(l===0)return e;if(m===0)return r;let h=Math.max(r.length,e.length),u=new Array(h);if(d){if(l<2||m<2)return;let w=$i.calcMatMulShape([r[l-2],r[l-1]],[e[m-2],e[m-1]]);if(w===void 0)return;[u[h-2],u[h-1]]=w}for(let w=d?3:1;w<=h;w++){let _=l-w<0?1:r[l-w],O=m-w<0?1:e[m-w];if(_!==O&&_>1&&O>1)return;u[h-w]=Math.max(_,O)}return u}static isValidBroadcast(r,e){let d=r.length,l=e.length;if(d>l)return!1;for(let m=1;m<=d;m++)if(r[d-m]!==1&&r[d-m]!==e[l-m])return!1;return!0}},Y=class t{static size(r){return t.getSizeFromDimensionRange(r,0,r.length)}static sizeFromDimension(r,e){if(e<0||e>r.length)throw new Error(`invalid dimension of ${e} for sizeFromDimension as Tensor has ${r.length} dimensions.`);return t.getSizeFromDimensionRange(r,e,r.length)}static sizeToDimension(r,e){if(e<0||e>r.length)throw new Error(`invalid dimension of ${e} for sizeToDimension as Tensor has ${r.length} dimensions.`);return t.getSizeFromDimensionRange(r,0,e)}static getSizeFromDimensionRange(r,e,d){let l=1;for(let m=e;m<d;m++){if(r[m]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");l*=r[m]}return l}static computeStrides(r){let e=r.length;if(e===0)return[];if(e===1)return[1];let d=new Array(e);d[e-1]=1,d[e-2]=r[e-1];for(let l=e-3;l>=0;--l)d[l]=d[l+1]*r[l+1];return d}static normalizeAxis(r,e){if(r<-e&&r>=e)throw new Error("unsupported axis for this operation.");return r<0?r+e:r}static normalizeAxes(r,e){return r.map(d=>this.normalizeAxis(d,e??r.length))}static sortBasedOnPerm(r,e){return e?e.map(d=>r[d]):r.slice().reverse()}static padShape(r,e){let d=r.length;return r.map((l,m)=>l+e[m]+e[m+d])}static areEqual(r,e){return r.length!==e.length?!1:r.every((d,l)=>d===e[l])}},Nt=class t{static adjustPoolAttributes(r,e,d,l,m,h){if(!r&&d.length!==e.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(r)for(let u=0;u<e.length-2;u++)u>=d.length?d.push(e[u+2]):d[u]=e[u+2];for(let u=0;u<d.length;u++)if(u<l.length){if(l[u]<0)throw new Error("strides should be greater than or equal to 1")}else l.push(1);for(let u=0;u<d.length;u++)if(u<m.length){if(m[u]<0)throw new Error("dilations should be greater than or equal to 1")}else m.push(1);for(let u=0;u<d.length*2;u++)if(u<h.length){if(h[u]<0)throw new Error("pad should be greater than or equal to 1")}else h.push(0);for(let u=0;u<d.length;u++){if(d[u]<=0)throw new Error("kernel shapes need to be greater than 0");if(h[u]>=d[u]||h[u+d.length]>=d[u])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(r,e,d,l,m,h,u){if(u){if(m.length!==2*(r.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(e.length!==r.length-2)throw new Error("length of strides should be the length of data dimensions");if(l.length!==r.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let w=0;w<r.length-2;w++)t.adjustPadAndReturnShape(r[w+(h?1:2)],e[w],d[w],l[w],m,w,w+r.length-2,u)}}static computePoolOutputShape(r,e,d,l,m,h,u){if(e.length<=0)throw new Error("input shape must be of size greater than 0");let w=[e[0],e[1]];return t.computeShapeHelper(r,e,w,d,l,m,h,u),w}static computeConvOutputShape(r,e,d,l,m,h,u){if(r.length<=0||e.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let w=[r[0],e[0]];return t.computeShapeHelper(!1,r,w,d,l,m,h,u),w}static computeShapeHelper(r,e,d,l,m,h,u,w){if(r)for(let _=0;_<e.length-2;_++)d.push(1);else for(let _=0;_<e.length-2;_++)d.push(t.adjustPadAndReturnShape(e[_+2],l[_],m[_],h[_],u,_,_+e.length-2,w))}static adjustPadAndReturnShape(r,e,d,l,m,h,u,w){let _=d*(l-1)+1;if(w&&w!=="NOTSET")switch(w){case"VALID":return m[h]=0,m[u]=0,Math.floor((r-_)/e+1);case"SAME_LOWER":case"SAME_UPPER":if(d!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let j=((r+e-1)/e-1)*e+l-r;return m[h]=Math.floor(w==="SAME_LOWER"?(j+1)/2:j/2),m[u]=j-m[h],Math.floor((r+j-l)/e+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((r+m[h]+m[u]-_)/e+1)}},Vn=class{static getShapeOfGemmResult(r,e,d,l,m){if(r.length!==2||d.length!==2)throw new Error("shape need to be of size 2");let h,u,w;e?(h=r[1],u=r[0]):(h=r[0],u=r[1]);let _=-1;if(l?(w=d[0],_=1):(w=d[1],_=0),d[_]!==u)throw new Error("dimension mismatch");if(h<=0||w<=0||u<=0)throw new Error("invalid shape specified");if(m&&!Ct.isValidBroadcast(m,[h,w]))throw new Error("gemm: invalid bias shape for broadcast");return[h,w,u]}},Un=-34028234663852886e22,Nn=34028234663852886e22});var Gp,Ja,Fe,Si,Ft,mt,Ht,dr,Za,ne,fe,xi,es,_i,Pe=oe(()=>{"use strict";Xe();Ae();Gp=64,Ja=(t,r)=>{if(r===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(t){case 10:return r>1?`vec${r}<f16>`:"f16";case 1:return r>1?`vec${r}<f32>`:"f32";case 6:return r>1?`vec${r}<i32>`:"i32";case 12:return r>1?`vec${r}<u32>`:"u32";case 7:if(r>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(r>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(r!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${t}`)}},Fe=(t,r=1)=>{let e=Ja(t,r);return typeof e=="string"?e:e[0]},Si=t=>[{type:"uint32",data:t},{type:"uint32",data:Y.computeStrides(t)}],Ft=t=>t%4===0?4:t%2===0?2:1,mt=(t="f32",r,e="0")=>!r||r===1?`${t}(${e})`:`vec${r}<${t}>(${e})`,Ht=(t,r,e)=>t==="f32"?e:r===1?`f32(${e})`:`vec${r}f(${e})`,dr=(t,r)=>r===4?`(${t}.x + ${t}.y + ${t}.z + ${t}.w)`:r===2?`(${t}.x + ${t}.y)`:r===3?`(${t}.x + ${t}.y + ${t}.z)`:t,Za=(t,r,e,d,l)=>{let m=typeof e=="number",h=m?e:e.length,u=[...new Array(h).keys()],w=h<2?"u32":h<=4?`vec${h}<u32>`:`array<u32, ${h}>`,_=Ja(r,l),O=typeof _=="string"?_:_[1],j=typeof _=="string"?_:_[0],B={indices:w,value:O,storage:j,tensor:r},P=ee=>typeof ee=="string"?ee:`${ee}u`,R={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},T=m?"uniforms.":"",k=`${T}${t}_shape`,U=`${T}${t}_strides`,K="";for(let ee=0;ee<h-1;ee++)K+=`\n    let dim${ee} = current / ${U}[${ee}];\n    let rest${ee} = current % ${U}[${ee}];\n    indices[${ee}] = dim${ee};\n    current = rest${ee};\n    `;K+=`indices[${h-1}] = current;`;let Q=h<2?"":`\n  fn o2i_${t}(offset: u32) -> ${B.indices} {\n    var indices: ${B.indices};\n    var current = offset;\n    ${K}\n    return indices;\n  }`,L=ee=>(R.offsetToIndices=!0,h<2?ee:`o2i_${t}(${ee})`),X=[];if(h>=2)for(let ee=h-1;ee>=0;ee--)X.push(`${U}[${ee}] * (indices[${ee}])`);let A=h<2?"":`\n  fn i2o_${t}(indices: ${B.indices}) -> u32 {\n    return ${X.join("+")};\n  }`,Z=ee=>(R.indicesToOffset=!0,h<2?ee:`i2o_${t}(${ee})`),re=(...ee)=>h===0?"0u":`${B.indices}(${ee.map(P).join(",")})`,ie=(ee,$e)=>h<2?`${ee}`:`${ee}[${$e}]`,Ce=(ee,$e,Oe)=>h<2?`${ee}=${Oe};`:`${ee}[${$e}]=${Oe};`,H={},le=(ee,$e)=>{R.broadcastedIndicesToOffset=!0;let Oe=`${$e.name}broadcastedIndicesTo${t}Offset`;if(Oe in H)return`${Oe}(${ee})`;let et=[];for(let tt=h-1;tt>=0;tt--){let Ge=$e.indicesGet("outputIndices",tt+$e.rank-h);et.push(`${ie(U,tt)} * (${Ge} % ${ie(k,tt)})`)}return H[Oe]=`fn ${Oe}(outputIndices: ${$e.type.indices}) -> u32 {\n             return ${et.length>0?et.join("+"):"0u"};\n           }`,`${Oe}(${ee})`},Be=(ee,$e)=>(()=>{if(B.storage===B.value)return`${t}[${ee}]=${$e};`;if(B.storage==="vec2<u32>"&&B.value==="i32")return`${t}[${ee}]=vec2<u32>(u32(${$e}), select(0u, 0xFFFFFFFFu, ${$e} < 0));`;if(B.storage==="vec2<u32>"&&B.value==="u32")return`${t}[${ee}]=vec2<u32>(u32(${$e}), 0u);`;if(B.storage==="u32"&&B.value==="vec4<bool>")return`${t}[${ee}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${$e}));`;throw new Error(`not supported combination of storage type ${B.storage} and value type ${B.value} yet`)})(),ue=ee=>(()=>{if(B.storage===B.value)return`${t}[${ee}]`;if(B.storage==="vec2<u32>"&&B.value==="i32")return`i32(${t}[${ee}].x)`;if(B.storage==="vec2<u32>"&&B.value==="u32")return`u32(${t}[${ee}].x)`;if(B.storage==="u32"&&B.value==="vec4<bool>")return`vec4<bool>(bool(${t}[${ee}] & 0xFFu), bool(${t}[${ee}] & 0xFF00u), bool(${t}[${ee}] & 0xFF0000u), bool(${t}[${ee}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${B.storage} and value type ${B.value} yet`)})(),ae=h<2?"":`\n  fn get_${t}ByIndices(indices: ${B.indices}) -> ${O} {\n    return ${ue(`i2o_${t}(indices)`)};\n  }`,Ze=h<2?"":(()=>{let ee=u.map(Oe=>`d${Oe}: u32`).join(", "),$e=u.map(Oe=>`d${Oe}`).join(", ");return`\n  fn get_${t}(${ee}) -> ${O} {\n    return get_${t}ByIndices(${re($e)});\n  }`})(),Ie=(...ee)=>{if(ee.length!==h)throw new Error(`indices length must be ${h}`);let $e=ee.map(P).join(",");return h===0?ue("0u"):h===1?ue($e[0]):(R.get=!0,R.getByIndices=!0,R.indicesToOffset=!0,`get_${t}(${$e})`)},He=ee=>h<2?ue(ee):(R.getByIndices=!0,R.indicesToOffset=!0,`get_${t}ByIndices(${ee})`),Ee=h<2?"":`\n  fn set_${t}ByIndices(indices: ${B.indices}, value: ${O}) {\n    ${Be(`i2o_${t}(indices)`,"value")}\n  }`,qe=h<2?"":(()=>{let ee=u.map(Oe=>`d${Oe}: u32`).join(", "),$e=u.map(Oe=>`d${Oe}`).join(", ");return`\n  fn set_${t}(${ee}, value: ${O}) {\n    set_${t}ByIndices(${re($e)}, value);\n  }`})();return{impl:()=>{let ee=[];return m||(ee.push(`const ${k} = ${B.indices}(${e.join(",")});`),ee.push(`const ${U} = ${B.indices}(${Y.computeStrides(e).join(",")});`)),R.offsetToIndices&&ee.push(Q),R.indicesToOffset&&ee.push(A),R.broadcastedIndicesToOffset&&Object.values(H).forEach($e=>ee.push($e)),R.set&&ee.push(qe),R.setByIndices&&ee.push(Ee),R.get&&ee.push(Ze),R.getByIndices&&ee.push(ae),ee.join(`\n`)},type:B,offsetToIndices:L,indicesToOffset:Z,broadcastedIndicesToOffset:le,indices:re,indicesGet:ie,indicesSet:Ce,set:(...ee)=>{if(ee.length!==h+1)throw new Error(`indices length must be ${h}`);let $e=ee[h];if(typeof $e!="string")throw new Error("value must be string");let Oe=ee.slice(0,h).map(P).join(",");return h===0?Be("0u",$e):h===1?Be(Oe[0],$e):(R.set=!0,R.setByIndices=!0,R.indicesToOffset=!0,`set_${t}(${Oe}, ${$e})`)},setByOffset:Be,setByIndices:(ee,$e)=>h<2?Be(ee,$e):(R.setByIndices=!0,R.indicesToOffset=!0,`set_${t}ByIndices(${ee}, ${$e});`),get:Ie,getByOffset:ue,getByIndices:He,usage:d?"input":"output",name:t,strides:U,shape:k,rank:h}},ne=(t,r,e,d=1)=>Za(t,r,e,!0,d),fe=(t,r,e,d=1)=>Za(t,r,e,!1,d),xi=class{constructor(r){this.normalizedDispatchGroup=r;this.indicesHelpers=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(r){return`if (global_idx >= ${typeof r=="number"?`${r}u`:r}) { return; }`}mainStart(r=Gp){let e=typeof r=="number"?r:r[0],d=typeof r=="number"?1:r[1],l=typeof r=="number"?1:r[2],m=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,h=m?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>`,u=m?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +\n          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${e*d*l}u + local_index;`;return`@compute @workgroup_size(${e}, ${d}, ${l})\n  fn main(${h}) {\n    ${u}\n  `}declareVariable(r,e){this.indicesHelpers.push(r),r.shape.startsWith("uniforms.")&&this.uniforms.push({name:r.shape.replace("uniforms.",""),type:r.type.indices}),r.strides.startsWith("uniforms.")&&this.uniforms.push({name:r.strides.replace("uniforms.",""),type:r.type.indices});let d=r.usage==="input"?"read":"read_write",l=r.type.storage;return`@group(0) @binding(${e}) var<storage, ${d}> ${r.name}: array<${l}>;`}declareVariables(...r){return r.map(e=>this.declareVariable(e,this.variableIndex++)).join(`\n`)}registerUniform(r,e){return this.uniforms.push({name:r,type:e}),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let r=[];for(let{name:e,type:d}of this.uniforms)r.push(`${e}:${d}`);return`\n      struct Uniforms { ${r.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.indicesHelpers.map(r=>r.impl()).join(`\n`)}},es=t=>new xi(t),_i=(t,r)=>{let e=t.length,d=[];for(let l=0;l<e;l++){let m=e-1-l,h=t[m]||1;(r[r.length-1-l]||1)>1&&h===1&&d.unshift(m)}return d}});var $t,Vp,Fn,Up,xt,ts,rs,ns,is,os,as,ss,us,ls,cs,ht,Ai=oe(()=>{"use strict";Ae();Ne();Pe();$t=t=>{if(!t||t.length===0||t.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(t.length===2&&t[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Vp=t=>["","",`var value = ${t.getByOffset("inputOffset")};`,""],Fn=(t,r,e,d,l,m,h=!1,u=!1)=>{let w=[],_=e[0].dims,O=Y.normalizeAxes(l,e[0].dims.length),j=!u&&O.length===0;_.forEach((Z,re)=>{j||O.indexOf(re)>=0?h&&w.push(1):w.push(Z)});let B=[],P=ne("_A",e[0].dataType,_),R=fe("output",m,w),T=d(P,R,O),k=`inputOffset = ${P.indicesToOffset("inputIndices")};`,U=`let ${k};`,K=`var ${k};`,Q=T[1]===""?"":K,L=(T[1]===""?U:k)+`\n`+T[2];for(let Z=0,re=0;Z<e[0].dims.length;Z++)j||O.indexOf(Z)>=0?(h&&re++,L=`for(var j${Z}: u32 = 0; j${Z} < ${e[0].dims[Z]}; j${Z}++) {\n                ${T[2].includes("lastIndex")?`let lastIndex = j${Z};`:""}\n                ${P.indicesSet("inputIndices",Z,`j${Z}`)}\n                ${L}\n              }`):(B.push(`${P.indicesSet("inputIndices",Z,R.indicesGet("outputIndices",re))};`),re++);let X=Y.size(w);return{name:t,shaderCache:r,getShaderSource:Z=>`\n        ${Z.declareVariables(P,R)}\n\n        ${Z.mainStart()}\n          ${Z.guardAgainstOutOfBoundsWorkgroupSizes(X)}\n          var inputIndices: ${P.type.indices};\n          let outputIndices = ${R.offsetToIndices("global_idx")};\n\n          ${B.join(`\n`)}\n          ${T[0]}       // init ops for reduce max/min\n          ${Q}\n          ${T[1]}\n          ${L}\n          ${T[3]}\n          ${T.length===4?R.setByOffset("global_idx","value"):T.slice(4).join(`\n`)}\n        }`,getRunData:()=>({outputs:[{dims:w,dataType:m}],dispatchGroup:{x:Math.ceil(X/64)}})}},Up=(t,r)=>{let e=[];return t[1].dims[0]>0&&t[1].getBigInt64Array().forEach(d=>e.push(Number(d))),ye({axes:e,keepDims:r.keepDims,noopWithEmptyAxes:r.noopWithEmptyAxes})},xt=(t,r,e,d)=>{let l=t.inputs,m=l.length===1?e:Up(l,e);t.compute(Fn(r,{hint:m.cacheKey},[l[0]],m.noopWithEmptyAxes&&m.axes.length===0?Vp:d,m.axes,l[0].dataType,m.keepDims,m.noopWithEmptyAxes),{inputs:[0]})},ts=(t,r)=>{$t(t.inputs),xt(t,"ReduceLogSum",r,(d,l)=>[`var value = ${l.type.storage}(0);`,"",`value += ${d.getByOffset("inputOffset")};`,"value = log(value);"])},rs=(t,r)=>{$t(t.inputs),xt(t,"ReduceL1",r,(d,l)=>[`var value = ${l.type.storage}(0);`,"",`value += abs(${d.getByOffset("inputOffset")});`,""])},ns=(t,r)=>{$t(t.inputs),xt(t,"ReduceL2",r,(d,l)=>[`var t = ${l.type.value}(0); var value = ${l.type.value}(0);`,"",`t = ${d.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])},is=(t,r)=>{$t(t.inputs),xt(t,"ReduceLogSumExp",r,(d,l)=>[`var value = ${l.type.storage}(0);`,"",`value += exp(${d.getByOffset("inputOffset")});`,"value = log(value);"])},os=(t,r)=>{$t(t.inputs),xt(t,"ReduceMax",r,(d,l,m)=>{let h=[];for(let u=0;u<d.rank;u++)(m.indexOf(u)>=0||m.length===0)&&h.push(d.indicesSet("inputIndices",u,0));return[`${h.join(`\n`)}`,`var value = ${d.getByOffset("inputOffset")};`,`value = max(value, ${d.getByOffset("inputOffset")});`,""]})},as=(t,r)=>{$t(t.inputs),xt(t,"ReduceMean",r,(d,l,m)=>{let h=1;for(let u=0;u<d.rank;u++)(m.indexOf(u)>=0||m.length===0)&&(h*=t.inputs[0].dims[u]);return["var sum = f32(0);","",`sum += f32(${d.getByOffset("inputOffset")});`,`let value = ${l.type.value}(sum / ${h});`]})},ss=(t,r)=>{$t(t.inputs),xt(t,"ReduceMin",r,(d,l,m)=>{let h=[];for(let u=0;u<d.rank;u++)(m.indexOf(u)>=0||m.length===0)&&h.push(`inputIndices[${u}] = 0;`);return[`${h.join(`\n`)}`,`var value = ${d.getByOffset("inputOffset")};`,`value = min(value, ${d.getByOffset("inputOffset")});`,""]})},us=(t,r)=>{$t(t.inputs),xt(t,"ReduceProd",r,(d,l)=>[`var value = ${l.type.storage}(1);`,"",`value *= ${d.getByOffset("inputOffset")};`,""])},ls=(t,r)=>{$t(t.inputs),xt(t,"ReduceSum",r,(d,l)=>[`var value = ${l.type.storage}(0);`,"",`value += ${d.getByOffset("inputOffset")};`,""])},cs=(t,r)=>{$t(t.inputs),xt(t,"ReduceSumSquare",r,(d,l)=>[`var t = ${l.type.value}(0); var value = ${l.type.value}(0);`,"",`t = ${d.getByOffset("inputOffset")}; value += t * t;`,""])},ht=t=>ye(t)});var ds,fs,ps,ms,Ii,hs=oe(()=>{"use strict";Xe();Ne();Ai();ds=t=>{if(!t||t.length===0||t.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(t[0].dataType!==1)throw new Error("Invalid input type.")},fs=(t,r)=>ye({axis:r.axis,keepDims:r.keepDims,selectLastIndex:r.selectLastIndex}),ps=(t,r)=>{ds(t.inputs);let e=(l,m,h)=>{let u=[];for(let w=0;w<l.rank;w++)(h.indexOf(w)>=0||h.length===0)&&u.push(`inputIndices[${w}] = 0;`);return[`${u.join(`\n`)}`,`var value = ${l.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${l.getByOffset("inputOffset")} ${r.selectLastIndex>0?"<=":"<"} value) {\n         value = ${l.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",m.setByOffset("global_idx","bestIndex")]},d=t.inputs.length===1?r:fs(t.inputs,r);t.compute(Fn("ArgMin",{hint:d.cacheKey},[t.inputs[0]],e,[d.axis],7,d.keepDims),{inputs:[0]})},ms=(t,r)=>{ds(t.inputs);let e=(l,m,h)=>{let u=[];for(let w=0;w<l.rank;w++)(h.indexOf(w)>=0||h.length===0)&&u.push(`inputIndices[${w}] = 0;`);return[`${u.join(`\n`)}`,`var value = ${l.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${l.getByOffset("inputOffset")} ${r.selectLastIndex>0?">=":">"} value) {\n         value = ${l.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",m.setByOffset("global_idx","bestIndex")]},d=t.inputs.length===1?r:fs(t.inputs,r);t.compute(Fn("argMax",{hint:d.cacheKey},[t.inputs[0]],e,[d.axis],7,d.keepDims),{inputs:[0]})},Ii=t=>ye(t)});var Np,Fp,gs,ys=oe(()=>{"use strict";Ae();Pe();Np=t=>{if(t[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(t[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(t[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(t[0].dims[2]!==t[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Fp=t=>{let r=t[0].dims,e=t[0].dims[2],d=Y.size(r)/4,l=t[0].dataType,m=ne("input",l,r,4),h=ne("bias",l,[e],4),u=ne("residual",l,r,4),w=fe("output",l,r,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:r,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)}}),getShaderSource:O=>`\n  const channels = ${e}u / 4;\n  ${O.declareVariables(m,h,u,w)}\n\n  ${O.mainStart()}\n    ${O.guardAgainstOutOfBoundsWorkgroupSizes(d)}\n    let value = ${m.getByOffset("global_idx")}\n      + ${h.getByOffset("global_idx % channels")} + ${u.getByOffset("global_idx")};\n    ${w.setByOffset("global_idx","value")}\n  }`}},gs=t=>{Np(t.inputs),t.compute(Fp(t.inputs))}});var Hp,Re,bs,vs,ws,Cs,$s,xs,Ss,_s,As,Ti,Lp,Is,Ts,Os,Es,Hn,Ps,Ln,Rs,ks,Bs,Ms,js,Ds,Ws,zs,Gs,Vs,Us,Ns,Fs,Hs,Ls,Ks,qs,Oi=oe(()=>{"use strict";Xe();Ae();Ne();Pe();Hp=(t,r,e,d,l,m)=>{let h=Math.ceil(r/4),u="";typeof l=="string"?u=`${l}(a)`:u=l("a");let w=ne("inputData",e,[h],4),_=fe("outputData",d,[h],4);return`\n  ${t.declareVariables(w,_)}\n\n  ${m??""}\n\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes(h)}\n\n    let a = ${w.getByOffset("global_idx")};\n    ${_.setByOffset("global_idx",u)}\n  }`},Re=(t,r,e,d,l,m=t.dataType)=>({name:r,shaderCache:{hint:l},getShaderSource:h=>Hp(h,Y.size(t.dims),t.dataType,m,e,d),getRunData:h=>({outputs:[{dims:t.dims,dataType:m}],dispatchGroup:{x:Math.ceil(Y.size(h[0].dims)/64/4)}})}),bs=t=>{t.compute(Re(t.inputs[0],"Abs","abs"))},vs=t=>{t.compute(Re(t.inputs[0],"Acos","acos"))},ws=t=>{t.compute(Re(t.inputs[0],"Acosh","acosh"))},Cs=t=>{t.compute(Re(t.inputs[0],"Asin","asin"))},$s=t=>{t.compute(Re(t.inputs[0],"Asinh","asinh"))},xs=t=>{t.compute(Re(t.inputs[0],"Atan","atan"))},Ss=t=>{t.compute(Re(t.inputs[0],"Atanh","atanh"))},_s=t=>ye(t),As=(t,r)=>{let e;switch(r.to){case 10:e="vec4<f16>";break;case 1:e="vec4<f32>";break;case 12:e="vec4<u32>";break;case 6:e="vec4<i32>";break;case 9:e="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${r.to}`)}t.compute(Re(t.inputs[0],"Cast",e,void 0,r.cacheKey,r.to))},Ti=(t,r)=>{let e=Fe(t.inputs[0].dataType);t.compute(Re(t.inputs[0],"Clip",d=>`clamp(${d}, clip_min_, clip_max_)`,`\n    const clip_min_: vec4<${e}> = vec4(${e}(${r.min}));\n    const clip_max_: vec4<${e}> = vec4(${e}(${r.max}));\n`,r.cacheKey),{inputs:[0]})},Lp=t=>{let r=t.length>=2?t[1].getFloat32Array()[0]:Un,e=t.length>=3?t[2].getFloat32Array()[0]:Nn;return ye({min:r,max:e})},Is=t=>{let r=Lp(t.inputs);Ti(t,r)},Ts=t=>{t.compute(Re(t.inputs[0],"Ceil","ceil"))},Os=t=>{t.compute(Re(t.inputs[0],"Cos","cos"))},Es=t=>{t.compute(Re(t.inputs[0],"Cosh","cosh"))},Hn=t=>ye(t),Ps=(t,r)=>{t.compute(Re(t.inputs[0],"Elu",e=>`elu_vf32(${e})`,`\n  const elu_alpha_: f32 = f32(${r.alpha});\n\n  fn elu_f32(a: f32) -> f32 {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,r.cacheKey))},Ln=(t,r="f32")=>`\nconst r0: ${r} = 0.3275911;\nconst r1: ${r} = 0.254829592;\nconst r2: ${r} = -0.284496736;\nconst r3: ${r} = 1.421413741;\nconst r4: ${r} = -1.453152027;\nconst r5: ${r} = 1.061405429;\n\nfn erf_vf32(v: ${t}) -> ${t} {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,Rs=t=>{let r=Fe(t.inputs[0].dataType);t.compute(Re(t.inputs[0],"Erf",e=>`erf_vf32(${e})`,Ln(`vec4<${r}>`,r)))},ks=t=>{t.compute(Re(t.inputs[0],"Exp","exp"))},Bs=t=>{t.compute(Re(t.inputs[0],"Floor","floor"))},Ms=t=>{let r=Fe(t.inputs[0].dataType);t.compute(Re(t.inputs[0],"Gelu",e=>`0.5 * ${e} * (1.0 + erf_vf32(${e} * 0.7071067811865475))`,Ln(`vec4<${r}>`,r)))},js=(t,r)=>{t.compute(Re(t.inputs[0],"LeakyRelu",e=>`select(leaky_relu_alpha_ * ${e}, ${e}, ${e} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${r.alpha});`,r.cacheKey))},Ds=t=>{t.compute(Re(t.inputs[0],"Not",r=>`!${r}`))},Ws=t=>{t.compute(Re(t.inputs[0],"Neg",r=>`-${r}`))},zs=t=>{t.compute(Re(t.inputs[0],"Reciprocal",r=>`1.0/${r}`))},Gs=t=>{t.compute(Re(t.inputs[0],"Relu",r=>`select(vec4<f32>(0.0), ${r}, ${r} > vec4<f32>(0.0))`))},Vs=t=>{t.compute(Re(t.inputs[0],"Sigmoid",r=>`(1.0 / (1.0 + exp(-${r})))`))},Us=t=>{t.compute(Re(t.inputs[0],"Sin","sin"))},Ns=t=>{t.compute(Re(t.inputs[0],"Sinh","sinh"))},Fs=t=>{t.compute(Re(t.inputs[0],"Sqrt","sqrt"))},Hs=t=>{t.compute(Re(t.inputs[0],"Tan","tan"))},Ls=t=>{t.compute(Re(t.inputs[0],"Tanh","tanh"))},Ks=(t,r)=>(t.compute(Re(t.inputs[0],"ThresholdedRelu",e=>`select(vec4<f32>(0.0), ${e}, ${e} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${r.alpha});`,r.cacheKey)),0),qs=t=>{t.compute(Re(t.inputs[0],"Log","log"))}});var qp,Yp,Ys,Xs=oe(()=>{"use strict";Ae();Pe();Oi();qp=t=>{if(t[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(t[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(t[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(t[0].dims[2]!==t[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Yp=t=>{let r=t[0].dims.slice();r[2]=r[2]/2;let e=ne("input",t[0].dataType,t[0].dims,4),d=ne("bias",t[0].dataType,[t[0].dims[2]],4),l=fe("output",t[0].dataType,r,4),m=Y.size(r)/4;return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:r,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)}}),getShaderSource:u=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${t[0].dims[2]/4/2}u;\n\n  ${u.declareVariables(e,d,l)}\n\n  ${Ln("vec4f")}\n\n  ${u.mainStart()}\n    ${u.guardAgainstOutOfBoundsWorkgroupSizes(m)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${l.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},Ys=t=>{qp(t.inputs),t.compute(Yp(t.inputs))}});var Xp,Qp,St,Qs,Js,Zs,eu,tu,ru,nu,iu,ou,au,su=oe(()=>{"use strict";Xe();Ae();Pe();Xp=(t,r,e,d,l,m,h,u,w,_,O)=>{let j=Y.size(d),B=Math.ceil(j/4),P,R;typeof h=="string"?P=R=(L,X)=>`${h}((${L}),(${X}))`:typeof h=="function"?P=R=h:(P=h.scalar,R=h.vector);let T="",k=fe("outputData",_,d,4),U=ne("aData",u,r,4),K=ne("bData",w,e,4);if(m){let L=X=>{let A=Y.computeStrides(X),Z=[];for(let re=X.length-1;re>=0;re--){let ie=k.indicesGet("outputIndices",re+d.length-X.length);Z.push(`${A[re]}u * (${ie} % ${X[re]}u)`)}return Z.length>0?Z.join("+"):"0u"};T=`\n          fn calcOffsetA(outputIndices: ${k.type.indices}) -> u32 {\n            return ${L(r)};\n          }\n\n          fn calcOffsetB(outputIndices: ${k.type.indices}) -> u32 {\n            return ${L(e)};\n          }\n        `}let Q;if(l)if(m){let L=Y.size(r)===1,X=Y.size(e)===1;L||X?Q=k.setByOffset("global_idx",R(L?`${U.type.value}(${U.getByOffset("0")}.x)`:U.getByOffset("global_idx"),X?`${K.type.value}(${K.getByOffset("0")}.x)`:K.getByOffset("global_idx"))):Q=`\n            let outputIndices = ${k.offsetToIndices("global_idx * 4u")};\n            let offsetA = calcOffsetA(outputIndices);\n            let offsetB = calcOffsetB(outputIndices);\n            ${k.setByOffset("global_idx",R(U.getByOffset("offsetA / 4u"),K.getByOffset("offsetB / 4u")))}\n          `}else Q=k.setByOffset("global_idx",R(U.getByOffset("global_idx"),K.getByOffset("global_idx")));else{if(!m)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let L=(X,A,Z="")=>{let re=`aData[indexA${A}][componentA${A}]`,ie=`bData[indexB${A}][componentB${A}]`;return`\n            let outputIndices${A} = ${k.offsetToIndices(`global_idx * 4u + ${A}u`)};\n            let offsetA${A} = calcOffsetA(outputIndices${A});\n            let offsetB${A} = calcOffsetB(outputIndices${A});\n            let indexA${A} = offsetA${A} / 4u;\n            let indexB${A} = offsetB${A} / 4u;\n            let componentA${A} = offsetA${A} % 4u;\n            let componentB${A} = offsetB${A} % 4u;\n            ${X}[${A}] = ${Z}(${P(re,ie)});\n          `};_===9?Q=`\n            var data = vec4<u32>(0);\n            ${L("data",0,"u32")}\n            ${L("data",1,"u32")}\n            ${L("data",2,"u32")}\n            ${L("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:Q=`\n            ${L("outputData[global_idx]",0)}\n            ${L("outputData[global_idx]",1)}\n            ${L("outputData[global_idx]",2)}\n            ${L("outputData[global_idx]",3)}\n          `}return`\n        ${t.declareVariables(U,K,k)}\n\n        ${O??""}\n        ${T}\n\n        ${t.mainStart()}\n        ${t.guardAgainstOutOfBoundsWorkgroupSizes(B)}\n        ${Q}\n      }`},Qp=(t,r,e,d,l,m,h=e.dataType)=>{let u=!Y.areEqual(e.dims,d.dims),w=e.dims,_=Y.size(e.dims),O=!1;if(u){let j=Ct.calcShape(e.dims,d.dims,!1);if(!j)throw new Error("Can\'t perform binary op on the given tensors");w=j,_=Y.size(w);let B=Y.size(e.dims)===1,P=Y.size(d.dims)===1,R=1;for(let T=1;T<w.length;T++){let k=e.dims[e.dims.length-T]??1,U=d.dims[d.dims.length-T]??1;if(k===U)R*=k;else break}(R%4===0||B||P)&&(O=!0)}else O=!0;return{name:t,shaderCache:{hint:r},getShaderSource:j=>Xp(j,e.dims,d.dims,w,O,u,l,e.dataType,d.dataType,h,m),getRunData:()=>({outputs:[{dims:w,dataType:h}],dispatchGroup:{x:Math.ceil(_/64/4)}})}},St=(t,r,e,d,l,m)=>{t.compute(Qp(r,l??"",t.inputs[0],t.inputs[1],e,d,m))},Qs=t=>{St(t,"Add",(r,e)=>`${r}+${e}`)},Js=t=>{St(t,"Div",(r,e)=>`${r}/${e}`)},Zs=t=>{St(t,"Equal",{scalar:(r,e)=>`u32(${r}==${e})`,vector:(r,e)=>`vec4<u32>(${r}==${e})`},void 0,void 0,9)},eu=t=>{St(t,"Mul",(r,e)=>`${r}*${e}`)},tu=t=>{let r=ne("input",t.inputs[0].dataType,t.inputs[0].dims).type.value;St(t,"Pow",{scalar:(d,l)=>`pow_custom(${d},${l})`,vector:(d,l)=>`pow_vector_custom(${d},${l})`},`\n    fn pow_custom(a : ${r}, b : ${r}) -> ${r} {\n      if (b == ${r}(0.0)) {\n        return ${r}(1.0);\n      } else if (a < ${r}(0.0) && f32(b) != floor(f32(b))) {\n        return ${r}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${r}(1.0), round(f32(abs(b) % ${r}(2.0))) != 1.0) * ${r}(${r==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${r}>, b : vec4<${r}>) -> vec4<${r}> {\n      // TODO: implement vectorized pow\n      return vec4<${r}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},ru=t=>{St(t,"Sub",(r,e)=>`${r}-${e}`)},nu=t=>{St(t,"Greater",{scalar:(r,e)=>`u32(${r}>${e})`,vector:(r,e)=>`vec4<u32>(${r}>${e})`},void 0,void 0,9)},iu=t=>{St(t,"Less",{scalar:(r,e)=>`u32(${r}<${e})`,vector:(r,e)=>`vec4<u32>(${r}<${e})`},void 0,void 0,9)},ou=t=>{St(t,"GreaterOrEqual",{scalar:(r,e)=>`u32(${r}>=${e})`,vector:(r,e)=>`vec4<u32>(${r}>=${e})`},void 0,void 0,9)},au=t=>{St(t,"LessOrEqual",{scalar:(r,e)=>`u32(${r}<=${e})`,vector:(r,e)=>`vec4<u32>(${r}<=${e})`},void 0,void 0,9)}});var Zp,em,tm,rm,uu,lu,cu=oe(()=>{"use strict";Ae();Ne();Pe();Zp=t=>{if(!t||t.length<1)throw new Error("too few inputs");let r=t[0].dataType,e=t[0].dims.length;for(let d of t){if(d.dataType!==r)throw new Error("input tensors should be one type");if(d.dims.length!==e)throw new Error("input tensors should have the same shape")}},em=t=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${t}u; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${t}u;\n  }`,tm=(t,r)=>{let e=t.length,d=[];for(let l=0;l<e;++l){let m=r.setByOffset("global_idx",t[l].getByIndices("indices"));e===1?d.push(m):l===0?d.push(`if (inputIndex == ${l}u) { ${m} }`):l===e-1?d.push(`else { ${m} }`):d.push(`else if (inputIndex == ${l}) { ${m} }`)}return d.join(`\n`)},rm=(t,r)=>{let e=t[0].dims.slice();if(r>=e.length||r<-1*e.length)throw new Error("axis specified for concat doesn\'t match input dimensionality");let d=r<0?e.length+r:r,l=e.slice(0);for(let P=1;P<t.length;P++){let R=t[P].dims.slice();for(let T=0;T<e.length;T++)if(T===d)l[d]+=R[T];else if(e[T]!==R[T])throw new Error("non concat dimensions must match")}let m=Y.size(l),h=new Array(t.length),u=new Array(t.length),w=t[0].dataType,_=0;for(let P=0;P<t.length;++P)_+=t[P].dims[d],h[P]=_,u[P]=ne(`input${P}`,w,t[P].dims);let O=fe("output",w,l),j=O.indicesGet("indices",d),B=P=>`\n  ${P.declareVariables(...u,O)}\n\n  const sizeInConcatAxis = array<u32, ${h.length}>(${h.map(R=>`${R}u`).join(",")});\n  ${em(h.length)}\n\n  ${P.mainStart()}\n    ${P.guardAgainstOutOfBoundsWorkgroupSizes(m)}\n\n    var indices = ${O.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${j});\n    if (inputIndex != 0u) {\n      ${j} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${tm(u,O)}\n  }`;return{name:"Concat",shaderCache:{hint:`${r}`},getRunData:()=>({outputs:[{dims:l,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)}}),getShaderSource:B}},uu=(t,r)=>{Zp(t.inputs),t.compute(rm(t.inputs,r.axis))},lu=t=>ye({axis:t.axis})});var Qe,Kn,qn,Yn=oe(()=>{"use strict";Qe=(t,r)=>{switch(t){case 1:return r;case 2:return`vec2<${r}>`;case 3:return`vec3<${r}>`;case 4:return`vec4<${r}>`;default:throw new Error(`${t}-component is not supported.`)}},Kn=(t,r=!1,e=!1,d=3)=>"",qn=(t,r)=>`\n      ${t?"value = value + getBiasByOutputCoords(coords);":""}\n      ${r?"value = activation(value, coords);":""}\n      `});var Xn,Ei=oe(()=>{"use strict";Xn=`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));\n}\n`});var Qn,Jn,on=oe(()=>{"use strict";Ae();Qn=t=>{switch(t.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${t.clipMin});const clip_max_=f32(${t.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},Jn=t=>{let r=t?.activation||"";if(r==="Clip"){let[e,d]=t?.activation_params||[Un,Nn];return{activation:r,clipMax:d,clipMin:e,activationCacheKey:`${r}:${e},${d}`}}return{activation:r,activationCacheKey:r}}});var nm,im,an,du,om,sn,am,Zn,un=oe(()=>{"use strict";Ae();Pe();on();Yn();nm=(t,r)=>t?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${r?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${r?", batchIndices":""});\n        `,im=(t,r)=>t?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${r===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${r===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${r===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,an=(t,r,e="f32",d,l=!1,m=32,h=!1,u=32)=>{let w=r[1]*t[1],_=r[0]*t[0],O=l?w:m,j=l?m:w,B=O/r[0],P=m/r[1];if(!((l&&B===4&&t[1]===4||!l&&(B===3||B===4))&&O%r[0]===0&&m%r[1]===0&&t[0]===4))throw new Error(`If transposeA ${l} is true, innerElementSize ${B} and workPerThread[1] ${t[1]} must be 4.\n      Otherwise, innerElementSize ${B} must be 3 or 4.\n  tileAWidth ${O} must be divisible by workgroupSize[0]${r[0]}. tileInner ${m} must be divisible by workgroupSize[1] ${r[1]}. colPerThread ${t[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${B}<${e}>, ${O/B}>, ${j}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${e}>, ${_/t[0]}>, ${m}>;\n\nconst rowPerThread = ${t[1]};\nconst colPerThread = ${t[0]};\nconst innerElementSize = ${B};\nconst tileInner = ${m};\n\n@compute @workgroup_size(${r[0]}, ${r[1]}, ${r[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${h?"0":"i32(globalId.z)"};\n  ${d?`let batchIndices = ${d.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${w};\n\n  let numTiles = ${h?`${Math.ceil(u/m)}`:"(dimInner - 1) / tileInner + 1"};\n  var kStart = ${h?`i32(globalId.z) * ${u}`:"0"};\n\n  var acc: array<vec4<${e}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${P};\n  for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${nm(l,d)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${P}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${d?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${B===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${im(l,B)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},du=(t,r)=>t?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${r?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${r?", batchIndices":""});\n            `,om=t=>t?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",sn=(t,r,e="f32",d,l=!1,m=32,h=!1,u=32,w=!1)=>{let _=t[1]*r[1],O=t[0]*r[0],j=l?_:m,B=l?m:_;if(!(B%r[1]===0&&j%r[0]===0&&m%r[1]===0))throw new Error(`tileAHight ${B} must be divisible by workgroupSize[1]${r[1]}, tileAWidth ${j} must be divisible by workgroupSize[0]${r[0]}, tileInner ${m} must be divisible by workgroupSize[1]${r[1]}`);let P=B/r[1],R=j/r[0],T=m/r[1],k=w?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${_};\n    let globalColStart = i32(workgroupId.x) * ${O};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${B}; inputRow = inputRow + ${r[1]}) {\n        for (var inputCol = localCol; inputCol < ${j}; inputCol = inputCol + ${r[0]}) {\n          ${du(l,d)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${m}; inputRow = inputRow + ${r[1]}) {\n            for (var inputCol = localCol; inputCol < ${O}; inputCol = inputCol + ${r[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${d?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${e}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${r[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${l?`mm_Asub[k][localRow + innerRow * ${r[1]}];`:`mm_Asub[localRow + innerRow * ${r[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${r[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${r[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${_};\n\nlet tileRowA = i32(localId.y) * ${P};\nlet tileColA = i32(localId.x) * ${R};\nlet tileRowB = i32(localId.y) * ${T};\n// Loop over shared dimension.\nfor (var t = 0; t < numTiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${P}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${R}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${du(l,d)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${T}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${d?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${e}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${om(l)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${e}, ${j}>, ${B}>;\n  var<workgroup> mm_Bsub : array<array<${e}, ${O}>, ${m}>;\n  const rowPerThread = ${t[1]};\n  const colPerThread = ${t[0]};\n  const tileInner = ${m};\n\n@compute @workgroup_size(${r[0]}, ${r[1]}, ${r[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${h?"0":"i32(globalId.z)"};\n    ${d?`let batchIndices = ${d.offsetToIndices("u32(batch)")};`:""}\n    let numTiles = ${h?`${Math.ceil(u/m)}`:"(dimInner - 1) / tileInner + 1"};\n    var kStart = ${h?`i32(globalId.z) * ${u}`:"0"};\n\n    var acc : array<array<${e}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${k}\n  }\n`},am=(t,r,e,d,l,m=!1)=>{let h=l[0],u=l[1],w=l[2],_=d[0],O=d[1],j=d[2],B=d[3],P=_i(h,w),R=_i(u,w),T=Fe(d[0].type.tensor),k=()=>{let Q=O.rank,L=_.rank,X=`var aIndices: ${O.type.indices};`;for(let A=Q-2-1,Z=L-1;A>=0;A--,Z--)X+=`\naIndices[${A}] = ${L>1?`batchIndices[${Z}]`:"batchIndices"};`;return P.forEach(A=>{X+=`\naIndices[${A}] = 0;`}),X+=`\naIndices[${Q-2}] = u32(row);\n                   aIndices[${Q-1}] = u32(colIn);`,X},U=()=>{let Q=j.rank,L=_.rank,X=`var bIndices: ${j.type.indices};`;for(let A=Q-2-1,Z=L-1;A>=0;A--,Z--)X+=`\nbIndices[${A}] = ${L>1?`batchIndices[${Z}]`:"batchIndices"};`;return R.forEach(A=>{X+=`\nbIndices[${A}] = 0;`}),X+=`\nbIndices[${Q-2}] = u32(row);\n                   bIndices[${Q-1}] = u32(colIn);`,X};return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${_.type.indices}) -> ${Qe(t,T)} {\n      var value = ${Qe(t,T)}(0.0);\n      let col = colIn * ${t};\n      if(row < dimAOuter && col < dimInner)\n      {\n        ${k()}\n        value = ${O.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${_.type.indices}) -> ${Qe(t,T)} {\n      var value = ${Qe(t,T)}(0.0);\n      let col = colIn * ${t};\n      if(row < dimInner && col < dimBOuter)\n      {\n        ${U()}\n        value = ${j.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Qe(t,T)}) {\n      let col = colIn * ${t};\n      if (row < dimAOuter && col < dimBOuter) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${r?`value = value + ${m?"bias[colIn]":`${Qe(t,T)}(bias[row])`};`:""}\n        ${e}\n        ${B.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},Zn=(t,r,e,d,l=!1)=>{let m=t[0].dims,h=t[1].dims,u=m.slice(0,-2),w=h.slice(0,-2),_=d?d.slice(0,-2):e.slice(0,-2),O=ne("batchDims",t[0].dataType,_),j=[O],B=[u,w,_],P=Y.size(_),R=m[m.length-2],T=m[m.length-1],k=h[h.length-1],U=T%4===0&&k%4===0,{activationFunction:K,applyActivation:Q}=Qn(r),L=R<=8?[4,1,1]:[4,4,1],X=[8,8,1],A=[Math.ceil(k/X[0]/L[0]),Math.ceil(R/X[1]/L[1]),Math.ceil(P/X[2]/L[2])],Z=Fe(t[0].dataType),re=U?4:1,ie=ne("a",t[0].dataType,[...u,R,T/re],re),Ce=ne("b",t[1].dataType,[...w,T,k/re],re),H=fe("result",t[0].dataType,[P,R,k/re],re);j.push(ie),j.push(Ce),j.push(H);let le=[ie,Ce],Be=t.length>2,ue=am(re,Be,Q,j,B,l);if(Be){let Ze=l?re:1;le.push(ne("bias",t[2].dataType,t[2].dims,Ze))}let ae=Ze=>`\n  const dimAOuter: i32 = ${R};\n  const dimBOuter: i32 = ${k};\n  const dimInner: i32 = ${T};\n  ${Ze.declareVariables(...le,H)}\n  ${ue}\n  ${K}\n  ${U?an(L,X,Z,O):sn(L,X,Z,O)}\n                   ${O.impl()}`;return{name:"MatMul",shaderCache:{hint:r.activationCacheKey},getRunData:()=>({outputs:[{dims:e,dataType:t[0].dataType}],dispatchGroup:{x:A[0],y:A[1],z:A[2]}}),getShaderSource:ae}}});var sm,fu,pu=oe(()=>{"use strict";Tt();Ae();Pe();Yn();Ei();un();sm=(t,r,e,d,l=!1,m,h=!1,u=4,w=4,_=4,O="f32")=>{let j=Ce=>{switch(Ce){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${O}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${Ce} is not supported.`)}},B=Ce=>{switch(Ce){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${Ce} is not supported.`)}},P=t?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,R=t?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,T=t?"xShape[1]":"xShape[2]",k=t?"xShape[2]":"xShape[3]",U=t?"row":"col",K=t?"col":"row",Q=`\n    let inChannels = wShape[2];\n    let outWidth = ${t?"outShape[2]":"outShape[3]"};\n    let outRow = ${U} / outWidth;\n    let outCol = ${U} % outWidth;\n\n    let WRow = ${K} / (filterDims[1] * inChannels);\n    let WCol = ${K} / inChannels % filterDims[1];\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\n    let xCh = ${K} % inChannels;\n    var resData = ${Qe(u,O)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the \'same\' padding type.\n    if (xRow >= 0 && xRow < ${T} && xCol >= 0 && xCol < ${k}) {\n      ${P}\n      let xIndex = getIndexFromCoords4D(coord, xShape);\n      ${j(u)}\n    }\n    return resData;`,L=t?r&&d?`\n    let col = colIn * ${u};\n    ${Q}`:`\n    let col = colIn * ${u};\n    if (row < dimAOuter && col < dimInner) {\n      ${Q}\n    }\n    return ${Qe(u,O)}(0.0);`:d&&e?`\n    let col = colIn * ${u};\n    ${Q}`:`\n    let col = colIn * ${u};\n    if (row < dimInner && col < dimBOuter) {\n      ${Q}\n    }\n    return ${Qe(u,O)}(0.0);`,X=`${B(w)}`,A=Qe(_,O),Z=t?Qe(u,O):Qe(w,O),re=t?Qe(w,O):Qe(u,O);return`\n    ${Kn(m,h,_===4,4)}\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${Z} {\n      ${t?L:X}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${re} {\n      ${t?X:L}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${A}) {\n      let col = colIn * ${_};\n      if (row < dimAOuter && col < dimBOuter)\n      {\n      var value = valueIn;\n      let outWidth = ${t?"outShape[2]":"outShape[3]"};\n      ${R}\n      ${qn(l,m)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},fu=(t,r,e,d,l,m,h,u)=>{let w=r.format==="NHWC",_=w?t[0].dims[3]:t[0].dims[1],O=e[0],j=w?e[2]:e[3],B=w?e[1]:e[2],P=w?e[3]:e[1],R=w&&(_%4===0||_%3===0)&&P%4===0,T=w?P:j*B,k=w?j*B:P,U=[8,8,1],K=d<=8?[4,1,1]:[4,4,1],Q=[Math.ceil(T/U[0]/K[0]),Math.ceil(k/U[1]/K[1]),Math.ceil(O/U[2]/K[2])];ze("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${Q}`);let L=R?w&&_%4!==0?3:4:K[0],X=U[1]*K[1],A=U[0]*K[0],Z=Math.max(U[0]*L,U[1]),re=d%X===0,ie=l%A===0,Ce=m%Z===0,H=R?[L,4,4]:[1,1,1],le=Fe(t[0].dataType),Be=[`@group(0) @binding(0) var<storage, read> x: array<${R&&L===4?`vec4<${le}>`:le}>;`,`@group(0) @binding(1) var<storage, read> w: array<${R?`vec4<${le}>`:le}>;`],ue=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${R?`vec4<${le}>`:le}) {\n        result[flatIndex] = ${R?`vec4<${le}>`:le}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${R?`vec4<${le}>`:le}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${R?"/ 4":""}, value);\n      }`;return h&&(Be.push(`@group(0) @binding(2) var<storage, read> bias: array<${R?`vec4<${le}>`:le}>;`),ue+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${R?`vec4<${le}>`:le} {\n          return bias[coords.${w?"w":"y"}${R?"/ 4":""}];\n        }`),{name:"Conv2DMatMul",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:e,dataType:t[0].dataType}],dispatchGroup:{x:Q[0],y:Q[1],z:Q[2]}}),getShaderSource:()=>`\n        ${Xn}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${Be.join("")}\n        @group(0) @binding(${Be.length}) var<storage, read_write> result: array<${R?`vec4<${le}>`:le}>;\n        //@group(0) @binding(${Be.length+1}) var<uniform> uniforms: Uniforms;\n\n        const xShape : vec4<i32> = vec4<i32>(${t[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${t[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${e.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${Y.computeStrides(e).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${r.kernelShape[0]}, ${r.kernelShape[1]});\n        const pad : vec2<i32> = vec2<i32>(${r.pads[0]}, ${r.pads[1]});\n        const stride : vec2<i32> = vec2<i32>(${r.strides[0]}, ${r.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${r.dilations[0]}, ${r.dilations[1]});\n        const dimAOuter : i32 = ${d};\n        const dimBOuter : i32 = ${l};\n        const dimInner : i32 = ${m};\n        ${ue}\n        ${sm(w,re,ie,Ce,h,void 0,!1,H[0],H[1],H[2],le)}\n            ${R?an(K,U,le,void 0,!w,Z):sn(K,U,le,void 0,!w,Z,!1,void 0,u)}`}}});var Pi,mu=oe(()=>{"use strict";Ae();Pe();ki();on();Pi=(t,r,e)=>{let d=t.length>2,l=d?"value += b[output_channel];":"",m=t[0].dims,h=t[1].dims,u=h[0]/r.group,{activationFunction:w,applyActivation:_}=Qn(r),O=r.format==="NHWC",j=Ri(m,h,r.dilations,r.pads,r.strides,O),B=Y.size(j),P=fe("output",t[0].dataType,j),R=ne("x",t[0].dataType,m),T=ne("w",t[1].dataType,h),k=[R,T];d&&k.push(ne("b",t[2].dataType,t[2].dims));let U=K=>`\n  const strides: vec2<u32> = vec2(${r.strides[0]}u, ${r.strides[1]}u);\n  const pads: vec2<u32> = vec2(${r.pads[0]}u, ${r.pads[1]}u);\n\n  ${K.declareVariables(...k,P)}\n\n  ${w}\n\n  ${K.mainStart()}\n    ${K.guardAgainstOutOfBoundsWorkgroupSizes(B)}\n\n    let outputIndices = ${P.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${O?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${O?1:2}], outputIndices[${O?2:3}]) * strides - pads;\n    let group_id: u32 = output_channel / ${u}u;\n\n    var value: ${P.type.value} = ${P.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < ${h[1]}u; wInChannel++) {\n      let input_channel = group_id * ${h[1]}u + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < ${h[2]}u; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * ${r.dilations[0]}u;\n\n        if (xHeight < 0u || xHeight >= ${m[O?1:2]}u) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < ${h[3]}u; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * ${r.dilations[1]}u;\n          if (xWidth < 0u || xWidth >= ${m[O?2:3]}u) {\n            continue;\n          }\n\n          let xVal = ${O?R.get("batch","xHeight","xWidth","input_channel"):R.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${T.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${l}\n    ${_}\n    ${P.setByOffset("global_idx","value")}\n  }`;return{name:"GroupedConv",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:e?e(j):j,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(B/64)}}),getShaderSource:U}}});var um,hu,lm,cm,fr,gu,yu,ei=oe(()=>{"use strict";Ae();Ne();Pe();um=t=>{if(!t||t.length!==1)throw new Error("Transpose requires 1 input.")},hu=(t,r)=>r&&r.length!==t?[...new Array(t).keys()].reverse():r,lm=(t,r)=>Y.sortBasedOnPerm(t,hu(t.length,r)),cm=(t,r,e,d)=>{let l=[];l.push(`fn perm(i: ${d.type.indices}) -> ${e.type.indices} {\n    var a: ${e.type.indices};`);for(let m=0;m<r;++m)l.push(e.indicesSet("a",t[m],`i[${m}]`));return l.push("return a;}"),l.join(`\n`)},fr=(t,r,e)=>{let d=hu(r,e),l=fe("output",t,e&&e.length||r),m=ne("a",t,r),h=u=>`\n  ${u.registerUniform("output_size","u32").declareVariables(m,l)}\n\n  ${cm(d,r,m,l)}\n\n  ${u.mainStart()}\n    ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${l.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${l.setByOffset("global_idx",m.getByIndices("aIndices"))}\n  }`;return{name:"Transpose",shaderCache:{hint:`${e}`,inputDependencies:["rank"]},getRunData:u=>{let w=lm(u[0].dims,d),_=Y.size(w);return{outputs:[{dims:w,dataType:u[0].dataType}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:[{type:"uint32",data:_},...Si(u[0].dims),...Si(w)]}},getShaderSource:h}},gu=(t,r)=>{um(t.inputs),t.compute(fr(t.inputs[0].dataType,t.inputs[0].dims.length,r.perm))},yu=t=>ye({perm:t.perm})});var Ri,bu,dm,vu,wu,fm,pm,Cu,ki=oe(()=>{"use strict";Ae();Ne();pu();un();mu();on();ei();Ri=(t,r,e,d,l,m)=>{let h=t[0],u=t.slice(m?1:2,m?3:4),w=u.length,_=r[0],j=r.slice(2).map((R,T)=>R+(R-1)*(e[T]-1)),P=u.map((R,T)=>R+d[T]+d[T+w]).map((R,T)=>Math.floor((R-j[T]+l[T])/l[T]));return P.splice(0,0,h),P.splice(m?3:1,0,_),P},bu=[2,3,1,0],dm=(t,r)=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(t[0].dims.length!==4&&t[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(t[0].dims.length!==t[1].dims.length)throw new Error("filter does not have same dimension as input");let e=t[0].dims[r.format==="NHWC"?t[0].dims.length-1:1],d=t[1].dims[1]*r.group;if(e!==d)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(t.length===3&&(t[2].dims.length!==1||t[1].dims[0]!==t[2].dims[0]))throw new Error("invalid bias");let l=t[0].dims.length-2;if(r.dilations.length!==l)throw new Error(`dilations should be ${l}D`);if(r.strides.length!==l)throw new Error(`strides should be ${l}D`);if(r.pads.length!==l*2)throw new Error(`pads should be ${l*2}D`);if(r.kernelShape.length!==0&&r.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape")},vu=(t,r)=>{let e=t.kernelShape.slice();for(let m=2;m<r[1].dims.length;++m)e[m-2]===0&&(e[m-2]=r[1].dims[m]);let d=t.pads.slice();Nt.adjustPadsBasedOnAutoPad(r[0].dims,t.strides,t.dilations,e,d,t.format==="NHWC",t.autoPad);let l=Object.assign({},t);return Object.assign(l,{kernelShape:e,pads:d,cacheKey:t.cacheKey}),l},wu=t=>{let r=Jn(t),e=t.format,d=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][t.auto_pad],l=t.dilations,m=t.group,h=t.kernel_shape,u=t.pads,w=t.strides,_=t.w_is_const();return ye({autoPad:d,format:e,dilations:l,group:m,kernelShape:h,pads:u,strides:w,wIsConst:_,...r})},fm=(t,r,e)=>{let d=vu(e,r);if(e.group!==1){t.compute(Pi(r,d));return}let l=e.format==="NHWC",m=r.length===3,h=r[0].dims[l?1:2],u=r[0].dims[l?2:3],w=r[0].dims[l?3:1],_=r[1].dims[2],O=r[1].dims[3],j=Ri(r[0].dims,r[1].dims,e.dilations,d.pads,e.strides,l),B=j[l?1:2],P=j[l?2:3],R=j[l?3:1],T=l&&_===h&&O===u&&e.pads[0]===0&&e.pads[1]===0;if(T||_===1&&O===1&&e.dilations[0]===1&&e.dilations[1]===1&&e.strides[0]===1&&e.strides[1]===1&&e.pads[0]===0&&e.pads[1]===0){let A=j[0],Z,re,ie,Ce=[];if(l){let H=t.kernelCustomData.wT??t.compute(fr(r[1].dataType,r[1].dims.length,bu),{inputs:[1],outputs:[e.wIsConst?-2:-1]})[0];if(e.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=H),T){let le=h*u*w;Z=r[0].reshape([1,A,le]),re=H.reshape([1,le,R]),ie=[1,A,R]}else Z=r[0].reshape([A,h*u,w]),re=H.reshape([1,w,R]),ie=[A,B*P,R];Ce.push(Z),Ce.push(re)}else Z=r[0].reshape([A,w,h*u]),re=r[1].reshape([1,R,w]),ie=[A,R,B*P],Ce.push(re),Ce.push(Z);m&&Ce.push(r[2]),t.compute(Zn(Ce,d,j,ie,l),{inputs:Ce});return}let k=!0,U=t.kernelCustomData.wT??t.compute(fr(r[1].dataType,r[1].dims.length,bu),{inputs:[1],outputs:[e.wIsConst?-2:-1]})[0];e.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=U);let K=[r[0],U];m&&K.push(r[2]);let Q=l?B*P:R,L=l?R:B*P,X=_*O*w;t.compute(fu(K,d,j,Q,L,X,m,k),{inputs:K})},pm=(t,r)=>{let e=r.format==="NHWC",d=[t.inputs[0].reshape(e?[t.inputs[0].dims[0],1,t.inputs[0].dims[1],t.inputs[0].dims[2]]:[t.inputs[0].dims[0],t.inputs[0].dims[1],1,t.inputs[0].dims[2]]),t.inputs[1].reshape([t.inputs[1].dims[0],t.inputs[1].dims[1],1,t.inputs[1].dims[2]])];t.inputs.length===3&&d.push(t.inputs[2]);let l=[0,r.pads[0],0,r.pads[1]],m=[1].concat(r.strides),h=[1].concat(r.dilations),u=[1].concat(r.kernelShape),w=vu({...r,pads:l,strides:m,dilations:h,kernelShape:u},d);t.compute(Pi(d,w,_=>e?[_[0],_[2],_[3]]:[]))},Cu=(t,r)=>{dm(t.inputs,r),t.inputs[0].dims.length===3?pm(t,r):fm(t,t.inputs,r)}});var mm,$u,xu=oe(()=>{"use strict";Tt();Ae();Yn();Ei();un();mm=(t,r=!1,e,d=!1,l=4)=>{let m=Qe(l,"f32"),h=U=>{switch(U){case 1:return"return W[getIndexFromCoords4D(coord, wShape)];";case 4:return`\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            `;default:throw new Error(`innerElementSize ${U} is not supported.`)}},u=t?`\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      `:`\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      `,w=t?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,_=t?"outBackprop[1]":"outBackprop[2]",O=t?"outBackprop[2]":"outBackprop[3]",j=t?"row":"col",B=t?"col":"row",P=`\n      let inChannels = ${t?"outBackprop[3]":"outBackprop[1]"};\n      let outWidth = ${t?"outShape[2]":"outShape[3]"};\n      let outRow = ${j} / outWidth;\n      let outCol = ${j} % outWidth;\n\n      let WRow = ${B} / (filterDims[1] * inChannels);\n      let WCol = ${B} / inChannels % filterDims[1];\n      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);\n      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);\n      if (xR < 0.0 || xR >= f32(${_}) || fract(xR) > 0.0) {\n        return ${m}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${O}) || fract(xC) > 0.0) {\n        return ${m}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${B} % inChannels;\n      ${u}\n      return x[getIndexFromCoords4D(coord, xShape)/${l}];`,R=t?`\n      let col = colIn * ${l};\n      if (row < dimAOuter && col < dimInner) {\n        ${P}\n      }\n      return ${m}(0.0);`:`\n      let col = colIn * ${l};\n      if (row < dimInner && col < dimBOuter) {\n        ${P}\n      }\n      return ${m}(0.0);`,T=`\n      let col = colIn * ${l};\n      let inChannels = ${t?"outBackprop[3]":"outBackprop[1]"};\n      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);\n      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];\n      if (${t?"row < dimInner && col < dimBOuter":"row < dimInner && col < dimAOuter"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${h(l)}\n      }\n      return ${m}(0.0);\n      `;return`\n  ${Kn(e,d,l===4,4)}\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${m} {\n    ${t?R:T}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${m} {\n    ${t?T:R}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${m}) {\n    let col = colIn * ${l};\n    if (row < dimAOuter && col < dimBOuter) {\n      var value = valueInput;\n      let outWidth = ${t?"outShape[2]":"outShape[3]"};\n      ${w}\n      ${qn(r,e)}\n      result[getIndexFromCoords4D(coords, outShape)/${l}] = value;\n    }\n  }`},$u=(t,r,e,d,l,m,h,u)=>{let w=r.format==="NHWC",_=w?t[0].dims[3]:t[0].dims[1],O=e[0],j=w?e[2]:e[3],B=w?e[1]:e[2],P=w?e[3]:e[1],R=w?_%4===0&&P%4===0:j%4===0&&P%4===0,T=w?P:j*B,k=w?j*B:P,U=R?[8,8,1]:[T<=4||k<=4?4:16,T>4&&k<=4?4:16,1],K=R?[4,4,1]:[T<=4?1:4,T>4&&k<=4?1:4,1],Q=[Math.ceil(T/U[0]/K[0]),Math.ceil(k/U[1]/K[1]),Math.ceil(O/U[2]/K[2])];ze("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${Q}`);let L=R?4:1,X=Math.max(U[0]*L,U[1]),A=[`@group(0) @binding(0) var<storage, read> x: array<${R?"vec4<f32>":"f32"}>;`,"@group(0) @binding(1) var<storage, read> W: array<f32>;"],Z="";return h&&(A.push(`@group(0) @binding(2) var<storage, read> bias: array<${R?"vec4<f32>":"f32"}>;`),Z+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${R?"vec4<f32>":"f32"} {\n          return bias[coords.${w?"w":"y"}${R?"/ 4":""}];\n        }`),{name:"Conv2DTransposeMatMul",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:e,dataType:t[0].dataType}],dispatchGroup:{x:Q[0],y:Q[1],z:Q[2]}}),getShaderSource:()=>`\n        ${Xn}\n        ${A.join(`\n`)}\n        @group(0) @binding(${A.length}) var<storage, read_write> result: array<${R?"vec4<f32>":"f32"}>;\n        const outBackprop : vec4<i32> = vec4<i32>(${t[0].dims.join(",")});\n        const xShape : vec4<i32> = vec4<i32>(${t[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${t[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${e.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${Y.computeStrides(e).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${r.kernelShape[w?1:2]}, ${r.kernelShape[w?2:3]});\n        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(\n              ${r.dilations[0]<=1?0:(r.kernelShape[w?1:2]-1)*(r.dilations[0]-1)},\n              ${r.dilations[1]<=1?0:(r.kernelShape[w?2:3]-1)*(r.dilations[1]-1)});\n        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,\n                                         i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);\n        const strides : vec2<i32> = vec2<i32>(${r.strides[0]}, ${r.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${r.dilations[0]}, ${r.dilations[1]});\n        const dimAOuter : i32 = ${d};\n        const dimBOuter : i32 = ${l};\n        const dimInner : i32 = ${m};\n        ${Z}\n        ${mm(w,h,void 0,!1,L)}\n        ${R?an(K,U,"f32",void 0,!w,X):sn(K,U,"f32",void 0,!w,X,!1,void 0,u)}`}}});var hm,Bi,Su=oe(()=>{"use strict";Tt();Ae();Pe();hm=(t,r,e,d,l,m,h=!1,u)=>{let w=e.format==="NHWC",_=w?1:2,O=w?2:3,j=w?3:1,B=Y.size(d),P=h?2:1,R=e.group,T=r[1].dims,k=T[0]/R,U=T[1],K=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${h?`vec4<${u}>`:u}) {\n    result[flatIndex] = ${h?`vec4<${u}>`:u}(value);\n  }`;l&&(K+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${h?`vec4<${u}>`:u} {\n      return bias[coords.${w?"w":"y"}${h?"/ 4":""}];\n    }`);let Q=h?4:1,L=ne("W",r[1].dataType,r[1].dims,Q),X=ne("Dy",r[0].dataType,r[0].dims,Q),A=[X,L];l&&A.push(ne("bias",r[2].dataType,[d[j]],Q));let Z=fe("result",r[0].dataType,d,Q),re=`{\n        let batch: u32 = ${m?"global_id.z":"workgroup_id.z"} / outShape[1];\n        let r = ${m?"global_id.z":"workgroup_id.z"} % outShape[1];\n        let c = ${m?"global_id.y":"workgroup_id.y"} * ${P};\n        let d1: u32 = ${m?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${u}>, ${P}>;\n        for (var i = 0; i < ${P}; i++) {\n          dotProd[i] = vec4<${u}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {\n          var dyR = (${u}(dyCorner.x) + ${u}(wR)) / ${u}(strides.x);\n          let wRPerm = filterDims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${u}(outBackprop[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {\n            let dyC = (${u}(dyCorner.y) + ${u}(wC)) / ${u}(strides.y);\n            let dyC2 = (${u}(dyCorner.y) + 1.0 + ${u}(wC)) / ${u}(strides.y);\n            let wCPerm = filterDims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${u}(outBackprop[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${u}(outBackprop[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${X.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${u}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${X.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${u}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = outBackprop[${j}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${X.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${u}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${X.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${u}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${P}; i = i + 1) {\n          let value = dotProd[i] + ${l?"bias[c+i]":"0.0"};\n          ${Z.set("batch","r","c + i","d1","value")};\n        }\n      }`,ie=`\n          let outputIndices = ${Z.offsetToIndices("global_idx")};\n          let batch = ${Z.indicesGet("outputIndices",0)};\n          let d1 = ${Z.indicesGet("outputIndices",j)};\n          let r = ${Z.indicesGet("outputIndices",_)};\n          let c = ${Z.indicesGet("outputIndices",O)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / ${U};\n          let wOutChannel = d1 - groupId * ${U};\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = 0.0;\n          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {\n            if (wR % dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${u}(dyRCorner) + ${u}(wR)) / ${u}(strides[0]);\n            let wRPerm = filterDims.x - 1 - wR / dilations.x;\n            if (dyR < 0.0 || dyR >= ${u}(outBackprop[${_}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {\n              if (wC % dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${u}(dyCCorner) + ${u}(wC)) / ${u}(strides.y);\n              let wCPerm = filterDims.y - 1 - wC / dilations.y;\n              if (dyC < 0.0 || dyC >= ${u}(outBackprop[${O}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * ${k};\n              for (var d2: u32 = 0; d2 < ${k}; d2 = d2 + 1) {\n                let xValue = ${w?X.get("batch","idyR","idyC","inputChannel"):X.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${L.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${l?"bias[d1]":"0.0"};\n          ${Z.setByOffset("global_idx","value")};\n        `;return`\n  ${t.declareVariables(...A,Z)}\n  ${K}\n  const outShape : vec4<u32> = vec4<u32>(${d.join(",")});\n  const outBackprop : vec4<u32> = vec4<u32>(${r[0].dims.join(",")});\n  const strides : vec2<u32> = vec2<u32>(${e.strides[0]}, ${e.strides[1]});\n  const filterDims : vec2<u32> = vec2<u32>(${e.kernelShape[w?1:2]}, ${e.kernelShape[w?2:3]});\n  const dilations : vec2<u32> = vec2<u32>(${e.dilations[0]}, ${e.dilations[1]});\n  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(\n          ${e.dilations[0]<=1?0:(e.kernelShape[w?1:2]-1)*(e.dilations[0]-1)},\n          ${e.dilations[1]<=1?0:(e.kernelShape[w?2:3]-1)*(e.dilations[1]-1)});\n  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${e.pads[0]+e.pads[2]})/2,\n                                     i32(effectiveFilterDims[1]) - 1 - (${e.pads[1]+e.pads[3]})/2);\n    ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes(B)};\n  ${h?re:ie}}`},Bi=(t,r,e)=>{let d=t.length>2,l=r.outputShape,m=Y.size(l),h=[Math.ceil(m/64),1,1];ze("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${h}`);let u=Fe(t[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:r.cacheKey},getRunData:()=>({dispatchGroup:{x:h[0],y:h[1],z:h[2]},outputs:[{dims:e?e(l):l,dataType:t[0].dataType}]}),getShaderSource:w=>hm(w,t,r,l,d,h[1]===1&&h[2]===1,!1,u)}}});var gm,ym,bm,_u,Au,vm,wm,Cm,$m,Iu,Tu=oe(()=>{"use strict";Ne();xu();Su();on();ei();gm=(t,r,e,d,l,m)=>(t-1)*r+e+(d-1)*l+1-m,ym=(t,r,e,d,l)=>{let m=Math.floor(t/2);r==="SAME_UPPER"?(e[d]=m,e[l]=t-m):r==="SAME_LOWER"&&(e[d]=t-m,e[l]=m)},bm=(t,r,e,d,l,m,h,u,w,_)=>{let O=t.length-2,j=_.length===0;if(w.length===0)for(let R=0;R<O;++R)w.push(0);let B=t[0],P=r[u?3:1]*l;for(let R=0,T=t.length-O-(u?1:0);R<O;++R,++T){let k=t[T],U=j?k*h[R]:_[R],K=gm(k,h[R],m[R],r[T],e[R],U);ym(K,d,m,R,R+O),j&&_.push(h[R]*(k-1)+w[R]+(r[T]-1)*e[R]+1-m[R]-m[R+O])}_.splice(0,0,B),_.splice(u?3:1,0,P)},_u=(t,r)=>{let e=t.kernelShape.slice();if(t.kernelShape.length===0||t.kernelShape.reduce((B,P)=>B*P,1)===0){e.length=0;for(let B=2;B<r[1].dims.length;++B)e.push(r[1].dims[B])}let d=t.format==="NHWC";e.splice(0,0,r[1].dims[0]),e.splice(d?3:1,0,r[1].dims[1]);let l=t.pads.slice(),m=t.outputShape.slice(),h=t.outputPadding.slice(),u=r[0].dims,w=t.dilations.slice();if(w.reduce((B,P)=>B+P,0)===0){let B=r[0].dims.length-2;w=new Array(B).fill(1)}let _=t.strides.slice();if(_.reduce((B,P)=>B+P,0)===0){let B=r[0].dims.length-2;_=new Array(B).fill(1)}bm(u,e,w,t.autoPad,t.group,l,_,d,h,m);let O=Object.assign({},t),j=t.cacheKey+[e.join("n,"),l.join(","),_.join(","),h.join(","),m.join(","),w.join(",")].join("_");return Object.assign(O,{kernelShape:e,pads:l,outputPadding:h,outputShape:m,dilations:w,strides:_,cacheKey:j}),O},Au=t=>{let r=Jn(t),e=t.format,d=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof t.autoPad>"u"?0:t.autoPad],l=t.dilations,m=t.group,h=t.kernelShape,u=t.pads,w=t.strides,_=t.wIsConst(),O=t.outputPadding,j=t.outputShape;return ye({autoPad:d,format:e,dilations:l,group:m,kernelShape:h,outputPadding:O,outputShape:j,pads:u,strides:w,wIsConst:_,...r})},vm=(t,r)=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(t[0].dims.length!==4&&t[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(t[0].dims.length!==t[1].dims.length)throw new Error("filter does not have same dimension as input");let e=t[0].dims[r.format==="NHWC"?t[0].dims.length-1:1],d=t[1].dims[0];if(e!==d)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let l=t[1].dims[1]*r.group;if(t.length===3&&(t[2].dims.length!==1||t[2].dims[0]!==l))throw new Error("invalid bias");let m=t[0].dims.length-2;if(r.dilations.reduce((O,j)=>O+j,0)>0&&r.dilations.length!==m)throw new Error(`dilations should be ${m}D`);if(r.strides.reduce((O,j)=>O+j,0)>0&&r.strides.length!==m)throw new Error(`strides should be ${m}D`);if(r.pads.reduce((O,j)=>O+j,0)>0&&r.pads.length!==m*2)throw new Error(`pads should be ${m*2}D`);if(r.outputPadding.length!==m&&r.outputPadding.length!==0)throw new Error(`output_padding should be ${m}D`);if(r.kernelShape.reduce((O,j)=>O+j,0)>0&&r.kernelShape.length!==0&&r.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape");if(r.outputShape.length!==0&&r.outputShape.length!==t[0].dims.length-2)throw new Error("invalid output shape")},wm=[2,3,1,0],Cm=(t,r,e)=>{let d=_u(e,r),l=e.format==="NHWC",m=r.length===3;if(d.group!==1){t.compute(Bi(r,d));return}let h=d.outputShape,u=h[l?1:2],w=h[l?2:3],_=h[l?3:1],O=r[1].dims[2],j=r[1].dims[3],B=r[0].dims[l?3:1],P=l?u*w:_,R=l?_:u*w,T=O*j*B,k=!0,U=t.kernelCustomData.wT??t.compute(fr(r[1].dataType,r[1].dims.length,wm),{inputs:[1],outputs:[e.wIsConst?-2:-1]})[0];e.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=U);let K=[r[0],U];m&&(!l&&r[2].dims.length===1?K.push(r[2].reshape([r[2].dims[0],1,1])):K.push(r[2])),t.compute($u(K,d,h,P,R,T,m,k),{inputs:K})},$m=(t,r)=>{let e=r.format==="NHWC",d=[t.inputs[0].reshape(e?[t.inputs[0].dims[0],1,t.inputs[0].dims[1],t.inputs[0].dims[2]]:[t.inputs[0].dims[0],t.inputs[0].dims[1],1,t.inputs[0].dims[2]]),t.inputs[1].reshape([t.inputs[1].dims[0],t.inputs[1].dims[1],1,t.inputs[1].dims[2]])];d.length===3&&d.push(t.inputs[2]);let l=r.kernelShape;(l.length===0||l[0]===0)&&(l=[t.inputs[1].dims[2]]);let m=r.dilations;(m.length===0||m[0]===0)&&(m=[1]);let h=r.strides;(h.length===0||h[0]===0)&&(h=[1]);let u=r.pads;u.length===0&&(u=[0,0]),u=[0,u[0],0,u[1]],h=[1].concat(h),m=[1].concat(m),l=[1].concat(l);let w=_u({...r,pads:u,strides:h,dilations:m,kernelShape:l},d);t.compute(Bi(d,w,_=>e?[_[0],_[2],_[3]]:[_[0],_[1],_[3]]))},Iu=(t,r)=>{vm(t.inputs,r),t.inputs[0].dims.length===3?$m(t,r):Cm(t,t.inputs,r)}});var Mi,ti,Ou,xm,Sm,ji,Di,_m,Eu,Pu,Ru=oe(()=>{"use strict";Ae();Ne();Pe();Mi="[a-zA-Z]|\\\\.\\\\.\\\\.",ti="("+Mi+")+",Ou="^"+ti+"$",xm="("+ti+",)*"+ti,Sm="^"+xm+"$",ji=class{constructor(r=-1){this.symbolToIndices=new Map,this.inputIndex=r}addSymbol(r,e){let d=this.symbolToIndices.get(r);d===void 0?d=[e]:d.push(e),this.symbolToIndices.set(r,d)}},Di=class{constructor(r,e){this.equation=e;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[d,l]=e.includes("->")?e.split("->",2):[e,""];if(!d.match(RegExp(Sm)))throw new Error("Invalid LHS term");if(d.split(",").forEach((u,w)=>{let _=r[w].dims.slice();if(!u.match(RegExp(Ou)))throw new Error("Invalid LHS term");let O=this.processTerm(u,!0,_,w);this.lhs.push(O)}),l==="")l+=[...this.symbolToInfo.entries()].filter(([u,w])=>w.count===1||u==="...").map(([u])=>u).join("");else if(!l.match(RegExp(ti)))throw new Error("Invalid RHS");l.match(RegExp(Mi,"g"))?.forEach(u=>{if(u==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let w=this.symbolToInfo.get(u);if(w===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(w.dimValue)}}),this.rhs=this.processTerm(l,!0,this.outputDims)}addSymbol(r,e,d){let l=this.symbolToInfo.get(r);if(l!==void 0){if(l.dimValue!==e&&l.count!==1)throw new Error("Dimension mismatch");l.count++,l.inputIndices.push(d)}else l={count:1,dimValue:e,inputIndices:[d]};this.symbolToInfo.set(r,l)}processTerm(r,e,d,l=-1){let m=d.length,h=!1,u=[],w=0;if(!r.match(RegExp(Ou))&&!e&&r!=="")throw new Error("Invalid LHS term");let _=r.match(RegExp(Mi,"g")),O=new ji(l);return _?.forEach((j,B)=>{if(j==="..."){if(h)throw new Error("Only one ellipsis is allowed per input term");h=!0;let P=m-_.length+1;if(P<0)throw new Error("Ellipsis out of bounds");if(u=d.slice(w,w+P),this.hasEllipsis){if(this.ellipsisDims.length!==u.length||this.ellipsisDims.toString()!==u.toString())throw new Error("Ellipsis dimensions mismatch")}else if(e)this.hasEllipsis=!0,this.ellipsisDims=u;else throw new Error("Ellipsis must be specified in the LHS");for(let R=0;R<u.length;R++){let T=String.fromCharCode("0".charCodeAt(0)+B);O.addSymbol(T,B+R),this.addSymbol(T,d[w++],l)}}else O.addSymbol(j,B),this.addSymbol(j,d[w++],l)}),O}},_m=(t,r)=>{let e=t[0].dataType,d=new Array(t.length);for(let Q=0;Q<t.length;++Q)d[Q]=ne(`input${Q}`,e,t[Q].dims);let l=r.outputDims,m=Y.size(l),h=fe("output",e,l),u=[],w=Array.from(r.rhs.symbolToIndices.keys()),_="var prod = 1.0;",O="var sum = 0.0;",j="sum += prod;",B=[],P=[],R=[],T=[],k=r.symbolToInfo.size===w.length;r.symbolToInfo.forEach((Q,L)=>{if(w.includes(L)){let X=w.indexOf(L);r.lhs.forEach((A,Z)=>{if(Q.inputIndices.includes(Z)){let re=A.symbolToIndices.get(L);if(re===void 0)throw new Error("Invalid symbol error");re.forEach(ie=>{u.push(`${d[Z].indicesSet(`input${Z}Indices`,ie,h.indicesGet("outputIndices",X))}`)})}})}else r.lhs.forEach((X,A)=>{let Z=r.symbolToInfo.get(L);if(Z===void 0)throw new Error("Invalid symbol error");if(Z.inputIndices.includes(A)){let re=X.symbolToIndices.get(L);if(re===void 0)throw new Error("Invalid symbol error");re.forEach(ie=>{B.push(`${d[A].indicesSet(`input${A}Indices`,ie,`${L}`)}`)}),T.push(`prod *= ${d[A].getByIndices(`input${A}Indices`)};`)}}),P.push(`for(var ${L}: u32 = 0; ${L} < ${r.symbolToInfo.get(L)?.dimValue}; ${L}++) {`),R.push("}")});let U=k?[...u,`let sum = ${d.map((Q,L)=>Q.getByIndices(`input${L}Indices`)).join(" * ")};`]:[...u,O,...P,...B,_,...T,j,...R],K=Q=>`\n      ${Q.declareVariables(...d,h)}\n\n      ${Q.mainStart()}\n        ${Q.guardAgainstOutOfBoundsWorkgroupSizes(m)}\n        var outputIndices = ${h.offsetToIndices("global_idx")};\n        ${d.map((L,X)=>`var input${X}Indices: ${d[X].type.indices};`).join(`\n`)}\n        ${U.join(`\n`)};\n        ${h.setByOffset("global_idx","sum")};\n      }`;return{name:"Einsum",shaderCache:{hint:r.equation},getRunData:()=>({outputs:[{dims:l,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)}}),getShaderSource:K}},Eu=(t,r)=>{let e=new Di(t.inputs,r.equation);t.compute(_m(t.inputs,e))},Pu=t=>{let r=t.equation.replace(/\\s+/g,"");return ye({equation:r})}});var Am,ku,Im,Tm,Bu,Mu=oe(()=>{"use strict";Ae();Pe();Am=t=>{if(!t||t.length!==2)throw new Error("Expand requires 2 input.");let r=t[0].dims,e=Array.from(t[1].getBigInt64Array(),Number),d=e.length<r.length?0:e.length-r.length,l=r.length<e.length?0:r.length-e.length;for(;d<e.length&&l<r.length;++d,++l)if(e[d]!==r[l]&&e[d]!==1&&r[l]!==1)throw new Error("Expand requires shape to be broadcastable to input")},ku=(t,r)=>{let e=t.length-r.length,d=[];for(let l=0;l<e;++l)d.push(t[l]);for(let l=0;l<r.length;++l)d.push(r[l]===1?t[l+e]:r[l]);return d},Im=(t,r)=>t.length>r.length?ku(t,r):ku(r,t),Tm=t=>{let r=t[0].dims,e=Array.from(t[1].getBigInt64Array(),Number),d=Im(r,e),l=Y.size(d),m=t[0].dataType,h=ne("input",m,r),u=fe("output",m,d),w=_=>`\n  const inputShape = ${h.indices(...r)};\n  ${_.declareVariables(h,u)}\n  ${_.mainStart()}\n  ${_.guardAgainstOutOfBoundsWorkgroupSizes(l)}\n    let outputIndices = ${u.offsetToIndices("global_idx")};\n    var inputIndices: ${h.type.indices};\n    for (var i = 0; i < ${r.length}; i++) {\n      if (${h.indicesGet("inputShape","i")} == 1) {\n        ${h.indicesSet("inputIndices","i",0)}\n      } else {\n        ${h.indicesSet("inputIndices","i",u.indicesGet("outputIndices",`i + ${d.length-r.length}`))}\n      }\n    }\n    ${u.setByOffset("global_idx",h.getByIndices("inputIndices"))}\n  }`;return{name:"Expand",shaderCache:{hint:`${d}`},getShaderSource:w,getRunData:()=>({outputs:[{dims:d,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)}})}},Bu=t=>{Am(t.inputs),t.compute(Tm(t.inputs),{inputs:[0]})}});var Om,Em,ju,Du,Wu=oe(()=>{"use strict";Ae();Ne();Pe();Om=t=>{if(!t||t.length!==2)throw new Error("Gather requires 2 inputs.")},Em=(t,r)=>{let e=t[0].dims,d=t[1].dims,l=e.length,m=Y.normalizeAxis(r.axis,l),h=e.slice(0);h.splice(m,1,...d);let u=e[m],w=Y.size(h),_=ne("data",t[0].dataType,t[0].dims),O=ne("inputIndices",t[1].dataType,t[1].dims),j=fe("output",t[0].dataType,h),B=()=>{let R=d.length,T=`var indicesIndices  = ${O.type.indices}(0);`;for(let k=0;k<R;k++)T+=`${R>1?`indicesIndices[${k}]`:"indicesIndices"} = ${h.length>1?`outputIndices[${m+k}]`:"outputIndices"};`;T+=`\n        var idx = ${O.getByIndices("indicesIndices")};\n        if (idx < 0) {\n          idx = idx + ${u};\n        }\n        var dataIndices = ${_.type.indices}(0);\n      `;for(let k=0,U=0;k<l;k++)k===m?(T+=`${l>1?`dataIndices[${k}]`:"dataIndices"} = u32(idx);`,U+=R):(T+=`${l>1?`dataIndices[${k}]`:"dataIndices"} = ${h.length>1?`outputIndices[${U}]`:"outputIndices"};`,U++);return T},P=R=>`\n      ${R.declareVariables(_,O,j)}\n      ${R.mainStart()}\n        ${R.guardAgainstOutOfBoundsWorkgroupSizes(w)}\n        let outputIndices = ${j.offsetToIndices("global_idx")};\n        ${B()};\n        let value = ${_.getByIndices("dataIndices")};\n        ${j.setByOffset("global_idx","value")};\n      }`;return{name:"Gather",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:h,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)}}),getShaderSource:P}},ju=t=>ye({axis:t.axis}),Du=(t,r)=>{let e=t.inputs;Om(e),t.compute(Em(t.inputs,r))}});var Pm,Rm,zu,Gu,Vu=oe(()=>{"use strict";Ae();Ne();Pe();Pm=t=>{if(!t||t.length!==2)throw new Error("GatherElements requires 2 inputs.");if(t[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(t[0].dims.length!==t[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},Rm=(t,r)=>{let e=t[0].dims,d=t[0].dataType,l=e.length,m=Y.computeStrides(e),h=Y.size(e),u=t[1].dims,w=t[1].dataType,_=Y.size(u),O=Y.normalizeAxis(r.axis,l),j=e[O],B=u.slice(0),P=Y.size(B),R=ne("input",d,e),T=ne("indices",w,[_]),k=fe("output",d,B),U=K=>`\n      const inputStrides = array<u32, ${m.length}>(${m.map(Q=>`${Q}u`).join(",")});\n      ${K.declareVariables(R,T,k)}\n      ${K.mainStart()}\n      ${K.guardAgainstOutOfBoundsWorkgroupSizes(P)}\n\n      let outputIndices = ${k.offsetToIndices("global_idx")};\n\n      var idx = ${T.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + ${j};\n      }\n\n      var srcOffset = u32(0);\n\n      for (var i = 0; i < ${e.length}; i++) {\n        if (i == ${O}) {\n          srcOffset +=  u32(idx) * inputStrides[i];\n        } else {\n          srcOffset += ${k.indicesGet("outputIndices","i")} * inputStrides[i];\n        }\n      }\n\n      // Should never hit this with valid values in indices\n      // This is a guard against malicious data in the indices input\n      if (srcOffset < 0 || srcOffset >= ${h}) {\n        return;\n      }\n\n      output[global_idx] = input[srcOffset];\n  }`;return{name:"GatherElements",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:B,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(P/64)}}),getShaderSource:U}},zu=t=>ye({axis:t.axis}),Gu=(t,r)=>{let e=t.inputs;Pm(e),t.compute(Rm(t.inputs,r))}});var km,Bm,Mm,Uu,Nu,Fu=oe(()=>{"use strict";Ae();Ne();Pe();km=t=>{if(!t)throw new Error("Input is missing");if(t.length<2||t.length>3)throw new Error("Invaid input number.");if(t.length===3&&t[2].dims.length>2)throw new Error("Invalid input shape of C");if(t[0].dataType!==t[1].dataType||t.length===3&&t[0].dataType!==t[2].dataType)throw new Error("Input types are mismatched")},Bm=(t,r,e)=>{if(e.length===0)return"0u";let d=e.length===1&&t!==1||e.length===2&&e[0]!==t,l=e[e.length-1]!==r,m="0u";return d||(m+=`+ m * ${e[e.length-1]}u`),l||(m+="+n"),m},Mm=(t,r)=>{let e=t[0].dims.slice(),d=t[1].dims.slice(),[l,m,h]=Vn.getShapeOfGemmResult(e,r.transA,d,r.transB,t.length===3?t[2].dims:void 0),u=[l,m];if(!u)throw new Error("Can\'t use gemm on the given tensors");let w=Y.size(u),_="";r.transA&&r.transB?_="value += a[k * M + m] * b[n * K + k];":r.transA&&!r.transB?_="value += a[k * M + m] * b[k * N + n];":!r.transA&&r.transB?_="value += a[m * K + k] * b[n * K + k];":!r.transA&&!r.transB&&(_="value += a[m * K + k] * b[k * N + n];");let O=Fe(t[0].dataType),j=r.alpha===1?"":"value *= alpha;",B=t.length===3?`value += beta * c[${Bm(l,m,t[2].dims)}];`:"",P=[`@group(0) @binding(0) var<storage, read> a : array<${O}>;`,`@group(0) @binding(1) var<storage, read> b : array<${O}>;`];t.length===3&&P.push(`@group(0) @binding(2) var<storage, read> c : array<${O}>;`);let R=T=>`\n  const M: u32 = ${l}u;\n  const N: u32 = ${m}u;\n  const K: u32 = ${h}u;\n  const alpha = ${O}(${r.alpha});\n  const beta = ${O}(${r.beta});\n\n  ${P.join(`\n`)}\n  @group(0) @binding(${t.length}) var<storage, read_write> output : array<${O}>;\n\n  ${T.mainStart()}\n    ${T.guardAgainstOutOfBoundsWorkgroupSizes(w)}\n\n    let m = global_id.x / N;\n    let n = global_id.x % N;\n\n    var value = ${O}(0);\n    for (var k: u32 = 0u; k<${h}u; k++) {\n      ${_}\n    }\n\n    ${j}\n    ${B}\n    output[global_id.x] = value;\n\n  }`;return{name:"Gemm",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:u,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)}}),getShaderSource:R}},Uu=(t,r)=>{km(t.inputs),t.compute(Mm(t.inputs,r))},Nu=t=>ye(t)});var jm,Dm,Wm,zm,Hu,Lu,Ku=oe(()=>{"use strict";Xe();Ae();Ne();Pe();jm={name:"InstanceNormalization"},Dm=(t,r)=>{let e=t[0].dims,d=e,l=2,m=Y.sizeToDimension(e,l),h=Y.sizeFromDimension(e,l),u=e[1],w=ne("x",t[0].dataType,[e[0],e[1],h]),_=ne("scale",t[1].dataType,t[1].dims),O=ne("bias",t[2].dataType,t[2].dims),j=fe("output",t[0].dataType,[e[0],e[1],h]),B=[w,_,O,j],P=w.type.value,R=64,T=k=>`\n\n  const C: u32 = ${u};\n  const normSize: u32 = ${h};\n  const epsilon: f32 = ${r.epsilon};\n  var<workgroup> meanShared : ${P};\n  var<workgroup> squaredNormShared : ${P};\n  var<workgroup> workgroupShared : array<${P}, ${R}>;\n  const workgroupSize = ${R}u;\n  ${k.declareVariables(...B)}\n  ${k.mainStart(R)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / C;\n    let channel = norm % C;\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial: ${P} = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      initial = initial + ${w.get("batch","channel","h")};\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = workgroupShared[0] / ${P}(normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let deviation =  ${w.get("batch","channel","h")} - meanShared;\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = workgroupShared[0];\n    }\n    workgroupBarrier();\n\n    let invStdDev = 1 / sqrt(squaredNormShared / ${P}(normSize) + epsilon);\n    let channelScale = invStdDev * ${_.getByOffset("channel")};\n    let channelShift = ${O.getByOffset("channel")} - meanShared * channelScale;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let value = ${w.get("batch","channel","h")} * channelScale + channelShift;\n      ${j.set("batch","channel","h","value")};\n    }\n  }`;return{...jm,shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:d,dataType:t[0].dataType}],dispatchGroup:{x:m}}),getShaderSource:T}},Wm=(t,r,e,d,l,m,h,u)=>{let w=Ft(h),_=ne("input",r.dataType,r.dims,w),O=ne("scale",e.dataType,e.dims,w),j=ne("bias",d.dataType,d.dims,w),B=64,P=w===1?"vec2f":`mat2x${w}f`,R=w===1?"f32":`vec${w}f`,T=(X,A)=>`${P}(${X}, ${A})`,k=l*h/w,U=Math.ceil(m/B),K=X=>`\n  const H: u32 = ${m};\n  const C: u32 = ${h/w};\n  const imageSize: u32 = ${m*h/w};\n\n  ${X.declareVariables(_)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${P}>;\n\n  ${X.mainStart(B)}\n    let currentImageNumber = global_idx / ${B} / C;\n    let currentChannelNumber = (global_idx / ${B}) % C;\n    let wgId = global_idx % ${B};\n    let wgOffset = wgId * ${U};\n    if (wgOffset >= H) {\n        return;\n    }\n    let wgMax = min(wgOffset + ${U}, H);\n\n    let offset = currentImageNumber * imageSize + currentChannelNumber;\n    var sum = ${mt("f32",w)};\n    var squaredSum = ${mt("f32",w)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${R}(input[offset + i * C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${T("sum","squaredSum")};\n  }`,Q=t.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:w,n:l,h:m,c:h})},getRunData:()=>({outputs:[{dims:[l,h,B,2],dataType:1}],dispatchGroup:{x:l*h/w}}),getShaderSource:K},{inputs:[r],outputs:[-1]})[0],L=X=>`\n  const H: u32 = ${m};\n  const C: u32 = ${h/w};\n  const imageSize: u32 = ${B*h/w};\n  const epsilon: f32 = ${u};\n\n  @group(0) @binding(0) var<storage, read> input : array<${P}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${O.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${j.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${P}>;\n\n  ${X.mainStart()}\n    ${X.guardAgainstOutOfBoundsWorkgroupSizes(k)}\n    let currentImageNumber = global_idx / C;\n    let currentChannelNumber = global_idx % C;\n\n    let offset = currentImageNumber * imageSize;\n    var sum = ${mt("f32",w)};\n    var squaredSum = ${mt("f32",w)};\n    for (var i: u32 = 0; i < ${B}; i++) {\n        let value = input[offset + i + currentChannelNumber * ${B}];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(H);\n    squaredSum = squaredSum / f32(H);\n    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);\n    let channelScale = invStdDev * ${R}(scale[currentChannelNumber]);\n    let channelShift = ${R}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${T("channelScale","channelShift")};\n  }`;return t.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:w,n:l,h:m,c:h,epsilon:u})},getRunData:()=>({outputs:[{dims:[l,h,2],dataType:1}],dispatchGroup:{x:Math.ceil(k/64)}}),getShaderSource:L},{inputs:[Q,e,d],outputs:[-1]})[0]},zm=(t,r,e)=>{let d=r[0].dims,l=d,m=d[0],h=d[d.length-1],u=Y.sizeFromDimension(d,1)/h,w=Ft(h),_=Y.size(l)/w,O=ne("input",r[0].dataType,r[0].dims,w),j=fe("output",r[0].dataType,l,w),B=Fe(r[0].dataType),P=w===1?"vec2f":`mat2x${w}f`,R=w===1?B:`vec${w}<${B}>`,T=Wm(t,r[0],r[1],r[2],m,u,h,e.epsilon),k=U=>`\n  const H: u32 = ${u};\n  const C: u32 = ${h/w};\n\n  @group(0) @binding(0) var<storage, read> input : array<${O.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${P}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${j.type.storage}>;\n\n  ${U.mainStart()}\n    let currentImageNumber = global_idx / (C * H);\n    let currentChannelNumber = global_idx % C;\n\n    let scaleOffset = currentImageNumber * C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${R}(scale[0]), ${R}(scale[1]));\n  }`;t.compute({name:"InstanceNormalization",shaderCache:{hint:`${e.cacheKey}`},getRunData:()=>({outputs:[{dims:l,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(_/64)}}),getShaderSource:k},{inputs:[r[0],T]})},Hu=t=>ye({epsilon:t.epsilon,format:t.format}),Lu=(t,r)=>{r.format==="NHWC"?zm(t,t.inputs,r):t.compute(Dm(t.inputs,r))}});var Gm,Vm,qu,Yu,Xu=oe(()=>{"use strict";Xe();Ae();Ne();Pe();Gm=t=>{if(!t||t.length<2)throw new Error("layerNorm requires at least 2 inputs.")},Vm=(t,r,e)=>{let d=t[0].dims,l=t[1],m=t[2],h=d,u=Y.normalizeAxis(r.axis,d.length),w=Y.sizeToDimension(d,u),_=Y.sizeFromDimension(d,u),O=Y.size(l.dims),j=m?Y.size(m.dims):0;if(O!==_||m&&j!==_)throw new Error(`Size of X.shape()[axis:] == ${_}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${O} and bias size of ${j}`);let B=[];for(let L=0;L<d.length;++L)L<u?B.push(d[L]):B.push(1);let P=Ft(_),R=Fe(t[0].dataType),T=[ne("x",t[0].dataType,t[0].dims,P),ne("scale",l.dataType,l.dims,P)];m&&T.push(ne("bias",m.dataType,m.dims,P)),T.push(fe("output",t[0].dataType,h,P));let k=e>1,U=e>2;k&&T.push(fe("meanDataOutput",1,B)),U&&T.push(fe("invStdOutput",1,B));let K=L=>`\n  const normSize: f32 = ${_};\n  const normSizeVectorized: u32 = ${_/P};\n  const epsilon: f32 = ${r.epsilon};\n\n  ${L.declareVariables(...T)}\n  ${L.mainStart()}\n    ${L.guardAgainstOutOfBoundsWorkgroupSizes(w)}\n    let offset = global_idx * normSizeVectorized;\n    var meanVector = ${mt("f32",P)};\n    var meanSquareVector = ${mt("f32",P)};\n\n    for (var h: u32 = 0u; h < normSizeVectorized; h++) {\n      let value = ${Ht(R,P,"x[h + offset]")};\n      meanVector += value;\n      meanSquareVector += value * value;\n    }\n    let mean = ${dr("meanVector",P)} / normSize;\n    let meanSquare = sqrt(${dr("meanSquareVector",P)} \n      / normSize - mean * mean + epsilon);\n\n    for (var j: u32 = 0; j < normSizeVectorized; j++) {\n      let f32input = ${Ht(R,P,"x[j + offset]")};\n      let f32scale = ${Ht(R,P,"scale[j]")};\n      output[j + offset] = ${T[0].type.value}((f32input - mean) / meanSquare * f32scale\n        ${m?`+ ${Ht(R,P,"bias[j]")}`:""}\n      );\n    }\n\n    ${k?"meanDataOutput[global_idx] = mean":""};\n    ${U?"invStdOutput[global_idx] = 1 / meanSquare":""};\n  }`,Q=[{dims:h,dataType:t[0].dataType}];return k&&Q.push({dims:B,dataType:1}),U&&Q.push({dims:B,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${r.cacheKey}|${e}|${t.length}`},getRunData:()=>({outputs:Q,dispatchGroup:{x:Math.ceil(w/64)}}),getShaderSource:K}},qu=t=>ye({axis:t.axis,epsilon:t.epsilon}),Yu=(t,r)=>{Gm(t.inputs),t.compute(Vm(t.inputs,r,t.outputCount))}});var Um,Qu,Ju=oe(()=>{"use strict";Ae();un();Um=t=>{if(!t||t.length!==2)throw new Error("MatMul requires 2 inputs.");if(t[0].dims[t[0].dims.length-1]!==t[1].dims[t[1].dims.length-2])throw new Error("shared dimension does not match.")},Qu=t=>{Um(t.inputs);let r=Ct.calcShape(t.inputs[0].dims,t.inputs[1].dims,!0);if(!r)throw new Error("Can\'t use matmul on the given tensors");t.compute(Zn(t.inputs,{activation:"",activationCacheKey:""},r))}});var Nm,Fm,Hm,Lm,Km,qm,Ym,Xm,Qm,Zu,el,tl=oe(()=>{"use strict";Xe();Ae();Ne();Pe();Nm=t=>{if(!t||t.length<1)throw new Error("Too few inputs");if(t[0].dataType!==1)throw new Error("Input type must be float.");if(t.length>=2){let r=t[0].dims.length*2===t[1].dims[0];if(t.length===4&&(r=t[3].dims[0]*2===t[1].dims[0]),!r)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},Fm=(t,r,e,d,l,m,h)=>{let u=e.length,w="";for(let _=u-1;_>=0;--_)w+=`\n            k = i32(${t.indicesGet("indices",_)}) - ${l[_]};\n            if (k < 0) {\n              break;\n            }\n            if (k >= ${e[_]}) {\n              break;\n            }\n            offset += k * ${d[_]};\n        `;return`\n          value = ${m}(${h});\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${w}\n            value = x[offset];\n          }\n      `},Hm=(t,r,e,d,l)=>{let m=e.length,h="";for(let u=m-1;u>=0;--u)h+=`\n                k = i32(${t.indicesGet("indices",u)}) - ${l[u]};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = ${2*(e[u]-1)};\n                  k = k % _2n_1;\n                  if(k >= ${e[u]}) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * ${d[u]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${h}\n              value = x[offset];\n          `},Lm=(t,r,e,d,l)=>{let m=e.length,h="";for(let u=m-1;u>=0;--u)h+=`\n                k = i32(${t.indicesGet("indices",u)}) - ${l[u]};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= ${e[u]}) {\n                  k = ${e[u]-1};\n                }\n                offset += k * ${d[u]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${h}\n              value = x[offset];\n          `},Km=(t,r,e,d,l)=>{let m=e.length,h="";for(let u=m-1;u>=0;--u)h+=`\n                k = i32(${t.indicesGet("indices",u)}) - ${l[u]};\n                if (k < 0)  {\n                  k += ${e[u]};\n                }\n                if (k >= ${e[u]}) {\n                  k -= ${e[u]};\n                }\n                offset += k * ${d[u]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${h}\n              value = x[offset];\n          `},qm=(t,r,e,d,l,m)=>{switch(l.mode){case 0:return Fm(t,r,e,d,l.pads,m,l.value);case 1:return Hm(t,r,e,d,l.pads);case 2:return Lm(t,r,e,d,l.pads);case 3:return Km(t,r,e,d,l.pads);default:throw new Error("Invalid mode")}},Ym=(t,r,e,d)=>{let l=r[0].dims,m=Y.padShape(l.slice(),e.pads),h=Y.size(m),u=Y.computeStrides(l),w=fe("output",r[0].dataType,m),_=ne("x",r[0].dataType,l),O=qm(w,m,l,u,e,d);return`\n              ${t.declareVariables(_,w)}\n              ${t.mainStart()}\n              ${t.guardAgainstOutOfBoundsWorkgroupSizes(h)}\n\n              let indices = ${w.offsetToIndices("global_idx")};\n\n              var value = ${d}(0);\n              ${O}\n              output[global_idx] = value;\n          }`},Xm=(t,r)=>{let e=Y.padShape(t[0].dims.slice(),r.pads);return{name:"Pad",shaderCache:{hint:r.cacheKey},getRunData:()=>({outputs:[{dims:e,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(Y.size(e)/64)}}),getShaderSource:d=>Ym(d,t,r,"f32")}},Qm=(t,r)=>{if(t.length>1){let e=t[1].getBigInt64Array(),d=t.length>=3&&t[2].data?t[2].getFloat32Array()[0]:0,l=t[0].dims.length,m=new Int32Array(2*l).fill(0);if(t.length>=4){let u=t[3].getBigInt64Array();for(let w=0;w<u.length;w++)m[Number(u[w])]=Number(e[w]),m[Number(u[w])+l]=Number(e[w+u.length])}else e.forEach((u,w)=>m[Number(w)]=Number(u));let h=[];return m.forEach(u=>h.push(u)),ye({mode:r.mode,value:d,pads:h})}else return r},Zu=(t,r)=>{Nm(t.inputs);let e=Qm(t.inputs,r);t.compute(Xm(t.inputs,e),{inputs:[0]})},el=t=>{let r=t.mode,e=t.value,d=t.pads;return ye({mode:r,value:e,pads:d})}});var ri,rl,nl,il,ol,al,sl,ul,ll,cl,dl,fl,pl,ml,hl,gl=oe(()=>{"use strict";Ae();Ne();Pe();ri=t=>{if(!t||t.length!==1)throw new Error("Pool ops requires 1 input.");if(t[0].dims.length!==4)throw new Error("Pool ops supports 2-D inputs only for now.")},rl=(t,r,e)=>{let d=r.format==="NHWC",l=d?[t.dims[0],t.dims[3],t.dims[1],t.dims[2]]:t.dims.slice(),m=Object.hasOwnProperty.call(r,"dilations"),h=r.kernelShape.slice(),u=r.strides.slice(),w=m?r.dilations.slice():[],_=r.pads.slice();Nt.adjustPoolAttributes(e,l,h,u,w,_);let O=Nt.computePoolOutputShape(e,l,u,w,h,_,r.autoPad),j=Object.assign({},r);return m?Object.assign(j,{kernelShape:h,strides:u,pads:_,dilations:w,cacheKey:r.cacheKey}):Object.assign(j,{kernelShape:h,strides:u,pads:_,cacheKey:r.cacheKey}),[j,d?[O[0],O[2],O[3],O[1]]:O]},nl=(t,r,e,d,l,m,h,u)=>{let w=l.format==="NHWC",_=e,O=r.type.value,j=_.length,B=Y.size(d),P=fe("output",r.type.tensor,d);if(l.kernelShape.length<=2){let R=l.kernelShape[l.kernelShape.length-1],T=l.strides[l.strides.length-1],k=l.pads[l.pads.length/2-1],U=l.pads[l.pads.length-1],K=j-(w?2:1),Q="",L="",X="";if(k+U!==0?Q=`\n              for (var i: u32 = 0u; i < ${R}u; i++) {\n                xIndices[${K}] = indices[${K}] * ${T} - ${k} + i;\n                if (xIndices[${K}] < 0 || xIndices[${K}] >= ${_[K]}) {\n                  pad++;\n                  continue;\n                }\n                let x_val = x[${r.indicesToOffset("xIndices")}];\n                ${m}\n              }`:Q=`\n              for (var i: u32 = 0u; i < ${R}u; i++) {\n                xIndices[${K}] = indices[${K}] * ${T} - ${k} + i;\n                let x_val = x[${r.indicesToOffset("xIndices")}];\n                ${m}\n              }`,l.kernelShape.length===2){let Z=l.kernelShape[l.kernelShape.length-2],re=l.strides[l.strides.length-2],ie=l.pads[l.pads.length/2-2],Ce=l.pads[l.pads.length-2],H=j-(w?3:2),le=_[H];ie+Ce!==0?L=`\n                for (var j: u32 = 0u; j < ${Z}u; j++) {\n                  xIndices[${H}] = indices[${H}] * ${re} - ${ie} + j;\n                  if (xIndices[${H}] < 0 || xIndices[${H}] >= ${le}) {\n                    pad+= ${R};\n                    continue;\n                  }\n              `:L=`\n                for (var j: u32 = 0u; j < ${Z}u; j++) {\n                  xIndices[${H}] = indices[${H}] * ${re} - ${ie} + j;\n                `,X=`\n              }\n            `}return`\n            ${t.declareVariables(r,P)}\n\n            ${t.mainStart()}\n              ${t.guardAgainstOutOfBoundsWorkgroupSizes(B)}\n\n              let indices = ${P.offsetToIndices("global_idx")};\n              var xIndices = ${P.offsetToIndices("global_idx")};\n\n              var value: ${O} = ${O}(${u});\n              var pad = 0;\n              ${L}\n              ${Q}\n              ${X}\n              ${h}\n\n              output[global_idx] = value;\n            }`}else{if(w)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let R=Y.size(l.kernelShape),T=Y.computeStrides(l.kernelShape),k=T.length,U=l.pads.length,K=l.pads.reduce((X,A)=>X+A),Q="";return K?Q=`\n                if (xIndices[j] >= inputDims[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${r.indicesToOffset("xIndices")}];\n                ${m}\n              }`:Q=`\n              }\n              let x_val = x[${r.indicesToOffset("xIndices")}];\n              ${m}\n            `,`\n            ${t.declareVariables(r,P)}\n\n            const pads = array<u32, ${U}>(${l.pads.map(X=>`${X}u`).join(",")});\n            const inputDims = array<u32, ${j}>(${_.map(X=>`${X}u`).join(",")});\n            const kernelStrides = array<u32, ${k}>(${T.map(X=>`${X}u`).join(",")});\n            const strides = array<u32, ${k}>(${l.strides.map(X=>`${X}u`).join(",")});\n\n            ${t.mainStart()}\n              ${t.guardAgainstOutOfBoundsWorkgroupSizes(B)}\n\n              let indices = ${P.offsetToIndices("global_idx")};\n              let xIndices = ${P.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${k}>;\n\n              var value = ${P.type.value}(${u});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < ${R}u; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${k-1}u; j++) {\n                  offsets[j] = offset / kernelStrides[j];\n                  offset -= offsets[j] * kernelStrides[j];\n                }\n                offsets[${k-1}] = offset;\n\n                isPad = false;\n                for (var j = ${j-k}u; j < ${j}u; j++) {\n                  xIndices[j] = indices[j] * strides[j - ${j-k}u]\n                    + offsets[j - ${j-k}u] - pads[j - 2u];\n                  ${Q}\n              }\n              ${h}\n\n              output[global_idx] = value;\n            }`}},il=t=>({format:t.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][t.auto_pad],ceilMode:t.ceil_mode,kernelShape:t.kernel_shape,strides:t.strides,pads:t.pads}),ol=(t,r,e,d)=>{let[l,m]=rl(r,d,e),h=Y.size(l.kernelShape),u=ne("x",r.dataType,r.dims),w=u.type.value,_="value += x_val;",O="";return l.countIncludePad?O+=`value /= ${w}(${h});`:O+=`value /= ${w}(${h} - pad);`,{name:t,shaderCache:{hint:d.cacheKey},getRunData:()=>({outputs:[{dims:m,dataType:r.dataType}],dispatchGroup:{x:Math.ceil(Y.size(m)/64)}}),getShaderSource:j=>nl(j,u,r.dims,m,l,_,O,"0.0")}},al=t=>{let r=t.count_include_pad!==0,e=il(t);if(e.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return ye({countIncludePad:r,...e})},sl=(t,r)=>{ri(t.inputs),t.compute(ol("AveragePool",t.inputs[0],!1,r))},ul={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},ll=t=>{let r=t.format;return{format:r,...ul,cacheKey:r}},cl=(t,r)=>{ri(t.inputs),t.compute(ol("GlobalAveragePool",t.inputs[0],!0,r))},dl=(t,r,e,d)=>{let[l,m]=rl(r,d,e),h=`\n      value = max(x_val, value);\n    `,u="",w=ne("x",r.dataType,r.dims);return{name:t,shaderCache:{hint:d.cacheKey},getRunData:()=>({outputs:[{dims:m,dataType:r.dataType}],dispatchGroup:{x:Math.ceil(Y.size(m)/64)}}),getShaderSource:_=>nl(_,w,r.dims,m,l,h,u,"-1e5")}},fl=(t,r)=>{ri(t.inputs),t.compute(dl("MaxPool",t.inputs[0],!1,r))},pl=t=>{let r=t.storage_order,e=t.dilations,d=il(t);if(r!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(d.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return ye({storageOrder:r,dilations:e,...d})},ml=t=>{let r=t.format;return{format:r,...ul,cacheKey:r}},hl=(t,r)=>{ri(t.inputs),t.compute(dl("GlobalMaxPool",t.inputs[0],!0,r))}});var Wi=oe(()=>{"use strict"});var yl=oe(()=>{"use strict";Wi()});var bl,vl=oe(()=>{"use strict";bl="1.17.0"});var wl,zi,Cl=oe(()=>{"use strict";vl();wl="warning",zi={wasm:{},webgl:{},webgpu:{},versions:{common:bl},set logLevel(t){if(t!==void 0){if(typeof t!="string"||["verbose","info","warning","error","fatal"].indexOf(t)===-1)throw new Error(`Unsupported logging level: ${t}`);wl=t}},get logLevel(){return wl}};Object.defineProperty(zi,"logLevel",{enumerable:!0})});var $l,xl=oe(()=>{"use strict";Cl();$l=zi});var Sl=oe(()=>{"use strict"});var _l=oe(()=>{"use strict";ni()});var Il=oe(()=>{"use strict"});var Tl=oe(()=>{"use strict";ni()});var ni=oe(()=>{"use strict";Sl();_l();Il();Tl()});var Gi=oe(()=>{"use strict";ni()});var Ol=oe(()=>{"use strict";Wi();Gi()});var El=oe(()=>{"use strict";Ol()});var Pl=oe(()=>{"use strict"});var Rl=oe(()=>{"use strict"});var kl=oe(()=>{"use strict";Rl()});var Bl=oe(()=>{"use strict";yl();xl();El();Gi();Pl();kl()});var Zm,eh,Ml,jl=oe(()=>{"use strict";Bl();Xe();Pe();Zm=(t,r,e)=>{let d=t===r,l=t<r&&e<0,m=t>r&&e>0;if(d||l||m)throw new Error("Range these inputs\' contents are invalid.")},eh=(t,r,e,d)=>{let l=Math.abs(Math.ceil((r-t)/e)),m=[l],h=l,u=fe("output",d,m),w=u.type.storage,_=O=>`\n        ${O.declareVariables(u)}\n        ${O.mainStart()}\n        ${O.guardAgainstOutOfBoundsWorkgroupSizes(h)}\n        output[global_idx] = ${w}(${t}) + ${w}(global_idx) * ${w}(${e});\n      }`;return{name:"Range",shaderCache:{hint:[t,r,e].map(O=>O.toString()).join("_")},getShaderSource:_,getRunData:()=>({outputs:[{dims:m,dataType:d}],dispatchGroup:{x:Math.ceil(h/64)}})}},Ml=t=>{let r=0,e=0,d=0;t.inputs[0].dataType===6?(r=t.inputs[0].getInt32Array()[0],e=t.inputs[1].getInt32Array()[0],d=t.inputs[2].getInt32Array()[0]):t.inputs[0].dataType===1&&(r=t.inputs[0].getFloat32Array()[0],e=t.inputs[1].getFloat32Array()[0],d=t.inputs[2].getFloat32Array()[0]),$l.webgpu.validateInputContent&&Zm(r,e,d),t.compute(eh(r,e,d,t.inputs[0].dataType),{inputs:[]})}});var th,rh,nh,ih,oh,ah,sh,uh,lh,ch,dh,fh,ph,mh,hh,Dl,Wl,zl=oe(()=>{"use strict";Ae();Ne();Pe();th=(t,r)=>{if(t.every(e=>e>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),t.length>0){if(r.mode==="linear"){if(!(t.length===2||t.length===4&&t[0]===1&&t[1]===1||t.length===4&&t[0]===1&&t[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(r.mode==="cubic"&&!(t.length===2||t.length===4&&t[0]===1&&t[1]===1||t.length===4&&t[0]===1&&t[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},rh=(t,r,e)=>{r.every(l=>l>=0&&l<e||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let d=new Array(e).fill(1);return r.forEach((l,m)=>d[l]=t[m]),d},nh=(t,r,e,d,l,m)=>{let[h,u,w]=e>10?[1,2,3]:[-1,t.length>1?1:-1,-1],_=t[0].dims.length;if(h>0&&t.length>h&&t[h].dims.length>0)t[h].getFloat32Array().forEach(O=>m.push(O));else if(r.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(u>0&&t.length>u&&t[u].dims.length>0){if(t[u].getFloat32Array().forEach(O=>d.push(O)),d.length!==0&&d.length!==_&&e>=18&&d.length!==r.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");th(d,r),r.axes.length>0&&rh(d,r.axes,_).forEach((O,j)=>d[j]=O)}if(w>0&&t.length>w&&(t[w].getBigInt64Array().forEach(O=>l.push(Number(O))),l.length!==_||e>=18&&l.length===r.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(r.axes.length>0){if(d.length!==r.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(l.length!==r.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(typeof d<"u"&&typeof l<"u"&&d.length>0&&l.length>_)throw new Error("Resize requires only of scales or sizes to be specified")},ih=t=>"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(t){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`\n`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${t} is not supported`)}})()+"}",oh=(t,r)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(t){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(r<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${t} is not supported`)}})()+"}",ah=(t,r,e)=>{let d=new Array(e).fill(0).concat(new Array(e).fill(1)),l=t.length===0?d:t.slice();return r.length>0?(r.forEach((m,h)=>{d[m]=l[h],d[h+e]=l[r.length+h]}),d):l},sh=(t,r,e,d)=>{let l=[];if(e.length>0)if(d.length>0){if(t.forEach(m=>l.push(m)),Math.max(...d)>t.length)throw new Error("axes is out of bound");d.forEach((m,h)=>l[m]=e[h])}else e.forEach(m=>l.push(m));else{if(r.length===0)throw new Error("Resize requires either scales or sizes.");l=t.map((m,h)=>Math.round(m*r[h]))}return l},uh=(t,r,e,d)=>{let l=(()=>{switch(d.keepAspectRatioPolicy){case"not_larger":return d.axes.length>0?Math.min(...d.axes.map(h=>e[h]),Number.MAX_VALUE):Math.min(...e,Number.MAX_VALUE);case"not_smaller":return d.axes.length>0?Math.max(...d.axes.map(h=>e[h]),Number.MIN_VALUE):Math.max(...e,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${d.keepAspectRatioPolicy} is not supported`)}})();e.fill(1,0,e.length);let m=t.slice();return d.axes.length>0?(d.axes.forEach(h=>e[h]=l),d.axes.forEach(h=>m[h]=Math.round(t[h]*e[h]))):(e.fill(l,0,e.length),m.forEach((h,u)=>m[u]=Math.round(h*e[u]))),m},lh=(t,r,e,d,l)=>`\n    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${t.type.indices}) -> array<f32, ${e.length}> {\n      const inputShape = array<u32, ${r.length}>(${r.map(m=>`${m}u`).join(",")});\n      const outputShape = array<u32, ${e.length}>(${e.map(m=>`${m}u`).join(",")});\n      const scales = array<f32, ${d.length}>(${d.map(m=>`${m}f`).join(",")});\n      const roi = array<f32, ${l.length}>(${l.map(m=>`${m}f`).join(",")});\n      var originalIndices: array<f32, ${e.length}>;\n      for (var i:u32 = 0; i < ${e.length}; i++) {\n        var outputIndex = ${e.length===1?"outputIndices":"outputIndices[i]"};\n        if (scales[i] == 1.0) {\n          originalIndices[i] = f32(outputIndex);\n        } else {\n          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${r.length}]);\n        }\n      }\n      return originalIndices;\n    }`,ch=(t,r,e,d,l,m,h)=>`\n    fn calculateInputIndicesFromOutputIndices(outputIndices: ${r.type.indices}) -> ${t.type.indices} {\n        const inputShape = array<u32, ${e.length}>(${e.map(u=>`${u}u`).join(",")});\n        const outputShape = array<u32, ${d.length}>(${d.map(u=>`${u}u`).join(",")});\n        const scales = array<f32, ${l.length}>(${l.map(u=>`${u}f`).join(",")});\n        const roi = array<f32, ${m.length}>(${m.map(u=>`${u}f`).join(",")});\n        var inputIndices: ${t.type.indices};\n        for (var i:u32 = 0; i < ${d.length}; i++) {\n          var outputIndex = ${d.length===1?"outputIndices":"outputIndices[i]"};\n          var inputIndex: u32;\n          if (scales[i] == 1.0) {\n            inputIndex = outputIndex;\n          } else {\n            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${e.length}]);\n            if (!${h} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {\n              if (original_idx < 0) {\n                inputIndex = 0;\n              } else if (original_idx > (f32(inputShape[i]) - 1)) {\n                inputIndex = inputShape[i] - 1;\n              } else {\n                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));\n              }\n            } else {\n              inputIndex = u32(original_idx);\n            }\n          }\n          ${t.indicesSet("inputIndices","i","inputIndex")}\n        }\n        return inputIndices;\n    }`,dh=(t,r)=>`\n    fn checkInputIndices(inputIndices: ${t.type.indices}) -> bool {\n      const inputShape = array<u32, ${r.length}>(${r.map(e=>`${e}u`).join(",")});\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var inputIndex = ${r.length===1?"inputIndices":"inputIndices[i]"};\n        if (inputIndex < 0 || inputIndex >= inputShape[i]) {\n          return false;\n        }\n      }\n      return true;\n    }`,fh=(t,r,e,d,l,m,h)=>{let[u,w,_,O]=e.length===2?[-1,0,1,-1]:l[1]===1?[0,2,3,1]:[0,1,2,3];return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {\n      var inputIndices: ${t.type.indices};\n      inputIndices[${w}] = max(0, min(row, ${e[w]} - 1));\n      inputIndices[${_}] = max(0, min(col, ${e[_]} - 1));\n      if (${e.length} > 2) {\n        inputIndices[${O}] = channel;\n        inputIndices[${u}] = batch;\n      };\n      return input[${t.indicesToOffset("inputIndices")}];\n    }\n\n    fn bilinearInterpolation(outputIndices: ${r.type.indices}) -> f32 {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);\n      var row:f32 = originalIndices[${w}];\n      var col:f32 = originalIndices[${_}];\n      if (${m} && (row < 0 || row > (${e[w]} - 1) || col < 0 || col > ${e[_]} - 1)) {\n        return ${h};\n      }\n      row = max(0, min(row, ${e[w]} - 1));\n      col = max(0, min(col, ${e[_]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = 0;\n      var batch: u32 = 0;\n      if (${e.length>2}) {\n        channel = u32(originalIndices[${O}]);\n        batch = u32(originalIndices[${u}]);\n      }\n      var x11: f32 = getInputValue(batch, channel, row1, col1);\n      var x12: f32 = getInputValue(batch, channel, row1, col2);\n      var x21: f32 = getInputValue(batch, channel, row2, col1);\n      var x22: f32 = getInputValue(batch, channel, row2, col2);\n      var dx1: f32 = row - f32(row1);\n      var dx2: f32 = f32(row2 ) - row;\n      var dy1 = col - f32(col1);\n      var dy2 = f32(col2) - col;\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},ph=(t,r,e,d,l,m,h,u,w,_)=>{let[O,j]=e.length===2?[0,1]:l[1]===1?[2,3]:[1,2],B=P=>{let R=P===O?"row":"col";return`\n      fn ${R}CubicInterpolation(inputIndices: ${t.type.indices}, outputIndices: ${r.type.indices}) -> f32 {\n        var outputIndex = ${d.length===1?"outputIndices":`outputIndices[${P}]`};\n        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${l[P]},\n        f32(${d[P]}), f32(${e[P]}), ${m[P]}, ${m[P]} + ${e.length});\n        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${u} && (originalIdx < 0 || originalIdx > (${e[P]} - 1))) {\n          return ${w};\n        }\n        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${R}: f32 = originalIdx + f32(i);\n          if (${R} < 0 || ${R} >= ${e[P]}) {\n            if (${_}) {\n              coefs[i + 1] = 0.0;\n              continue;\n            } else if (${u}) {\n              return ${w};\n            } else {\n              ${R} = max(0, min(${R}, ${e[P]} - 1));\n            }\n          }\n          var inputIndicesCopy: ${t.type.indices} = inputIndices;\n          inputIndicesCopy[${P}] = u32(${R});\n          data[i + 1] = ${P===O?`input[${t.indicesToOffset("inputIndicesCopy")}];`:`\n                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);`}\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${B(O)};\n    ${B(j)};\n  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {\n    var absS = abs(s);\n    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: f32 = 1.0 - absS;\n    var twoMinusAbsS: f32 = 2.0 - absS;\n    var onePlusAbsS: f32 = 1.0 + absS;\n    coeffs[0] = ((${h} * onePlusAbsS - 5 * ${h}) * onePlusAbsS + 8 * ${h}) * onePlusAbsS - 4 * ${h};\n    coeffs[1] = ((${h} + 2) * absS - (${h} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${h} + 2) * oneMinusAbsS - (${h} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${h} * twoMinusAbsS - 5 * ${h}) * twoMinusAbsS + 8 * ${h}) * twoMinusAbsS - 4 * ${h};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {\n    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(outputIndices: ${r.type.indices}) -> f32 {\n    var inputIndices: ${t.type.indices} = outputIndices;\n    return colCubicInterpolation(inputIndices, outputIndices);\n  }\n    `},mh=(t,r,e,d,l,m)=>{let h=t.dims,u=ah(m,r.axes,h.length),w=sh(h,d,l,r.axes),_=d.slice();d.length===0&&(_=h.map((k,U)=>k===0?1:w[U]/k),r.keepAspectRatioPolicy!=="stretch"&&(w=uh(h,w,_,r)));let O=fe("output",t.dataType,w),j=ne("input",t.dataType,h),B=Y.size(w),P=h.length===w.length&&h.every((k,U)=>k===w[U]),R=r.coordinateTransformMode==="tf_crop_and_resize",T=k=>`\n      ${ih(r.coordinateTransformMode)};\n      ${(()=>{switch(r.mode){case"nearest":return`\n              ${dh(j,h)};\n              ${oh(r.nearestMode,e)};\n              ${ch(j,O,h,w,_,u,R)};\n              `;case"linear":return`\n              ${lh(O,h,w,_,u)};\n              ${fh(j,O,h,w,_,R,r.extrapolationValue)};\n              `;case"cubic":return`\n            ${ph(j,O,h,w,_,u,r.cubicCoeffA,R,r.extrapolationValue,r.excludeOutside)};\n            `;default:throw Error("Invalid resize mode")}})()};\n      ${k.declareVariables(j,O)}\n      ${k.mainStart()}\n        ${k.guardAgainstOutOfBoundsWorkgroupSizes(B)}\n        if (${P}) {\n          output[global_idx] = input[global_idx];\n        } else {\n          let outputIndices = ${O.offsetToIndices("global_idx")};\n          var inputIndices: ${j.type.indices};\n          ${(()=>{switch(r.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);\n                  if (checkInputIndices(inputIndices)) {\n                    output[global_idx] = input[${j.indicesToOffset("inputIndices")}];\n                  } else {\n                    output[global_idx] = ${r.extrapolationValue};\n                  }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${r.mode}`)}})()};\n        }\n      }`;return{name:"Resize",shaderCache:{hint:`${r.cacheKey}|${e}|${_.length>0?_:""}|${l.length>0?l:""}`},getShaderSource:T,getRunData:()=>({outputs:[{dims:w,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(B/64)}})}},hh=t=>{let r=t.customDataBuffer;return new Uint32Array(r,r.byteOffset,1)[0]},Dl=(t,r)=>{let e=[],d=[],l=[],m=hh(t);nh(t.inputs,r,m,e,d,l),t.compute(mh(t.inputs[0],r,m,e,d,l),{inputs:[0]})},Wl=t=>{let r=t.antialias,e=t.axes,d=t.coordinateTransformMode,l=t.cubicCoeffA,m=t.excludeOutside!==0,h=t.extrapolationValue,u=t.keepAspectRatioPolicy,w=t.mode,_=t.nearestMode===""?"simple":t.nearestMode;return ye({antialias:r,axes:e,coordinateTransformMode:d,cubicCoeffA:l,excludeOutside:m,extrapolationValue:h,keepAspectRatioPolicy:u,mode:w,nearestMode:_})}});var gh,yh,Gl,Vl,Ul=oe(()=>{"use strict";Xe();Ae();Ne();Pe();gh=t=>{if(!t||t.length<3)throw new Error("layerNorm requires at least 3 inputs.");let r=t[0],e=t[1],d=t[2];if(r.dataType!==e.dataType||r.dataType!==d.dataType)throw new Error("All inputs must have the same data type");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Input must be 2D or 3D");if(e.dims.length!==3&&e.dims.length!==2)throw new Error("Skip must be 2D or 3D");let l=r.dims[r.dims.length-1],m=r.dims[r.dims.length-2];if(e.dims[e.dims.length-1]!==l)throw new Error("Skip must have the same hidden size as input");if(e.dims[e.dims.length-2]!==m)throw new Error("Skip must have the same sequence length as input");if(d.dims.length!==1)throw new Error("Gamma must be 1D");if(d.dims[d.dims.length-1]!==l)throw new Error("Gamma must have the same hidden size as input");if(t.length>3){let h=t[3];if(h.dims.length!==1)throw new Error("Beta must be 1D");if(h.dims[h.dims.length-1]!==l)throw new Error("Beta must have the same hidden size as input")}if(t.length>4){let h=t[4];if(h.dims.length!==1)throw new Error("Bias must be 1D");if(h.dims[h.dims.length-1]!==l)throw new Error("Bias must have the same hidden size as input")}},yh=(t,r,e,d)=>{let l=t[0].dims,m=Y.size(l),h=l,u=m,w=l.slice(-1)[0],_=d?l.slice(0,-1).concat(1):[],O=t.length>3,j=t.length>4,B=d&&e>1,P=d&&e>2,R=e>3,T=Ft(w),k=[ne("x",t[0].dataType,t[0].dims,T),ne("skip",t[1].dataType,t[1].dims,T),ne("gamma",t[2].dataType,t[2].dims,T)];O&&k.push(ne("beta",t[3].dataType,t[3].dims,T)),j&&k.push(ne("bias",t[4].dataType,t[4].dims,T)),k.push(fe("output",t[0].dataType,h,T)),B&&k.push(fe("meanOutput",1,_)),P&&k.push(fe("invStdOutput",1,_)),R&&k.push(fe("inputSkipBiasSum",t[0].dataType,h,T));let U=Fe(t[0].dataType),K=L=>`\n      const hiddenSize: f32 = ${w};\n      const hiddenSizeVectorized: u32 = ${w/T};\n      const epsilon: f32 = ${r.epsilon};\n\n      ${L.declareVariables(...k)}\n\n      ${L.mainStart()}\n        ${L.guardAgainstOutOfBoundsWorkgroupSizes(u/w)}\n        let offset = global_idx * hiddenSizeVectorized;\n        var sum = ${mt("f32",T)};\n        var squareSum = ${mt("f32",T)};\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          let skipValue = skip[offset + i];\n          let biasValue = ${j?"bias[i]":"0.0"};\n          let inputValue = x[offset + i];\n          let value = inputValue + skipValue + biasValue;\n          ${R?"inputSkipBiasSum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32Value = ${Ht(U,T,"value")};\n          sum += f32Value;\n          squareSum += f32Value * f32Value;\n        }\n        let mean = ${dr("sum",T)} / hiddenSize;\n        let variance = sqrt(${dr("squareSum",T)} / hiddenSize - mean * mean + epsilon);\n        ${B?"meanOutput[global_idx] = mean;":""}\n        ${P?"invStdOutput[global_idx] = 1.0 / variance;":""}\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          output[offset + i] = (output[offset + i] - ${U}(mean)) / ${U}(variance) * gamma[i]\n           + ${O?"beta[i]":"0.0"};\n        }\n      }`,Q=[{dims:h,dataType:t[0].dataType}];return e>1&&Q.push({dims:_,dataType:1}),e>2&&Q.push({dims:_,dataType:1}),e>3&&Q.push({dims:l,dataType:t[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:r.cacheKey},getShaderSource:K,getRunData:()=>({outputs:Q,dispatchGroup:{x:Math.ceil(u/w/64)}})}},Gl=(t,r)=>{gh(t.inputs);let d=[0];t.outputCount>1&&d.push(-3),t.outputCount>2&&d.push(-3),t.outputCount>3&&d.push(3),t.compute(yh(t.inputs,r,t.outputCount,!1),{outputs:d})},Vl=t=>{let r=t.epsilon;return ye({epsilon:r})}});var bh,ii,vh,Nl,wh,Ch,Fl,Hl,Ll=oe(()=>{"use strict";Xe();Ae();Ne();Pe();bh=(t,r)=>{if(!t||t.length<1)throw new Error("too few inputs");if(r.axes.length!==0){if(r.axes.length!==r.starts.length||r.axes.length!==r.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(r.starts.length!==r.ends.length)throw new Error("starts and ends must have the same length");t.slice(1).forEach((e,d)=>{if(t[d+1].dataType!==6&&t[d+1].dataType!==7)throw new Error(`Input ${d} must be an array of int32 or int64`)})},ii=(t,r)=>{let e=[];if(t.length>r)if(t[r].dataType===7)t[r].getBigInt64Array().forEach(d=>e.push(Number(d)));else if(t[r].dataType===6)t[r].getInt32Array().forEach(d=>e.push(Number(d)));else throw new Error(`Input ${r} must be an array of int32 or int64`);return e},vh=(t,r)=>{if(t.length>1){let e=ii(t,1),d=ii(t,2),l=ii(t,3);return l.length===0&&(l=[...Array(t[0].dims.length).keys()]),ye({starts:e,ends:d,axes:l})}else return r},Nl=(t,r,e,d,l)=>{let m=t;return t<0&&(m+=e[d[r]]),l[r]<0?Math.max(0,Math.min(m,e[d[r]]-1)):Math.max(0,Math.min(m,e[d[r]]))},wh=(t,r,e,d)=>`fn calculateInputIndices(outputIndices: ${r.type.indices}) -> ${t.type.indices} {\n          var inputIndices: ${t.type.indices};\n          var carry = 0u;\n          for (var i = ${e.length}; i >= 0; i--) {\n            var outputIndex = ${d.length===1?"outputIndices":"outputIndices[i]"};\n            var inputIndex = outputIndex * steps[i] + starts[i] + carry;\n            carry = inputIndex / inputShape[i];\n            inputIndex = inputIndex % inputShape[i];\n            if (signs[i] < 0) {\n              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];\n            }\n            ${e.length===1?"inputIndices":"inputIndices[i]"} = inputIndex;\n          }\n          return inputIndices;\n      }`,Ch=(t,r)=>{let e=t[0].dims,d=Y.size(e),l=r.axes.length>0?Y.normalizeAxes(r.axes,e.length):[...Array(e.length).keys()],m=ii(t,4);m.forEach(T=>T!==0||(()=>{throw new Error("step cannot be 0")})),m.length===0&&(m=Array(l.length).fill(1));let h=r.starts.map((T,k)=>Nl(T,k,e,l,m)),u=r.ends.map((T,k)=>Nl(T,k,e,l,m));if(l.length!==e.length)for(let T=0;T<e.length;++T)l.includes(T)||(h.splice(T,0,0),u.splice(T,0,e[T]),m.splice(T,0,1));let w=m.map(T=>Math.sign(T));m.forEach((T,k,U)=>{if(T<0){let K=(u[k]-h[k])/T,Q=h[k],L=Q+K*m[k];h[k]=L,u[k]=Q,U[k]=-T}});let _=e.slice(0);l.forEach((T,k)=>{_[T]=Math.ceil((u[T]-h[T])/m[T])});let O={dims:_,dataType:t[0].dataType},j=fe("output",t[0].dataType,_),B=ne("input",t[0].dataType,e),P=Y.size(_),R=T=>`\n      ${T.declareVariables(B,j)}\n        const signs = array<i32, ${w.length}>(${w.map(k=>`${k}i`).join(",")});\n        const starts = array<u32, ${h.length}>(${h.map(k=>`${k}u`).join(",")});\n        const ends = array<u32, ${u.length}>(${u.map(k=>`${k}u`).join(",")});\n        const steps = array<u32, ${m.length}>(${m.map(k=>`${k}u`).join(",")});\n        const inputShape = array<u32, ${e.length}>(${e.map(k=>`${k}u`).join(",")});\n\n        ${wh(B,j,e,_)}\n        ${T.mainStart()}\n          ${T.guardAgainstOutOfBoundsWorkgroupSizes(P)}\n          let outputIndices = ${j.offsetToIndices("global_idx")};\n          let inputIndices = calculateInputIndices(outputIndices);\n          ${j.setByOffset("global_idx",B.getByIndices("inputIndices"))}\n      }`;return{name:"Slice",shaderCache:{hint:`${r.cacheKey}|${t[4]?.dims??""}`},getShaderSource:R,getRunData:()=>({outputs:[O],dispatchGroup:{x:Math.ceil(d/64)}})}},Fl=(t,r)=>{bh(t.inputs,r);let e=vh(t.inputs,r);t.compute(Ch(t.inputs,e),{inputs:[0]})},Hl=t=>{let r=t.starts,e=t.ends,d=t.axes;return ye({starts:r,ends:e,axes:d})}});var $h,xh,Kl,ql,Yl=oe(()=>{"use strict";Ae();Ne();Pe();$h=t=>{if(!t||t.length!==1)throw new Error("Softmax op requires 1 input.")},xh=(t,r)=>{let e=Fe(t.dataType),d=t.dims,l=Y.size(d),m=64,h=r.axis;if(h<0&&(h=d.length+h),h<d.length-1)throw new Error("softmax only supports last axis for now.");let u=d[h],w=l/u,_=e==="f32"?"var threadMax: f32 = -3.402823e+38f;":"var threadMax: f16 = -65504.0h;";return{name:"Softmax",getRunData:()=>({outputs:[{dims:d,dataType:t.dataType}],dispatchGroup:{x:w}}),getShaderSource:j=>`\n      var<workgroup> rowMaxShared : ${e};\n      var<workgroup> rowSumShared : ${e};\n      var<workgroup> threadShared : array<${e}, ${m}>;\n\n      @group(0) @binding(0) var<storage, read> x : array<${e}>;\n      @group(0) @binding(1) var<storage, read_write> result : array<${e}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${e} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${e}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n\n      @compute @workgroup_size(${m}, 1, 1)\n      fn main(@builtin(local_invocation_id) local_id : vec3<u32>, @builtin(global_invocation_id) global_id : vec3u) {\n        let gindex = i32(global_id.x);\n        let lindex = i32(local_id.x);\n        const wg = ${m};\n        let row = gindex / wg;\n        let cols = ${u};\n        let row_stride : i32 = ${u};\n\n        // find the rows max\n        ${_}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = threadShared[0];\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum: ${e} = 0.0;\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = threadShared[0];\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`}},Kl=(t,r)=>{$h(t.inputs),t.compute(xh(t.inputs[0],r))},ql=t=>ye({axis:t.axis})});var Sh,_h,Ah,Ih,Th,Xl,Ql,Jl=oe(()=>{"use strict";Ae();Ne();Pe();Sh=t=>{if(!t||t.length<1)throw new Error("too few inputs")},_h=(t,r)=>{let e=[],d=r.numOutputs;return t[1].dims[0]>0&&(t[1].getBigInt64Array().forEach(l=>e.push(Number(l))),d=e.length),ye({numOutputs:d,axis:r.axis,splitSizes:e})},Ah=t=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${t}u; i += 1u ) {\n    if (index < sizeInConcatAxis[i]) {\n        return i;\n    }\n    }\n    return ${t}u;\n}`,Ih=t=>{let r=t.length,e=[];for(let d=0;d<r;++d){let l=t[d].setByIndices("indices","input[global_idx]");r===1?e.push(l):d===0?e.push(`if (outputNumber == ${d}u) { ${l} }`):d===r-1?e.push(`else { ${l} }`):e.push(`else if (outputNumber == ${d}) { ${l} }`)}return`\n      fn writeBufferData(outputNumber: u32, indices: ${t[0].type.indices}, global_idx: u32) {\n        ${e.join(`\n`)}\n      }`},Th=(t,r)=>{let e=t[0].dims,d=Y.size(e),l=t[0].dataType,m=e.length,h=r.axis,u=h<0?e.length+h:h,w=new Array(r.numOutputs),_=ne("input",l,e),O=new Array(r.numOutputs),j=[],B=[],P=0;for(let k=0;k<r.numOutputs;k++){P+=r.splitSizes[k],O[k]=P;let U=e.slice();U[r.axis]=r.splitSizes[k],B.push(U),w[k]=fe(`output${k}`,l,B[k]),j.push({dims:B[k],dataType:t[0].dataType})}let R=m<2?"indices":`indices[${u}]`,T=k=>`\n  ${k.declareVariables(_,...w)}\n  const sizeInConcatAxis = array<u32, ${O.length}>(${O.map(U=>`${U}u`).join(",")});\n  ${Ah(O.length)}\n  ${Ih(w)}\n\n  ${k.mainStart()}\n    ${k.guardAgainstOutOfBoundsWorkgroupSizes(d)}\n\n    var indices = ${_.offsetToIndices("global_idx")};\n    let outputNumber = calculateOutputIndex(${R});\n    if (outputNumber != 0) {\n        ${R} -= sizeInConcatAxis[outputNumber - 1u];\n    }\n    writeBufferData(outputNumber, indices, global_idx);\n  }`;return{name:"Split",shaderCache:{hint:r.cacheKey},getShaderSource:T,getRunData:()=>({outputs:j,dispatchGroup:{x:Math.ceil(d/64)}})}},Xl=(t,r)=>{Sh(t.inputs);let e=t.inputs.length===1?r:_h(t.inputs,r);t.compute(Th(t.inputs,e),{inputs:[0]})},Ql=t=>{let r=t.axis,e=t.splitSizes,d=t.numOutputs<0?e.length:t.numOutputs;if(d!==e.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ye({axis:r,numOutputs:d,splitSizes:e})}});var Zl,Oh,Eh,Ph,ec,tc=oe(()=>{"use strict";Xe();Ae();Pe();Zl=t=>Array.from(t.getBigInt64Array(),Number),Oh=t=>{if(!t||t.length!==2)throw new Error("Tile requires 2 inputs.");if(t[0].dataType!==1&&t[0].dataType!==6&&t[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(t[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(t[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(Zl(t[1]).length!==t[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Eh=(t,r)=>{let e=[];for(let d=0;d<t.length;++d)e.push(t[d]*r[d]);return e},Ph=t=>{let r=t[0].dims,e=Zl(t[1]),d=Eh(r,e),l=Y.size(d),m=t[0].dataType,h=ne("input",m,r),u=fe("output",m,d),w=_=>`\n      const inputShape = ${h.indices(...r)};\n      ${_.declareVariables(h,u)}\n      ${_.mainStart()}\n      ${_.guardAgainstOutOfBoundsWorkgroupSizes(l)}\n      let outputIndices = ${u.offsetToIndices("global_idx")};\n      var inputIndices: ${h.type.indices};\n      for (var i = 0; i < ${r.length}; i++) {\n        let inputDimValue = ${u.indicesGet("outputIndices","i")}  % ${h.indicesGet("inputShape","i")};\n\n        ${h.indicesSet("inputIndices","i","inputDimValue")}\n      }\n      ${u.setByOffset("global_idx",h.getByIndices("inputIndices"))}\n    }`;return{name:"Tile",shaderCache:{hint:`${e}`},getRunData:()=>({outputs:[{dims:d,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)}}),getShaderSource:w}},ec=t=>{Oh(t.inputs),t.compute(Ph(t.inputs),{inputs:[0]})}});var Rh,kh,rc,nc=oe(()=>{"use strict";Xe();Ae();Pe();Rh=(t,r,e,d,l)=>{let m=Y.size(e),h=Math.ceil(m/4),u=fe("outputData",l,e,4),w=ne("aData",r[1].dataType,r[1].dims,4),_=ne("bData",r[2].dataType,r[2].dims,4),O=ne("cData",r[0].dataType,r[0].dims,4),j,B=(P,R,T)=>`select(${R}, ${P}, ${T})`;if(!d)j=u.setByOffset("global_idx",B(w.getByOffset("global_idx"),_.getByOffset("global_idx"),O.getByOffset("global_idx")));else{let P=(R,T,k="")=>{let U=`aData[indexA${T}][componentA${T}]`,K=`bData[indexB${T}][componentB${T}]`,Q=`bool(cData[indexC${T}] & ${4278190080>>>(3-T)*8}u)`;return`\n            let outputIndices${T} = ${u.offsetToIndices(`global_idx * 4u + ${T}u`)};\n            let offsetA${T} = ${w.broadcastedIndicesToOffset(`outputIndices${T}`,u)};\n            let offsetB${T} = ${_.broadcastedIndicesToOffset(`outputIndices${T}`,u)};\n            let offsetC${T} = ${O.broadcastedIndicesToOffset(`outputIndices${T}`,u)};\n            let indexA${T} = offsetA${T} / 4u;\n            let indexB${T} = offsetB${T} / 4u;\n            let indexC${T} = offsetC${T} / 4u;\n            let componentA${T} = offsetA${T} % 4u;\n            let componentB${T} = offsetB${T} % 4u;\n            ${R}[${T}] = ${k}(${B(U,K,Q)});\n          `};l===9?j=`\n            var data = vec4<u32>(0);\n            ${P("data",0,"u32")}\n            ${P("data",1,"u32")}\n            ${P("data",2,"u32")}\n            ${P("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:j=`\n            ${P("outputData[global_idx]",0)}\n            ${P("outputData[global_idx]",1)}\n            ${P("outputData[global_idx]",2)}\n            ${P("outputData[global_idx]",3)}\n          `}return`\n        ${t.declareVariables(O,w,_,u)}\n        ${t.mainStart()}\n        ${t.guardAgainstOutOfBoundsWorkgroupSizes(h)}\n        ${j}\n      }`},kh=t=>{let r=t[1].dims,e=t[2].dims,d=t[0].dims,l=t[1].dataType,m=!(Y.areEqual(r,e)&&Y.areEqual(e,d)),h=r,u=Y.size(r);if(m){let w=Ct.calcShape(Ct.calcShape(r,e,!1),d,!1);if(!w)throw new Error("Can\'t perform where op on the given tensors");h=w,u=Y.size(h)}return{name:"Where",getShaderSource:w=>Rh(w,t,h,m,l),getRunData:()=>({outputs:[{dims:h,dataType:l}],dispatchGroup:{x:Math.ceil(u/64/4)}})}},rc=t=>{t.compute(kh(t.inputs))}});var ic,oc=oe(()=>{"use strict";hs();ys();Xs();su();cu();ki();Tu();Ru();Mu();Wu();Vu();Fu();Ku();Xu();Ju();tl();gl();jl();Ai();zl();Ul();Ll();Yl();Jl();tc();ei();Oi();nc();ic=new Map([["Abs",[bs]],["Acos",[vs]],["Acosh",[ws]],["Add",[Qs]],["ArgMax",[ms,Ii]],["ArgMin",[ps,Ii]],["Asin",[Cs]],["Asinh",[$s]],["Atan",[xs]],["Atanh",[Ss]],["AveragePool",[sl,al]],["BiasAdd",[gs]],["BiasSplitGelu",[Ys]],["Cast",[As,_s]],["Ceil",[Ts]],["ClipV10",[Ti]],["Clip",[Is]],["Concat",[uu,lu]],["Conv",[Cu,wu]],["ConvTranspose",[Iu,Au]],["Cos",[Os]],["Cosh",[Es]],["Div",[Js]],["Einsum",[Eu,Pu]],["Elu",[Ps,Hn]],["Equal",[Zs]],["Erf",[Rs]],["Exp",[ks]],["Expand",[Bu]],["Floor",[Bs]],["Gather",[Du,ju]],["GatherElements",[Gu,zu]],["Gelu",[Ms]],["Gemm",[Uu,Nu]],["GlobalAveragePool",[cl,ll]],["GlobalMaxPool",[hl,ml]],["Greater",[nu]],["GreaterOrEqual",[ou]],["InstanceNormalization",[Lu,Hu]],["LayerNormalization",[Yu,qu]],["LeakyRelu",[js,Hn]],["Less",[iu]],["LessOrEqual",[au]],["Log",[qs]],["MatMul",[Qu]],["MaxPool",[fl,pl]],["Mul",[eu]],["Neg",[Ws]],["Not",[Ds]],["Pad",[Zu,el]],["Pow",[tu]],["Range",[Ml]],["Reciprocal",[zs]],["ReduceMin",[ss,ht]],["ReduceMean",[as,ht]],["ReduceMax",[os,ht]],["ReduceSum",[ls,ht]],["ReduceProd",[us,ht]],["ReduceL1",[rs,ht]],["ReduceL2",[ns,ht]],["ReduceLogSum",[ts,ht]],["ReduceLogSumExp",[is,ht]],["ReduceSumSquare",[cs,ht]],["Relu",[Gs]],["Resize",[Dl,Wl]],["Sigmoid",[Vs]],["Sin",[Us]],["Sinh",[Ns]],["Slice",[Fl,Hl]],["SkipLayerNormalization",[Gl,Vl]],["Split",[Xl,Ql]],["Sqrt",[Fs]],["Softmax",[Kl,ql]],["Sub",[ru]],["Tan",[Hs]],["Tanh",[Ls]],["ThresholdedRelu",[Ks,Hn]],["Tile",[ec]],["Transpose",[gu,yu]],["Where",[rc]]])});var oi,ac=oe(()=>{"use strict";Xe();Tt();Pe();oi=class{constructor(r){this.backend=r;this.repo=new Map,this.attributesBound=!1}getArtifact(r){return this.repo.get(r)}setArtifact(r,e){this.repo.set(r,e)}run(r,e,d,l,m,h,u){let w=this.backend.device,_=this.backend.getComputePassEncoder(),O=this.backend.supportTimestampQuery&&this.backend.env.webgpu.profilingMode==="default";O&&_.writeTimestamp(this.backend.profilingQuerySet,0),_.setPipeline(r.computePipeline);let j=[];for(let P of l)j.push({binding:j.length,resource:{buffer:P.buffer}});for(let P of m)j.push({binding:j.length,resource:{buffer:P.buffer}});u&&j.push({binding:j.length,resource:u});let B=w.createBindGroup({layout:r.computePipeline.getBindGroupLayout(0),entries:j,label:r.programInfo.name});if(_.setBindGroup(0,B),_.dispatchWorkgroups(...h),this.backend.pendingDispatchNumber++,O){_.writeTimestamp(this.backend.profilingQuerySet,1),this.backend.profilingQueryData==null&&(this.backend.profilingQueryData=this.backend.gpuDataManager.create(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let P=this.backend.gpuDataManager.create(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.profilingQuerySet,0,2,this.backend.profilingQueryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.profilingQueryData.buffer,0,P.buffer,0,16),this.backend.flush();let R=this.backend.currentKernelId,T=this.backend.kernels.get(R),k=`[${T[0]}] ${T[1]}`;P.buffer.mapAsync(GPUMapMode.READ).then(()=>{let U=new BigUint64Array(P.buffer.getMappedRange()),K=U[0],Q=U[1];P.buffer.unmap(),typeof this.backend.profilingTimeBase>"u"&&(this.backend.profilingTimeBase=K);let L=Number(K-this.backend.profilingTimeBase),X=Number(Q-this.backend.profilingTimeBase);if(!Number.isSafeInteger(L)||!Number.isSafeInteger(X))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(P.id);let A="";e.forEach((re,ie)=>{A+=`input[${ie}]: [${re.dims}] | ${tn(re.dataType)}, `});let Z="";d.forEach((re,ie)=>{Z+=`output[${ie}]: [${re.dims}] | ${tn(re.dataType)}, `}),console.log(`[profiling] kernel "${R}|${k}" ${A}${Z}execution time: ${X-L} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(r,e){let d=this.backend.device,l=[];d.features.has("shader-f16")&&l.push("enable f16;");let m=es(e),h=r.getShaderSource(m),u=`${l.join(`\n`)}\n${m.additionalImplementations}\n${h}`,w=d.createShaderModule({code:u,label:r.name});ze("verbose",()=>`[WebGPU] shader code: ${u}`);let _=d.createComputePipeline({compute:{module:w,entryPoint:"main"},layout:"auto",label:r.name});return{programInfo:r,computePipeline:_}}normalizeDispatchGroupSize(r){let e=typeof r=="number"?r:r.x,d=typeof r=="number"?1:r.y||1,l=typeof r=="number"?1:r.z||1,m=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(e<=m&&d<=m&&l<=m)return[e,d,l];let h=e*d*l,u=Math.ceil(Math.sqrt(h));if(u>m){if(u=Math.ceil(Math.cbrt(h)),u>m)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[u,u,u]}else return[u,u,1]}}});var Bh,Mh,ai,sc=oe(()=>{"use strict";Tt();Ka();Qa();oc();ac();Bh=(t,r)=>{if(r.length!==t.length)throw new Error(`inputDependencies length ${r.length} is not equal to inputTensors length ${t.length}.`);let e=[];for(let d=0;d<t.length;++d){let l=t[d].dataType;switch(r[d]){case"none":{e.push("");break}case"type":{e.push(`${l}`);break}case"rank":{let m=t[d].dims.length;e.push(`${l};${m}`);break}case"dims":{let m=t[d].dims.join(",");e.push(`${l};${m}`);break}default:throw new Error(`unsupported input dependency: ${r[d]}`)}}return e.join("|")},Mh=(t,r)=>{let e=t.name;return t.shaderCache?.hint&&(e+="["+t.shaderCache.hint+"]"),e+=`:${Bh(r,t.shaderCache?.inputDependencies??new Array(r.length).fill("dims"))}`,e},ai=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.supportTimestampQuery=!1;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let r=this.kernelCustomData.get(this.currentKernelId);return r||(r={},this.kernelCustomData.set(this.currentKernelId,r)),r}async initialize(r){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let e=await navigator.gpu.requestAdapter();if(!e)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=r;let d=[],l={requiredLimits:{maxComputeWorkgroupStorageSize:e.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:e.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:e.limits.maxStorageBufferBindingSize,maxBufferSize:e.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:e.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:e.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:e.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:e.limits.maxComputeWorkgroupSizeZ},requiredFeatures:d};e.features.has("timestamp-query-inside-passes")&&(this.supportTimestampQuery=!0,d.push("timestamp-query-inside-passes")),e.features.has("shader-f16")&&d.push("shader-f16"),this.device=await e.requestDevice(l),this.gpuDataManager=Xa(this),this.programManager=new oi(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Ha(r.logLevel,!!r.debug),this.device.onuncapturederror=m=>{m.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${m.error.message}`)},this.supportTimestampQuery&&(this.profilingQuerySet=this.device.createQuerySet({type:"timestamp",count:2})),Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){return this.computePassEncoder||(this.computePassEncoder=this.getCommandEncoder().beginComputePass()),this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}run(r,e,d,l,m){let h=[];for(let U=0;U<e.length;++U){let K=this.gpuDataManager.get(e[U].data);if(!K)throw new Error(`no GPU data for input: ${e[U].data}`);h[U]=K}let u=Mh(r,e),w=this.programManager.getArtifact(u),{outputs:_,dispatchGroup:O,programUniforms:j}=r.getRunData(e),B=d.length===0?_.map((U,K)=>K):d;if(B.length!==_.length)throw new Error(`Output size ${B.length} must be equal to ${_.length}.`);let P=[],R=[];for(let U=0;U<_.length;++U){if(!Number.isInteger(B[U])||B[U]<-3||B[U]>=_.length)throw new Error(`Invalid output index: ${B[U]}`);if(B[U]===-3)continue;let K=B[U]===-1,Q=B[U]===-2,L=K||Q?m(_[U].dataType,_[U].dims):l(B[U],_[U].dataType,_[U].dims),X=this.gpuDataManager.get(L.data);if(!X)throw new Error(`no GPU data for output: ${L.data}`);if(K&&this.temporaryData.push(X),Q){let A=this.kernelPersistentData.get(this.currentKernelId);A||(A=[],this.kernelPersistentData.set(this.currentKernelId,A)),A.push(X)}P.push(L),R.push(X)}let T;if(j){let U=0,K=0,Q=[],L=1;j.forEach(Z=>{let re=typeof Z.data=="number"?[Z.data]:Z.data,ie;switch(re.length){case 1:ie=4;break;case 2:ie=8;break;case 3:ie=16;break;case 4:ie=16;break;case 5:ie=16;break;case 6:ie=16;break;default:throw new Error(`unsupported data length: ${re.length}`)}(K===5||K===6)&&(ie=16),ie>L&&(L=ie),U=Math.ceil(U/ie)*ie,K=re.length,Q.push(U),U+=re.length*4}),U=Math.ceil(U/L)*L;let X=new ArrayBuffer(U);j.forEach((Z,re)=>{let ie=Q[re],Ce=typeof Z.data=="number"?[Z.data]:Z.data;Z.type==="int32"?new Int32Array(X,ie,Ce.length).set(Ce):Z.type==="uint32"?new Uint32Array(X,ie,Ce.length).set(Ce):new Float32Array(X,ie,Ce.length).set(Ce)});let A=this.gpuDataManager.create(U,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(A.buffer,0,X,0,U),this.gpuDataManager.release(A.id),T={offset:0,size:U,buffer:A.buffer}}let k=this.programManager.normalizeDispatchGroupSize(O);return w||(w=this.programManager.build(r,k),this.programManager.setArtifact(u,w)),ze("info",()=>`[ProgramManager] run "${r.name}" (key=${u}) with ${k[0]}x${k[1]}x${k[2]}`),this.programManager.run(w,e,P,h,R,k,T),P}upload(r,e){this.gpuDataManager.upload(r,e)}memcpy(r,e){this.gpuDataManager.memcpy(r,e)}async download(r,e){await this.gpuDataManager.download(r,e)}alloc(r){return this.gpuDataManager.create(r).id}free(r){return this.gpuDataManager.release(r)}createKernel(r,e,d,l){let m=ic.get(r);if(!m)throw new Error(`kernel not implemented: ${r}`);this.kernels.set(e,[r,l,m[0],[m[1],d]])}releaseKernel(r){let e=this.kernelPersistentData.get(r);if(e){for(let d of e)this.gpuDataManager.release(d.id);this.kernelPersistentData.delete(r)}this.kernelCustomData.delete(r),this.kernels.delete(r)}computeKernel(r,e,d){let l=this.kernels.get(r);if(!l)throw new Error(`kernel not created: ${r}`);let[m,h,u,w]=l;if(this.currentKernelId!==null)throw new Error(`kernel "[${m}] ${h}" is not allowed to be called recursively`);this.currentKernelId=r,w[0]&&(w[1]=w[0](w[1]),w[0]=void 0),ze("info",()=>`[WebGPU] Start to run kernel "[${m}] ${h}"...`);let _=this.env.debug;this.temporaryData=[];try{return _&&this.device.pushErrorScope("validation"),u(e,w[1]),0}catch(O){return d.push(Promise.resolve(`[WebGPU] Kernel "[${m}] ${h}" failed. ${O}`)),1}finally{_&&d.push(this.device.popErrorScope().then(O=>O?`GPU validation error for kernel "[${m}] ${h}": ${O.message}`:null));for(let O of this.temporaryData)this.gpuDataManager.release(O.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(r,e,d,l){let m=this.sessionExternalDataMapping.get(r);m||(m=new Map,this.sessionExternalDataMapping.set(r,m));let h=m.get(e),u=this.gpuDataManager.registerExternalBuffer(d,l,h?.[1]);return m.set(e,[u,d]),u}unregisterBuffers(r){let e=this.sessionExternalDataMapping.get(r);e&&(e.forEach(d=>this.gpuDataManager.unregisterExternalBuffer(d[1])),this.sessionExternalDataMapping.delete(r))}getBuffer(r){let e=this.gpuDataManager.get(r);if(!e)throw new Error(`no GPU data for buffer: ${r}`);return e.buffer}createDownloader(r,e,d){return async()=>{let l=await wi(this,r,e);return La(l.buffer,d)}}}});var uc={};Dn(uc,{init:()=>jh});var ln,Vi,jh,lc=oe(()=>{"use strict";Xe();sc();Tt();Ae();ln=class t{constructor(r,e,d,l){this.module=r;this.dataType=e;this.data=d;this.dims=l}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let r=Y.size(this.dims);return r===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,r)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let r=Y.size(this.dims);return r===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,r)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let r=Y.size(this.dims);return r===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,r)}reshape(r){if(Y.size(r)!==Y.size(this.dims))throw new Error("Invalid new shape");return new t(this.module,this.dataType,this.data,r)}},Vi=class{constructor(r,e,d){this.module=r;this.backend=e;this.customDataOffset=0;this.customDataSize=0;let l=r.HEAPU32,m=d>>2;this.opKernelContext=l[m++];let h=l[m++];this.outputCount=l[m++],this.customDataOffset=l[m++],this.customDataSize=l[m++];let u=[];for(let w=0;w<h;w++){let _=l[m++],O=l[m++],j=l[m++],B=[];for(let P=0;P<j;P++)B.push(l[m++]);u.push(new ln(r,_,O,B))}this.inputs=u}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(r,e){let d=e?.inputs?.map(u=>typeof u=="number"?this.inputs[u]:u)??this.inputs,l=e?.outputs??[],m=(u,w,_)=>new ln(this.module,w,this.output(u,_),_),h=(u,w)=>{let _=rn(u);if(!_)throw new Error(`Unsupported data type: ${u}`);let O=_*Y.size(w);return new ln(this.module,u,this.backend.gpuDataManager.create(O).id,w)};return this.backend.run(r,d,l,m,h)}output(r,e){let d=this.module.stackSave();try{let l=this.module.stackAlloc((1+e.length)*4),m=l>>2;this.module.HEAPU32[m++]=e.length;for(let h=0;h<e.length;h++)this.module.HEAPU32[m++]=e[h];return this.module._JsepOutput(this.opKernelContext,r,l)}catch(l){throw new Error(`Failed to generate kernel\'s output[${r}] with dims [${e}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${l}`)}finally{this.module.stackRestore(d)}}},jh=async(t,r)=>{let e=t.jsepInit;if(e&&navigator.gpu){if(!r.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let d=new ai;await d.initialize(r),e(d,l=>d.alloc(l),l=>d.free(l),(l,m,h,u=!1)=>{if(u)ze("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${l}, dst=${m}, size=${h}`),d.memcpy(l,m);else{ze("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${l}, gpuDataId=${m}, size=${h}`);let w=t.HEAPU8.subarray(l,l+h);d.upload(m,w)}},async(l,m,h)=>{ze("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${l}, dataOffset=${m}, size=${h}`),await d.download(l,()=>t.HEAPU8.subarray(m,m+h))},(l,m,h)=>d.createKernel(l,m,h,r.debug||r.webgpu.profilingMode==="default"?t.UTF8ToString(t._JsepGetNodeName(m)):`${m}`),l=>d.releaseKernel(l),(l,m,h,u)=>{ze("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${h}, kernel=${l}, contextDataOffset=${m}`);let w=new Vi(t,d,m);return d.computeKernel(l,w,u)})}}});var Wa;Wa=Ta();var Tp=Ma(),hi,gi=!1,Wn=!1,Da=!1,Op=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},Ep=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Pp=(t,r)=>t?r?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":r?"ort-wasm-threaded.wasm":"ort-wasm.wasm",za=async t=>{if(gi)return Promise.resolve();if(Wn)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(Da)throw new Error("previous call to \'initializeWebAssembly()\' failed.");Wn=!0;let r=t.initTimeout,e=t.numThreads,d=t.simd,l=e>1&&Op(),m=d&&Ep(),h=t.wasmPaths,u=typeof h=="string"?h:void 0,w=Pp(m,l),_=typeof h=="object"?h[w]:void 0,O=!1,j=[];if(r>0&&j.push(new Promise(B=>{setTimeout(()=>{O=!0,B()},r)})),j.push(new Promise((B,P)=>{let R=l?Tp:Wa,T={locateFile:(k,U)=>{if(l&&k.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([ja()],{type:"text/javascript"}));if(k.endsWith(".wasm")){if(_)return _;let K=u??U;return w==="ort-wasm-simd.wasm"?K+"ort-wasm-simd.jsep.wasm":w==="ort-wasm-simd-threaded.wasm"?K+"ort-wasm-simd-threaded.jsep.wasm":K+w}return U+k}};if(l)if(typeof Blob>"u")T.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let k=`var ortWasmThreaded=${R.toString()};`;T.mainScriptUrlOrBlob=new Blob([k],{type:"text/javascript"})}R(T).then(k=>{Wn=!1,gi=!0,hi=k,B()},k=>{Wn=!1,Da=!0,P(k)})})),await Promise.race(j),O)throw new Error(`WebAssembly backend initializing failed due to timeout: ${r}ms`)},Ue=()=>{if(gi&&hi)return hi;throw new Error("WebAssembly is not initialized yet.")};var Ke=(t,r)=>{let e=Ue(),d=e.lengthBytesUTF8(t)+1,l=e._malloc(d);return e.stringToUTF8(t,l,d),r.push(l),l},en=(t,r,e,d)=>{if(typeof t=="object"&&t!==null){if(e.has(t))throw new Error("Circular reference in options");e.add(t)}Object.entries(t).forEach(([l,m])=>{let h=r?r+l:l;if(typeof m=="object")en(m,h+".",e,d);else if(typeof m=="string"||typeof m=="number")d(h,m.toString());else if(typeof m=="boolean")d(h,m?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof m}`)})},We=t=>{let r=Ue(),e=r.stackSave();try{let d=r.stackAlloc(8);r._OrtGetLastError(d,d+4);let l=r.HEAP32[d/4],m=r.HEAPU32[d/4+1],h=m?r.UTF8ToString(m):"";throw new Error(`${t} ERROR_CODE: ${l}, ERROR_MESSAGE: ${h}`)}finally{r.stackRestore(e)}};var Ga=t=>{let r=Ue(),e=0,d=[],l=t||{};try{if(t?.logSeverityLevel===void 0)l.logSeverityLevel=2;else if(typeof t.logSeverityLevel!="number"||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(t?.logVerbosityLevel===void 0)l.logVerbosityLevel=0;else if(typeof t.logVerbosityLevel!="number"||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);t?.terminate===void 0&&(l.terminate=!1);let m=0;return t?.tag!==void 0&&(m=Ke(t.tag,d)),e=r._OrtCreateRunOptions(l.logSeverityLevel,l.logVerbosityLevel,!!l.terminate,m),e===0&&We("Can\'t create run options."),t?.extra!==void 0&&en(t.extra,"",new WeakSet,(h,u)=>{let w=Ke(h,d),_=Ke(u,d);r._OrtAddRunConfigEntry(e,w,_)!==0&&We(`Can\'t set a run config entry: ${h} - ${u}.`)}),[e,d]}catch(m){throw e!==0&&r._OrtReleaseRunOptions(e),d.forEach(h=>r._free(h)),m}};var Rp=t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}},kp=t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}},Bp=t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});let r=t.extra.session;r.use_ort_model_bytes_directly||(r.use_ort_model_bytes_directly="1"),t.executionProviders&&t.executionProviders.some(e=>(typeof e=="string"?e:e.name)==="webgpu")&&(t.enableMemPattern=!1)},Mp=(t,r,e)=>{for(let d of r){let l=typeof d=="string"?d:d.name;switch(l){case"xnnpack":l="XNNPACK";break;case"webnn":if(l="WEBNN",typeof d!="string"){let h=d;if(h?.deviceType){let u=Ke("deviceType",e),w=Ke(h.deviceType,e);Ue()._OrtAddSessionConfigEntry(t,u,w)!==0&&We(`Can\'t set a session config entry: \'deviceType\' - ${h.deviceType}.`)}if(h?.powerPreference){let u=Ke("powerPreference",e),w=Ke(h.powerPreference,e);Ue()._OrtAddSessionConfigEntry(t,u,w)!==0&&We(`Can\'t set a session config entry: \'powerPreference\' - ${h.powerPreference}.`)}}break;case"webgpu":if(l="JS",typeof d!="string"){let h=d;if(h?.preferredLayout){if(h.preferredLayout!=="NCHW"&&h.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${h.preferredLayout}`);let u=Ke("preferredLayout",e),w=Ke(h.preferredLayout,e);Ue()._OrtAddSessionConfigEntry(t,u,w)!==0&&We(`Can\'t set a session config entry: \'preferredLayout\' - ${h.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${l}`)}let m=Ke(l,e);Ue()._OrtAppendExecutionProvider(t,m)!==0&&We(`Can\'t append execution provider: ${l}.`)}},Va=t=>{let r=Ue(),e=0,d=[],l=t||{};Bp(l);try{let m=Rp(l.graphOptimizationLevel??"all"),h=kp(l.executionMode??"sequential"),u=typeof l.logId=="string"?Ke(l.logId,d):0,w=l.logSeverityLevel??2;if(!Number.isInteger(w)||w<0||w>4)throw new Error(`log serverity level is not valid: ${w}`);let _=l.logVerbosityLevel??0;if(!Number.isInteger(_)||_<0||_>4)throw new Error(`log verbosity level is not valid: ${_}`);let O=typeof l.optimizedModelFilePath=="string"?Ke(l.optimizedModelFilePath,d):0;if(e=r._OrtCreateSessionOptions(m,!!l.enableCpuMemArena,!!l.enableMemPattern,h,!!l.enableProfiling,0,u,w,_,O),e===0&&We("Can\'t create session options."),l.executionProviders&&Mp(e,l.executionProviders,d),l.freeDimensionOverrides)for(let[j,B]of Object.entries(l.freeDimensionOverrides)){if(typeof j!="string")throw new Error(`free dimension override name must be a string: ${j}`);if(typeof B!="number"||!Number.isInteger(B)||B<0)throw new Error(`free dimension override value must be a non-negative integer: ${B}`);let P=Ke(j,d);r._OrtAddFreeDimensionOverride(e,P,B)!==0&&We(`Can\'t set a free dimension override: ${j} - ${B}.`)}return l.extra!==void 0&&en(l.extra,"",new WeakSet,(j,B)=>{let P=Ke(j,d),R=Ke(B,d);r._OrtAddSessionConfigEntry(e,P,R)!==0&&We(`Can\'t set a session config entry: ${j} - ${B}.`)}),[e,d]}catch(m){throw e!==0&&r._OrtReleaseSessionOptions(e),d.forEach(h=>r._free(h)),m}};Xe();var Dh=t=>{let r=Ue(),e=r.stackSave();try{let d=r.stackAlloc(8);return r._OrtGetInputOutputCount(t,d,d+4)!==0&&We("Can\'t get session input/output count."),[r.HEAP32[d/4],r.HEAP32[d/4+1]]}finally{r.stackRestore(e)}},Wh=(t,r)=>{Ue()._OrtInit(t,r)!==0&&We("Can\'t initialize onnxruntime.")},dc=async t=>{Wh(t.wasm.numThreads,nn(t.logLevel));{let r=(lc(),cr(uc)).init;await r(Ue(),t)}},cn=new Map,Ui=t=>{let r=Ue(),e=r._malloc(t.byteLength);if(e===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${t.byteLength}.`);return r.HEAPU8.set(t,e),[e,t.byteLength]},Ni=(t,r)=>{let e=Ue(),d=0,l=0,m=0,h=[],u=[],w=[];try{[l,h]=Va(r),d=e._OrtCreateSession(t[0],t[1],l),d===0&&We("Can\'t create a session.");let[_,O]=Dh(d),j=[],B=[],P=[];for(let T=0;T<_;T++){let k=e._OrtGetInputName(d,T);k===0&&We("Can\'t get an input name."),u.push(k),j.push(e.UTF8ToString(k))}for(let T=0;T<O;T++){let k=e._OrtGetOutputName(d,T);k===0&&We("Can\'t get an output name."),w.push(k);let U=e.UTF8ToString(k);B.push(U);{let K=typeof r?.preferredOutputLocation=="string"?r.preferredOutputLocation:r?.preferredOutputLocation?.[U]??"cpu";if(K!=="cpu"&&K!=="cpu-pinned"&&K!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${K}.`);P.push(K)}}let R=null;return P.some(T=>T==="gpu-buffer")&&(m=e._OrtCreateBinding(d),m===0&&We("Can\'t create IO binding."),R={handle:m,outputPreferredLocations:P,outputPreferredLocationsEncoded:P.map(T=>bi(T))}),cn.set(d,[d,u,w,R]),[d,j,B]}catch(_){throw u.forEach(O=>e._OrtFree(O)),w.forEach(O=>e._OrtFree(O)),m!==0&&e._OrtReleaseBinding(m),d!==0&&e._OrtReleaseSession(d),_}finally{e._free(t[0]),l!==0&&e._OrtReleaseSessionOptions(l),h.forEach(_=>e._free(_))}},fc=(t,r)=>{let e=Ui(t);return Ni(e,r)},pc=t=>{let r=Ue(),e=cn.get(t);if(!e)throw new Error(`cannot release session. invalid session id: ${t}`);let[d,l,m,h]=e;h&&r._OrtReleaseBinding(h.handle),r.jsepUnregisterBuffers?.(t),l.forEach(u=>r._OrtFree(u)),m.forEach(u=>r._OrtFree(u)),r._OrtReleaseSession(d),cn.delete(t)},cc=(t,r,e,d,l)=>{if(!t){r.push(0);return}let m=Ue(),h=t[0],u=t[1],w=t[3],_,O;if(h==="string"&&w==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(w==="gpu-buffer"){let P=t[2].gpuBuffer,R=rn(yi(h));O=u.reduce((T,k)=>T*k,1)*R,_=m.jsepRegisterBuffer(d,l,P,O)}else{let P=t[2];if(Array.isArray(P)){O=4*P.length,_=m._malloc(O),e.push(_);let R=_/4;for(let T=0;T<P.length;T++){if(typeof P[T]!="string")throw new TypeError(`tensor data at index ${T} is not a string`);m.HEAPU32[R++]=Ke(P[T],e)}}else O=P.byteLength,_=m._malloc(O),e.push(_),m.HEAPU8.set(new Uint8Array(P.buffer,P.byteOffset,O),_)}let j=m.stackSave(),B=m.stackAlloc(4*u.length);try{let P=B/4;u.forEach(T=>m.HEAP32[P++]=T);let R=m._OrtCreateTensor(yi(h),_,O,B,u.length,bi(w));R===0&&We(`Can\'t create tensor for input/output. session=${d}, index=${l}.`),r.push(R)}finally{m.stackRestore(j)}},mc=async(t,r,e,d,l,m)=>{let h=Ue(),u=cn.get(t);if(!u)throw new Error(`cannot run inference. invalid session id: ${t}`);let[w,_,O,j]=u,B=r.length,P=d.length,R=0,T=[],k=[],U=[],K=[],Q=h.stackSave(),L=h.stackAlloc(B*4),X=h.stackAlloc(B*4),A=h.stackAlloc(P*4),Z=h.stackAlloc(P*4);try{[R,T]=Ga(m);for(let ue=0;ue<B;ue++)cc(e[ue],k,K,t,r[ue]);for(let ue=0;ue<P;ue++)cc(l[ue],U,K,t,B+d[ue]);let re=L/4,ie=X/4,Ce=A/4,H=Z/4;for(let ue=0;ue<B;ue++)h.HEAPU32[re++]=k[ue],h.HEAPU32[ie++]=_[r[ue]];for(let ue=0;ue<P;ue++)h.HEAPU32[Ce++]=U[ue],h.HEAPU32[H++]=O[d[ue]];if(j){let{handle:ue,outputPreferredLocations:ae,outputPreferredLocationsEncoded:Ze}=j;if(_.length!==B)throw new Error(`input count from feeds (${B}) is expected to be always equal to model\'s input count (${_.length}).`);for(let Ie=0;Ie<B;Ie++){let He=r[Ie];await h._OrtBindInput(ue,_[He],k[Ie])!==0&&We(`Can\'t bind input[${Ie}] for session=${t}.`)}for(let Ie=0;Ie<P;Ie++){let He=d[Ie];l[Ie]?.[3]?h._OrtBindOutput(ue,O[He],U[Ie],0)!==0&&We(`Can\'t bind pre-allocated output[${Ie}] for session=${t}.`):h._OrtBindOutput(ue,O[He],0,Ze[He])!==0&&We(`Can\'t bind output[${Ie}] to ${ae[Ie]} for session=${t}.`)}}let le;j?le=await h._OrtRunWithBinding(w,j.handle,P,A,R):le=await h._OrtRun(w,X,L,B,Z,P,A,R),le!==0&&We("failed to call OrtRun().");let Be=[];for(let ue=0;ue<P;ue++){let ae=h.HEAPU32[A/4+ue];if(ae===U[ue]){Be.push(l[ue]);continue}let Ze=h.stackSave(),Ie=h.stackAlloc(4*4),He=!1,Ee,qe=0;try{h._OrtGetTensorData(ae,Ie,Ie+4,Ie+8,Ie+12)!==0&&We(`Can\'t access output tensor data on index ${ue}.`);let Je=Ie/4,_t=h.HEAPU32[Je++];qe=h.HEAPU32[Je++];let ee=h.HEAPU32[Je++],$e=h.HEAPU32[Je++],Oe=[];for(let Ge=0;Ge<$e;Ge++)Oe.push(h.HEAPU32[ee/4+Ge]);h._OrtFree(ee);let et=Oe.reduce((Ge,Me)=>Ge*Me,1);Ee=tn(_t);let tt=j?.outputPreferredLocations[d[ue]];if(Ee==="string"){if(tt==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Ge=[],Me=qe/4;for(let rt=0;rt<et;rt++){let yt=h.HEAPU32[Me++],ut=rt===et-1?void 0:h.HEAPU32[Me]-yt;Ge.push(h.UTF8ToString(yt,ut))}Be.push([Ee,Oe,Ge,"cpu"])}else if(tt==="gpu-buffer"&&et>0){let Ge=h.jsepGetBuffer(qe),Me=rn(_t);if(Me===void 0||!Ua(Ee))throw new Error(`Unsupported data type: ${Ee}`);He=!0,Be.push([Ee,Oe,{gpuBuffer:Ge,download:h.jsepCreateDownloader(Ge,et*Me,Ee),dispose:()=>{h._OrtReleaseTensor(ae)}},"gpu-buffer"])}else{let Ge=zn(Ee),Me=new Ge(et);new Uint8Array(Me.buffer,Me.byteOffset,Me.byteLength).set(h.HEAPU8.subarray(qe,qe+Me.byteLength)),Be.push([Ee,Oe,Me,"cpu"])}}finally{h.stackRestore(Ze),Ee==="string"&&qe&&h._free(qe),He||h._OrtReleaseTensor(ae)}}return j&&h._OrtClearBoundOutputs(j.handle),Be}finally{h.stackRestore(Q),k.forEach(re=>h._OrtReleaseTensor(re)),U.forEach(re=>h._OrtReleaseTensor(re)),K.forEach(re=>h._free(re)),R!==0&&h._OrtReleaseRunOptions(R),T.forEach(re=>h._free(re))}},hc=t=>{let r=Ue(),e=cn.get(t);if(!e)throw new Error("invalid session id");let d=e[0],l=r._OrtEndProfiling(d);l===0&&We("Can\'t get an profile file name."),r._OrtFree(l)},gc=t=>{let r=[];for(let e of t){let d=e[2];!Array.isArray(d)&&"buffer"in d&&r.push(d.buffer)}return r};self.onmessage=t=>{switch(t.data.type){case"init-wasm":try{za(t.data.in).then(()=>postMessage({type:"init-wasm"}),r=>postMessage({type:"init-wasm",err:r}))}catch(r){postMessage({type:"init-wasm",err:r})}break;case"init-ort":try{dc(t.data.in).then(()=>postMessage({type:"init-ort"}),r=>postMessage({type:"init-ort",err:r}))}catch(r){postMessage({type:"init-ort",err:r})}break;case"create_allocate":try{let{model:r}=t.data.in,e=Ui(r);postMessage({type:"create_allocate",out:e})}catch(r){postMessage({type:"create_allocate",err:r})}break;case"create_finalize":try{let{modeldata:r,options:e}=t.data.in,d=Ni(r,e);postMessage({type:"create_finalize",out:d})}catch(r){postMessage({type:"create_finalize",err:r})}break;case"create":try{let{model:r,options:e}=t.data.in,d=fc(r,e);postMessage({type:"create",out:d})}catch(r){postMessage({type:"create",err:r})}break;case"release":try{let r=t.data.in;pc(r),postMessage({type:"release"})}catch(r){postMessage({type:"release",err:r})}break;case"run":try{let{sessionId:r,inputIndices:e,inputs:d,outputIndices:l,options:m}=t.data.in;mc(r,e,d,l,m).then(h=>{postMessage({type:"run",out:h},gc(h))},h=>{postMessage({type:"run",err:h})})}catch(r){postMessage({type:"run",err:r})}break;case"end-profiling":try{let r=t.data.in;hc(r),postMessage({type:"end-profiling"})}catch(r){postMessage({type:"end-profiling",err:r})}break;default:}};})();\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n'});var Bt,lt,Sn,$a,Ca,pa,ha,ma,ga,ya,va,ba,wa,tr,Yg,xn,dc,cc,fc,pc,_a,hc,mc,gc,xa=ie(()=>{"use strict";Qt();uc();Cr();Bt=()=>!!ze.wasm.proxy&&typeof document<"u",Sn=!1,$a=!1,Ca=!1,ma=[],ga=[],ya=[],va=[],ba=[],wa=[],tr=()=>{if(Sn||!$a||Ca||!lt)throw new Error("worker not ready")},Yg=t=>{switch(t.data.type){case"init-wasm":Sn=!1,t.data.err?(Ca=!0,pa[1](t.data.err)):($a=!0,pa[0]());break;case"init-ort":t.data.err?ha[1](t.data.err):ha[0]();break;case"create_allocate":t.data.err?ma.shift()[1](t.data.err):ma.shift()[0](t.data.out);break;case"create_finalize":t.data.err?ga.shift()[1](t.data.err):ga.shift()[0](t.data.out);break;case"create":t.data.err?ya.shift()[1](t.data.err):ya.shift()[0](t.data.out);break;case"release":t.data.err?va.shift()[1](t.data.err):va.shift()[0]();break;case"run":t.data.err?ba.shift()[1](t.data.err):ba.shift()[0](t.data.out);break;case"end-profiling":t.data.err?wa.shift()[1](t.data.err):wa.shift()[0]();break;default:}},xn=typeof document<"u"?document?.currentScript?.src:void 0,dc=async()=>{if(Bt()){if($a)return;if(Sn)throw new Error("multiple calls to 'initWasm()' detected.");if(Ca)throw new Error("previous call to 'initWasm()' failed.");return Sn=!0,ze.wasm.wasmPaths===void 0&&xn&&xn.indexOf("blob:")!==0&&(ze.wasm.wasmPaths=xn.substr(0,+xn.lastIndexOf("/")+1)),new Promise((t,r)=>{lt?.terminate();let e=URL.createObjectURL(new Blob([lc()],{type:"text/javascript"}));lt=new Worker(e,{name:"ort-wasm-proxy-worker"}),lt.onerror=u=>r(u),lt.onmessage=Yg,URL.revokeObjectURL(e),pa=[t,r];let d={type:"init-wasm",in:ze.wasm};lt.postMessage(d)})}else return qs(ze.wasm)},cc=async t=>{if(Bt())return tr(),new Promise((r,e)=>{ha=[r,e];let d={type:"init-ort",in:t};lt.postMessage(d)});await rc(t)},fc=async t=>Bt()?(tr(),new Promise((r,e)=>{ma.push([r,e]);let d={type:"create_allocate",in:{model:t}};lt.postMessage(d,[t.buffer])})):ca(t),pc=async(t,r)=>Bt()?(tr(),new Promise((e,d)=>{ga.push([e,d]);let u={type:"create_finalize",in:{modeldata:t,options:r}};lt.postMessage(u)})):fa(t,r),_a=async(t,r)=>{if(Bt()){if(r?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return tr(),new Promise((e,d)=>{ya.push([e,d]);let u={type:"create",in:{model:t,options:r}};lt.postMessage(u,[t.buffer])})}else return ic(t,r)},hc=async t=>{if(Bt())return tr(),new Promise((r,e)=>{va.push([r,e]);let d={type:"release",in:t};lt.postMessage(d)});nc(t)},mc=async(t,r,e,d,u,h)=>{if(Bt()){if(e.some(m=>m[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(u.some(m=>m))throw new Error("pre-allocated output tensor is not supported for proxy.");return tr(),new Promise((m,o)=>{ba.push([m,o]);let y=e,$={type:"run",in:{sessionId:t,inputIndices:r,inputs:y,outputIndices:d,options:h}};lt.postMessage($,sc(y))})}else return ac(t,r,e,d,u,h)},gc=async t=>{if(Bt())return tr(),new Promise((r,e)=>{wa.push([r,e]);let d={type:"end-profiling",in:t};lt.postMessage(d)});oc(t)}});var yc,In,vc,Xg,An,bc=ie(()=>{"use strict";Qt();xa();Ye();vc=(t,r)=>{switch(t.location){case"cpu":return[t.type,t.dims,t.data,"cpu"];case"gpu-buffer":return[t.type,t.dims,{gpuBuffer:t.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${t.location} for ${r()}`)}},Xg=t=>{switch(t[3]){case"cpu":return new xt(t[0],t[2],t[1]);case"gpu-buffer":{let r=t[0];if(!rn(r))throw new Error(`not supported data type: ${r} for deserializing GPU tensor`);let{gpuBuffer:e,download:d,dispose:u}=t[2];return xt.fromGpuBuffer(e,{dataType:r,dims:t[1],download:d,dispose:u})}default:throw new Error(`invalid data location: ${t[3]}`)}},An=class{async createSessionAllocate(r){let e=await fetch(r);if(e.status!==200)throw new Error(`failed to load model: ${r}`);let d=await e.arrayBuffer();return fc(new Uint8Array(d))}async loadModel(r,e){if(yc||(In||(In=cc(ze)),await In,In=void 0,yc=!0),typeof r=="string")if(typeof process<"u"&&process.versions&&process.versions.node){let d=await(void 0)(r);[this.sessionId,this.inputNames,this.outputNames]=await _a(d,e)}else{let d=await this.createSessionAllocate(r);[this.sessionId,this.inputNames,this.outputNames]=await pc(d,e)}else[this.sessionId,this.inputNames,this.outputNames]=await _a(r,e)}async dispose(){return hc(this.sessionId)}async run(r,e,d){let u=[],h=[];Object.entries(r).forEach(O=>{let R=O[0],j=O[1],k=this.inputNames.indexOf(R);if(k===-1)throw new Error(`invalid input '${R}'`);u.push(j),h.push(k)});let m=[],o=[];Object.entries(e).forEach(O=>{let R=O[0],j=O[1],k=this.outputNames.indexOf(R);if(k===-1)throw new Error(`invalid output '${R}'`);m.push(j),o.push(k)});let y=u.map((O,R)=>vc(O,()=>`input "${this.inputNames[h[R]]}"`)),$=m.map((O,R)=>O?vc(O,()=>`output "${this.outputNames[o[R]]}"`):null),A=await mc(this.sessionId,h,y,o,$,d),T={};for(let O=0;O<A.length;O++)T[this.outputNames[o[O]]]=m[O]??Xg(A[O]);return T}startProfiling(){}endProfiling(){gc(this.sessionId)}}});var Qg,En,wc=ie(()=>{"use strict";Qt();xa();bc();Qg=()=>{if((typeof ze.wasm.initTimeout!="number"||ze.wasm.initTimeout<0)&&(ze.wasm.initTimeout=0),typeof ze.wasm.simd!="boolean"&&(ze.wasm.simd=!0),typeof ze.wasm.proxy!="boolean"&&(ze.wasm.proxy=!1),typeof ze.wasm.numThreads!="number"||!Number.isInteger(ze.wasm.numThreads)||ze.wasm.numThreads<=0){let t=typeof navigator>"u"?(void 0)().length:navigator.hardwareConcurrency;ze.wasm.numThreads=Math.min(4,Math.ceil((t||1)/2))}},En=class{async init(){Qg(),await dc()}async createInferenceSessionHandler(r,e){let d=new An;return await d.loadModel(r,e),Promise.resolve(d)}}});var $c={};$r($c,{wasmBackend:()=>Jg});var Jg,Cc=ie(()=>{"use strict";wc();Jg=new En});var Zg={};$r(Zg,{InferenceSession:()=>Th,Tensor:()=>xt,TrainingSession:()=>Rh,env:()=>ze,registerBackend:()=>jt});module.exports=kt(Zg);Qt();Qt();var js="1.17.0";{let t=(Cc(),kt($c)).wasmBackend;typeof navigator<"u"&&navigator.gpu&&jt("webgpu",t,5),jt("cpu",t,10),jt("wasm",t,10),jt("xnnpack",t,9),jt("webnn",t,9)}Object.defineProperty(ze.versions,"web",{value:js,enumerable:!0});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
//# sourceMappingURL=ort.webgpu.min.js.map
