/*!
 * ONNX Runtime Web v1.17.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var jn=Object.defineProperty;var yd=Object.getOwnPropertyDescriptor;var bd=Object.getOwnPropertyNames;var vd=Object.prototype.hasOwnProperty;var j=(e,t)=>()=>(e&&(t=e(e=0)),t);var nr=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),ar=(e,t)=>{for(var r in t)jn(e,r,{get:t[r],enumerable:!0})},wd=(e,t,r,a)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of bd(t))!vd.call(e,o)&&o!==r&&jn(e,o,{get:()=>t[o],enumerable:!(a=yd(t,o))||a.enumerable});return e};var Ft=e=>wd(jn({},"__esModule",{value:!0}),e);var Jr,Lt,Ot,Zr,Qr=j(()=>{Jr=new Map,Lt=[],Ot=(e,t,r)=>{if(t&&typeof t.init=="function"&&typeof t.createInferenceSessionHandler=="function"){let a=Jr.get(e);if(a===void 0)Jr.set(e,{backend:t,priority:r});else{if(a.priority>r)return;if(a.priority===r&&a.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${r}`)}if(r>=0){let o=Lt.indexOf(e);o!==-1&&Lt.splice(o,1);for(let u=0;u<Lt.length;u++)if(Jr.get(Lt[u]).priority<=r){Lt.splice(u,0,e);return}Lt.push(e)}return}throw new TypeError("not a valid backend")},Zr=async e=>{let t=e.length===0?Lt:e,r=[];for(let a of t){let o=Jr.get(a);if(o){if(o.initialized)return o.backend;if(o.aborted)continue;let u=!!o.initPromise;try{return u||(o.initPromise=o.backend.init()),await o.initPromise,o.initialized=!0,o.backend}catch(i){u||r.push({name:a,err:i}),o.aborted=!0}finally{delete o.initPromise}}}throw new Error(`no available backend found. ERR: ${r.map(a=>`[${a.name}] ${a.err}`).join(", ")}`)}});var Co=j(()=>{Qr()});var Ao,Io=j(()=>{Ao="1.17.0"});var _o,qn,Oo=j(()=>{Io();_o="warning",qn={wasm:{},webgl:{},webgpu:{},versions:{common:Ao},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);_o=e}},get logLevel(){return _o}};Object.defineProperty(qn,"logLevel",{enumerable:!0})});var Ie,To=j(()=>{Oo();Ie=qn});var Eo,Ro,Po=j(()=>{Eo=(e,t)=>{let r=document.createElement("canvas");r.width=e.dims[3],r.height=e.dims[2];let a=r.getContext("2d");if(a!=null){let o,u;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(o=e.dims[2],u=e.dims[3]):(o=e.dims[3],u=e.dims[2]);let i=t?.format!==void 0?t.format:"RGB",l=t?.norm,p,m;l===void 0||l.mean===void 0?p=[255,255,255,255]:typeof l.mean=="number"?p=[l.mean,l.mean,l.mean,l.mean]:(p=[l.mean[0],l.mean[1],l.mean[2],0],l.mean[3]!==void 0&&(p[3]=l.mean[3])),l===void 0||l.bias===void 0?m=[0,0,0,0]:typeof l.bias=="number"?m=[l.bias,l.bias,l.bias,l.bias]:(m=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(m[3]=l.bias[3]));let d=u*o,v=0,y=d,w=d*2,x=-1;i==="RGBA"?(v=0,y=d,w=d*2,x=d*3):i==="RGB"?(v=0,y=d,w=d*2):i==="RBG"&&(v=0,w=d,y=d*2);for(let $=0;$<u;$++)for(let A=0;A<o;A++){let k=(e.data[v++]-m[0])*p[0],O=(e.data[y++]-m[1])*p[1],T=(e.data[w++]-m[2])*p[2],R=x===-1?255:(e.data[x++]-m[3])*p[3];a.fillStyle="rgba("+k+","+O+","+T+","+R+")",a.fillRect(A,$,1,1)}return r.toDataURL()}else throw new Error("Can not access image data")},Ro=(e,t)=>{let r=document.createElement("canvas").getContext("2d"),a;if(r!=null){let o,u,i;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(o=e.dims[2],u=e.dims[1],i=e.dims[3]):(o=e.dims[3],u=e.dims[2],i=e.dims[1]);let l=t!==void 0&&t.format!==void 0?t.format:"RGB",p=t?.norm,m,d;p===void 0||p.mean===void 0?m=[255,255,255,255]:typeof p.mean=="number"?m=[p.mean,p.mean,p.mean,p.mean]:(m=[p.mean[0],p.mean[1],p.mean[2],255],p.mean[3]!==void 0&&(m[3]=p.mean[3])),p===void 0||p.bias===void 0?d=[0,0,0,0]:typeof p.bias=="number"?d=[p.bias,p.bias,p.bias,p.bias]:(d=[p.bias[0],p.bias[1],p.bias[2],0],p.bias[3]!==void 0&&(d[3]=p.bias[3]));let v=u*o;if(t!==void 0&&(t.format!==void 0&&i===4&&t.format!=="RGBA"||i===3&&t.format!=="RGB"&&t.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let y=4,w=0,x=1,$=2,A=3,k=0,O=v,T=v*2,R=-1;l==="RGBA"?(k=0,O=v,T=v*2,R=v*3):l==="RGB"?(k=0,O=v,T=v*2):l==="RBG"&&(k=0,T=v,O=v*2),a=r.createImageData(o,u);for(let z=0;z<u*o;w+=y,x+=y,$+=y,A+=y,z++)a.data[w]=(e.data[k++]-d[0])*m[0],a.data[x]=(e.data[O++]-d[1])*m[1],a.data[$]=(e.data[T++]-d[2])*m[2],a.data[A]=R===-1?255:(e.data[R++]-d[3])*m[3]}else throw new Error("Can not access image data");return a}});var Kn,ko,Bo,Mo,Do,zo=j(()=>{en();Kn=(e,t)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(t.height===void 0||t.width===void 0)throw new Error("Image height and width must be defined");if(t.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:r,width:a}=t,o=t.norm??{mean:255,bias:0},u,i;typeof o.mean=="number"?u=[o.mean,o.mean,o.mean,o.mean]:u=[o.mean[0],o.mean[1],o.mean[2],o.mean[3]??255],typeof o.bias=="number"?i=[o.bias,o.bias,o.bias,o.bias]:i=[o.bias[0],o.bias[1],o.bias[2],o.bias[3]??0];let l=t.format!==void 0?t.format:"RGBA",p=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:"RGB",m=r*a,d=p==="RGBA"?new Float32Array(m*4):new Float32Array(m*3),v=4,y=0,w=1,x=2,$=3,A=0,k=m,O=m*2,T=-1;l==="RGB"&&(v=3,y=0,w=1,x=2,$=-1),p==="RGBA"?T=m*3:p==="RBG"?(A=0,O=m,k=m*2):p==="BGR"&&(O=0,k=m,A=m*2);for(let z=0;z<m;z++,y+=v,x+=v,w+=v,$+=v)d[A++]=(e[y]+i[0])/u[0],d[k++]=(e[w]+i[1])/u[1],d[O++]=(e[x]+i[2])/u[2],T!==-1&&$!==-1&&(d[T++]=(e[$]+i[3])/u[3]);return p==="RGBA"?new Le("float32",d,[1,4,r,a]):new Le("float32",d,[1,3,r,a])},ko=async(e,t)=>{let r=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,a=typeof ImageData<"u"&&e instanceof ImageData,o=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,u=typeof e=="string",i,l=t??{};if(r){let p=document.createElement("canvas");p.width=e.width,p.height=e.height;let m=p.getContext("2d");if(m!=null){let d=e.height,v=e.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(d=t.resizedHeight,v=t.resizedWidth),t!==void 0){if(l=t,t.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");l.tensorFormat="RGBA",l.height=d,l.width=v}else l.tensorFormat="RGBA",l.height=d,l.width=v;m.drawImage(e,0,0),i=m.getImageData(0,0,v,d).data}else throw new Error("Can not access image data")}else if(a){let p,m;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(p=t.resizedHeight,m=t.resizedWidth):(p=e.height,m=e.width),t!==void 0&&(l=t),l.format="RGBA",l.height=p,l.width=m,t!==void 0){let d=document.createElement("canvas");d.width=m,d.height=p;let v=d.getContext("2d");if(v!=null)v.putImageData(e,0,0),i=v.getImageData(0,0,m,p).data;else throw new Error("Can not access image data")}else i=e.data}else if(o){if(t===void 0)throw new Error("Please provide image config with format for Imagebitmap");let p=document.createElement("canvas");p.width=e.width,p.height=e.height;let m=p.getContext("2d");if(m!=null){let d=e.height,v=e.width;return m.drawImage(e,0,0,v,d),i=m.getImageData(0,0,v,d).data,l.height=d,l.width=v,Kn(i,l)}else throw new Error("Can not access image data")}else{if(u)return new Promise((p,m)=>{let d=document.createElement("canvas"),v=d.getContext("2d");if(!e||!v)return m();let y=new Image;y.crossOrigin="Anonymous",y.src=e,y.onload=()=>{d.width=y.width,d.height=y.height,v.drawImage(y,0,0,d.width,d.height);let w=v.getImageData(0,0,d.width,d.height);l.height=d.height,l.width=d.width,p(Kn(w.data,l))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(i!==void 0)return Kn(i,l);throw new Error("Input data provided is not supported - aborted tensor creation")},Bo=(e,t)=>{let{width:r,height:a,download:o,dispose:u}=t,i=[1,a,r,4];return new Le({location:"texture",type:"float32",texture:e,dims:i,download:o,dispose:u})},Mo=(e,t)=>{let{dataType:r,dims:a,download:o,dispose:u}=t;return new Le({location:"gpu-buffer",type:r??"float32",gpuBuffer:e,dims:a,download:o,dispose:u})},Do=(e,t,r)=>new Le({location:"cpu-pinned",type:e,data:t,dims:r??[t.length]})});var Sr,tn,Wo,Vo,No=j(()=>{Sr=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),tn=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),Wo=!1,Vo=()=>{if(!Wo){Wo=!0;let e=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",t=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function";e&&(Sr.set("int64",BigInt64Array),tn.set(BigInt64Array,"int64")),t&&(Sr.set("uint64",BigUint64Array),tn.set(BigUint64Array,"uint64"))}}});var Uo,Go,Fo=j(()=>{en();Uo=e=>{let t=1;for(let r=0;r<e.length;r++){let a=e[r];if(typeof a!="number"||!Number.isSafeInteger(a))throw new TypeError(`dims[${r}] must be an integer, got: ${a}`);if(a<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${a}`);t*=a}return t},Go=(e,t)=>{switch(e.location){case"cpu":return new Le(e.type,e.data,t);case"cpu-pinned":return new Le({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new Le({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new Le({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}});var Le,en=j(()=>{Po();zo();No();Fo();Le=class{constructor(t,r,a){Vo();let o,u;if(typeof t=="object"&&"location"in t)switch(this.dataLocation=t.location,o=t.type,u=t.dims,t.location){case"cpu-pinned":{let l=Sr.get(o);if(!l)throw new TypeError(`unsupported type "${o}" to create tensor from pinned buffer`);if(!(t.data instanceof l))throw new TypeError(`buffer should be of type ${l.name}`);this.cpuData=t.data;break}case"texture":{if(o!=="float32")throw new TypeError(`unsupported type "${o}" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case"gpu-buffer":{if(o!=="float32"&&o!=="float16"&&o!=="int32"&&o!=="int64"&&o!=="uint32"&&o!=="bool")throw new TypeError(`unsupported type "${o}" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let l,p;if(typeof t=="string")if(o=t,p=a,t==="string"){if(!Array.isArray(r))throw new TypeError("A string tensor's data must be a string array.");l=r}else{let m=Sr.get(t);if(m===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(r)){if(t==="float16")throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");t==="uint64"||t==="int64"?l=m.from(r,BigInt):l=m.from(r)}else if(r instanceof m)l=r;else throw new TypeError(`A ${o} tensor's data must be type of ${m}`)}else if(p=r,Array.isArray(t)){if(t.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let m=typeof t[0];if(m==="string")o="string",l=t;else if(m==="boolean")o="bool",l=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${m}.`)}else{let m=tn.get(t.constructor);if(m===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);o=m,l=t}if(p===void 0)p=[l.length];else if(!Array.isArray(p))throw new TypeError("A tensor's dims must be a number array");u=p,this.cpuData=l,this.dataLocation="cpu"}let i=Uo(u);if(this.cpuData&&i!==this.cpuData.length)throw new Error(`Tensor's size(${i}) does not match data length(${this.cpuData.length}).`);this.type=o,this.dims=u,this.size=i}static async fromImage(t,r){return ko(t,r)}static fromTexture(t,r){return Bo(t,r)}static fromGpuBuffer(t,r){return Mo(t,r)}static fromPinnedBuffer(t,r,a){return Do(t,r,a)}toDataURL(t){return Eo(this,t)}toImageData(t){return Ro(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(t){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let r=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=r,t&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return Go(this,t)}}});var Ge,rn=j(()=>{en();Ge=Le});var nn,Lo=j(()=>{Qr();rn();nn=class e{constructor(t){this.handler=t}async run(t,r,a){let o={},u={};if(typeof t!="object"||t===null||t instanceof Ge||Array.isArray(t))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let i=!0;if(typeof r=="object"){if(r===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof Ge)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(r.length===0)throw new TypeError("'fetches' cannot be an empty array.");i=!1;for(let m of r){if(typeof m!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(m)===-1)throw new RangeError(`'fetches' contains invalid output name: ${m}.`);o[m]=null}if(typeof a=="object"&&a!==null)u=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else{let m=!1,d=Object.getOwnPropertyNames(r);for(let v of this.outputNames)if(d.indexOf(v)!==-1){let y=r[v];(y===null||y instanceof Ge)&&(m=!0,i=!1,o[v]=y)}if(m){if(typeof a=="object"&&a!==null)u=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else u=r}}else if(typeof r<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let m of this.inputNames)if(typeof t[m]>"u")throw new Error(`input '${m}' is missing in 'feeds'.`);if(i)for(let m of this.outputNames)o[m]=null;let l=await this.handler.run(t,o,u),p={};for(let m in l)if(Object.hasOwnProperty.call(l,m)){let d=l[m];d instanceof Ge?p[m]=d:p[m]=new Ge(d.type,d.data,d.dims)}return p}async release(){return this.handler.dispose()}static async create(t,r,a,o){let u,i={};if(typeof t=="string"){if(u=t,typeof r=="object"&&r!==null)i=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(u=t,typeof r=="object"&&r!==null)i=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer){let v=t,y=0,w=t.byteLength;if(typeof r=="object"&&r!==null)i=r;else if(typeof r=="number"){if(y=r,!Number.isSafeInteger(y))throw new RangeError("'byteOffset' must be an integer.");if(y<0||y>=v.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${v.byteLength}).`);if(w=t.byteLength-y,typeof a=="number"){if(w=a,!Number.isSafeInteger(w))throw new RangeError("'byteLength' must be an integer.");if(w<=0||y+w>v.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${v.byteLength-y}].`);if(typeof o=="object"&&o!==null)i=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else if(typeof a<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof r<"u")throw new TypeError("'options' must be an object.");u=new Uint8Array(v,y,w)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let p=(i.executionProviders||[]).map(v=>typeof v=="string"?v:v.name),d=await(await Zr(p)).createInferenceSessionHandler(u,i);return new e(d)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var $d,Ho=j(()=>{Lo();$d=nn});var jo=j(()=>{});var xd,an,qo=j(()=>{Qr();rn();xd="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",an=class e{constructor(t){this.handler=t}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}static async create(t,r){let a=t.evalModel||"",o=t.optimizerModel||"",u=r||{},l=(u.executionProviders||[]).map(m=>typeof m=="string"?m:m.name),p=await Zr(l);if(p.createTrainingSessionHandler){let m=await p.createTrainingSessionHandler(t.checkpointState,t.trainModel,a,o,u);return new e(m)}else throw new Error(xd)}typeNarrowingForRunStep(t,r,a){let o={},u={};if(typeof t!="object"||t===null||t instanceof Ge||Array.isArray(t))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let i=!0;if(typeof r=="object"){if(r===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof Ge)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(r.length===0)throw new TypeError("'fetches' cannot be an empty array.");i=!1;for(let l of r){if(typeof l!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(l)===-1)throw new RangeError(`'fetches' contains invalid output name: ${l}.`);o[l]=null}if(typeof a=="object"&&a!==null)u=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else{let l=!1,p=Object.getOwnPropertyNames(r);for(let m of this.outputNames)if(p.indexOf(m)!==-1){let d=r[m];(d===null||d instanceof Ge)&&(l=!0,i=!1,o[m]=d)}if(l){if(typeof a=="object"&&a!==null)u=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else u=r}}else if(typeof r<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let l of this.inputNames)if(typeof t[l]>"u")throw new Error(`input '${l}' is missing in 'feeds'.`);if(i)for(let l of this.outputNames)o[l]=null;return[o,u]}convertHandlerReturnTypeToMapOfTensors(t){let r={};for(let a in t)if(Object.hasOwnProperty.call(t,a)){let o=t[a];o instanceof Ge?r[a]=o:r[a]=new Ge(o.type,o.data,o.dims)}return r}async runTrainStep(t,r,a){let[o,u]=this.typeNarrowingForRunStep(t,r,a),i=await this.handler.runTrainStep(t,o,u);return this.convertHandlerReturnTypeToMapOfTensors(i)}async loadParametersBuffer(t,r){throw new Error("Method not implemented.")}async getContiguousParameters(t){throw new Error("Method not implemented.")}async release(){return this.handler.dispose()}}});var Sd,Ko=j(()=>{qo();Sd=an});var Yn={};ar(Yn,{InferenceSession:()=>$d,Tensor:()=>Ge,TrainingSession:()=>Sd,env:()=>Ie,registerBackend:()=>Ot});var Tt=j(()=>{Co();To();Ho();rn();jo();Ko()});var Xn={};ar(Xn,{readFile:()=>Cd});var Cd,Jn=j(()=>{Cd=void 0});var Zn={};ar(Zn,{join:()=>Ad});var Ad,Qn=j(()=>{Ad=void 0});var Zo=nr((Jo,ea)=>{"use strict";var Xo=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){var r=t,a,o;r.ready=new Promise((c,h)=>{a=c,o=h}),r.jsepInit=(c,h,b,S,I,N,F,re)=>{r.ab=c,r.Ra=h,r.Ta=b,r.La=S,r.Sa=I,r.xa=N,r.Ua=F,r.Va=re,h=(X,oe,ne)=>(...me)=>{let ye=Xe,P=oe?.();me=X(...me);let se=oe?.();return P!==se&&(X=se,ne(P),oe=ne=null),Xe!=ye?mr():me},b=X=>async(...oe)=>{try{if(r.Fa)throw Error("Session already started");let ne=r.Fa={Wa:oe[0],errors:[]},me=await X(...oe);if(r.Fa!==ne)throw Error("Session mismatch");c.flush();let ye=ne.errors;if(0<ye.length){let P=await Promise.all(ye);if(P=P.filter(se=>se),0<P.length)throw Error(P.join(`
`))}return me}finally{r.Fa=null}},r._OrtRun=b(h(r._OrtRun,()=>r._OrtRun,X=>r._OrtRun=X)),r._OrtRunWithBinding=b(h(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,X=>r._OrtRunWithBinding=X)),r._OrtBindInput=h(r._OrtBindInput,()=>r._OrtBindInput,X=>r._OrtBindInput=X),r.jsepRegisterBuffer=(X,oe,ne,me)=>c.registerBuffer(X,oe,ne,me),r.jsepUnregisterBuffers=X=>{c.unregisterBuffers(X)},r.jsepGetBuffer=X=>c.getBuffer(X),r.jsepCreateDownloader=(X,oe,ne)=>c.createDownloader(X,oe,ne)};var u=Object.assign({},r),i="./this.program",l=(c,h)=>{throw h},p=typeof window=="object",m=typeof importScripts=="function",d=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",v="",y,w,x;if(d){var $=(Jn(),Ft(Xn)),A=(Qn(),Ft(Zn));v=m?A.dirname(v)+"/":__dirname+"/",y=(c,h)=>(c=c.startsWith("file://")?new URL(c):A.normalize(c),$.readFileSync(c,h?void 0:"utf8")),x=c=>(c=y(c,!0),c.buffer||(c=new Uint8Array(c)),c),w=(c,h,b,S=!0)=>{c=c.startsWith("file://")?new URL(c):A.normalize(c),$.readFile(c,S?void 0:"utf8",(I,N)=>{I?b(I):h(S?N.buffer:N)})},!r.thisProgram&&1<process.argv.length&&(i=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),l=(c,h)=>{throw process.exitCode=c,h},r.inspect=()=>"[Emscripten Module object]"}else(p||m)&&(m?v=self.location.href:typeof document<"u"&&document.currentScript&&(v=document.currentScript.src),e&&(v=e),v.indexOf("blob:")!==0?v=v.substr(0,v.replace(/[?#].*/,"").lastIndexOf("/")+1):v="",y=c=>{var h=new XMLHttpRequest;return h.open("GET",c,!1),h.send(null),h.responseText},m&&(x=c=>{var h=new XMLHttpRequest;return h.open("GET",c,!1),h.responseType="arraybuffer",h.send(null),new Uint8Array(h.response)}),w=(c,h,b)=>{var S=new XMLHttpRequest;S.open("GET",c,!0),S.responseType="arraybuffer",S.onload=()=>{S.status==200||S.status==0&&S.response?h(S.response):b()},S.onerror=b,S.send(null)});var k=r.print||console.log.bind(console),O=r.printErr||console.error.bind(console);Object.assign(r,u),u=null,r.thisProgram&&(i=r.thisProgram),r.quit&&(l=r.quit);var T;r.wasmBinary&&(T=r.wasmBinary);var R=r.noExitRuntime||!0;typeof WebAssembly!="object"&&G("no native wasm support detected");var z,M,W=!1,K,ee,ae,D,te,_e,Z;function we(){var c=z.buffer;r.HEAP8=ee=new Int8Array(c),r.HEAP16=new Int16Array(c),r.HEAP32=D=new Int32Array(c),r.HEAPU8=ae=new Uint8Array(c),r.HEAPU16=new Uint16Array(c),r.HEAPU32=te=new Uint32Array(c),r.HEAPF32=_e=new Float32Array(c),r.HEAPF64=Z=new Float64Array(c)}var Oe,be=[],De=[],Se=[];function Ue(){var c=r.preRun.shift();be.unshift(c)}var Je=0,Ze=null,Qe=null;function G(c){throw r.onAbort&&r.onAbort(c),c="Aborted("+c+")",O(c),W=!0,K=1,c=new WebAssembly.RuntimeError(c+". Build with -sASSERTIONS for more info."),o(c),c}function pe(c){return c.startsWith("data:application/octet-stream;base64,")}var ce;if(ce="ort-wasm-simd.wasm",!pe(ce)){var Fe=ce;ce=r.locateFile?r.locateFile(Fe,v):v+Fe}function He(c){if(c==ce&&T)return new Uint8Array(T);if(x)return x(c);throw"both async and sync fetching of the wasm failed"}function Ce(c){if(!T&&(p||m)){if(typeof fetch=="function"&&!c.startsWith("file://"))return fetch(c,{credentials:"same-origin"}).then(h=>{if(!h.ok)throw"failed to load wasm binary file at '"+c+"'";return h.arrayBuffer()}).catch(()=>He(c));if(w)return new Promise((h,b)=>{w(c,S=>h(new Uint8Array(S)),b)})}return Promise.resolve().then(()=>He(c))}function Pe(c,h,b){return Ce(c).then(S=>WebAssembly.instantiate(S,h)).then(S=>S).then(b,S=>{O("failed to asynchronously prepare wasm: "+S),G(S)})}function At(c,h){var b=ce;return T||typeof WebAssembly.instantiateStreaming!="function"||pe(b)||b.startsWith("file://")||d||typeof fetch!="function"?Pe(b,c,h):fetch(b,{credentials:"same-origin"}).then(S=>WebAssembly.instantiateStreaming(S,c).then(h,function(I){return O("wasm streaming compile failed: "+I),O("falling back to ArrayBuffer instantiation"),Pe(b,c,h)}))}var Ye,Kt={916496:c=>{r.xa("Abs",c,void 0)},916547:c=>{r.xa("Neg",c,void 0)},916598:c=>{r.xa("Floor",c,void 0)},916651:c=>{r.xa("Ceil",c,void 0)},916703:c=>{r.xa("Reciprocal",c,void 0)},916761:c=>{r.xa("Sqrt",c,void 0)},916813:c=>{r.xa("Exp",c,void 0)},916864:c=>{r.xa("Erf",c,void 0)},916915:c=>{r.xa("Sigmoid",c,void 0)},916970:c=>{r.xa("Log",c,void 0)},917021:c=>{r.xa("Sin",c,void 0)},917072:c=>{r.xa("Cos",c,void 0)},917123:c=>{r.xa("Tan",c,void 0)},917174:c=>{r.xa("Asin",c,void 0)},917226:c=>{r.xa("Acos",c,void 0)},917278:c=>{r.xa("Atan",c,void 0)},917330:c=>{r.xa("Sinh",c,void 0)},917382:c=>{r.xa("Cosh",c,void 0)},917434:c=>{r.xa("Asinh",c,void 0)},917487:c=>{r.xa("Acosh",c,void 0)},917540:c=>{r.xa("Atanh",c,void 0)},917593:c=>{r.xa("Tanh",c,void 0)},917645:c=>{r.xa("Not",c,void 0)},917696:(c,h,b)=>{r.xa("ClipV10",c,{min:h,max:b})},917768:c=>{r.xa("Clip",c,void 0)},917820:(c,h)=>{r.xa("Elu",c,{alpha:h})},917878:c=>{r.xa("Relu",c,void 0)},917930:(c,h)=>{r.xa("LeakyRelu",c,{alpha:h})},917994:(c,h)=>{r.xa("ThresholdedRelu",c,{alpha:h})},918064:(c,h)=>{r.xa("Cast",c,{to:h})},918122:c=>{r.xa("Add",c,void 0)},918173:c=>{r.xa("Sub",c,void 0)},918224:c=>{r.xa("Mul",c,void 0)},918275:c=>{r.xa("Div",c,void 0)},918326:c=>{r.xa("Pow",c,void 0)},918377:c=>{r.xa("Equal",c,void 0)},918430:c=>{r.xa("Greater",c,void 0)},918485:c=>{r.xa("GreaterOrEqual",c,void 0)},918547:c=>{r.xa("Less",c,void 0)},918599:c=>{r.xa("LessOrEqual",c,void 0)},918658:(c,h,b,S,I)=>{r.xa("ReduceMean",c,{keepDims:!!h,noopWithEmptyAxes:!!b,axes:S?Array.from(D.subarray(I>>>0,I+S>>>0)):[]})},918822:(c,h,b,S,I)=>{r.xa("ReduceMax",c,{keepDims:!!h,noopWithEmptyAxes:!!b,axes:S?Array.from(D.subarray(I>>>0,I+S>>>0)):[]})},918985:(c,h,b,S,I)=>{r.xa("ReduceMin",c,{keepDims:!!h,noopWithEmptyAxes:!!b,axes:S?Array.from(D.subarray(I>>>0,I+S>>>0)):[]})},919148:(c,h,b,S,I)=>{r.xa("ReduceProd",c,{keepDims:!!h,noopWithEmptyAxes:!!b,axes:S?Array.from(D.subarray(I>>>0,I+S>>>0)):[]})},919312:(c,h,b,S,I)=>{r.xa("ReduceSum",c,{keepDims:!!h,noopWithEmptyAxes:!!b,axes:S?Array.from(D.subarray(I>>>0,I+S>>>0)):[]})},919475:(c,h,b,S,I)=>{r.xa("ReduceL1",c,{keepDims:!!h,noopWithEmptyAxes:!!b,axes:S?Array.from(D.subarray(I>>>0,I+S>>>0)):[]})},919637:(c,h,b,S,I)=>{r.xa("ReduceL2",c,{keepDims:!!h,noopWithEmptyAxes:!!b,axes:S?Array.from(D.subarray(I>>>0,I+S>>>0)):[]})},919799:(c,h,b,S,I)=>{r.xa("ReduceLogSum",c,{keepDims:!!h,noopWithEmptyAxes:!!b,axes:S?Array.from(D.subarray(I>>>0,I+S>>>0)):[]})},919965:(c,h,b,S,I)=>{r.xa("ReduceSumSquare",c,{keepDims:!!h,noopWithEmptyAxes:!!b,axes:S?Array.from(D.subarray(I>>>0,I+S>>>0)):[]})},920134:(c,h,b,S,I)=>{r.xa("ReduceLogSumExp",c,{keepDims:!!h,noopWithEmptyAxes:!!b,axes:S?Array.from(D.subarray(I>>>0,I+S>>>0)):[]})},920303:c=>{r.xa("Where",c,void 0)},920356:(c,h,b)=>{r.xa("Transpose",c,{perm:h?Array.from(D.subarray(b>>>0,b+h>>>0)):[]})},920469:(c,h,b,S,I,N,F,re,X,oe,ne,me,ye,P,se)=>{r.xa("ConvTranspose",c,{format:X?"NHWC":"NCHW",autoPad:h,dilations:[b],group:S,kernel_shape:[I],pads:[N,F],strides:[re],wIsConst:()=>!!ee[oe>>>0],outputPadding:ne?Array.from(D.subarray(me>>>0,me+ne>>>0)):[],outputShape:ye?Array.from(D.subarray(P>>>0,P+ye>>>0)):[],activation:ze(se)})},920883:(c,h,b,S,I,N,F,re,X,oe,ne,me,ye,P)=>{r.xa("ConvTranspose",c,{format:re?"NHWC":"NCHW",autoPad:h,dilations:Array.from(D.subarray(b>>>0,b+2>>>0)),group:S,kernelShape:Array.from(D.subarray(I>>>0,I+2>>>0)),pads:Array.from(D.subarray(N>>>0,N+4>>>0)),strides:Array.from(D.subarray(F>>>0,F+2>>>0)),wIsConst:()=>!!ee[X>>>0],outputPadding:0<oe?Array.from(D.subarray(ne>>>0,ne+oe>>>0)):[],outputShape:0<me?Array.from(D.subarray(ye>>>0,ye+me>>>0)):[],activation:ze(P)})},921440:(c,h,b,S,I,N,F,re,X,oe,ne,me,ye,P,se)=>{r.xa("ConvTranspose",c,{format:X?"NHWC":"NCHW",autoPad:h,dilations:[b],group:S,kernel_shape:[I],pads:[N,F],strides:[re],wIsConst:()=>!!ee[oe>>>0],outputPadding:ne?Array.from(D.subarray(me>>>0,me+ne>>>0)):[],outputShape:ye?Array.from(D.subarray(P>>>0,P+ye>>>0)):[],activation:ze(se)})},921854:(c,h,b,S,I,N,F,re,X,oe,ne,me,ye,P)=>{r.xa("ConvTranspose",c,{format:re?"NHWC":"NCHW",autoPad:h,dilations:Array.from(D.subarray(b>>>0,b+2>>>0)),group:S,kernelShape:Array.from(D.subarray(I>>>0,I+2>>>0)),pads:Array.from(D.subarray(N>>>0,N+4>>>0)),strides:Array.from(D.subarray(F>>>0,F+2>>>0)),wIsConst:()=>!!ee[X>>>0],outputPadding:0<oe?Array.from(D.subarray(ne>>>0,ne+oe>>>0)):[],outputShape:0<me?Array.from(D.subarray(ye>>>0,ye+me>>>0)):[],activation:ze(P)})},922411:(c,h)=>{r.xa("GlobalAveragePool",c,{format:h?"NHWC":"NCHW"})},922502:(c,h,b,S,I,N,F,re,X,oe,ne,me,ye,P,se,he)=>{r.xa("AveragePool",c,{format:he?"NHWC":"NCHW",auto_pad:h,ceil_mode:b,count_include_pad:S,storage_order:I,dilations:[N,F],kernel_shape:[re,X],pads:[oe,ne,me,ye],strides:[P,se]})},922786:(c,h)=>{r.xa("GlobalAveragePool",c,{format:h?"NHWC":"NCHW"})},922877:(c,h,b,S,I,N,F,re,X,oe,ne,me,ye,P,se,he)=>{r.xa("AveragePool",c,{format:he?"NHWC":"NCHW",auto_pad:h,ceil_mode:b,count_include_pad:S,storage_order:I,dilations:[N,F],kernel_shape:[re,X],pads:[oe,ne,me,ye],strides:[P,se]})},923161:(c,h)=>{r.xa("GlobalMaxPool",c,{format:h?"NHWC":"NCHW"})},923248:(c,h,b,S,I,N,F,re,X,oe,ne,me,ye,P,se,he)=>{r.xa("MaxPool",c,{format:he?"NHWC":"NCHW",auto_pad:h,ceil_mode:b,count_include_pad:S,storage_order:I,dilations:[N,F],kernel_shape:[re,X],pads:[oe,ne,me,ye],strides:[P,se]})},923528:(c,h)=>{r.xa("GlobalMaxPool",c,{format:h?"NHWC":"NCHW"})},923615:(c,h,b,S,I,N,F,re,X,oe,ne,me,ye,P,se,he)=>{r.xa("MaxPool",c,{format:he?"NHWC":"NCHW",auto_pad:h,ceil_mode:b,count_include_pad:S,storage_order:I,dilations:[N,F],kernel_shape:[re,X],pads:[oe,ne,me,ye],strides:[P,se]})},923895:(c,h,b,S,I)=>{r.xa("Gemm",c,{alpha:h,beta:b,transA:S,transB:I})},923999:c=>{r.xa("MatMul",c,void 0)},924053:(c,h,b,S)=>{r.xa("ArgMax",c,{keepDims:!!h,selectLastIndex:!!b,axis:S})},924161:(c,h,b,S)=>{r.xa("ArgMin",c,{keepDims:!!h,selectLastIndex:!!b,axis:S})},924269:(c,h)=>{r.xa("Softmax",c,{axis:h})},924332:(c,h)=>{r.xa("Concat",c,{axis:h})},924392:(c,h,b,S,I)=>{r.xa("Split",c,{axis:h,numOutputs:b,splitSizes:S?Array.from(D.subarray(I>>>0,I+S>>>0)):[]})},924537:c=>{r.xa("Expand",c,void 0)},924591:(c,h)=>{r.xa("Gather",c,{axis:Number(h)})},924662:(c,h)=>{r.xa("GatherElements",c,{axis:Number(h)})},924741:(c,h,b,S,I,N,F,re,X,oe,ne)=>{r.xa("Resize",c,{antialias:h,axes:b?Array.from(D.subarray(S>>>0,S+b>>>0)):[],coordinateTransformMode:ze(I),cubicCoeffA:N,excludeOutside:F,extrapolationValue:re,keepAspectRatioPolicy:ze(X),mode:ze(oe),nearestMode:ze(ne)})},925092:(c,h,b,S,I,N,F)=>{r.xa("Slice",c,{starts:h?Array.from(D.subarray(b>>>0,b+h>>>0)):[],ends:S?Array.from(D.subarray(I>>>0,I+S>>>0)):[],axes:N?Array.from(D.subarray(F>>>0,F+N>>>0)):[]})},925323:c=>{r.xa("Tile",c,void 0)},925375:(c,h,b)=>{r.xa("LayerNormalization",c,{axis:Number(h),epsilon:Number(b)})},925482:(c,h,b)=>{r.xa("InstanceNormalization",c,{epsilon:h,format:b?"NHWC":"NCHW"})},925596:(c,h,b)=>{r.xa("InstanceNormalization",c,{epsilon:h,format:b?"NHWC":"NCHW"})},925710:c=>{r.xa("Range",c,void 0)},925763:(c,h)=>{r.xa("Einsum",c,{equation:ze(h)})},925844:(c,h,b,S,I)=>{r.xa("Pad",c,{mode:h,value:b,pads:S?Array.from(D.subarray(I>>>0,I+S>>>0)):[]})},925976:c=>{r.xa("Gelu",c,void 0)},926028:c=>{r.xa("BiasAdd",c,void 0)},926083:c=>{r.xa("BiasSplitGelu",c,void 0)},926144:(c,h)=>{r.xa("SkipLayerNormalization",c,{epsilon:h})},926225:(c,h,b,S,I,N,F,re,X,oe,ne,me,ye)=>{r.xa("Conv",c,{format:X?"NHWC":"NCHW",auto_pad:h,dilations:[b],group:S,kernel_shape:[I],pads:N?Array.from(D.subarray(F>>>0,F+N>>>0)):[],strides:[re],w_is_const:()=>!!ee[oe>>>0],activation:ze(ne),activation_params:me?Array.from(_e.subarray(ye>>>0,ye+me>>>0)):[]})},926606:(c,h,b,S,I,N,F,re,X,oe,ne,me,ye,P,se,he)=>{r.xa("Conv",c,{format:me?"NHWC":"NCHW",auto_pad:h,dilations:[b,S],group:I,kernel_shape:[N,F],pads:re?Array.from(D.subarray(X>>>0,X+re>>>0)):[],strides:[oe,ne],w_is_const:()=>!!ee[ye>>>0],activation:ze(P),activation_params:se?Array.from(_e.subarray(he>>>0,he+se>>>0)):[]})},927008:c=>{r.Ua(c)},927042:(c,h)=>r.Va(c,h,r.Fa.Wa,r.Fa.errors),927154:c=>r.Ra(c),927187:c=>r.Ta(c),927219:(c,h,b)=>{r.La(c,h,b,!0)},927258:(c,h,b)=>{r.La(c,h,b)}};function st(c){this.name="ExitStatus",this.message=`Program terminated with exit(${c})`,this.status=c}var Mt=c=>{for(;0<c.length;)c.shift()(r)};function Dt(c){this.Ka=c-24,this.Pa=function(h){te[this.Ka+4>>2>>>0]=h},this.Oa=function(h){te[this.Ka+8>>2>>>0]=h},this.Ma=function(h,b){this.Na(),this.Pa(h),this.Oa(b)},this.Na=function(){te[this.Ka+16>>2>>>0]=0}}var ir=0,tt=0,sr=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,zt=(c,h,b)=>{h>>>=0;var S=h+b;for(b=h;c[b]&&!(b>=S);)++b;if(16<b-h&&c.buffer&&sr)return sr.decode(c.subarray(h,b));for(S="";h<b;){var I=c[h++];if(I&128){var N=c[h++]&63;if((I&224)==192)S+=String.fromCharCode((I&31)<<6|N);else{var F=c[h++]&63;I=(I&240)==224?(I&15)<<12|N<<6|F:(I&7)<<18|N<<12|F<<6|c[h++]&63,65536>I?S+=String.fromCharCode(I):(I-=65536,S+=String.fromCharCode(55296|I>>10,56320|I&1023))}}else S+=String.fromCharCode(I)}return S},ze=(c,h)=>(c>>>=0)?zt(ae,c,h):"",Yt=c=>{for(var h=0,b=0;b<c.length;++b){var S=c.charCodeAt(b);127>=S?h++:2047>=S?h+=2:55296<=S&&57343>=S?(h+=4,++b):h+=3}return h},ur=(c,h,b,S)=>{if(b>>>=0,!(0<S))return 0;var I=b;S=b+S-1;for(var N=0;N<c.length;++N){var F=c.charCodeAt(N);if(55296<=F&&57343>=F){var re=c.charCodeAt(++N);F=65536+((F&1023)<<10)|re&1023}if(127>=F){if(b>=S)break;h[b++>>>0]=F}else{if(2047>=F){if(b+1>=S)break;h[b++>>>0]=192|F>>6}else{if(65535>=F){if(b+2>=S)break;h[b++>>>0]=224|F>>12}else{if(b+3>=S)break;h[b++>>>0]=240|F>>18,h[b++>>>0]=128|F>>12&63}h[b++>>>0]=128|F>>6&63}h[b++>>>0]=128|F&63}}return h[b>>>0]=0,b-I},bt=c=>c%4===0&&(c%100!==0||c%400===0),Br=[0,31,60,91,121,152,182,213,244,274,305,335],Xt=[0,31,59,90,120,151,181,212,243,273,304,334],Wt=c=>{var h=Yt(c)+1,b=Qt(h);return b&&ur(c,ae,b,h),b},Vt=[],lr=(c,h)=>{Vt.length=0;var b;for(h>>=2;b=ae[c++>>>0];)h+=b!=105&h,Vt.push(b==105?D[h>>>0]:Z[h++>>>1]),++h;return Vt},rt={},dr=()=>{if(!Jt){var c={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:i||"./this.program"},h;for(h in rt)rt[h]===void 0?delete c[h]:c[h]=rt[h];var b=[];for(h in c)b.push(`${h}=${c[h]}`);Jt=b}return Jt},Jt,Ne=[null,[],[]],cr=[31,29,31,30,31,30,31,31,30,31,30,31],Zt=[31,28,31,30,31,30,31,31,30,31,30,31];function kn(c){var h=Array(Yt(c)+1);return ur(c,h,0,h.length),h}function le(c,h,b,S){function I(P,se,he){for(P=typeof P=="number"?P.toString():P||"";P.length<se;)P=he[0]+P;return P}function N(P,se){return I(P,se,"0")}function F(P,se){function he(Ut){return 0>Ut?-1:0<Ut?1:0}var at;return(at=he(P.getFullYear()-se.getFullYear()))===0&&(at=he(P.getMonth()-se.getMonth()))===0&&(at=he(P.getDate()-se.getDate())),at}function re(P){switch(P.getDay()){case 0:return new Date(P.getFullYear()-1,11,29);case 1:return P;case 2:return new Date(P.getFullYear(),0,3);case 3:return new Date(P.getFullYear(),0,2);case 4:return new Date(P.getFullYear(),0,1);case 5:return new Date(P.getFullYear()-1,11,31);case 6:return new Date(P.getFullYear()-1,11,30)}}function X(P){var se=P.Da;for(P=new Date(new Date(P.Ea+1900,0,1).getTime());0<se;){var he=P.getMonth(),at=(bt(P.getFullYear())?cr:Zt)[he];if(se>at-P.getDate())se-=at-P.getDate()+1,P.setDate(1),11>he?P.setMonth(he+1):(P.setMonth(0),P.setFullYear(P.getFullYear()+1));else{P.setDate(P.getDate()+se);break}}return he=new Date(P.getFullYear()+1,0,4),se=re(new Date(P.getFullYear(),0,4)),he=re(he),0>=F(se,P)?0>=F(he,P)?P.getFullYear()+1:P.getFullYear():P.getFullYear()-1}c>>>=0,h>>>=0,b>>>=0,S>>>=0;var oe=D[S+40>>2>>>0];S={Za:D[S>>2>>>0],Ya:D[S+4>>2>>>0],Ga:D[S+8>>2>>>0],Ja:D[S+12>>2>>>0],Ha:D[S+16>>2>>>0],Ea:D[S+20>>2>>>0],Ca:D[S+24>>2>>>0],Da:D[S+28>>2>>>0],bb:D[S+32>>2>>>0],Xa:D[S+36>>2>>>0],$a:oe?ze(oe):""},b=ze(b),oe={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ne in oe)b=b.replace(new RegExp(ne,"g"),oe[ne]);var me="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),ye="January February March April May June July August September October November December".split(" ");oe={"%a":P=>me[P.Ca].substring(0,3),"%A":P=>me[P.Ca],"%b":P=>ye[P.Ha].substring(0,3),"%B":P=>ye[P.Ha],"%C":P=>N((P.Ea+1900)/100|0,2),"%d":P=>N(P.Ja,2),"%e":P=>I(P.Ja,2," "),"%g":P=>X(P).toString().substring(2),"%G":P=>X(P),"%H":P=>N(P.Ga,2),"%I":P=>(P=P.Ga,P==0?P=12:12<P&&(P-=12),N(P,2)),"%j":P=>{for(var se=0,he=0;he<=P.Ha-1;se+=(bt(P.Ea+1900)?cr:Zt)[he++]);return N(P.Ja+se,3)},"%m":P=>N(P.Ha+1,2),"%M":P=>N(P.Ya,2),"%n":()=>`
`,"%p":P=>0<=P.Ga&&12>P.Ga?"AM":"PM","%S":P=>N(P.Za,2),"%t":()=>"	","%u":P=>P.Ca||7,"%U":P=>N(Math.floor((P.Da+7-P.Ca)/7),2),"%V":P=>{var se=Math.floor((P.Da+7-(P.Ca+6)%7)/7);if(2>=(P.Ca+371-P.Da-2)%7&&se++,se)se==53&&(he=(P.Ca+371-P.Da)%7,he==4||he==3&&bt(P.Ea)||(se=1));else{se=52;var he=(P.Ca+7-P.Da-1)%7;(he==4||he==5&&bt(P.Ea%400-1))&&se++}return N(se,2)},"%w":P=>P.Ca,"%W":P=>N(Math.floor((P.Da+7-(P.Ca+6)%7)/7),2),"%y":P=>(P.Ea+1900).toString().substring(2),"%Y":P=>P.Ea+1900,"%z":P=>{P=P.Xa;var se=0<=P;return P=Math.abs(P)/60,(se?"+":"-")+("0000"+(P/60*100+P%60)).slice(-4)},"%Z":P=>P.$a,"%%":()=>"%"},b=b.replace(/%%/g,"\0\0");for(ne in oe)b.includes(ne)&&(b=b.replace(new RegExp(ne,"g"),oe[ne](S)));return b=b.replace(/\0\0/g,"%"),ne=kn(b),ne.length>h?0:(ee.set(ne,c>>>0),ne.length-1)}function vt(c){try{c()}catch(h){G(h)}}function Mr(c){var h={},b;for(b in c)(function(S){var I=c[S];h[S]=typeof I=="function"?function(){Nt.push(S);try{return I.apply(null,arguments)}finally{W||(Nt.pop()===S||G(),Xe&&ut===1&&Nt.length===0&&(ut=0,vt(tr),typeof Fibers<"u"&&Fibers.cb()))}}:I})(b);return h}var ut=0,Xe=null,Dr=0,Nt=[],pr={},fr={},zr=0,It=null,Wr=[];function mr(){return new Promise((c,h)=>{It={resolve:c,reject:h}})}function Vr(){var c=Qt(65548),h=c+12;te[c>>2>>>0]=h,te[c+4>>2>>>0]=h+65536,h=Nt[0];var b=pr[h];return b===void 0&&(b=zr++,pr[h]=b,fr[b]=h),D[c+8>>2>>>0]=b,c}function Nr(c){if(!W){if(ut===0){var h=!1,b=!1;c((S=0)=>{if(!W&&(Dr=S,h=!0,b)){ut=2,vt(()=>Fr(Xe)),typeof Browser<"u"&&Browser.Ia.Qa&&Browser.Ia.resume(),S=!1;try{var I=(0,M[fr[D[Xe+8>>2>>>0]]])()}catch(re){I=re,S=!0}var N=!1;if(!Xe){var F=It;F&&(It=null,(S?F.reject:F.resolve)(I),N=!0)}if(S&&!N)throw I}}),b=!0,h||(ut=1,Xe=Vr(),typeof Browser<"u"&&Browser.Ia.Qa&&Browser.Ia.pause(),vt(()=>er(Xe)))}else ut===2?(ut=0,vt(nt),yr(Xe),Xe=null,Wr.forEach(S=>{if(!W)try{if(S(),!R)try{K=K=S=K,R||(r.onExit&&r.onExit(S),W=!0),l(S,new st(S))}catch(I){I instanceof st||I=="unwind"||l(1,I)}}catch(I){I instanceof st||I=="unwind"||l(1,I)}})):G(`invalid state: ${ut}`);return Dr}}function Ur(c){return Nr(h=>{c().then(h)})}var wt=[],$t=void 0,hr=[];function gr(c,h){if(!$t){$t=new WeakMap;var b=Oe.length;if($t)for(var S=0;S<0+b;S++){var I=S,N=wt[I];N||(I>=wt.length&&(wt.length=I+1),wt[I]=N=Oe.get(I)),(I=N)&&$t.set(I,S)}}if(b=$t.get(c)||0)return b;if(hr.length)b=hr.pop();else{try{Oe.grow(1)}catch(re){throw re instanceof RangeError?"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.":re}b=Oe.length-1}try{S=b,Oe.set(S,c),wt[S]=Oe.get(S)}catch(re){if(!(re instanceof TypeError))throw re;if(typeof WebAssembly.Function=="function"){S=WebAssembly.Function,I={i:"i32",j:"i64",f:"f32",d:"f64",p:"i32"},N={parameters:[],results:h[0]=="v"?[]:[I[h[0]]]};for(var F=1;F<h.length;++F)N.parameters.push(I[h[F]]);h=new S(N,c)}else{for(S=[1],I=h.slice(0,1),h=h.slice(1),N={i:127,p:127,j:126,f:125,d:124},S.push(96),F=h.length,128>F?S.push(F):S.push(F%128|128,F>>7),F=0;F<h.length;++F)S.push(N[h[F]]);I=="v"?S.push(0):S.push(1,N[I]),h=[0,97,115,109,1,0,0,0,1],I=S.length,128>I?h.push(I):h.push(I%128|128,I>>7),h.push.apply(h,S),h.push(2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0),h=new WebAssembly.Module(new Uint8Array(h)),h=new WebAssembly.Instance(h,{e:{f:c}}).exports.f}S=b,Oe.set(S,h),wt[S]=Oe.get(S)}return $t.set(c,b),b}var Gr={n:function(c,h,b){return Ur(async()=>{await r.Sa(c,h,b)})},a:function(c,h,b){throw c>>>=0,new Dt(c).Ma(h>>>0,b>>>0),ir=c,tt++,ir},g:function(){return 0},J:function(){},z:function(){},B:function(){},L:function(){return 0},H:function(){},C:function(){},F:function(){},m:function(){},A:function(){},x:function(){},I:function(){},y:function(){},M:()=>!0,q:function(c,h,b){c=h+2097152>>>0<4194305-!!c?(c>>>0)+4294967296*h:NaN,b>>>=0,c=new Date(1e3*c),D[b>>2>>>0]=c.getUTCSeconds(),D[b+4>>2>>>0]=c.getUTCMinutes(),D[b+8>>2>>>0]=c.getUTCHours(),D[b+12>>2>>>0]=c.getUTCDate(),D[b+16>>2>>>0]=c.getUTCMonth(),D[b+20>>2>>>0]=c.getUTCFullYear()-1900,D[b+24>>2>>>0]=c.getUTCDay(),D[b+28>>2>>>0]=(c.getTime()-Date.UTC(c.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(c,h,b){c=h+2097152>>>0<4194305-!!c?(c>>>0)+4294967296*h:NaN,b>>>=0,c=new Date(1e3*c),D[b>>2>>>0]=c.getSeconds(),D[b+4>>2>>>0]=c.getMinutes(),D[b+8>>2>>>0]=c.getHours(),D[b+12>>2>>>0]=c.getDate(),D[b+16>>2>>>0]=c.getMonth(),D[b+20>>2>>>0]=c.getFullYear()-1900,D[b+24>>2>>>0]=c.getDay(),D[b+28>>2>>>0]=(bt(c.getFullYear())?Br:Xt)[c.getMonth()]+c.getDate()-1|0,D[b+36>>2>>>0]=-(60*c.getTimezoneOffset()),h=new Date(c.getFullYear(),6,1).getTimezoneOffset();var S=new Date(c.getFullYear(),0,1).getTimezoneOffset();D[b+32>>2>>>0]=(h!=S&&c.getTimezoneOffset()==Math.min(S,h))|0},s:function(c){c>>>=0;var h=new Date(D[c+20>>2>>>0]+1900,D[c+16>>2>>>0],D[c+12>>2>>>0],D[c+8>>2>>>0],D[c+4>>2>>>0],D[c>>2>>>0],0),b=D[c+32>>2>>>0],S=h.getTimezoneOffset(),I=new Date(h.getFullYear(),6,1).getTimezoneOffset(),N=new Date(h.getFullYear(),0,1).getTimezoneOffset(),F=Math.min(N,I);return 0>b?D[c+32>>2>>>0]=+(I!=N&&F==S):0<b!=(F==S)&&(I=Math.max(N,I),h.setTime(h.getTime()+6e4*((0<b?F:I)-S))),D[c+24>>2>>>0]=h.getDay(),D[c+28>>2>>>0]=(bt(h.getFullYear())?Br:Xt)[h.getMonth()]+h.getDate()-1|0,D[c>>2>>>0]=h.getSeconds(),D[c+4>>2>>>0]=h.getMinutes(),D[c+8>>2>>>0]=h.getHours(),D[c+12>>2>>>0]=h.getDate(),D[c+16>>2>>>0]=h.getMonth(),D[c+20>>2>>>0]=h.getYear(),c=h.getTime()/1e3,br((Ye=c,1<=+Math.abs(Ye)?0<Ye?+Math.floor(Ye/4294967296)>>>0:~~+Math.ceil((Ye-+(~~Ye>>>0))/4294967296)>>>0:0)),c>>>0},o:function(){return-52},p:function(){},v:function(c,h,b){function S(X){return(X=X.toTimeString().match(/\(([A-Za-z ]+)\)$/))?X[1]:"GMT"}b>>>=0;var I=new Date().getFullYear(),N=new Date(I,0,1),F=new Date(I,6,1);I=N.getTimezoneOffset();var re=F.getTimezoneOffset();te[c>>>0>>2>>>0]=60*Math.max(I,re),D[h>>>0>>2>>>0]=+(I!=re),c=S(N),h=S(F),c=Wt(c),h=Wt(h),re<I?(te[b>>2>>>0]=c,te[b+4>>2>>>0]=h):(te[b>>2>>>0]=h,te[b+4>>2>>>0]=c)},e:()=>{G("")},b:function(c,h,b){return c>>>=0,h=lr(h>>>0,b>>>0),Kt[c].apply(null,h)},j:function(c,h,b){return c>>>=0,h=lr(h>>>0,b>>>0),Kt[c].apply(null,h)},h:function(){return Date.now()},w:function(){return 4294901760},c:()=>performance.now(),K:function(c,h,b){return h>>>=0,ae.copyWithin(c>>>0>>>0,h>>>0,h+(b>>>0)>>>0)},u:function(c){c>>>=0;var h=ae.length;if(4294901760<c)return!1;for(var b=1;4>=b;b*=2){var S=h*(1+.2/b);S=Math.min(S,c+100663296);var I=Math;S=Math.max(c,S);e:{I=I.min.call(I,4294901760,S+(65536-S%65536)%65536)-z.buffer.byteLength+65535>>>16;try{z.grow(I),we();var N=1;break e}catch{}N=void 0}if(N)return!0}return!1},D:function(c,h){c>>>=0,h>>>=0;var b=0;return dr().forEach(function(S,I){var N=h+b;for(I=te[c+4*I>>2>>>0]=N,N=0;N<S.length;++N)ee[I++>>0>>>0]=S.charCodeAt(N);ee[I>>0>>>0]=0,b+=S.length+1}),0},E:function(c,h){c>>>=0,h>>>=0;var b=dr();te[c>>2>>>0]=b.length;var S=0;return b.forEach(function(I){S+=I.length+1}),te[h>>2>>>0]=S,0},f:()=>52,l:function(){return 52},t:function(){return 70},k:function(c,h,b,S){h>>>=0,b>>>=0,S>>>=0;for(var I=0,N=0;N<b;N++){var F=te[h>>2>>>0],re=te[h+4>>2>>>0];h+=8;for(var X=0;X<re;X++){var oe=ae[F+X>>>0],ne=Ne[c];oe===0||oe===10?((c===1?k:O)(zt(ne,0)),ne.length=0):ne.push(oe)}I+=re}return te[S>>2>>>0]=I,0},G:le,d:function(c,h,b,S){return le(c>>>0,h>>>0,b>>>0,S>>>0)},i:function(c,h,b,S){let I=Oe.length;c=new Uint8Array(ae.slice(c+h,c+b));try{var N=new WebAssembly.Module(c),F=new WebAssembly.Instance(N,{env:{memory:z}}),re;for(re in F.exports)gr(F.exports[re]);return I<Oe.length?I:S}catch(X){return console.log(X),S}}};(function(){function c(b){if(b=b.exports,b=Mr(b),M=b=Bn(b),z=M.N,we(),Oe=M.sa,De.unshift(M.O),Je--,r.monitorRunDependencies&&r.monitorRunDependencies(Je),Je==0&&(Ze!==null&&(clearInterval(Ze),Ze=null),Qe)){var S=Qe;Qe=null,S()}return b}var h={a:Gr};if(Je++,r.monitorRunDependencies&&r.monitorRunDependencies(Je),r.instantiateWasm)try{return r.instantiateWasm(h,c)}catch(b){O("Module.instantiateWasm callback failed with error: "+b),o(b)}return At(h,function(b){c(b.instance)}).catch(o),{}})(),r._OrtInit=(c,h)=>(r._OrtInit=M.P)(c,h),r._OrtGetLastError=(c,h)=>(r._OrtGetLastError=M.Q)(c,h),r._OrtCreateSessionOptions=(c,h,b,S,I,N,F,re,X,oe)=>(r._OrtCreateSessionOptions=M.R)(c,h,b,S,I,N,F,re,X,oe),r._OrtAppendExecutionProvider=(c,h)=>(r._OrtAppendExecutionProvider=M.S)(c,h),r._OrtAddFreeDimensionOverride=(c,h,b)=>(r._OrtAddFreeDimensionOverride=M.T)(c,h,b),r._OrtAddSessionConfigEntry=(c,h,b)=>(r._OrtAddSessionConfigEntry=M.U)(c,h,b),r._OrtReleaseSessionOptions=c=>(r._OrtReleaseSessionOptions=M.V)(c),r._OrtCreateSession=(c,h,b)=>(r._OrtCreateSession=M.W)(c,h,b),r._OrtReleaseSession=c=>(r._OrtReleaseSession=M.X)(c),r._OrtGetInputOutputCount=(c,h,b)=>(r._OrtGetInputOutputCount=M.Y)(c,h,b),r._OrtGetInputName=(c,h)=>(r._OrtGetInputName=M.Z)(c,h),r._OrtGetOutputName=(c,h)=>(r._OrtGetOutputName=M._)(c,h),r._OrtFree=c=>(r._OrtFree=M.$)(c),r._OrtCreateTensor=(c,h,b,S,I,N)=>(r._OrtCreateTensor=M.aa)(c,h,b,S,I,N),r._OrtGetTensorData=(c,h,b,S,I)=>(r._OrtGetTensorData=M.ba)(c,h,b,S,I),r._OrtReleaseTensor=c=>(r._OrtReleaseTensor=M.ca)(c),r._OrtCreateRunOptions=(c,h,b,S)=>(r._OrtCreateRunOptions=M.da)(c,h,b,S),r._OrtAddRunConfigEntry=(c,h,b)=>(r._OrtAddRunConfigEntry=M.ea)(c,h,b),r._OrtReleaseRunOptions=c=>(r._OrtReleaseRunOptions=M.fa)(c),r._OrtCreateBinding=c=>(r._OrtCreateBinding=M.ga)(c),r._OrtBindInput=(c,h,b)=>(r._OrtBindInput=M.ha)(c,h,b),r._OrtBindOutput=(c,h,b,S)=>(r._OrtBindOutput=M.ia)(c,h,b,S),r._OrtClearBoundOutputs=c=>(r._OrtClearBoundOutputs=M.ja)(c),r._OrtReleaseBinding=c=>(r._OrtReleaseBinding=M.ka)(c),r._OrtRunWithBinding=(c,h,b,S,I)=>(r._OrtRunWithBinding=M.la)(c,h,b,S,I),r._OrtRun=(c,h,b,S,I,N,F,re)=>(r._OrtRun=M.ma)(c,h,b,S,I,N,F,re),r._OrtEndProfiling=c=>(r._OrtEndProfiling=M.na)(c),r._JsepOutput=(c,h,b)=>(r._JsepOutput=M.oa)(c,h,b),r._JsepGetNodeName=c=>(r._JsepGetNodeName=M.pa)(c);var Qt=r._malloc=c=>(Qt=r._malloc=M.qa)(c),yr=r._free=c=>(yr=r._free=M.ra)(c),br=c=>(br=M.ta)(c),vr=()=>(vr=M.ua)(),wr=c=>(wr=M.va)(c),je=c=>(je=M.wa)(c),er=c=>(er=M.ya)(c),tr=()=>(tr=M.za)(),Fr=c=>(Fr=M.Aa)(c),nt=()=>(nt=M.Ba)();r.___start_em_js=927291,r.___stop_em_js=928064;function Bn(c){c=Object.assign({},c);var h=S=>()=>S()>>>0,b=S=>I=>S(I)>>>0;return c.__errno_location=h(c.__errno_location),c.malloc=b(c.malloc),c.stackSave=h(c.stackSave),c.stackAlloc=b(c.stackAlloc),c}r.stackAlloc=je,r.stackSave=vr,r.stackRestore=wr,r.addFunction=gr,r.UTF8ToString=ze,r.stringToUTF8=(c,h,b)=>ur(c,ae,h,b),r.lengthBytesUTF8=Yt;var qe;Qe=function c(){qe||$r(),qe||(Qe=c)};function $r(){function c(){if(!qe&&(qe=!0,r.calledRun=!0,!W)){if(Mt(De),a(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),r.postRun)for(typeof r.postRun=="function"&&(r.postRun=[r.postRun]);r.postRun.length;){var h=r.postRun.shift();Se.unshift(h)}Mt(Se)}}if(!(0<Je)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;)Ue();Mt(be),0<Je||(r.setStatus?(r.setStatus("Running..."),setTimeout(function(){setTimeout(function(){r.setStatus("")},1),c()},1)):c())}}if(r.preInit)for(typeof r.preInit=="function"&&(r.preInit=[r.preInit]);0<r.preInit.length;)r.preInit.pop()();return $r(),t.ready}})();typeof Jo=="object"&&typeof ea=="object"?ea.exports=Xo:typeof define=="function"&&define.amd&&define([],()=>Xo)});var Qo=nr(()=>{});var ei=nr(()=>{});var ti={};ar(ti,{cpus:()=>Id});var Id,ri=j(()=>{Id=void 0});var oi=nr((ai,ta)=>{"use strict";var ni=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){function r(){return we.buffer!=Se.buffer&&Ce(),Se}function a(){return we.buffer!=Se.buffer&&Ce(),Ue}function o(){return we.buffer!=Se.buffer&&Ce(),Je}function u(){return we.buffer!=Se.buffer&&Ce(),Ze}function i(){return we.buffer!=Se.buffer&&Ce(),Qe}function l(){return we.buffer!=Se.buffer&&Ce(),G}function p(){return we.buffer!=Se.buffer&&Ce(),pe}function m(){return we.buffer!=Se.buffer&&Ce(),He}var d=t,v,y;d.ready=new Promise((n,s)=>{v=n,y=s}),d.jsepInit=(n,s,f,g,C,_,B,U)=>{d.oc=n,d.Wb=s,d.Yb=f,d.Lb=g,d.Xb=C,d.cb=_,d.Zb=B,d.$b=U,s=(L,q,Q)=>(...de)=>{let fe=lt,E=q?.();de=L(...de);let ie=q?.();return E!==ie&&(L=ie,Q(E),q=Q=null),lt!=fe?ld():de},f=L=>async(...q)=>{try{if(d.Cb)throw Error("Session already started");let Q=d.Cb={cc:q[0],errors:[]},de=await L(...q);if(d.Cb!==Q)throw Error("Session mismatch");n.flush();let fe=Q.errors;if(0<fe.length){let E=await Promise.all(fe);if(E=E.filter(ie=>ie),0<E.length)throw Error(E.join(`
`))}return de}finally{d.Cb=null}},d._OrtRun=f(s(d._OrtRun,()=>d._OrtRun,L=>d._OrtRun=L)),d._OrtRunWithBinding=f(s(d._OrtRunWithBinding,()=>d._OrtRunWithBinding,L=>d._OrtRunWithBinding=L)),d._OrtBindInput=s(d._OrtBindInput,()=>d._OrtBindInput,L=>d._OrtBindInput=L),d.jsepRegisterBuffer=(L,q,Q,de)=>n.registerBuffer(L,q,Q,de),d.jsepUnregisterBuffers=L=>{n.unregisterBuffers(L)},d.jsepGetBuffer=L=>n.getBuffer(L),d.jsepCreateDownloader=(L,q,Q)=>n.createDownloader(L,q,Q)};var w=Object.assign({},d),x="./this.program",$=(n,s)=>{throw s},A=typeof window=="object",k=typeof importScripts=="function",O=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",T=d.ENVIRONMENT_IS_PTHREAD||!1,R="";function z(n){return d.locateFile?d.locateFile(n,R):R+n}var M,W,K;if(O){var ee=(Jn(),Ft(Xn)),ae=(Qn(),Ft(Zn));R=k?ae.dirname(R)+"/":__dirname+"/",M=(s,f)=>(s=zt(s)?new URL(s):ae.normalize(s),ee.readFileSync(s,f?void 0:"utf8")),K=s=>(s=M(s,!0),s.buffer||(s=new Uint8Array(s)),s),W=(s,f,g,C=!0)=>{s=zt(s)?new URL(s):ae.normalize(s),ee.readFile(s,C?void 0:"utf8",(_,B)=>{_?g(_):f(C?B.buffer:B)})},!d.thisProgram&&1<process.argv.length&&(x=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),$=(s,f)=>{throw process.exitCode=s,f},d.inspect=()=>"[Emscripten Module object]";let n;try{n=Qo()}catch(s){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),s}global.Worker=n.Worker}else(A||k)&&(k?R=self.location.href:typeof document<"u"&&document.currentScript&&(R=document.currentScript.src),typeof e<"u"&&e&&(R=e),R.indexOf("blob:")!==0?R=R.substr(0,R.replace(/[?#].*/,"").lastIndexOf("/")+1):R="",O||(M=n=>{var s=new XMLHttpRequest;return s.open("GET",n,!1),s.send(null),s.responseText},k&&(K=n=>{var s=new XMLHttpRequest;return s.open("GET",n,!1),s.responseType="arraybuffer",s.send(null),new Uint8Array(s.response)}),W=(n,s,f)=>{var g=new XMLHttpRequest;g.open("GET",n,!0),g.responseType="arraybuffer",g.onload=()=>{g.status==200||g.status==0&&g.response?s(g.response):f()},g.onerror=f,g.send(null)}));O&&typeof performance>"u"&&(global.performance=ei().performance);var D=console.log.bind(console),te=console.error.bind(console);O&&(D=(...n)=>ee.writeSync(1,n.join(" ")+`
`),te=(...n)=>ee.writeSync(2,n.join(" ")+`
`));var _e=D,Z=te;Object.assign(d,w),w=null,typeof WebAssembly!="object"&&tt("no native wasm support detected");var we,Oe,be=!1,De,Se,Ue,Je,Ze,Qe,G,pe,ce,Fe,He;function Ce(){var n=we.buffer;d.HEAP8=Se=new Int8Array(n),d.HEAP16=Je=new Int16Array(n),d.HEAPU8=Ue=new Uint8Array(n),d.HEAPU16=Ze=new Uint16Array(n),d.HEAP32=Qe=new Int32Array(n),d.HEAPU32=G=new Uint32Array(n),d.HEAPF32=pe=new Float32Array(n),d.HEAPF64=He=new Float64Array(n),d.HEAP64=ce=new BigInt64Array(n),d.HEAPU64=Fe=new BigUint64Array(n)}var Pe=16777216;if(5242880<=Pe||tt("INITIAL_MEMORY should be larger than STACK_SIZE, was "+Pe+"! (STACK_SIZE=5242880)"),T)we=d.wasmMemory;else if(we=new WebAssembly.Memory({initial:Pe/65536,maximum:65536,shared:!0}),!(we.buffer instanceof SharedArrayBuffer))throw Z("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),O&&Z("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Ce(),Pe=we.buffer.byteLength;var At=[],Ye=[],Kt=[],st=0,Mt=null,Dt=null;function ir(){if(st--,st==0&&(Mt!==null&&(clearInterval(Mt),Mt=null),Dt)){var n=Dt;Dt=null,n()}}function tt(n){throw n="Aborted("+n+")",Z(n),be=!0,De=1,n=new WebAssembly.RuntimeError(n+". Build with -sASSERTIONS for more info."),y(n),n}var sr=n=>n.startsWith("data:application/octet-stream;base64,"),zt=n=>n.startsWith("file://"),ze;ze="ort-wasm-simd-threaded.wasm",sr(ze)||(ze=z(ze));function Yt(n){if(K)return K(n);throw"both async and sync fetching of the wasm failed"}function ur(n){if(A||k){if(typeof fetch=="function"&&!zt(n))return fetch(n,{credentials:"same-origin"}).then(s=>{if(!s.ok)throw"failed to load wasm binary file at '"+n+"'";return s.arrayBuffer()}).catch(()=>Yt(n));if(W)return new Promise((s,f)=>{W(n,g=>s(new Uint8Array(g)),f)})}return Promise.resolve().then(()=>Yt(n))}function bt(n,s,f){return ur(n).then(g=>WebAssembly.instantiate(g,s)).then(g=>g).then(f,g=>{Z(`failed to asynchronously prepare wasm: ${g}`),tt(g)})}function Br(n,s){var f=ze;return typeof WebAssembly.instantiateStreaming!="function"||sr(f)||zt(f)||O||typeof fetch!="function"?bt(f,n,s):fetch(f,{credentials:"same-origin"}).then(g=>WebAssembly.instantiateStreaming(g,n).then(s,function(C){return Z(`wasm streaming compile failed: ${C}`),Z("falling back to ArrayBuffer instantiation"),bt(f,n,s)}))}var Xt={1441368:n=>{d.cb("Abs",n,void 0)},1441419:n=>{d.cb("Neg",n,void 0)},1441470:n=>{d.cb("Floor",n,void 0)},1441523:n=>{d.cb("Ceil",n,void 0)},1441575:n=>{d.cb("Reciprocal",n,void 0)},1441633:n=>{d.cb("Sqrt",n,void 0)},1441685:n=>{d.cb("Exp",n,void 0)},1441736:n=>{d.cb("Erf",n,void 0)},1441787:n=>{d.cb("Sigmoid",n,void 0)},1441842:n=>{d.cb("Log",n,void 0)},1441893:n=>{d.cb("Sin",n,void 0)},1441944:n=>{d.cb("Cos",n,void 0)},1441995:n=>{d.cb("Tan",n,void 0)},1442046:n=>{d.cb("Asin",n,void 0)},1442098:n=>{d.cb("Acos",n,void 0)},1442150:n=>{d.cb("Atan",n,void 0)},1442202:n=>{d.cb("Sinh",n,void 0)},1442254:n=>{d.cb("Cosh",n,void 0)},1442306:n=>{d.cb("Asinh",n,void 0)},1442359:n=>{d.cb("Acosh",n,void 0)},1442412:n=>{d.cb("Atanh",n,void 0)},1442465:n=>{d.cb("Tanh",n,void 0)},1442517:n=>{d.cb("Not",n,void 0)},1442568:(n,s,f)=>{d.cb("ClipV10",n,{min:s,max:f})},1442640:n=>{d.cb("Clip",n,void 0)},1442692:(n,s)=>{d.cb("Elu",n,{alpha:s})},1442750:n=>{d.cb("Relu",n,void 0)},1442802:(n,s)=>{d.cb("LeakyRelu",n,{alpha:s})},1442866:(n,s)=>{d.cb("ThresholdedRelu",n,{alpha:s})},1442936:n=>{d.Zb(n)},1442970:(n,s)=>d.$b(n,s,d.Cb.cc,d.Cb.errors),1443082:(n,s)=>{d.cb("Cast",n,{to:s})},1443140:n=>{d.cb("Add",n,void 0)},1443191:n=>{d.cb("Sub",n,void 0)},1443242:n=>{d.cb("Mul",n,void 0)},1443293:n=>{d.cb("Div",n,void 0)},1443344:n=>{d.cb("Pow",n,void 0)},1443395:n=>{d.cb("Equal",n,void 0)},1443448:n=>{d.cb("Greater",n,void 0)},1443503:n=>{d.cb("GreaterOrEqual",n,void 0)},1443565:n=>{d.cb("Less",n,void 0)},1443617:n=>{d.cb("LessOrEqual",n,void 0)},1443676:(n,s,f,g,C)=>{d.cb("ReduceMean",n,{keepDims:!!s,noopWithEmptyAxes:!!f,axes:g?Array.from(i().subarray(C>>>0,C+g>>>0)):[]})},1443840:(n,s,f,g,C)=>{d.cb("ReduceMax",n,{keepDims:!!s,noopWithEmptyAxes:!!f,axes:g?Array.from(i().subarray(C>>>0,C+g>>>0)):[]})},1444003:(n,s,f,g,C)=>{d.cb("ReduceMin",n,{keepDims:!!s,noopWithEmptyAxes:!!f,axes:g?Array.from(i().subarray(C>>>0,C+g>>>0)):[]})},1444166:(n,s,f,g,C)=>{d.cb("ReduceProd",n,{keepDims:!!s,noopWithEmptyAxes:!!f,axes:g?Array.from(i().subarray(C>>>0,C+g>>>0)):[]})},1444330:(n,s,f,g,C)=>{d.cb("ReduceSum",n,{keepDims:!!s,noopWithEmptyAxes:!!f,axes:g?Array.from(i().subarray(C>>>0,C+g>>>0)):[]})},1444493:(n,s,f,g,C)=>{d.cb("ReduceL1",n,{keepDims:!!s,noopWithEmptyAxes:!!f,axes:g?Array.from(i().subarray(C>>>0,C+g>>>0)):[]})},1444655:(n,s,f,g,C)=>{d.cb("ReduceL2",n,{keepDims:!!s,noopWithEmptyAxes:!!f,axes:g?Array.from(i().subarray(C>>>0,C+g>>>0)):[]})},1444817:(n,s,f,g,C)=>{d.cb("ReduceLogSum",n,{keepDims:!!s,noopWithEmptyAxes:!!f,axes:g?Array.from(i().subarray(C>>>0,C+g>>>0)):[]})},1444983:(n,s,f,g,C)=>{d.cb("ReduceSumSquare",n,{keepDims:!!s,noopWithEmptyAxes:!!f,axes:g?Array.from(i().subarray(C>>>0,C+g>>>0)):[]})},1445152:(n,s,f,g,C)=>{d.cb("ReduceLogSumExp",n,{keepDims:!!s,noopWithEmptyAxes:!!f,axes:g?Array.from(i().subarray(C>>>0,C+g>>>0)):[]})},1445321:n=>{d.cb("Where",n,void 0)},1445374:(n,s,f)=>{d.cb("Transpose",n,{perm:s?Array.from(i().subarray(f>>>0,f+s>>>0)):[]})},1445487:(n,s,f,g,C,_,B,U,L,q,Q,de,fe)=>{d.cb("Conv",n,{format:L?"NHWC":"NCHW",auto_pad:s,dilations:[f],group:g,kernel_shape:[C],pads:_?Array.from(i().subarray(B>>>0,B+_>>>0)):[],strides:[U],w_is_const:()=>!!r()[q>>>0],activation:Ne(Q),activation_params:de?Array.from(p().subarray(fe>>>0,fe+de>>>0)):[]})},1445868:(n,s,f,g,C,_,B,U,L,q,Q,de,fe,E,ie,ve)=>{d.cb("Conv",n,{format:de?"NHWC":"NCHW",auto_pad:s,dilations:[f,g],group:C,kernel_shape:[_,B],pads:U?Array.from(i().subarray(L>>>0,L+U>>>0)):[],strides:[q,Q],w_is_const:()=>!!r()[fe>>>0],activation:Ne(E),activation_params:ie?Array.from(p().subarray(ve>>>0,ve+ie>>>0)):[]})},1446270:(n,s,f,g,C,_,B,U,L,q,Q,de,fe,E,ie)=>{d.cb("ConvTranspose",n,{format:L?"NHWC":"NCHW",autoPad:s,dilations:[f],group:g,kernel_shape:[C],pads:[_,B],strides:[U],wIsConst:()=>!!r()[q>>>0],outputPadding:Q?Array.from(i().subarray(de>>>0,de+Q>>>0)):[],outputShape:fe?Array.from(i().subarray(E>>>0,E+fe>>>0)):[],activation:Ne(ie)})},1446684:(n,s,f,g,C,_,B,U,L,q,Q,de,fe,E)=>{d.cb("ConvTranspose",n,{format:U?"NHWC":"NCHW",autoPad:s,dilations:Array.from(i().subarray(f>>>0,f+2>>>0)),group:g,kernelShape:Array.from(i().subarray(C>>>0,C+2>>>0)),pads:Array.from(i().subarray(_>>>0,_+4>>>0)),strides:Array.from(i().subarray(B>>>0,B+2>>>0)),wIsConst:()=>!!r()[L>>>0],outputPadding:0<q?Array.from(i().subarray(Q>>>0,Q+q>>>0)):[],outputShape:0<de?Array.from(i().subarray(fe>>>0,fe+de>>>0)):[],activation:Ne(E)})},1447241:(n,s,f,g,C,_,B,U,L,q,Q,de,fe,E,ie)=>{d.cb("ConvTranspose",n,{format:L?"NHWC":"NCHW",autoPad:s,dilations:[f],group:g,kernel_shape:[C],pads:[_,B],strides:[U],wIsConst:()=>!!r()[q>>>0],outputPadding:Q?Array.from(i().subarray(de>>>0,de+Q>>>0)):[],outputShape:fe?Array.from(i().subarray(E>>>0,E+fe>>>0)):[],activation:Ne(ie)})},1447655:(n,s,f,g,C,_,B,U,L,q,Q,de,fe,E)=>{d.cb("ConvTranspose",n,{format:U?"NHWC":"NCHW",autoPad:s,dilations:Array.from(i().subarray(f>>>0,f+2>>>0)),group:g,kernelShape:Array.from(i().subarray(C>>>0,C+2>>>0)),pads:Array.from(i().subarray(_>>>0,_+4>>>0)),strides:Array.from(i().subarray(B>>>0,B+2>>>0)),wIsConst:()=>!!r()[L>>>0],outputPadding:0<q?Array.from(i().subarray(Q>>>0,Q+q>>>0)):[],outputShape:0<de?Array.from(i().subarray(fe>>>0,fe+de>>>0)):[],activation:Ne(E)})},1448212:(n,s)=>{d.cb("GlobalAveragePool",n,{format:s?"NHWC":"NCHW"})},1448303:(n,s,f,g,C,_,B,U,L,q,Q,de,fe,E,ie,ve)=>{d.cb("AveragePool",n,{format:ve?"NHWC":"NCHW",auto_pad:s,ceil_mode:f,count_include_pad:g,storage_order:C,dilations:[_,B],kernel_shape:[U,L],pads:[q,Q,de,fe],strides:[E,ie]})},1448587:(n,s)=>{d.cb("GlobalAveragePool",n,{format:s?"NHWC":"NCHW"})},1448678:(n,s,f,g,C,_,B,U,L,q,Q,de,fe,E,ie,ve)=>{d.cb("AveragePool",n,{format:ve?"NHWC":"NCHW",auto_pad:s,ceil_mode:f,count_include_pad:g,storage_order:C,dilations:[_,B],kernel_shape:[U,L],pads:[q,Q,de,fe],strides:[E,ie]})},1448962:(n,s)=>{d.cb("GlobalMaxPool",n,{format:s?"NHWC":"NCHW"})},1449049:(n,s,f,g,C,_,B,U,L,q,Q,de,fe,E,ie,ve)=>{d.cb("MaxPool",n,{format:ve?"NHWC":"NCHW",auto_pad:s,ceil_mode:f,count_include_pad:g,storage_order:C,dilations:[_,B],kernel_shape:[U,L],pads:[q,Q,de,fe],strides:[E,ie]})},1449329:(n,s)=>{d.cb("GlobalMaxPool",n,{format:s?"NHWC":"NCHW"})},1449416:(n,s,f,g,C,_,B,U,L,q,Q,de,fe,E,ie,ve)=>{d.cb("MaxPool",n,{format:ve?"NHWC":"NCHW",auto_pad:s,ceil_mode:f,count_include_pad:g,storage_order:C,dilations:[_,B],kernel_shape:[U,L],pads:[q,Q,de,fe],strides:[E,ie]})},1449696:(n,s,f,g,C)=>{d.cb("Gemm",n,{alpha:s,beta:f,transA:g,transB:C})},1449800:n=>{d.cb("MatMul",n,void 0)},1449854:(n,s,f,g)=>{d.cb("ArgMax",n,{keepDims:!!s,selectLastIndex:!!f,axis:g})},1449962:(n,s,f,g)=>{d.cb("ArgMin",n,{keepDims:!!s,selectLastIndex:!!f,axis:g})},1450070:(n,s)=>{d.cb("Softmax",n,{axis:s})},1450133:(n,s)=>{d.cb("Concat",n,{axis:s})},1450193:(n,s,f,g,C)=>{d.cb("Split",n,{axis:s,numOutputs:f,splitSizes:g?Array.from(i().subarray(C>>>0,C+g>>>0)):[]})},1450338:n=>{d.cb("Expand",n,void 0)},1450392:(n,s)=>{d.cb("Gather",n,{axis:Number(s)})},1450463:(n,s)=>{d.cb("GatherElements",n,{axis:Number(s)})},1450542:(n,s,f,g,C,_,B,U,L,q,Q)=>{d.cb("Resize",n,{antialias:s,axes:f?Array.from(i().subarray(g>>>0,g+f>>>0)):[],coordinateTransformMode:Ne(C),cubicCoeffA:_,excludeOutside:B,extrapolationValue:U,keepAspectRatioPolicy:Ne(L),mode:Ne(q),nearestMode:Ne(Q)})},1450893:(n,s,f,g,C,_,B)=>{d.cb("Slice",n,{starts:s?Array.from(i().subarray(f>>>0,f+s>>>0)):[],ends:g?Array.from(i().subarray(C>>>0,C+g>>>0)):[],axes:_?Array.from(i().subarray(B>>>0,B+_>>>0)):[]})},1451124:n=>{d.cb("Tile",n,void 0)},1451176:(n,s,f)=>{d.cb("LayerNormalization",n,{axis:Number(s),epsilon:Number(f)})},1451283:(n,s,f)=>{d.cb("InstanceNormalization",n,{epsilon:s,format:f?"NHWC":"NCHW"})},1451397:(n,s,f)=>{d.cb("InstanceNormalization",n,{epsilon:s,format:f?"NHWC":"NCHW"})},1451511:n=>{d.cb("Range",n,void 0)},1451564:(n,s)=>{d.cb("Einsum",n,{equation:Ne(s)})},1451645:(n,s,f,g,C)=>{d.cb("Pad",n,{mode:s,value:f,pads:g?Array.from(i().subarray(C>>>0,C+g>>>0)):[]})},1451777:n=>{d.cb("Gelu",n,void 0)},1451829:n=>{d.cb("BiasAdd",n,void 0)},1451884:n=>{d.cb("BiasSplitGelu",n,void 0)},1451945:(n,s)=>{d.cb("SkipLayerNormalization",n,{epsilon:s})},1452026:n=>d.Wb(n),1452059:n=>d.Yb(n),1452091:(n,s,f)=>{d.Lb(n,s,f,!0)},1452130:(n,s,f)=>{d.Lb(n,s,f)}};function Wt(n){this.name="ExitStatus",this.message=`Program terminated with exit(${n})`,this.status=n}var Vt=n=>{n.terminate(),n.onmessage=()=>{}},lr=n=>{if(le.zb.length==0){var s=z("ort-wasm-simd-threaded.worker.js");s=new Worker(s),le.zb.push(s),le.ac(le.zb[0])}if(s=le.zb.pop(),!s)return 6;le.wb.push(s),le.nb[n.vb]=s,s.vb=n.vb;var f={cmd:"run",start_routine:n.dc,arg:n.Rb,pthread_ptr:n.vb};return O&&s.unref(),s.postMessage(f,n.kc),0},rt=0,dr=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Jt=(n,s,f)=>{s>>>=0;var g=s+f;for(f=s;n[f]&&!(f>=g);)++f;if(16<f-s&&n.buffer&&dr)return dr.decode(n.buffer instanceof SharedArrayBuffer?n.slice(s,f):n.subarray(s,f));for(g="";s<f;){var C=n[s++];if(C&128){var _=n[s++]&63;if((C&224)==192)g+=String.fromCharCode((C&31)<<6|_);else{var B=n[s++]&63;C=(C&240)==224?(C&15)<<12|_<<6|B:(C&7)<<18|_<<12|B<<6|n[s++]&63,65536>C?g+=String.fromCharCode(C):(C-=65536,g+=String.fromCharCode(55296|C>>10,56320|C&1023))}}else g+=String.fromCharCode(C)}return g},Ne=(n,s)=>(n>>>=0)?Jt(a(),n,s):"";function cr(n){if(T)return Te(0,1,n);De=n,0<rt||(le.ec(),be=!0),$(n,new Wt(n))}var Zt=n=>{if(De=n,T)throw Mr(n),"unwind";cr(n)};function kn(){At.unshift(()=>{st++,ir()})}var le={zb:[],wb:[],Qb:[],nb:{},Fb(){T?(le.receiveObjectTransfer=le.bc,le.threadInitTLS=le.Pb,le.setExitStatus=le.Ob):kn()},Ob:n=>{De=n},pc:["$terminateWorker"],ec:()=>{for(var n of le.wb)Vt(n);for(n of le.zb)Vt(n);le.zb=[],le.wb=[],le.nb=[]},Nb:n=>{var s=n.vb;delete le.nb[s],le.zb.push(n),le.wb.splice(le.wb.indexOf(n),1),n.vb=0,Gn(s)},bc(){},Pb(){le.Qb.forEach(n=>n())},ac:n=>new Promise(s=>{n.onmessage=_=>{_=_.data;var B=_.cmd;if(_.targetThread&&_.targetThread!=Kr()){var U=le.nb[_.targetThread];U?U.postMessage(_,_.transferList):Z(`Internal error! Worker sent a message "${B}" to target pthread ${_.targetThread}, but that thread no longer exists!`)}else B==="checkMailbox"?Ut():B==="spawnThread"?lr(_):B==="cleanupThread"?((_=le.nb[_.thread])||tt(),le.Nb(_)):B==="killThread"?(_=_.thread,B=le.nb[_],delete le.nb[_],Vt(B),Gn(_),le.wb.splice(le.wb.indexOf(B),1),B.vb=0):B==="cancelThread"?le.nb[_.thread].postMessage({cmd:"cancel"}):B==="loaded"?(n.loaded=!0,s(n)):B==="alert"?alert(`Thread ${_.threadId}: ${_.text}`):_.target==="setimmediate"?n.postMessage(_):B==="callHandler"?d[_.handler](..._.args):B&&Z(`worker sent an unknown command ${B}`)},n.onerror=_=>{throw Z(`worker sent an error! ${_.filename}:${_.lineno}: ${_.message}`),_},O&&(n.on("message",_=>n.onmessage({data:_})),n.on("error",_=>n.onerror(_)));var f=[],g=[],C;for(C of g)d.hasOwnProperty(C)&&f.push(C);n.postMessage({cmd:"load",handlers:f,urlOrBlob:d.mainScriptUrlOrBlob||e,wasmMemory:we,wasmModule:Oe})})};d.PThread=le;var vt=n=>{for(;0<n.length;)n.shift()(d)};d.establishStackSpace=()=>{var n=Kr(),s=l()[n+52>>>2>>>0];n=l()[n+56>>>2>>>0],go(s,s-n),Yr(s)};function Mr(n){if(T)return Te(1,0,n);Zt(n)}d.invokeEntryPoint=(n,s)=>{n=yo.apply(null,[n,s]),0<rt?le.Ob(n):Fn(n)};function ut(n){this.Ab=n-24,this.lc=function(s){l()[this.Ab+4>>>2>>>0]=s},this.Ib=function(s){l()[this.Ab+8>>>2>>>0]=s},this.Fb=function(s,f){this.Hb(),this.lc(s),this.Ib(f)},this.Hb=function(){l()[this.Ab+16>>>2>>>0]=0}}var Xe=0,Dr=0;function Nt(n,s,f,g){return T?Te(2,1,n,s,f,g):pr(n,s,f,g)}function pr(n,s,f,g){if(n>>>=0,s>>>=0,f>>>=0,g>>>=0,typeof SharedArrayBuffer>"u")return Z("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var C=[];return T&&C.length===0?Nt(n,s,f,g):(n={dc:f,vb:n,Rb:g,kc:C},T?(n.nc="spawnThread",postMessage(n,C),0):lr(n))}function fr(n,s,f){return T?Te(3,1,n,s,f):0}function zr(n,s){if(T)return Te(4,1,n,s)}var It=n=>{for(var s=0,f=0;f<n.length;++f){var g=n.charCodeAt(f);127>=g?s++:2047>=g?s+=2:55296<=g&&57343>=g?(s+=4,++f):s+=3}return s},Wr=(n,s,f,g)=>{if(f>>>=0,!(0<g))return 0;var C=f;g=f+g-1;for(var _=0;_<n.length;++_){var B=n.charCodeAt(_);if(55296<=B&&57343>=B){var U=n.charCodeAt(++_);B=65536+((B&1023)<<10)|U&1023}if(127>=B){if(f>=g)break;s[f++>>>0]=B}else{if(2047>=B){if(f+1>=g)break;s[f++>>>0]=192|B>>6}else{if(65535>=B){if(f+2>=g)break;s[f++>>>0]=224|B>>12}else{if(f+3>=g)break;s[f++>>>0]=240|B>>18,s[f++>>>0]=128|B>>12&63}s[f++>>>0]=128|B>>6&63}s[f++>>>0]=128|B&63}}return s[f>>>0]=0,f-C},mr=(n,s,f)=>Wr(n,a(),s,f);function Vr(n,s){if(T)return Te(5,1,n,s)}function Nr(n,s,f){if(T)return Te(6,1,n,s,f)}function Ur(n,s,f){return T?Te(7,1,n,s,f):0}function wt(n,s){if(T)return Te(8,1,n,s)}function $t(n,s,f){if(T)return Te(9,1,n,s,f)}function hr(n,s,f,g){if(T)return Te(10,1,n,s,f,g)}function gr(n,s,f,g){if(T)return Te(11,1,n,s,f,g)}function Gr(n,s,f,g){if(T)return Te(12,1,n,s,f,g)}function Qt(n){if(T)return Te(13,1,n)}function yr(n,s){if(T)return Te(14,1,n,s)}function br(n,s,f){if(T)return Te(15,1,n,s,f)}var vr=n=>{if(n===null)return"null";var s=typeof n;return s==="object"||s==="array"||s==="function"?n.toString():""+n},wr,je=n=>{for(var s="";a()[n>>>0];)s+=wr[a()[n++>>>0]];return s},er={},tr={},Fr={},nt;function Bn(n,s,f={}){var g=s.name;if(!n)throw new nt(`type "${g}" must have a positive integer typeid pointer`);if(tr.hasOwnProperty(n)){if(f.Ub)return;throw new nt(`Cannot register type '${g}' twice`)}tr[n]=s,delete Fr[n],er.hasOwnProperty(n)&&(s=er[n],delete er[n],s.forEach(C=>C()))}function qe(n,s,f={}){if(!("argPackAdvance"in s))throw new TypeError("registerType registeredInstance requires argPackAdvance");Bn(n,s,f)}var $r=(n,s,f)=>{switch(s){case 1:return f?g=>r()[g>>>0>>>0]:g=>a()[g>>>0>>>0];case 2:return f?g=>o()[g>>>1>>>0]:g=>u()[g>>>1>>>0];case 4:return f?g=>i()[g>>>2>>>0]:g=>l()[g>>>2>>>0];case 8:return f?g=>ce[g>>>3]:g=>Fe[g>>>3];default:throw new TypeError(`invalid integer width (${s}): ${n}`)}};function c(){this.ub=[void 0],this.Kb=[]}var h=new c;function b(n){n>>>=0,n>=h.Ab&&--h.get(n).Mb===0&&h.Ib(n)}var S=n=>{if(!n)throw new nt("Cannot use deleted val. handle = "+n);return h.get(n).value},I=n=>{switch(n){case void 0:return 1;case null:return 2;case!0:return 3;case!1:return 4;default:return h.Hb({Mb:1,value:n})}};function N(n){return this.fromWireType(i()[n>>>2>>>0])}var F=(n,s)=>{switch(s){case 4:return function(f){return this.fromWireType(p()[f>>>2>>>0])};case 8:return function(f){return this.fromWireType(m()[f>>>3>>>0])};default:throw new TypeError(`invalid float width (${s}): ${n}`)}};function re(n){return this.fromWireType(l()[n>>>2>>>0])}var X=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,oe=(n,s)=>{for(var f=n>>1,g=f+s/2;!(f>=g)&&u()[f>>>0];)++f;if(f<<=1,32<f-n&&X)return X.decode(a().slice(n,f));for(f="",g=0;!(g>=s/2);++g){var C=o()[n+2*g>>>1>>>0];if(C==0)break;f+=String.fromCharCode(C)}return f},ne=(n,s,f)=>{if(f===void 0&&(f=2147483647),2>f)return 0;f-=2;var g=s;f=f<2*n.length?f/2:n.length;for(var C=0;C<f;++C){var _=n.charCodeAt(C);o()[s>>>1>>>0]=_,s+=2}return o()[s>>>1>>>0]=0,s-g},me=n=>2*n.length,ye=(n,s)=>{for(var f=0,g="";!(f>=s/4);){var C=i()[n+4*f>>>2>>>0];if(C==0)break;++f,65536<=C?(C-=65536,g+=String.fromCharCode(55296|C>>10,56320|C&1023)):g+=String.fromCharCode(C)}return g},P=(n,s,f)=>{if(s>>>=0,f===void 0&&(f=2147483647),4>f)return 0;var g=s;f=g+f-4;for(var C=0;C<n.length;++C){var _=n.charCodeAt(C);if(55296<=_&&57343>=_){var B=n.charCodeAt(++C);_=65536+((_&1023)<<10)|B&1023}if(i()[s>>>2>>>0]=_,s+=4,s+4>f)break}return i()[s>>>2>>>0]=0,s-g},se=n=>{for(var s=0,f=0;f<n.length;++f){var g=n.charCodeAt(f);55296<=g&&57343>=g&&++f,s+=4}return s},he=n=>{if(!be)try{if(n(),!(0<rt))try{T?Fn(De):Zt(De)}catch(s){s instanceof Wt||s=="unwind"||$(1,s)}}catch(s){s instanceof Wt||s=="unwind"||$(1,s)}};function at(n){n>>>=0,typeof Atomics.mc=="function"&&(Atomics.mc(i(),n>>>2,n).value.then(Ut),n+=128,Atomics.store(i(),n>>>2,1))}d.__emscripten_thread_mailbox_await=at;var Ut=()=>{var n=Kr();n&&(at(n),he(()=>ho()))};d.checkMailbox=Ut;var Xl=n=>{var s=Ln();return n=n(),Yr(s),n};function Te(n,s){var f=arguments.length-2,g=arguments;return Xl(()=>{for(var C=2*f,_=Hn(8*C),B=_>>>3,U=0;U<f;U++){var L=g[2+U];typeof L=="bigint"?(ce[B+2*U]=1n,ce[B+2*U+1]=L):(ce[B+2*U]=0n,m()[B+2*U+1>>>0]=L)}return mo(n,C,_,s)})}var Mn=[],Lr=(n,s)=>{var f=tr[n];if(f===void 0)throw n=po(n),f=je(n),dt(n),new nt(s+" has unknown type "+f);return f},Jl={},Dn=n=>{var s=Jl[n];return s===void 0?je(n):s},zn=[],Ga=()=>typeof globalThis=="object"?globalThis:Function("return this")(),Zl=n=>{var s=zn.length;return zn.push(n),s},Ql=(n,s)=>{for(var f=Array(n),g=0;g<n;++g)f[g]=Lr(l()[s+4*g>>>2>>>0],"parameter "+g);return f},Fa=n=>{if(n===void 0)return"_unknown";n=n.replace(/[^a-zA-Z0-9_]/g,"$");var s=n.charCodeAt(0);return 48<=s&&57>=s?`_${n}`:n};function ed(n,s){return n=Fa(n),{[n]:function(){return s.apply(this,arguments)}}[n]}function td(n){var s=Function;if(!(s instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof s} which is not a function`);var f=ed(s.name||"unknownFunctionName",function(){});return f.prototype=s.prototype,f=new f,n=s.apply(f,n),n instanceof Object?n:f}var rd=n=>{for(var s="",f=0;f<n;++f)s+=(f!==0?", ":"")+"arg"+f;var g="return function emval_allocator_"+n+`(constructor, argTypes, args) {
  var HEAPU32 = getMemory();
`;for(f=0;f<n;++f)g+="var argType"+f+" = requireRegisteredType(HEAPU32[((argTypes)>>>2)], 'parameter "+f+`');
var arg`+f+" = argType"+f+`.readValueFromPointer(args);
args += argType`+f+`['argPackAdvance'];
argTypes += 4;
`;return new Function("requireRegisteredType","Module","valueToHandle","getMemory",g+("var obj = new constructor("+s+`);
return valueToHandle(obj);
}
`))(Lr,d,I,()=>l())},La={},rr=n=>n%4===0&&(n%100!==0||n%400===0),Ha=[0,31,60,91,121,152,182,213,244,274,305,335],ja=[0,31,59,90,120,151,181,212,243,273,304,334];function qa(n,s,f,g,C,_,B){return T?Te(16,1,n,s,f,g,C,_,B):-52}function Ka(n,s,f,g,C,_){if(T)return Te(17,1,n,s,f,g,C,_)}var Ya=n=>{var s=It(n)+1,f=xr(s);return f&&mr(n,f,s),f},Wn=[],Xa=(n,s)=>{Wn.length=0;for(var f;f=a()[n++>>>0];){var g=f!=105;g&=f!=112,s+=g&&s%8?4:0,Wn.push(f==112?l()[s>>>2>>>0]:f==106?ce[s>>>3]:f==105?i()[s>>>2>>>0]:m()[s>>>3>>>0]),s+=g?8:4}return Wn},Vn={},Ja=()=>{if(!Nn){var n={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:x||"./this.program"},s;for(s in Vn)Vn[s]===void 0?delete n[s]:n[s]=Vn[s];var f=[];for(s in n)f.push(`${s}=${n[s]}`);Nn=f}return Nn},Nn;function Za(n,s){if(T)return Te(18,1,n,s);n>>>=0,s>>>=0;var f=0;return Ja().forEach((g,C)=>{var _=s+f;for(C=l()[n+4*C>>>2>>>0]=_,_=0;_<g.length;++_)r()[C++>>>0>>>0]=g.charCodeAt(_);r()[C>>>0>>>0]=0,f+=g.length+1}),0}function Qa(n,s){if(T)return Te(19,1,n,s);n>>>=0,s>>>=0;var f=Ja();l()[n>>>2>>>0]=f.length;var g=0;return f.forEach(C=>g+=C.length+1),l()[s>>>2>>>0]=g,0}function eo(n){return T?Te(20,1,n):52}function to(n,s,f,g){return T?Te(21,1,n,s,f,g):52}function ro(n,s,f,g){return T?Te(22,1,n,s,f,g):70}var nd=[null,[],[]];function no(n,s,f,g){if(T)return Te(23,1,n,s,f,g);s>>>=0,f>>>=0,g>>>=0;for(var C=0,_=0;_<f;_++){var B=l()[s>>>2>>>0],U=l()[s+4>>>2>>>0];s+=8;for(var L=0;L<U;L++){var q=a()[B+L>>>0],Q=nd[n];q===0||q===10?((n===1?_e:Z)(Jt(Q,0)),Q.length=0):Q.push(q)}C+=U}return l()[g>>>2>>>0]=C,0}var ao=[31,29,31,30,31,30,31,31,30,31,30,31],oo=[31,28,31,30,31,30,31,31,30,31,30,31];function ad(n){var s=Array(It(n)+1);return Wr(n,s,0,s.length),s}var od=(n,s)=>{r().set(n,s>>>0)};function io(n,s,f,g){function C(E,ie,ve){for(E=typeof E=="number"?E.toString():E||"";E.length<ie;)E=ve[0]+E;return E}function _(E,ie){return C(E,ie,"0")}function B(E,ie){function ve(So){return 0>So?-1:0<So?1:0}var Gt;return(Gt=ve(E.getFullYear()-ie.getFullYear()))===0&&(Gt=ve(E.getMonth()-ie.getMonth()))===0&&(Gt=ve(E.getDate()-ie.getDate())),Gt}function U(E){switch(E.getDay()){case 0:return new Date(E.getFullYear()-1,11,29);case 1:return E;case 2:return new Date(E.getFullYear(),0,3);case 3:return new Date(E.getFullYear(),0,2);case 4:return new Date(E.getFullYear(),0,1);case 5:return new Date(E.getFullYear()-1,11,31);case 6:return new Date(E.getFullYear()-1,11,30)}}function L(E){var ie=E.xb;for(E=new Date(new Date(E.yb+1900,0,1).getTime());0<ie;){var ve=E.getMonth(),Gt=(rr(E.getFullYear())?ao:oo)[ve];if(ie>Gt-E.getDate())ie-=Gt-E.getDate()+1,E.setDate(1),11>ve?E.setMonth(ve+1):(E.setMonth(0),E.setFullYear(E.getFullYear()+1));else{E.setDate(E.getDate()+ie);break}}return ve=new Date(E.getFullYear()+1,0,4),ie=U(new Date(E.getFullYear(),0,4)),ve=U(ve),0>=B(ie,E)?0>=B(ve,E)?E.getFullYear()+1:E.getFullYear():E.getFullYear()-1}n>>>=0,s>>>=0,f>>>=0,g>>>=0;var q=l()[g+40>>>2>>>0];g={ic:i()[g>>>2>>>0],hc:i()[g+4>>>2>>>0],Db:i()[g+8>>>2>>>0],Jb:i()[g+12>>>2>>>0],Eb:i()[g+16>>>2>>>0],yb:i()[g+20>>>2>>>0],tb:i()[g+24>>>2>>>0],xb:i()[g+28>>>2>>>0],qc:i()[g+32>>>2>>>0],fc:i()[g+36>>>2>>>0],jc:q?Ne(q):""},f=Ne(f),q={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var Q in q)f=f.replace(new RegExp(Q,"g"),q[Q]);var de="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),fe="January February March April May June July August September October November December".split(" ");q={"%a":E=>de[E.tb].substring(0,3),"%A":E=>de[E.tb],"%b":E=>fe[E.Eb].substring(0,3),"%B":E=>fe[E.Eb],"%C":E=>_((E.yb+1900)/100|0,2),"%d":E=>_(E.Jb,2),"%e":E=>C(E.Jb,2," "),"%g":E=>L(E).toString().substring(2),"%G":E=>L(E),"%H":E=>_(E.Db,2),"%I":E=>(E=E.Db,E==0?E=12:12<E&&(E-=12),_(E,2)),"%j":E=>{for(var ie=0,ve=0;ve<=E.Eb-1;ie+=(rr(E.yb+1900)?ao:oo)[ve++]);return _(E.Jb+ie,3)},"%m":E=>_(E.Eb+1,2),"%M":E=>_(E.hc,2),"%n":()=>`
`,"%p":E=>0<=E.Db&&12>E.Db?"AM":"PM","%S":E=>_(E.ic,2),"%t":()=>"	","%u":E=>E.tb||7,"%U":E=>_(Math.floor((E.xb+7-E.tb)/7),2),"%V":E=>{var ie=Math.floor((E.xb+7-(E.tb+6)%7)/7);if(2>=(E.tb+371-E.xb-2)%7&&ie++,ie)ie==53&&(ve=(E.tb+371-E.xb)%7,ve==4||ve==3&&rr(E.yb)||(ie=1));else{ie=52;var ve=(E.tb+7-E.xb-1)%7;(ve==4||ve==5&&rr(E.yb%400-1))&&ie++}return _(ie,2)},"%w":E=>E.tb,"%W":E=>_(Math.floor((E.xb+7-(E.tb+6)%7)/7),2),"%y":E=>(E.yb+1900).toString().substring(2),"%Y":E=>E.yb+1900,"%z":E=>{E=E.fc;var ie=0<=E;return E=Math.abs(E)/60,(ie?"+":"-")+("0000"+(E/60*100+E%60)).slice(-4)},"%Z":E=>E.jc,"%%":()=>"%"},f=f.replace(/%%/g,"\0\0");for(Q in q)f.includes(Q)&&(f=f.replace(new RegExp(Q,"g"),q[Q](g)));return f=f.replace(/\0\0/g,"%"),Q=ad(f),Q.length>s?0:(od(Q,n),Q.length-1)}var Hr=n=>{try{n()}catch(s){tt(s)}};function id(){var n=J,s={},f;for(f in n)(function(g){var C=n[g];s[g]=typeof C=="function"?function(){jr.push(g);try{return C.apply(null,arguments)}finally{be||(jr.pop()===g||tt(),lt&&_t===1&&jr.length===0&&(_t=0,rt+=1,Hr(vo),typeof Fibers<"u"&&Fibers.rc()))}}:C})(f);return s}var _t=0,lt=null,so=0,jr=[],uo={},lo={},sd=0,Un=null,ud=[];function ld(){return new Promise((n,s)=>{Un={resolve:n,reject:s}})}function dd(){var n=xr(65548),s=n+12;l()[n>>>2>>>0]=s,l()[n+4>>>2>>>0]=s+65536,s=jr[0];var f=uo[s];return f===void 0&&(f=sd++,uo[s]=f,lo[f]=s),s=f,i()[n+8>>>2>>>0]=s,n}function cd(){var n=i()[lt+8>>>2>>>0];return n=J[lo[n]],--rt,n()}function pd(n){if(!be){if(_t===0){var s=!1,f=!1;n((g=0)=>{if(!be&&(so=g,s=!0,f)){_t=2,Hr(()=>wo(lt)),typeof Browser<"u"&&Browser.Gb.Tb&&Browser.Gb.resume(),g=!1;try{var C=cd()}catch(U){C=U,g=!0}var _=!1;if(!lt){var B=Un;B&&(Un=null,(g?B.reject:B.resolve)(C),_=!0)}if(g&&!_)throw C}}),f=!0,s||(_t=1,lt=dd(),typeof Browser<"u"&&Browser.Gb.Tb&&Browser.Gb.pause(),Hr(()=>bo(lt)))}else _t===2?(_t=0,Hr($o),dt(lt),lt=null,ud.forEach(g=>he(g))):tt(`invalid state: ${_t}`);return so}}function fd(n){return pd(s=>{n().then(s)})}le.Fb();for(var co=Array(256),qr=0;256>qr;++qr)co[qr]=String.fromCharCode(qr);wr=co,nt=d.BindingError=class extends Error{constructor(n){super(n),this.name="BindingError"}},d.InternalError=class extends Error{constructor(n){super(n),this.name="InternalError"}},Object.assign(c.prototype,{get(n){return this.ub[n]},has(n){return this.ub[n]!==void 0},Hb(n){var s=this.Kb.pop()||this.ub.length;return this.ub[s]=n,s},Ib(n){this.ub[n]=void 0,this.Kb.push(n)}}),h.ub.push({value:void 0},{value:null},{value:!0},{value:!1}),h.Ab=h.ub.length,d.count_emval_handles=()=>{for(var n=0,s=h.Ab;s<h.ub.length;++s)h.ub[s]!==void 0&&++n;return n};var md=[cr,Mr,Nt,fr,zr,Vr,Nr,Ur,wt,$t,hr,gr,Gr,Qt,yr,br,qa,Ka,Za,Qa,eo,to,ro,no],hd={ta:function(n,s,f){return fd(async()=>{await d.Xb(n,s,f)})},b:function(n,s,f){throw n>>>=0,new ut(n).Fb(s>>>0,f>>>0),Xe=n,Dr++,Xe},fa:function(n){fo(n>>>0,!k,1,!A,131072,!1),le.Pb()},D:function(n){n>>>=0,T?postMessage({cmd:"cleanupThread",thread:n}):((n=le.nb[n])||tt(),le.Nb(n))},X:pr,u:fr,la:zr,T:Vr,V:Nr,M:Ur,ja:wt,ca:$t,ia:hr,F:gr,U:Gr,R:Qt,ka:yr,S:br,I:function(n,s,f,g,C){n>>>=0,s>>>=0,f>>>=0,s=je(s);var _=s.indexOf("u")!=-1;_&&(C=(1n<<64n)-1n),qe(n,{name:s,fromWireType:B=>B,toWireType:function(B,U){if(typeof U!="bigint"&&typeof U!="number")throw new TypeError(`Cannot convert "${vr(U)}" to ${this.name}`);if(U<g||U>C)throw new TypeError(`Passing a number "${vr(U)}" from JS side to C/C++ side to an argument of type "${s}", which is outside the valid range [${g}, ${C}]!`);return U},argPackAdvance:8,readValueFromPointer:$r(s,f,!_),Bb:null})},ra:function(n,s,f,g){n>>>=0,s=je(s>>>0),qe(n,{name:s,fromWireType:function(C){return!!C},toWireType:function(C,_){return _?f:g},argPackAdvance:8,readValueFromPointer:function(C){return this.fromWireType(a()[C>>>0])},Bb:null})},qa:function(n,s){n>>>=0,s=je(s>>>0),qe(n,{name:s,fromWireType:f=>{var g=S(f);return b(f),g},toWireType:(f,g)=>I(g),argPackAdvance:8,readValueFromPointer:N,Bb:null})},H:function(n,s,f){n>>>=0,f>>>=0,s=je(s>>>0),qe(n,{name:s,fromWireType:g=>g,toWireType:(g,C)=>C,argPackAdvance:8,readValueFromPointer:F(s,f),Bb:null})},w:function(n,s,f,g,C){if(n>>>=0,f>>>=0,s=je(s>>>0),C===-1&&(C=4294967295),C=U=>U,g===0){var _=32-8*f;C=U=>U<<_>>>_}var B=s.includes("unsigned")?function(U,L){return L>>>0}:function(U,L){return L};qe(n,{name:s,fromWireType:C,toWireType:B,argPackAdvance:8,readValueFromPointer:$r(s,f,g!==0),Bb:null})},p:function(n,s,f){function g(_){var B=l()[_>>>2>>>0];return _=l()[_+4>>>2>>>0],new C(r().buffer,_,B)}n>>>=0;var C=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][s];f=je(f>>>0),qe(n,{name:f,fromWireType:g,argPackAdvance:8,readValueFromPointer:g},{Ub:!0})},J:function(n,s){n>>>=0,s=je(s>>>0);var f=s==="std::string";qe(n,{name:s,fromWireType:function(g){var C=l()[g>>>2>>>0],_=g+4;if(f)for(var B=_,U=0;U<=C;++U){var L=_+U;if(U==C||a()[L>>>0]==0){if(B=Ne(B,L-B),q===void 0)var q=B;else q+=String.fromCharCode(0),q+=B;B=L+1}}else{for(q=Array(C),U=0;U<C;++U)q[U]=String.fromCharCode(a()[_+U>>>0]);q=q.join("")}return dt(g),q},toWireType:function(g,C){C instanceof ArrayBuffer&&(C=new Uint8Array(C));var _=typeof C=="string";if(!(_||C instanceof Uint8Array||C instanceof Uint8ClampedArray||C instanceof Int8Array))throw new nt("Cannot pass non-string to std::string");var B=f&&_?It(C):C.length,U=xr(4+B+1),L=U+4;if(l()[U>>>2>>>0]=B,f&&_)mr(C,L,B+1);else if(_)for(_=0;_<B;++_){var q=C.charCodeAt(_);if(255<q)throw dt(L),new nt("String has UTF-16 code units that do not fit in 8 bits");a()[L+_>>>0]=q}else for(_=0;_<B;++_)a()[L+_>>>0]=C[_];return g!==null&&g.push(dt,U),U},argPackAdvance:8,readValueFromPointer:re,Bb(g){dt(g)}})},B:function(n,s,f){if(n>>>=0,s>>>=0,f>>>=0,f=je(f),s===2)var g=oe,C=ne,_=me,B=()=>u(),U=1;else s===4&&(g=ye,C=P,_=se,B=()=>l(),U=2);qe(n,{name:f,fromWireType:L=>{for(var q=l()[L>>>2>>>0],Q=B(),de,fe=L+4,E=0;E<=q;++E){var ie=L+4+E*s;(E==q||Q[ie>>>U]==0)&&(fe=g(fe,ie-fe),de===void 0?de=fe:(de+=String.fromCharCode(0),de+=fe),fe=ie+s)}return dt(L),de},toWireType:(L,q)=>{if(typeof q!="string")throw new nt(`Cannot pass non-string to C++ string type ${f}`);var Q=_(q),de=xr(4+Q+s);return l()[de>>>2]=Q>>U,C(q,de+4,Q+s),L!==null&&L.push(dt,de),de},argPackAdvance:8,readValueFromPointer:N,Bb(L){dt(L)}})},sa:function(n,s){n>>>=0,s=je(s>>>0),qe(n,{Vb:!0,name:s,argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})},oa:()=>!0,P:function(n,s){n>>>=0,n==s>>>0?setTimeout(()=>Ut()):T?postMessage({targetThread:n,cmd:"checkMailbox"}):(n=le.nb[n])&&n.postMessage({cmd:"checkMailbox"})},Y:function(n,s,f,g){s>>>=0,f/=2,Mn.length=f,g=g>>>0>>>3;for(var C=0;C<f;C++)Mn[C]=ce[g+2*C]?ce[g+2*C+1]:m()[g+2*C+1>>>0];return n=0>n?Xt[-n-1]:md[n],le.Sb=s,s=n.apply(null,Mn),le.Sb=0,s},ea:at,na:function(n){O&&le.nb[n>>>0].ref()},v:function(n,s,f){s>>>=0,f>>>=0,n=S(n>>>0),s=Lr(s,"emval::as");var g=[],C=I(g);return l()[f>>>2>>>0]=C,s.toWireType(g,n)},l:function(n,s,f,g,C){f>>>=0,g>>>=0,C>>>=0,n=zn[n>>>0],s=S(s>>>0),f=Dn(f);var _=[];return n=n(s,f,_,C),_.length&&(l()[g>>>2>>>0]=I(_)),n},c:b,L:function(n,s){return s>>>=0,n=S(n>>>0),s=S(s),n==s},q:function(n){return n>>>=0,n===0?I(Ga()):(n=Dn(n),I(Ga()[n]))},k:function(n,s){s=Ql(n,s>>>0);var f=s.shift();n--;for(var g=["retType"],C=[f],_="",B=0;B<n;++B)_+=(B!==0?", ":"")+"arg"+B,g.push("argType"+B),C.push(s[B]);B=f.name+"_$"+s.map(q=>q.name).join("_")+"$";var U="return function "+Fa("methodCaller_"+B)+`(handle, name, destructors, args) {
`,L=0;for(B=0;B<n;++B)U+="    var arg"+B+" = argType"+B+".readValueFromPointer(args"+(L?"+"+L:"")+`);
`,L+=s[B].argPackAdvance;for(U+="    var rv = handle[name]("+_+`);
`,B=0;B<n;++B)s[B].deleteObject&&(U+="    argType"+B+".deleteObject(arg"+B+`);
`);return f.Vb||(U+=`    return retType.toWireType(destructors, rv);
`),g.push(U+`};
`),n=td(g).apply(null,C),Zl(n)},t:function(n,s){return s>>>=0,n=S(n>>>0),s=S(s),I(n[s])},h:function(n){n>>>=0,4<n&&(h.get(n).Mb+=1)},r:function(n,s,f,g){f>>>=0,g>>>=0,n=S(n>>>0);var C=La[s];return C||(C=rd(s),La[s]=C),C(n,f,g)},x:function(){return I([])},m:function(n){n=S(n>>>0);for(var s=Array(n.length),f=0;f<n.length;f++)s[f]=n[f];return I(s)},e:function(n){return I(Dn(n>>>0))},j:function(){return I({})},i:function(n){n>>>=0;for(var s=S(n);s.length;){var f=s.pop();s.pop()(f)}b(n)},g:function(n,s,f){s>>>=0,f>>>=0,n=S(n>>>0),s=S(s),f=S(f),n[s]=f},d:function(n,s){return s>>>=0,n=Lr(n>>>0,"_emval_take_value"),n=n.readValueFromPointer(s),I(n)},$:function(n,s){n=-9007199254740992>n||9007199254740992<n?NaN:Number(n),s>>>=0,n=new Date(1e3*n),i()[s>>>2>>>0]=n.getUTCSeconds(),i()[s+4>>>2>>>0]=n.getUTCMinutes(),i()[s+8>>>2>>>0]=n.getUTCHours(),i()[s+12>>>2>>>0]=n.getUTCDate(),i()[s+16>>>2>>>0]=n.getUTCMonth(),i()[s+20>>>2>>>0]=n.getUTCFullYear()-1900,i()[s+24>>>2>>>0]=n.getUTCDay(),n=(n.getTime()-Date.UTC(n.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,i()[s+28>>>2>>>0]=n},aa:function(n,s){n=-9007199254740992>n||9007199254740992<n?NaN:Number(n),s>>>=0,n=new Date(1e3*n),i()[s>>>2>>>0]=n.getSeconds(),i()[s+4>>>2>>>0]=n.getMinutes(),i()[s+8>>>2>>>0]=n.getHours(),i()[s+12>>>2>>>0]=n.getDate(),i()[s+16>>>2>>>0]=n.getMonth(),i()[s+20>>>2>>>0]=n.getFullYear()-1900,i()[s+24>>>2>>>0]=n.getDay();var f=(rr(n.getFullYear())?Ha:ja)[n.getMonth()]+n.getDate()-1|0;i()[s+28>>>2>>>0]=f,i()[s+36>>>2>>>0]=-(60*n.getTimezoneOffset()),f=new Date(n.getFullYear(),6,1).getTimezoneOffset();var g=new Date(n.getFullYear(),0,1).getTimezoneOffset();n=(f!=g&&n.getTimezoneOffset()==Math.min(g,f))|0,i()[s+32>>>2>>>0]=n},ba:function(n){n>>>=0;var s=new Date(i()[n+20>>>2>>>0]+1900,i()[n+16>>>2>>>0],i()[n+12>>>2>>>0],i()[n+8>>>2>>>0],i()[n+4>>>2>>>0],i()[n>>>2>>>0],0),f=i()[n+32>>>2>>>0],g=s.getTimezoneOffset(),C=new Date(s.getFullYear(),6,1).getTimezoneOffset(),_=new Date(s.getFullYear(),0,1).getTimezoneOffset(),B=Math.min(_,C);return 0>f?i()[n+32>>>2>>>0]=+(C!=_&&B==g):0<f!=(B==g)&&(C=Math.max(_,C),s.setTime(s.getTime()+6e4*((0<f?B:C)-g))),i()[n+24>>>2>>>0]=s.getDay(),f=(rr(s.getFullYear())?Ha:ja)[s.getMonth()]+s.getDate()-1|0,i()[n+28>>>2>>>0]=f,i()[n>>>2>>>0]=s.getSeconds(),i()[n+4>>>2>>>0]=s.getMinutes(),i()[n+8>>>2>>>0]=s.getHours(),i()[n+12>>>2>>>0]=s.getDate(),i()[n+16>>>2>>>0]=s.getMonth(),i()[n+20>>>2>>>0]=s.getYear(),BigInt(s.getTime()/1e3)},Z:qa,_:Ka,O:function(n,s,f){function g(q){return(q=q.toTimeString().match(/\(([A-Za-z ]+)\)$/))?q[1]:"GMT"}n>>>=0,s>>>=0,f>>>=0;var C=new Date().getFullYear(),_=new Date(C,0,1),B=new Date(C,6,1);C=_.getTimezoneOffset();var U=B.getTimezoneOffset(),L=Math.max(C,U);l()[n>>>2>>>0]=60*L,i()[s>>>2>>>0]=+(C!=U),n=g(_),s=g(B),n=Ya(n),s=Ya(s),U<C?(l()[f>>>2>>>0]=n,l()[f+4>>>2>>>0]=s):(l()[f>>>2>>>0]=s,l()[f+4>>>2>>>0]=n)},o:()=>{tt("")},f:function(n,s,f){return n>>>=0,s=Xa(s>>>0,f>>>0),Xt[n].apply(null,s)},K:function(n,s,f){return n>>>=0,s=Xa(s>>>0,f>>>0),Xt[n].apply(null,s)},E:()=>{},G:()=>Date.now(),ma:()=>{throw rt+=1,"unwind"},Q:function(){return 4294901760},n:()=>performance.timeOrigin+performance.now(),z:()=>O?(ri(),Ft(ti)).cpus().length:navigator.hardwareConcurrency,N:function(n){n>>>=0;var s=a().length;if(n<=s||4294901760<n)return!1;for(var f=1;4>=f;f*=2){var g=s*(1+.2/f);g=Math.min(g,n+100663296);var C=Math;g=Math.max(n,g);e:{C=(C.min.call(C,4294901760,g+(65536-g%65536)%65536)-we.buffer.byteLength+65535)/65536;try{we.grow(C),Ce();var _=1;break e}catch{}_=void 0}if(_)return!0}return!1},ga:Za,ha:Qa,W:Zt,y:eo,C:to,da:ro,A:no,a:we||d.wasmMemory,pa:io,s:function(n,s,f,g){return io(n>>>0,s>>>0,f>>>0,g>>>0)}},J=function(){var n={a:hd};return st++,Br(n,function(s){var f=s.module;J=s.instance.exports,J=id(),J=gd(),le.Qb.push(J.$a),Ye.unshift(J.ua),Oe=f,ir()}).catch(y),{}}();d._OrtInit=(n,s)=>(d._OrtInit=J.va)(n,s),d._OrtGetLastError=(n,s)=>(d._OrtGetLastError=J.wa)(n,s),d._OrtCreateSessionOptions=(n,s,f,g,C,_,B,U,L,q)=>(d._OrtCreateSessionOptions=J.xa)(n,s,f,g,C,_,B,U,L,q),d._OrtAppendExecutionProvider=(n,s)=>(d._OrtAppendExecutionProvider=J.ya)(n,s),d._OrtAddFreeDimensionOverride=(n,s,f)=>(d._OrtAddFreeDimensionOverride=J.za)(n,s,f),d._OrtAddSessionConfigEntry=(n,s,f)=>(d._OrtAddSessionConfigEntry=J.Aa)(n,s,f),d._OrtReleaseSessionOptions=n=>(d._OrtReleaseSessionOptions=J.Ba)(n),d._OrtCreateSession=(n,s,f)=>(d._OrtCreateSession=J.Ca)(n,s,f),d._OrtReleaseSession=n=>(d._OrtReleaseSession=J.Da)(n),d._OrtGetInputOutputCount=(n,s,f)=>(d._OrtGetInputOutputCount=J.Ea)(n,s,f),d._OrtGetInputName=(n,s)=>(d._OrtGetInputName=J.Fa)(n,s),d._OrtGetOutputName=(n,s)=>(d._OrtGetOutputName=J.Ga)(n,s),d._OrtFree=n=>(d._OrtFree=J.Ha)(n),d._OrtCreateTensor=(n,s,f,g,C,_)=>(d._OrtCreateTensor=J.Ia)(n,s,f,g,C,_),d._OrtGetTensorData=(n,s,f,g,C)=>(d._OrtGetTensorData=J.Ja)(n,s,f,g,C),d._OrtReleaseTensor=n=>(d._OrtReleaseTensor=J.Ka)(n),d._OrtCreateRunOptions=(n,s,f,g)=>(d._OrtCreateRunOptions=J.La)(n,s,f,g),d._OrtAddRunConfigEntry=(n,s,f)=>(d._OrtAddRunConfigEntry=J.Ma)(n,s,f),d._OrtReleaseRunOptions=n=>(d._OrtReleaseRunOptions=J.Na)(n),d._OrtCreateBinding=n=>(d._OrtCreateBinding=J.Oa)(n),d._OrtBindInput=(n,s,f)=>(d._OrtBindInput=J.Pa)(n,s,f),d._OrtBindOutput=(n,s,f,g)=>(d._OrtBindOutput=J.Qa)(n,s,f,g),d._OrtClearBoundOutputs=n=>(d._OrtClearBoundOutputs=J.Ra)(n),d._OrtReleaseBinding=n=>(d._OrtReleaseBinding=J.Sa)(n),d._OrtRunWithBinding=(n,s,f,g,C)=>(d._OrtRunWithBinding=J.Ta)(n,s,f,g,C),d._OrtRun=(n,s,f,g,C,_,B,U)=>(d._OrtRun=J.Ua)(n,s,f,g,C,_,B,U),d._OrtEndProfiling=n=>(d._OrtEndProfiling=J.Va)(n),d._JsepOutput=(n,s,f)=>(d._JsepOutput=J.Wa)(n,s,f),d._JsepGetNodeName=n=>(d._JsepGetNodeName=J.Xa)(n);var Kr=d._pthread_self=()=>(Kr=d._pthread_self=J.Ya)(),xr=d._malloc=n=>(xr=d._malloc=J.Za)(n),dt=d._free=n=>(dt=d._free=J._a)(n);d.__emscripten_tls_init=()=>(d.__emscripten_tls_init=J.$a)();var po=n=>(po=J.ab)(n);d.__embind_initialize_bindings=()=>(d.__embind_initialize_bindings=J.bb)();var fo=d.__emscripten_thread_init=(n,s,f,g,C,_)=>(fo=d.__emscripten_thread_init=J.db)(n,s,f,g,C,_);d.__emscripten_thread_crashed=()=>(d.__emscripten_thread_crashed=J.eb)();var mo=(n,s,f,g)=>(mo=J.fb)(n,s,f,g),Gn=n=>(Gn=J.gb)(n),Fn=d.__emscripten_thread_exit=n=>(Fn=d.__emscripten_thread_exit=J.hb)(n),ho=d.__emscripten_check_mailbox=()=>(ho=d.__emscripten_check_mailbox=J.ib)(),go=(n,s)=>(go=J.jb)(n,s),Ln=()=>(Ln=J.kb)(),Yr=n=>(Yr=J.lb)(n),Hn=n=>(Hn=J.mb)(n),yo=d.dynCall_ii=(n,s)=>(yo=d.dynCall_ii=J.ob)(n,s),bo=n=>(bo=J.pb)(n),vo=()=>(vo=J.qb)(),wo=n=>(wo=J.rb)(n),$o=()=>($o=J.sb)();d.___start_em_js=1452163,d.___stop_em_js=1452324;function gd(){var n=J;n=Object.assign({},n);var s=g=>()=>g()>>>0,f=g=>C=>g(C)>>>0;return n.__errno_location=s(n.__errno_location),n.Ya=s(n.Ya),n.Za=f(n.Za),n.ab=f(n.ab),n.kb=s(n.kb),n.mb=f(n.mb),n}d.wasmMemory=we,d.stackAlloc=Hn,d.stackSave=Ln,d.stackRestore=Yr,d.keepRuntimeAlive=()=>0<rt,d.UTF8ToString=Ne,d.stringToUTF8=mr,d.lengthBytesUTF8=It,d.ExitStatus=Wt,d.PThread=le;var Xr;Dt=function n(){Xr||xo(),Xr||(Dt=n)};function xo(){0<st||(T?(v(d),T||vt(Ye),startWorker(d)):(vt(At),0<st||Xr||(Xr=!0,d.calledRun=!0,be||(T||vt(Ye),v(d),T||vt(Kt)))))}return xo(),t.ready}})();typeof ai=="object"&&typeof ta=="object"?ta.exports=ni:typeof define=="function"&&define.amd&&define([],()=>ni)});var ii=nr((rm,_d)=>{_d.exports='"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\n'});var ui,Od,ra,na,on,si,Td,Ed,Rd,li,Re,or=j(()=>{"use strict";ui=Zo();Od=oi(),na=!1,on=!1,si=!1,Td=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},Ed=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Rd=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",li=async e=>{if(na)return Promise.resolve();if(on)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(si)throw new Error("previous call to 'initializeWebAssembly()' failed.");on=!0;let t=e.initTimeout,r=e.numThreads,a=e.simd,o=r>1&&Td(),u=a&&Ed(),i=e.wasmPaths,l=typeof i=="string"?i:void 0,p=Rd(u,o),m=typeof i=="object"?i[p]:void 0,d=!1,v=[];if(t>0&&v.push(new Promise(y=>{setTimeout(()=>{d=!0,y()},t)})),v.push(new Promise((y,w)=>{let x=o?Od:ui,$={locateFile:(A,k)=>{if(o&&A.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([ii()],{type:"text/javascript"}));if(A.endsWith(".wasm")){if(m)return m;let O=l??k;return p==="ort-wasm-simd.wasm"?O+"ort-wasm-simd.jsep.wasm":p==="ort-wasm-simd-threaded.wasm"?O+"ort-wasm-simd-threaded.jsep.wasm":O+p}return k+A}};if(o)if(typeof Blob>"u")$.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let A=`var ortWasmThreaded=${x.toString()};`;$.mainScriptUrlOrBlob=new Blob([A],{type:"text/javascript"})}x($).then(A=>{on=!1,na=!0,ra=A,y()},A=>{on=!1,si=!0,w(A)})})),await Promise.race(v),d)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Re=()=>{if(na&&ra)return ra;throw new Error("WebAssembly is not initialized yet.")}});var ke,Cr,Ae,sn=j(()=>{"use strict";or();ke=(e,t)=>{let r=Re(),a=r.lengthBytesUTF8(e)+1,o=r._malloc(a);return r.stringToUTF8(e,o,a),t.push(o),o},Cr=(e,t,r,a)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([o,u])=>{let i=t?t+o:o;if(typeof u=="object")Cr(u,i+".",r,a);else if(typeof u=="string"||typeof u=="number")a(i,u.toString());else if(typeof u=="boolean")a(i,u?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof u}`)})},Ae=e=>{let t=Re(),r=t.stackSave();try{let a=t.stackAlloc(8);t._OrtGetLastError(a,a+4);let o=t.HEAP32[a/4],u=t.HEAPU32[a/4+1],i=u?t.UTF8ToString(u):"";throw new Error(`${e} ERROR_CODE: ${o}, ERROR_MESSAGE: ${i}`)}finally{t.stackRestore(r)}}});var di,ci=j(()=>{"use strict";or();sn();di=e=>{let t=Re(),r=0,a=[],o=e||{};try{if(e?.logSeverityLevel===void 0)o.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)o.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(o.terminate=!1);let u=0;return e?.tag!==void 0&&(u=ke(e.tag,a)),r=t._OrtCreateRunOptions(o.logSeverityLevel,o.logVerbosityLevel,!!o.terminate,u),r===0&&Ae("Can't create run options."),e?.extra!==void 0&&Cr(e.extra,"",new WeakSet,(i,l)=>{let p=ke(i,a),m=ke(l,a);t._OrtAddRunConfigEntry(r,p,m)!==0&&Ae(`Can't set a run config entry: ${i} - ${l}.`)}),[r,a]}catch(u){throw r!==0&&t._OrtReleaseRunOptions(r),a.forEach(i=>t._free(i)),u}}});var Pd,kd,Bd,Md,pi,fi=j(()=>{"use strict";or();sn();Pd=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},kd=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Bd=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},Md=(e,t,r)=>{for(let a of t){let o=typeof a=="string"?a:a.name;switch(o){case"xnnpack":o="XNNPACK";break;case"webnn":if(o="WEBNN",typeof a!="string"){let i=a;if(i?.deviceType){let l=ke("deviceType",r),p=ke(i.deviceType,r);Re()._OrtAddSessionConfigEntry(e,l,p)!==0&&Ae(`Can't set a session config entry: 'deviceType' - ${i.deviceType}.`)}if(i?.numThreads){let l=i.numThreads;(typeof l!="number"||!Number.isInteger(l)||l<0)&&(l=0);let p=ke("numThreads",r),m=ke(l.toString(),r);Re()._OrtAddSessionConfigEntry(e,p,m)!==0&&Ae(`Can't set a session config entry: 'numThreads' - ${i.numThreads}.`)}if(i?.powerPreference){let l=ke("powerPreference",r),p=ke(i.powerPreference,r);Re()._OrtAddSessionConfigEntry(e,l,p)!==0&&Ae(`Can't set a session config entry: 'powerPreference' - ${i.powerPreference}.`)}}break;case"webgpu":if(o="JS",typeof a!="string"){let i=a;if(i?.preferredLayout){if(i.preferredLayout!=="NCHW"&&i.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${i.preferredLayout}`);let l=ke("preferredLayout",r),p=ke(i.preferredLayout,r);Re()._OrtAddSessionConfigEntry(e,l,p)!==0&&Ae(`Can't set a session config entry: 'preferredLayout' - ${i.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${o}`)}let u=ke(o,r);Re()._OrtAppendExecutionProvider(e,u)!==0&&Ae(`Can't append execution provider: ${o}.`)}},pi=e=>{let t=Re(),r=0,a=[],o=e||{};Bd(o);try{let u=Pd(o.graphOptimizationLevel??"all"),i=kd(o.executionMode??"sequential"),l=typeof o.logId=="string"?ke(o.logId,a):0,p=o.logSeverityLevel??2;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log serverity level is not valid: ${p}`);let m=o.logVerbosityLevel??0;if(!Number.isInteger(m)||m<0||m>4)throw new Error(`log verbosity level is not valid: ${m}`);let d=typeof o.optimizedModelFilePath=="string"?ke(o.optimizedModelFilePath,a):0;if(r=t._OrtCreateSessionOptions(u,!!o.enableCpuMemArena,!!o.enableMemPattern,i,!!o.enableProfiling,0,l,p,m,d),r===0&&Ae("Can't create session options."),o.executionProviders&&Md(r,o.executionProviders,a),o.freeDimensionOverrides)for(let[v,y]of Object.entries(o.freeDimensionOverrides)){if(typeof v!="string")throw new Error(`free dimension override name must be a string: ${v}`);if(typeof y!="number"||!Number.isInteger(y)||y<0)throw new Error(`free dimension override value must be a non-negative integer: ${y}`);let w=ke(v,a);t._OrtAddFreeDimensionOverride(r,w,y)!==0&&Ae(`Can't set a free dimension override: ${v} - ${y}.`)}return o.extra!==void 0&&Cr(o.extra,"",new WeakSet,(v,y)=>{let w=ke(v,a),x=ke(y,a);t._OrtAddSessionConfigEntry(r,w,x)!==0&&Ae(`Can't set a session config entry: ${v} - ${y}.`)}),[r,a]}catch(u){throw r!==0&&t._OrtReleaseSessionOptions(r),a.forEach(i=>t._free(i)),u}}});var aa,Ar,Ir,un,_r,ln,oa,We=j(()=>{"use strict";aa=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},Ar=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},Ir=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],un=e=>{switch(e){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},_r=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},ln=e=>e==="float32"||e==="int32"||e==="int64"||e==="bool"||e==="float16"||e==="uint32",oa=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var Dd,zd,mi,hi,gi,Wd,Ee,Et=j(()=>{"use strict";We();Dd=["V","I","W","E","F"],zd=(e,t)=>{console.log(`[${Dd[e]},${new Date().toISOString()}]${t}`)},gi=(e,t)=>{mi=e,hi=t},Wd=(e,t)=>{let r=_r(e),a=_r(mi);r>=a&&zd(r,typeof t=="function"?t():t)},Ee=(...e)=>{hi&&Wd(...e)}});var yi,bi=j(()=>{"use strict";We();yi=(e,t)=>new(un(t))(e)});var vi=j(()=>{"use strict"});var dn,Vd,wi,sa,ia,$i,xi=j(()=>{"use strict";Et();vi();dn=e=>Math.ceil(e/16)*16,Vd=1,wi=()=>Vd++,sa=async(e,t,r,a)=>{let o=dn(r),u=e.device.createBuffer({size:o,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let i=e.getCommandEncoder();e.endComputePass(),i.copyBufferToBuffer(t,0,u,0,o),e.flush(),await u.mapAsync(GPUMapMode.READ);let l=u.getMappedRange();if(a){let p=a();return p.set(new Uint8Array(l,0,r)),p}else return new Uint8Array(l.slice(0,r))}finally{u.destroy()}},ia=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(t,r){let a=r.buffer,o=r.byteOffset,u=r.byteLength,i=dn(u),l=this.storageCache.get(t);if(!l)throw new Error("gpu data for uploading does not exist");if(l.originalSize!==u)throw new Error(`inconsistent data size. gpu data size=${l.originalSize}, data size=${u}`);let p=this.backend.device.createBuffer({mappedAtCreation:!0,size:i,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),m=p.getMappedRange();new Uint8Array(m).set(new Uint8Array(a,o,u)),p.unmap();let d=this.backend.getCommandEncoder();this.backend.endComputePass(),d.copyBufferToBuffer(p,0,l.gpuData.buffer,0,i),Ee("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(p)}memcpy(t,r){let a=this.storageCache.get(t);if(!a)throw new Error("source gpu data for memcpy does not exist");let o=this.storageCache.get(r);if(!o)throw new Error("destination gpu data for memcpy does not exist");if(a.originalSize!==o.originalSize)throw new Error("inconsistent source and destination gpu data size");let u=dn(a.originalSize),i=this.backend.getCommandEncoder();this.backend.endComputePass(),i.copyBufferToBuffer(a.gpuData.buffer,0,o.gpuData.buffer,0,u)}registerExternalBuffer(t,r,a){let o;if(a){if(o=this.externalBuffers.get(a),o===void 0)throw new Error("previous buffer is not registered");if(t===a)return Ee("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${o}, buffer is the same, skip.`),o;this.externalBuffers.delete(a)}else o=wi();return this.storageCache.set(o,{gpuData:{id:o,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,o),Ee("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${o}, registered.`),o}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),Ee("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let a=dn(t),o,u=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,i=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(u||i){let p=u?this.freeBuffers:this.freeUniformBuffers,m=p.get(a);m||(m=[],p.set(a,m)),m.length>0?o=m.pop():o=this.backend.device.createBuffer({size:a,usage:r})}else o=this.backend.device.createBuffer({size:a,usage:r});let l={id:wi(),type:0,buffer:o};return this.storageCache.set(l.id,{gpuData:l,originalSize:t}),Ee("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${l.id}`),l}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error("releasing data does not exist");return Ee("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let a=this.storageCache.get(t);if(!a)throw new Error("data does not exist");await sa(this.backend,a.gpuData.buffer,a.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();this.buffersForUploadingPending=[];for(let t of this.buffersPending)(t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(t.size).push(t):(t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(t.size).push(t):t.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},$i=(...e)=>new ia(...e)});var ua,ue,Be=j(()=>{"use strict";ua=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this._cacheKey}},ue=e=>new ua(e)});var la,ct,V,Ht,cn,pn,fn,ge=j(()=>{"use strict";la=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},ct=class{static calcShape(t,r,a=!1){let o=t.length,u=r.length;if(o===0)return r;if(u===0)return t;let i=Math.max(t.length,r.length),l=new Array(i);if(a){if(o<2||u<2)return;let p=la.calcMatMulShape([t[o-2],t[o-1]],[r[u-2],r[u-1]]);if(p===void 0)return;[l[i-2],l[i-1]]=p}for(let p=a?3:1;p<=i;p++){let m=o-p<0?1:t[o-p],d=u-p<0?1:r[u-p];if(m!==d&&m>1&&d>1)return;l[i-p]=Math.max(m,d)}return l}static isValidBroadcast(t,r){let a=t.length,o=r.length;if(a>o)return!1;for(let u=1;u<=a;u++)if(t[a-u]!==1&&t[a-u]!==r[o-u])return!1;return!0}},V=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,a){let o=1;for(let u=r;u<a;u++){if(t[u]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");o*=t[u]}return o}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let a=new Array(r);a[r-1]=1,a[r-2]=t[r-1];for(let o=r-3;o>=0;--o)a[o]=a[o+1]*t[o+1];return a}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(a=>this.normalizeAxis(a,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(a=>t[a]):t.slice().reverse()}static padShape(t,r){let a=t.length;return t.map((o,u)=>o+r[u]+r[u+a])}static areEqual(t,r){return t.length!==r.length?!1:t.every((a,o)=>a===r[o])}},Ht=class e{static adjustPoolAttributes(t,r,a,o,u,i){if(!t&&a.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let l=0;l<r.length-2;l++)l>=a.length?a.push(r[l+2]):a[l]=r[l+2];for(let l=0;l<a.length;l++)if(l<o.length){if(o[l]<0)throw new Error("strides should be greater than or equal to 1")}else o.push(1);for(let l=0;l<a.length;l++)if(l<u.length){if(u[l]<0)throw new Error("dilations should be greater than or equal to 1")}else u.push(1);for(let l=0;l<a.length*2;l++)if(l<i.length){if(i[l]<0)throw new Error("pad should be greater than or equal to 1")}else i.push(0);for(let l=0;l<a.length;l++){if(a[l]<=0)throw new Error("kernel shapes need to be greater than 0");if(i[l]>=a[l]||i[l+a.length]>=a[l])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,a,o,u,i,l){if(l){if(u.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(o.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let p=0;p<t.length-2;p++)e.adjustPadAndReturnShape(t[p+(i?1:2)],r[p],a[p],o[p],u,p,p+t.length-2,l)}}static computePoolOutputShape(t,r,a,o,u,i,l){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let p=[r[0],r[1]];return e.computeShapeHelper(t,r,p,a,o,u,i,l),p}static computeConvOutputShape(t,r,a,o,u,i,l){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let p=[t[0],r[0]];return e.computeShapeHelper(!1,t,p,a,o,u,i,l),p}static computeShapeHelper(t,r,a,o,u,i,l,p){if(t)for(let m=0;m<r.length-2;m++)a.push(1);else for(let m=0;m<r.length-2;m++)a.push(e.adjustPadAndReturnShape(r[m+2],o[m],u[m],i[m],l,m,m+r.length-2,p))}static adjustPadAndReturnShape(t,r,a,o,u,i,l,p){let m=a*(o-1)+1;if(p&&p!=="NOTSET")switch(p){case"VALID":return u[i]=0,u[l]=0,Math.floor((t-m)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(a!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let v=((t+r-1)/r-1)*r+o-t;return u[i]=Math.floor(p==="SAME_LOWER"?(v+1)/2:v/2),u[l]=v-u[i],Math.floor((t+v-o)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+u[i]+u[l]-m)/r+1)}},cn=class{static getShapeOfGemmResult(t,r,a,o,u){if(t.length!==2||a.length!==2)throw new Error("shape need to be of size 2");let i,l,p;r?(i=t[1],l=t[0]):(i=t[0],l=t[1]);let m=-1;if(o?(p=a[0],m=1):(p=a[1],m=0),a[m]!==l)throw new Error("dimension mismatch");if(i<=0||p<=0||l<=0)throw new Error("invalid shape specified");if(u&&!ct.isValidBroadcast(u,[i,p]))throw new Error("gemm: invalid bias shape for broadcast");return[i,p,l]}},pn=-34028234663852886e22,fn=34028234663852886e22});var Nd,Si,Me,pt,xt,ot,jt,Rt,Ci,H,Y,da,Ai,ca,St,$e=j(()=>{"use strict";We();ge();Nd=64,Si=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},Me=(e,t=1)=>{let r=Si(e,t);return typeof r=="string"?r:r[0]},pt=e=>e.length===0?[]:[{type:"uint32",data:e},{type:"uint32",data:V.computeStrides(e)}],xt=e=>e%4===0?4:e%2===0?2:1,ot=(e="f32",t,r="0")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,jt=(e,t,r)=>e==="f32"?r:t===1?`f32(${r})`:`vec${t}f(${r})`,Rt=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,Ci=(e,t,r,a,o)=>{let u=typeof r=="number",i=u?r:r.length,l=[...new Array(i).keys()],p=i<2?"u32":i<=4?`vec${i}<u32>`:`array<u32, ${i}>`,m=Si(t,o),d=typeof m=="string"?m:m[1],v=typeof m=="string"?m:m[0],y={indices:p,value:d,storage:v,tensor:t},w=G=>typeof G=="string"?G:`${G}u`,x={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},$=u?"uniforms.":"",A=`${$}${e}_shape`,k=`${$}${e}_strides`,O="";for(let G=0;G<i-1;G++)O+=`
    let dim${G} = current / ${k}[${G}];
    let rest${G} = current % ${k}[${G}];
    indices[${G}] = dim${G};
    current = rest${G};
    `;O+=`indices[${i-1}] = current;`;let T=i<2?"":`
  fn o2i_${e}(offset: u32) -> ${y.indices} {
    var indices: ${y.indices};
    var current = offset;
    ${O}
    return indices;
  }`,R=G=>(x.offsetToIndices=!0,i<2?G:`o2i_${e}(${G})`),z=[];if(i>=2)for(let G=i-1;G>=0;G--)z.push(`${k}[${G}] * (indices[${G}])`);let M=i<2?"":`
  fn i2o_${e}(indices: ${y.indices}) -> u32 {
    return ${z.join("+")};
  }`,W=G=>(x.indicesToOffset=!0,i<2?G:`i2o_${e}(${G})`),K=(...G)=>i===0?"0u":`${y.indices}(${G.map(w).join(",")})`,ee=(G,pe)=>i<2?`${G}`:`${G}[${pe}]`,ae=(G,pe,ce)=>i<2?`${G}=${ce};`:`${G}[${pe}]=${ce};`,D={},te=(G,pe)=>{x.broadcastedIndicesToOffset=!0;let ce=`${pe.name}broadcastedIndicesTo${e}Offset`;if(ce in D)return`${ce}(${G})`;let Fe=[];for(let He=i-1;He>=0;He--){let Ce=pe.indicesGet("outputIndices",He+pe.rank-i);Fe.push(`${ee(k,He)} * (${Ce} % ${ee(A,He)})`)}return D[ce]=`fn ${ce}(outputIndices: ${pe.type.indices}) -> u32 {
             return ${Fe.length>0?Fe.join("+"):"0u"};
           }`,`${ce}(${G})`},_e=(G,pe)=>(()=>{if(y.storage===y.value)return`${e}[${G}]=${pe};`;if(y.storage==="vec2<u32>"&&y.value==="i32")return`${e}[${G}]=vec2<u32>(u32(${pe}), select(0u, 0xFFFFFFFFu, ${pe} < 0));`;if(y.storage==="vec2<u32>"&&y.value==="u32")return`${e}[${G}]=vec2<u32>(u32(${pe}), 0u);`;if(y.storage==="u32"&&y.value==="vec4<bool>")return`${e}[${G}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${pe}));`;throw new Error(`not supported combination of storage type ${y.storage} and value type ${y.value} yet`)})(),Z=G=>(()=>{if(y.storage===y.value)return`${e}[${G}]`;if(y.storage==="vec2<u32>"&&y.value==="i32")return`i32(${e}[${G}].x)`;if(y.storage==="vec2<u32>"&&y.value==="u32")return`u32(${e}[${G}].x)`;if(y.storage==="u32"&&y.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${G}] & 0xFFu), bool(${e}[${G}] & 0xFF00u), bool(${e}[${G}] & 0xFF0000u), bool(${e}[${G}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${y.storage} and value type ${y.value} yet`)})(),we=i<2?"":`
  fn get_${e}ByIndices(indices: ${y.indices}) -> ${d} {
    return ${Z(`i2o_${e}(indices)`)};
  }`,Oe=i<2?"":(()=>{let G=l.map(ce=>`d${ce}: u32`).join(", "),pe=l.map(ce=>`d${ce}`).join(", ");return`
  fn get_${e}(${G}) -> ${d} {
    return get_${e}ByIndices(${K(pe)});
  }`})(),be=(...G)=>{if(G.length!==i)throw new Error(`indices length must be ${i}`);let pe=G.map(w).join(",");return i===0?Z("0u"):i===1?Z(pe[0]):(x.get=!0,x.getByIndices=!0,x.indicesToOffset=!0,`get_${e}(${pe})`)},De=G=>i<2?Z(G):(x.getByIndices=!0,x.indicesToOffset=!0,`get_${e}ByIndices(${G})`),Se=i<2?"":`
  fn set_${e}ByIndices(indices: ${y.indices}, value: ${d}) {
    ${_e(`i2o_${e}(indices)`,"value")}
  }`,Ue=i<2?"":(()=>{let G=l.map(ce=>`d${ce}: u32`).join(", "),pe=l.map(ce=>`d${ce}`).join(", ");return`
  fn set_${e}(${G}, value: ${d}) {
    set_${e}ByIndices(${K(pe)}, value);
  }`})();return{impl:()=>{let G=[];return u||(G.push(`const ${A} = ${y.indices}(${r.join(",")});`),G.push(`const ${k} = ${y.indices}(${V.computeStrides(r).join(",")});`)),x.offsetToIndices&&G.push(T),x.indicesToOffset&&G.push(M),x.broadcastedIndicesToOffset&&Object.values(D).forEach(pe=>G.push(pe)),x.set&&G.push(Ue),x.setByIndices&&G.push(Se),x.get&&G.push(Oe),x.getByIndices&&G.push(we),G.join(`
`)},type:y,offsetToIndices:R,indicesToOffset:W,broadcastedIndicesToOffset:te,indices:K,indicesGet:ee,indicesSet:ae,set:(...G)=>{if(G.length!==i+1)throw new Error(`indices length must be ${i}`);let pe=G[i];if(typeof pe!="string")throw new Error("value must be string");let ce=G.slice(0,i).map(w).join(",");return i===0?_e("0u",pe):i===1?_e(ce[0],pe):(x.set=!0,x.setByIndices=!0,x.indicesToOffset=!0,`set_${e}(${ce}, ${pe})`)},setByOffset:_e,setByIndices:(G,pe)=>i<2?_e(G,pe):(x.setByIndices=!0,x.indicesToOffset=!0,`set_${e}ByIndices(${G}, ${pe});`),get:be,getByOffset:Z,getByIndices:De,usage:a?"input":"output",name:e,strides:k,shape:A,rank:i}},H=(e,t,r,a=1)=>Ci(e,t,r,!0,a),Y=(e,t,r,a=1)=>Ci(e,t,r,!1,a),da=class{constructor(t){this.normalizedDispatchGroup=t;this.indicesHelpers=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=Nd){let r=typeof t=="number"?t:t[0],a=typeof t=="number"?1:t[1],o=typeof t=="number"?1:t[2],u=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,i=u?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,l=u?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${r*a*o}u + local_index;`;return`@compute @workgroup_size(${r}, ${a}, ${o})
  fn main(${i}) {
    ${l}
  `}declareVariable(t,r){this.indicesHelpers.push(t),t.rank!==0&&(t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:t.type.indices}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:t.type.indices}));let a=t.usage==="input"?"read":"read_write",o=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${a}> ${t.name}: array<${o}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`
`)}registerUniform(t,r){return this.uniforms.push({name:t,type:r}),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:r,type:a}of this.uniforms)t.push(`${r}:${a}`);return`
      struct Uniforms { ${t.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.indicesHelpers.map(t=>t.impl()).join(`
`)}},Ai=e=>new da(e),ca=(e,t)=>{let r=e.length,a=[];for(let o=0;o<r;o++){let u=r-1-o,i=e[u]||1;(t[t.length-1-o]||1)>1&&i===1&&a.unshift(u)}return a},St=e=>e<=4});var Ud,Ii,Gd,Fd,Pt,_i,Oi,Or=j(()=>{"use strict";ge();Be();$e();Ud=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},Ii=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,Gd=(e,t)=>V.sortBasedOnPerm(e,Ii(e.length,t)),Fd=(e,t,r,a)=>{let o=[];o.push(`fn perm(i: ${a.type.indices}) -> ${r.type.indices} {
    var a: ${r.type.indices};`);for(let u=0;u<t;++u)o.push(r.indicesSet("a",e[u],`i[${u}]`));return o.push("return a;}"),o.join(`
`)},Pt=(e,t)=>{let r=e.dataType,a=e.dims.length,o=Ii(a,t),u=St(a),i=Gd(e.dims,o),l=u?i.length:i,p=u?a:e.dims,m=Y("output",r,l),d=H("a",r,p),v=y=>`
  ${y.registerUniform("output_size","u32").declareVariables(d,m)}

  ${Fd(o,a,d,m)}

  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${m.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${m.setByOffset("global_idx",d.getByIndices("aIndices"))}
  }`;return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:u?["rank"]:["dims"]},getRunData:y=>{let w=V.size(i);return{outputs:[{dims:i,dataType:y[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:u?[{type:"uint32",data:w},...pt(y[0].dims),...pt(i)]:[{type:"uint32",data:w}]}},getShaderSource:v}},_i=(e,t)=>{Ud(e.inputs),e.compute(Pt(e.inputs[0],t.perm))},Oi=e=>ue({perm:e.perm})});var Ld,Hd,jd,qd,Kd,Yd,Xd,Jd,Zd,Qd,ft,Ti,Ei,Ri,Pi,ki,Bi,Mi,Di,zi,Wi,Vi=j(()=>{"use strict";ge();$e();mn();Or();Ld={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},Hd={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},jd={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},qd={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Kd=(e,t)=>{let r=[];for(let a=t-e;a<t;++a)r.push(a);return r},Yd=(e,t)=>{let r=[],a=e.length;for(let u=0;u<a;u++)t.indexOf(u)===-1&&r.push(e[u]);let o=t.map(u=>e[u]);return[r,o]},Xd=(e,t)=>{let r=e.length+t.length,a=[],o=0;for(let u=0;u<r;u++)t.indexOf(u)===-1?a.push(e[o++]):a.push(1);return a},Jd=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},Zd=(e,t)=>{let r=[];if(!Jd(e,t)){for(let a=0;a<t;++a)e.indexOf(a)===-1&&r.push(a);e.forEach(a=>r.push(a))}return r},Qd=(e,t,r,a,o,u,i)=>{let l=r[0].dims,p=V.size(u),m=V.size(i),d=H("_A",r[0].dataType,l),v=Y("output",o,u),y=32,w=`
          var<workgroup> aBestValues : array<${v.type.storage}, ${y}>;
       `;return{name:e,shaderCache:t,getShaderSource:$=>`
        ${$.registerUniform("reduceSize","u32").declareVariables(d,v)}
        ${w}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${$.mainStart(y)}
          let local_idx = local_id.x;

          let outputIndex = global_idx / ${y};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = ${v.type.storage}(${jd[a]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${y}) {
           let candidate = ${v.type.storage}(${d.getByOffset("offset + k")});
           bestValue = ${Ld[a]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${y}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${Hd[a]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${v.setByOffset("outputIndex",`${a==="mean"?`bestValue / ${v.type.storage}(uniforms.reduceSize)`:`${qd[a]}`}`)};
         }
        }`,getRunData:()=>({outputs:[{dims:u,dataType:o}],dispatchGroup:{x:p},programUniforms:[{type:"uint32",data:m}]})}},ft=(e,t,r,a)=>{let o=e.inputs.length===1?r:pa(e.inputs,r),u=o.axes;u.length===0&&!o.noopWithEmptyAxes&&(u=e.inputs[0].dims.map((w,x)=>x));let i=V.normalizeAxes(u,e.inputs[0].dims.length),l=i,p=e.inputs[0],m=Zd(l,e.inputs[0].dims.length);m.length>0&&(p=e.compute(Pt(e.inputs[0],m),{inputs:[0],outputs:[-1]})[0],l=Kd(l.length,p.dims.length));let[d,v]=Yd(p.dims,l),y=d;o.keepDims&&(y=Xd(d,i)),e.compute(Qd(t,{hint:o.cacheKey,inputDependencies:["type"]},[p],a,e.inputs[0].dataType,y,v),{inputs:[p]})},Ti=(e,t)=>{ft(e,"ReduceMeanShared",t,"mean")},Ei=(e,t)=>{ft(e,"ReduceL1Shared",t,"l1")},Ri=(e,t)=>{ft(e,"ReduceL2Shared",t,"l2")},Pi=(e,t)=>{ft(e,"ReduceLogSumExpShared",t,"logSumExp")},ki=(e,t)=>{ft(e,"ReduceMaxShared",t,"max")},Bi=(e,t)=>{ft(e,"ReduceMinShared",t,"min")},Mi=(e,t)=>{ft(e,"ReduceProdShared",t,"prod")},Di=(e,t)=>{ft(e,"ReduceSumShared",t,"sum")},zi=(e,t)=>{ft(e,"ReduceSumSquareShared",t,"sumSquare")},Wi=(e,t)=>{ft(e,"ReduceLogSumShared",t,"logSum")}});var mt,ec,hn,pa,ht,tc,rc,nc,ac,oc,ic,sc,uc,lc,dc,gt,Ni,Ui,Gi,Fi,Li,Hi,ji,qi,Ki,Yi,it,mn=j(()=>{"use strict";ge();Be();$e();Vi();mt=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},ec=e=>["","",`var value = ${e.getByOffset("inputOffset")};`,""],hn=(e,t,r,a,o,u,i=!1,l=!1)=>{let p=[],m=r[0].dims,d=V.normalizeAxes(o,r[0].dims.length),v=!l&&d.length===0;m.forEach((W,K)=>{v||d.indexOf(K)>=0?i&&p.push(1):p.push(W)});let y=[],w=H("_A",r[0].dataType,m),x=Y("output",u,p),$=a(w,x,d),A=`inputOffset = ${w.indicesToOffset("inputIndices")};`,k=`let ${A};`,O=`var ${A};`,T=$[1]===""?"":O,R=($[1]===""?k:A)+`
`+$[2];for(let W=0,K=0;W<r[0].dims.length;W++)v||d.indexOf(W)>=0?(i&&K++,R=`for(var j${W}: u32 = 0; j${W} < ${r[0].dims[W]}; j${W}++) {
                ${$[2].includes("lastIndex")?`let lastIndex = j${W};`:""}
                ${w.indicesSet("inputIndices",W,`j${W}`)}
                ${R}
              }`):(y.push(`${w.indicesSet("inputIndices",W,x.indicesGet("outputIndices",K))};`),K++);let z=V.size(p);return{name:e,shaderCache:t,getShaderSource:W=>`
        ${W.declareVariables(w,x)}

        ${W.mainStart()}
          ${W.guardAgainstOutOfBoundsWorkgroupSizes(z)}
          var inputIndices: ${w.type.indices};
          let outputIndices = ${x.offsetToIndices("global_idx")};

          ${y.join(`
`)}
          ${$[0]}       // init ops for reduce max/min
          ${T}
          ${$[1]}
          ${R}
          ${$[3]}
          ${$.length===4?x.setByOffset("global_idx","value"):$.slice(4).join(`
`)}
        }`,getRunData:()=>({outputs:[{dims:p,dataType:u}],dispatchGroup:{x:Math.ceil(z/64)}})}},pa=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(a=>r.push(Number(a))),ue({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},ht=(e,t,r,a)=>{let o=e.inputs,u=o.length===1?r:pa(o,r);e.compute(hn(t,{hint:u.cacheKey},[o[0]],u.noopWithEmptyAxes&&u.axes.length===0?ec:a,u.axes,o[0].dataType,u.keepDims,u.noopWithEmptyAxes),{inputs:[0]})},tc=(e,t)=>{mt(e.inputs),ht(e,"ReduceLogSum",t,(a,o)=>[`var value = ${o.type.storage}(0);`,"",`value += ${a.getByOffset("inputOffset")};`,"value = log(value);"])},rc=(e,t)=>{mt(e.inputs),ht(e,"ReduceL1",t,(a,o)=>[`var value = ${o.type.storage}(0);`,"",`value += abs(${a.getByOffset("inputOffset")});`,""])},nc=(e,t)=>{mt(e.inputs),ht(e,"ReduceL2",t,(a,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,"",`t = ${a.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])},ac=(e,t)=>{mt(e.inputs),ht(e,"ReduceLogSumExp",t,(a,o)=>[`var value = ${o.type.storage}(0);`,"",`value += exp(${a.getByOffset("inputOffset")});`,"value = log(value);"])},oc=(e,t)=>{mt(e.inputs),ht(e,"ReduceMax",t,(a,o,u)=>{let i=[];for(let l=0;l<a.rank;l++)(u.indexOf(l)>=0||u.length===0)&&i.push(a.indicesSet("inputIndices",l,0));return[`${i.join(`
`)}`,`var value = ${a.getByOffset("inputOffset")};`,`value = max(value, ${a.getByOffset("inputOffset")});`,""]})},ic=(e,t)=>{mt(e.inputs),ht(e,"ReduceMean",t,(a,o,u)=>{let i=1;for(let l=0;l<a.rank;l++)(u.indexOf(l)>=0||u.length===0)&&(i*=e.inputs[0].dims[l]);return["var sum = f32(0);","",`sum += f32(${a.getByOffset("inputOffset")});`,`let value = ${o.type.value}(sum / ${i});`]})},sc=(e,t)=>{mt(e.inputs),ht(e,"ReduceMin",t,(a,o,u)=>{let i=[];for(let l=0;l<a.rank;l++)(u.indexOf(l)>=0||u.length===0)&&i.push(`inputIndices[${l}] = 0;`);return[`${i.join(`
`)}`,`var value = ${a.getByOffset("inputOffset")};`,`value = min(value, ${a.getByOffset("inputOffset")});`,""]})},uc=(e,t)=>{mt(e.inputs),ht(e,"ReduceProd",t,(a,o)=>[`var value = ${o.type.storage}(1);`,"",`value *= ${a.getByOffset("inputOffset")};`,""])},lc=(e,t)=>{mt(e.inputs),ht(e,"ReduceSum",t,(a,o)=>[`var value = ${o.type.storage}(0);`,"",`value += ${a.getByOffset("inputOffset")};`,""])},dc=(e,t)=>{mt(e.inputs),ht(e,"ReduceSumSquare",t,(a,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,"",`t = ${a.getByOffset("inputOffset")}; value += t * t;`,""])},gt=(e,t,r)=>{if(t.length===0)return!!r;let a=1,o=1;for(let u=0;u<t.length;u++)t.indexOf(u)===-1?a*=e[u]:o*=e[u];return o<32&&a>1024},Ni=(e,t)=>{gt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ic(e,t):Ti(e,t)},Ui=(e,t)=>{gt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?rc(e,t):Ei(e,t)},Gi=(e,t)=>{gt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?nc(e,t):Ri(e,t)},Fi=(e,t)=>{gt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ac(e,t):Pi(e,t)},Li=(e,t)=>{gt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?oc(e,t):ki(e,t)},Hi=(e,t)=>{gt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?sc(e,t):Bi(e,t)},ji=(e,t)=>{gt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?uc(e,t):Mi(e,t)},qi=(e,t)=>{gt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?lc(e,t):Di(e,t)},Ki=(e,t)=>{gt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?dc(e,t):zi(e,t)},Yi=(e,t)=>{gt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?tc(e,t):Wi(e,t)},it=e=>ue(e)});var Xi,Ji,Zi,Qi,fa,es=j(()=>{"use strict";We();Be();mn();Xi=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},Ji=(e,t)=>ue({axis:t.axis,keepDims:t.keepDims,selectLastIndex:t.selectLastIndex}),Zi=(e,t)=>{Xi(e.inputs);let r=(o,u,i)=>{let l=[];for(let p=0;p<o.rank;p++)(i.indexOf(p)>=0||i.length===0)&&l.push(`inputIndices[${p}] = 0;`);return[`${l.join(`
`)}`,`var value = ${o.getByOffset("inputOffset")};
var bestIndex : i32 = 0;`,`if (${o.getByOffset("inputOffset")} ${t.selectLastIndex>0?"<=":"<"} value) {
         value = ${o.getByOffset("inputOffset")};
         bestIndex = i32(lastIndex);
       }`,"",u.setByOffset("global_idx","bestIndex")]},a=e.inputs.length===1?t:Ji(e.inputs,t);e.compute(hn("ArgMin",{hint:a.cacheKey},[e.inputs[0]],r,[a.axis],7,a.keepDims),{inputs:[0]})},Qi=(e,t)=>{Xi(e.inputs);let r=(o,u,i)=>{let l=[];for(let p=0;p<o.rank;p++)(i.indexOf(p)>=0||i.length===0)&&l.push(`inputIndices[${p}] = 0;`);return[`${l.join(`
`)}`,`var value = ${o.getByOffset("inputOffset")};
var bestIndex : i32 = 0;`,`if (${o.getByOffset("inputOffset")} ${t.selectLastIndex>0?">=":">"} value) {
         value = ${o.getByOffset("inputOffset")};
         bestIndex = i32(lastIndex);
       }`,"",u.setByOffset("global_idx","bestIndex")]},a=e.inputs.length===1?t:Ji(e.inputs,t);e.compute(hn("argMax",{hint:a.cacheKey},[e.inputs[0]],r,[a.axis],7,a.keepDims),{inputs:[0]})},fa=e=>ue(e)});var cc,pc,ts,rs=j(()=>{"use strict";ge();$e();cc=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},pc=e=>{let t=e[0].dims,r=e[0].dims[2],a=V.size(t)/4,o=e[0].dataType,u=H("input",o,t,4),i=H("bias",o,[r],4),l=H("residual",o,t,4),p=Y("output",o,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:d=>`
  const channels = ${r}u / 4;
  ${d.declareVariables(u,i,l,p)}

  ${d.mainStart()}
    ${d.guardAgainstOutOfBoundsWorkgroupSizes(a)}
    let value = ${u.getByOffset("global_idx")}
      + ${i.getByOffset("global_idx % channels")} + ${l.getByOffset("global_idx")};
    ${p.setByOffset("global_idx","value")}
  }`}},ts=e=>{cc(e.inputs),e.compute(pc(e.inputs))}});var fc,xe,ns,as,os,is,ss,us,ls,ds,cs,ma,mc,ps,fs,ms,hs,gn,gs,yn,ys,bs,vs,ws,$s,xs,Ss,Cs,As,Is,_s,Os,Ts,Es,Rs,Ps,ks,ha=j(()=>{"use strict";We();ge();Be();$e();fc=(e,t,r,a,o,u)=>{let i=Math.ceil(t/4),l="";typeof o=="string"?l=`${o}(a)`:l=o("a");let p=H("inputData",r,[i],4),m=Y("outputData",a,[i],4);return`
      ${e.registerUniform("vec_size","u32").declareVariables(p,m)}

  ${u??""}

  ${e.mainStart()}
    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${p.getByOffset("global_idx")};
    ${m.setByOffset("global_idx",l)}
  }`},xe=(e,t,r,a,o,u=e.dataType)=>({name:t,shaderCache:{hint:o,inputDependencies:["type"]},getShaderSource:i=>fc(i,V.size(e.dims),e.dataType,u,r,a),getRunData:i=>({outputs:[{dims:e.dims,dataType:u}],dispatchGroup:{x:Math.ceil(V.size(i[0].dims)/64/4)},programUniforms:[{type:"uint32",data:Math.ceil(V.size(e.dims)/4)}]})}),ns=e=>{e.compute(xe(e.inputs[0],"Abs","abs"))},as=e=>{e.compute(xe(e.inputs[0],"Acos","acos"))},os=e=>{e.compute(xe(e.inputs[0],"Acosh","acosh"))},is=e=>{e.compute(xe(e.inputs[0],"Asin","asin"))},ss=e=>{e.compute(xe(e.inputs[0],"Asinh","asinh"))},us=e=>{e.compute(xe(e.inputs[0],"Atan","atan"))},ls=e=>{e.compute(xe(e.inputs[0],"Atanh","atanh"))},ds=e=>ue(e),cs=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute(xe(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},ma=(e,t)=>{let r=Me(e.inputs[0].dataType);e.compute(xe(e.inputs[0],"Clip",a=>`clamp(${a}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<${r}> = vec4(${r}(${t.min}));
    const clip_max_: vec4<${r}> = vec4(${r}(${t.max}));
`,t.cacheKey),{inputs:[0]})},mc=e=>{let t=e.length>=2?e[1].getFloat32Array()[0]:pn,r=e.length>=3?e[2].getFloat32Array()[0]:fn;return ue({min:t,max:r})},ps=e=>{let t=mc(e.inputs);ma(e,t)},fs=e=>{e.compute(xe(e.inputs[0],"Ceil","ceil"))},ms=e=>{e.compute(xe(e.inputs[0],"Cos","cos"))},hs=e=>{e.compute(xe(e.inputs[0],"Cosh","cosh"))},gn=e=>ue(e),gs=(e,t)=>{e.compute(xe(e.inputs[0],"Elu",r=>`elu_vf32(${r})`,`
  const elu_alpha_: f32 = f32(${t.alpha});

  fn elu_f32(a: f32) -> f32 {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,t.cacheKey))},yn=(e,t="f32")=>`
const r0: ${t} = 0.3275911;
const r1: ${t} = 0.254829592;
const r2: ${t} = -0.284496736;
const r3: ${t} = 1.421413741;
const r4: ${t} = -1.453152027;
const r5: ${t} = 1.061405429;

fn erf_vf32(v: ${e}) -> ${e} {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,ys=e=>{let t=Me(e.inputs[0].dataType);e.compute(xe(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,yn(`vec4<${t}>`,t)))},bs=e=>{e.compute(xe(e.inputs[0],"Exp","exp"))},vs=e=>{e.compute(xe(e.inputs[0],"Floor","floor"))},ws=e=>{let t=Me(e.inputs[0].dataType);e.compute(xe(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,yn(`vec4<${t}>`,t)))},$s=(e,t)=>{e.compute(xe(e.inputs[0],"LeakyRelu",r=>`select(leaky_relu_alpha_ * ${r}, ${r}, ${r} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${t.alpha});`,t.cacheKey))},xs=e=>{e.compute(xe(e.inputs[0],"Not",t=>`!${t}`))},Ss=e=>{e.compute(xe(e.inputs[0],"Neg",t=>`-${t}`))},Cs=e=>{e.compute(xe(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},As=e=>{e.compute(xe(e.inputs[0],"Relu",t=>`select(vec4<f32>(0.0), ${t}, ${t} > vec4<f32>(0.0))`))},Is=e=>{e.compute(xe(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},_s=e=>{e.compute(xe(e.inputs[0],"Sin","sin"))},Os=e=>{e.compute(xe(e.inputs[0],"Sinh","sinh"))},Ts=e=>{e.compute(xe(e.inputs[0],"Sqrt","sqrt"))},Es=e=>{e.compute(xe(e.inputs[0],"Tan","tan"))},Rs=e=>{e.compute(xe(e.inputs[0],"Tanh","tanh"))},Ps=(e,t)=>(e.compute(xe(e.inputs[0],"ThresholdedRelu",r=>`select(vec4<f32>(0.0), ${r}, ${r} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${t.alpha});`,t.cacheKey)),0),ks=e=>{e.compute(xe(e.inputs[0],"Log","log"))}});var gc,yc,Bs,Ms=j(()=>{"use strict";ge();$e();ha();gc=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},yc=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=H("input",e[0].dataType,e[0].dims,4),a=H("bias",e[0].dataType,[e[0].dims[2]],4),o=Y("output",e[0].dataType,t,4),u=V.size(t)/4;return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:l=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${e[0].dims[2]/4/2}u;

  ${l.declareVariables(r,a,o)}

  ${yn("vec4f")}

  ${l.mainStart()}
    ${l.guardAgainstOutOfBoundsWorkgroupSizes(u)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${o.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},Bs=e=>{gc(e.inputs),e.compute(yc(e.inputs))}});var bc,vc,yt,Ds,zs,Ws,Vs,Ns,Us,Gs,Fs,Ls,Hs,js=j(()=>{"use strict";We();ge();$e();bc=(e,t,r,a,o,u,i,l,p,m,d,v)=>{let y,w;typeof i=="string"?y=w=(z,M)=>`${i}((${z}),(${M}))`:typeof i=="function"?y=w=i:(y=i.scalar,w=i.vector);let x=d?t.length:t,$=d?r.length:r,A=d?a.length:a,k=Y("outputData",m,A,4),O=H("aData",l,x,4),T=H("bData",p,$,4),R;if(o)if(u){let z=V.size(t)===1,M=V.size(r)===1;z||M?R=k.setByOffset("global_idx",w(z?`${O.type.value}(${O.getByOffset("0")}.x)`:O.getByOffset("global_idx"),M?`${T.type.value}(${T.getByOffset("0")}.x)`:T.getByOffset("global_idx"))):R=`
            let outputIndices = ${k.offsetToIndices("global_idx * 4u")};
            let offsetA = ${O.broadcastedIndicesToOffset("outputIndices",k)};
            let offsetB = ${T.broadcastedIndicesToOffset("outputIndices",k)};
            ${k.setByOffset("global_idx",w(O.getByOffset("offsetA / 4u"),T.getByOffset("offsetB / 4u")))}
          `}else R=k.setByOffset("global_idx",w(O.getByOffset("global_idx"),T.getByOffset("global_idx")));else{if(!u)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let z=(M,W,K="")=>{let ee=`aData[indexA${W}][componentA${W}]`,ae=`bData[indexB${W}][componentB${W}]`;return`
            let outputIndices${W} = ${k.offsetToIndices(`global_idx * 4u + ${W}u`)};
            let offsetA${W} = ${O.broadcastedIndicesToOffset(`outputIndices${W}`,k)};
            let offsetB${W} = ${T.broadcastedIndicesToOffset(`outputIndices${W}`,k)};
            let indexA${W} = offsetA${W} / 4u;
            let indexB${W} = offsetB${W} / 4u;
            let componentA${W} = offsetA${W} % 4u;
            let componentB${W} = offsetB${W} % 4u;
            ${M}[${W}] = ${K}(${y(ee,ae)});
          `};m===9?R=`
            var data = vec4<u32>(0);
            ${z("data",0,"u32")}
            ${z("data",1,"u32")}
            ${z("data",2,"u32")}
            ${z("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:R=`
            ${z("outputData[global_idx]",0)}
            ${z("outputData[global_idx]",1)}
            ${z("outputData[global_idx]",2)}
            ${z("outputData[global_idx]",3)}
          `}return`
        ${e.registerUniform("vec_size","u32").declareVariables(O,T,k)}

        ${v??""}

        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${R}
      }`},vc=(e,t,r,a,o,u,i=r.dataType)=>{let l=!V.areEqual(r.dims,a.dims),p=r.dims,m=V.size(r.dims),d=!1,v=[l];if(l){let w=ct.calcShape(r.dims,a.dims,!1);if(!w)throw new Error("Can't perform binary op on the given tensors");p=w,m=V.size(p);let x=V.size(r.dims)===1,$=V.size(a.dims)===1;v.push(x),v.push($);let A=1;for(let k=1;k<p.length;k++){let O=r.dims[r.dims.length-k]??1,T=a.dims[a.dims.length-k]??1;if(O===T)A*=O;else break}(A%4===0||x||$)&&(d=!0)}else d=!0;v.push(d);let y=St(r.dims.length)&&St(a.dims.length)&&St(p.length);return{name:e,shaderCache:{hint:t+v.map(w=>w.toString()).join("_"),inputDependencies:y?["rank","rank"]:["dims","dims"]},getShaderSource:w=>bc(w,r.dims,a.dims,p,d,l,o,r.dataType,a.dataType,i,y,u),getRunData:()=>({outputs:[{dims:p,dataType:i}],dispatchGroup:{x:Math.ceil(m/64/4)},programUniforms:y?[{type:"uint32",data:Math.ceil(V.size(p)/4)},...pt(r.dims),...pt(a.dims),...pt(p)]:[{type:"uint32",data:Math.ceil(V.size(p)/4)}]})}},yt=(e,t,r,a,o,u)=>{e.compute(vc(t,o??"",e.inputs[0],e.inputs[1],r,a,u))},Ds=e=>{yt(e,"Add",(t,r)=>`${t}+${r}`)},zs=e=>{yt(e,"Div",(t,r)=>`${t}/${r}`)},Ws=e=>{yt(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Vs=e=>{yt(e,"Mul",(t,r)=>`${t}*${r}`)},Ns=e=>{let t=H("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;yt(e,"Pow",{scalar:(a,o)=>`pow_custom(${a},${o})`,vector:(a,o)=>`pow_vector_custom(${a},${o})`},`
    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {
      if (b == ${t}(0.0)) {
        return ${t}(1.0);
      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {
        return ${t}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {
      // TODO: implement vectorized pow
      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},Us=e=>{yt(e,"Sub",(t,r)=>`${t}-${r}`)},Gs=e=>{yt(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},Fs=e=>{yt(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},Ls=e=>{yt(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},Hs=e=>{yt(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var $c,xc,Sc,Cc,qs,Ks,Ys=j(()=>{"use strict";ge();Be();$e();$c=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].dataType,r=e[0].dims.length;for(let a of e){if(a.dataType!==t)throw new Error("input tensors should be one type");if(a.dims.length!==r)throw new Error("input tensors should have the same shape")}},xc=(e,t)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${e}u>(${t});
    for (var i: u32 = 0u; i < ${e}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${e}u;
  }`,Sc=(e,t)=>{let r=e.length,a=[];for(let o=0;o<r;++o){let u=t.setByOffset("global_idx",e[o].getByIndices("indices"));r===1?a.push(u):o===0?a.push(`if (inputIndex == ${o}u) { ${u} }`):o===r-1?a.push(`else { ${u} }`):a.push(`else if (inputIndex == ${o}) { ${u} }`)}return a.join(`
`)},Cc=(e,t)=>{let r=e[0].dims.slice();if(t>=r.length||t<-1*r.length)throw new Error("axis specified for concat doesn't match input dimensionality");let a=t<0?r.length+t:t,o=r.slice(0);for(let R=1;R<e.length;R++){let z=e[R].dims.slice();for(let M=0;M<r.length;M++)if(M===a)o[a]+=z[M];else if(r[M]!==z[M])throw new Error("non concat dimensions must match")}let u=V.size(o),i=new Array(e.length),l=new Array(e.length),p=e[0].dataType,m=0,d=[],v=[],y=[],w=[{type:"uint32",data:u}];for(let R=0;R<e.length;++R)m+=e[R].dims[a],i[R]=m,y.push(St(e[R].dims.length)),v.push(y[R]?e[R].dims.length:e[R].dims),l[R]=H(`input${R}`,p,v[R]),d.push(y[R]?"rank":"dims"),w.push({type:"uint32",data:i[R]});for(let R=0;R<e.length;++R)y[R]&&w.push(...pt(e[R].dims));let x=St(o.length);x&&w.push(...pt(o));let $=x?o.length:o,A=Y("output",p,$),k=A.indicesGet("indices",a),O=Array.from(Array(i.length).keys()).map(R=>`uniforms.sizeInConcatAxis${R}`).join(","),T=R=>`

  ${(()=>{R.registerUniform("outputSize","u32");for(let z=0;z<e.length;z++)R.registerUniform(`sizeInConcatAxis${z}`,"u32");return R.declareVariables(...l,A)})()}

  ${xc(i.length,O)}

  ${R.mainStart()}
    ${R.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${A.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${k});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${i.length}u>(${O});
      ${k} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${Sc(l,A)}
  }`;return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:w}),getShaderSource:T}},qs=(e,t)=>{$c(e.inputs),e.compute(Cc(e.inputs,t.axis))},Ks=e=>ue({axis:e.axis})});var kt,bn,qt=j(()=>{"use strict";ge();kt=(e,t)=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:`value = max(value, ${t}(0.0));`};case"Sigmoid":return{activationFunction:"",applyActivation:`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`};case"Clip":return{activationFunction:`const clip_min_=${t}(${e.clipMin});const clip_max_=${t}(${e.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},bn=e=>{let t=e?.activation||"";if(t==="Clip"){let[r,a]=e?.activation_params||[pn,fn];return{activation:t,clipMax:a,clipMin:r,activationCacheKey:`${t}:${r},${a}`}}return{activation:t,activationCacheKey:t}}});var Ve,vn,wn=j(()=>{"use strict";Ve=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},vn=e=>`
      ${e?"value = value + getBiasByOutputCoords(coords);":""}
      `});var $n,ga=j(()=>{"use strict";$n=`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));
}
`});var Ac,Ic,Tr,Xs,_c,Er,Oc,xn,Rr=j(()=>{"use strict";ge();$e();qt();wn();Ac=(e,t)=>e?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${t?", batchIndices":""});
        `,Ic=(e,t)=>e?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,Tr=(e,t,r="f32",a,o=!1,u=32,i=!1,l=32)=>{let p=t[1]*e[1],m=t[0]*e[0],d=o?p:u,v=o?u:p,y=d/t[0],w=u/t[1];if(!((o&&y===4&&e[1]===4||!o&&(y===3||y===4))&&d%t[0]===0&&u%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${o} is true, innerElementSize ${y} and workPerThread[1] ${e[1]} must be 4.
      Otherwise, innerElementSize ${y} must be 3 or 4.
  tileAWidth ${d} must be divisible by workgroupSize[0]${t[0]}. tileInner ${u} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${y}<${r}>, ${d/y}>, ${v}>;
var<workgroup> mm_Bsub: array<array<vec4<${r}>, ${m/e[0]}>, ${u}>;

const rowPerThread = ${e[1]};
const colPerThread = ${e[0]};
const innerElementSize = ${y};
const tileInner = ${u};

@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${i?"0":"i32(globalId.z)"};
  ${a?`let batchIndices = ${a.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${p};

  let numTiles = ${i?`${Math.ceil(l/u)}`:"(dimInner - 1) / tileInner + 1"};
  var kStart = ${i?`i32(globalId.z) * ${l}`:"0"};

  var acc: array<vec4<${r}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${w};
  for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${Ac(o,a)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${a?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${y===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${Ic(o,y)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},Xs=(e,t)=>e?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${t?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${t?", batchIndices":""});
            `,_c=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",Er=(e,t,r="f32",a,o=!1,u=32,i=!1,l=32,p=!1)=>{let m=e[1]*t[1],d=e[0]*t[0],v=o?m:u,y=o?u:m;if(!(y%t[1]===0&&v%t[0]===0&&u%t[1]===0))throw new Error(`tileAHight ${y} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${v} must be divisible by workgroupSize[0]${t[0]}, tileInner ${u} must be divisible by workgroupSize[1]${t[1]}`);let w=y/t[1],x=v/t[0],$=u/t[1],A=p?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${m};
    let globalColStart = i32(workgroupId.x) * ${d};

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${y}; inputRow = inputRow + ${t[1]}) {
        for (var inputCol = localCol; inputCol < ${v}; inputCol = inputCol + ${t[0]}) {
          ${Xs(o,a)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${u}; inputRow = inputRow + ${t[1]}) {
            for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${t[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${a?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${r}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${o?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${t[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${t[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${m};

let tileRowA = i32(localId.y) * ${w};
let tileColA = i32(localId.x) * ${x};
let tileRowB = i32(localId.y) * ${$};
// Loop over shared dimension.
for (var t = 0; t < numTiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${x}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${Xs(o,a)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${$}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${a?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${r}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${_c(o)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${r}, ${v}>, ${y}>;
  var<workgroup> mm_Bsub : array<array<${r}, ${d}>, ${u}>;
  const rowPerThread = ${e[1]};
  const colPerThread = ${e[0]};
  const tileInner = ${u};

@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${i?"0":"i32(globalId.z)"};
    ${a?`let batchIndices = ${a.offsetToIndices("u32(batch)")};`:""}
    let numTiles = ${i?`${Math.ceil(l/u)}`:"(dimInner - 1) / tileInner + 1"};
    var kStart = ${i?`i32(globalId.z) * ${l}`:"0"};

    var acc : array<array<${r}, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${A}
  }
`},Oc=(e,t,r,a,o,u=!1)=>{let i=o[0],l=o[1],p=o[2],m=a[0],d=a[1],v=a[2],y=a[3],w=ca(i,p),x=ca(l,p),$=Me(a[0].type.tensor),A=()=>{let T=d.rank,R=m.rank,z=`var aIndices: ${d.type.indices};`;for(let M=T-2-1,W=R-1;M>=0;M--,W--)z+=`
aIndices[${M}] = ${R>1?`batchIndices[${W}]`:"batchIndices"};`;return w.forEach(M=>{z+=`
aIndices[${M}] = 0;`}),z+=`
aIndices[${T-2}] = u32(row);
                   aIndices[${T-1}] = u32(colIn);`,z},k=()=>{let T=v.rank,R=m.rank,z=`var bIndices: ${v.type.indices};`;for(let M=T-2-1,W=R-1;M>=0;M--,W--)z+=`
bIndices[${M}] = ${R>1?`batchIndices[${W}]`:"batchIndices"};`;return x.forEach(M=>{z+=`
bIndices[${M}] = 0;`}),z+=`
bIndices[${T-2}] = u32(row);
                   bIndices[${T-1}] = u32(colIn);`,z};return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${m.type.indices}) -> ${Ve(e,$)} {
      var value = ${Ve(e,$)}(0.0);
      let col = colIn * ${e};
      if(row < dimAOuter && col < dimInner)
      {
        ${A()}
        value = ${d.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${m.type.indices}) -> ${Ve(e,$)} {
      var value = ${Ve(e,$)}(0.0);
      let col = colIn * ${e};
      if(row < dimInner && col < dimBOuter)
      {
        ${k()}
        value = ${v.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Ve(e,$)}) {
      let col = colIn * ${e};
      if (row < dimAOuter && col < dimBOuter) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${t?`value = value + ${u?"bias[colIn]":`${Ve(e,$)}(bias[row])`};`:""}
        ${r}
        ${y.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},xn=(e,t,r,a,o=!1)=>{let u=e[0].dims,i=e[1].dims,l=u.slice(0,-2),p=i.slice(0,-2),m=a?a.slice(0,-2):r.slice(0,-2),d=H("batchDims",e[0].dataType,m),v=[d],y=[l,p,m],w=V.size(m),x=u[u.length-2],$=u[u.length-1],A=i[i.length-1],k=$%4===0&&A%4===0,O=x<=8?[4,1,1]:[4,4,1],T=[8,8,1],R=[Math.ceil(A/T[0]/O[0]),Math.ceil(x/T[1]/O[1]),Math.ceil(w/T[2]/O[2])],z=Me(e[0].dataType),M=k?4:1,W=H("a",e[0].dataType,[...l,x,$/M],M),K=H("b",e[1].dataType,[...p,$,A/M],M),ee=Y("result",e[0].dataType,[w,x,A/M],M);v.push(W),v.push(K),v.push(ee);let ae=[W,K],D=e.length>2,{activationFunction:te,applyActivation:_e}=kt(t,ee.type.value),Z=Oc(M,D,_e,v,y,o);if(D){let Oe=o?M:1;ae.push(H("bias",e[2].dataType,e[2].dims,Oe))}let we=Oe=>`
  const dimAOuter: i32 = ${x};
  const dimBOuter: i32 = ${A};
  const dimInner: i32 = ${$};
  ${Oe.declareVariables(...ae,ee)}
  ${te}
  ${Z}
  ${k?Tr(O,T,z,d):Er(O,T,z,d)}
                   ${d.impl()}`;return{name:"MatMul",shaderCache:{hint:t.activationCacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:R[0],y:R[1],z:R[2]}}),getShaderSource:we}}});var Tc,Js,Zs=j(()=>{"use strict";Et();ge();$e();qt();wn();ga();Rr();Tc=(e,t,r,a,o=!1,u,i=4,l=4,p=4,m="f32")=>{let d=D=>{switch(D){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${m}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${D} is not supported.`)}},v=D=>{switch(D){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${D} is not supported.`)}},y=e?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,w=e?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,x=e?"xShape[1]":"xShape[2]",$=e?"xShape[2]":"xShape[3]",A=e?"row":"col",k=e?"col":"row",O=`
    let inChannels = wShape[2];
    let outWidth = ${e?"outShape[2]":"outShape[3]"};
    let outRow = ${A} / outWidth;
    let outCol = ${A} % outWidth;

    let WRow = ${k} / (filterDims[1] * inChannels);
    let WCol = ${k} / inChannels % filterDims[1];
    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];
    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];
    let xCh = ${k} % inChannels;
    var resData = ${Ve(i,m)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${x} && xCol >= 0 && xCol < ${$}) {
      ${y}
      let xIndex = getIndexFromCoords4D(coord, xShape);
      ${d(i)}
    }
    return resData;`,T=e?t&&a?`
    let col = colIn * ${i};
    ${O}`:`
    let col = colIn * ${i};
    if (row < dimAOuter && col < dimInner) {
      ${O}
    }
    return ${Ve(i,m)}(0.0);`:a&&r?`
    let col = colIn * ${i};
    ${O}`:`
    let col = colIn * ${i};
    if (row < dimInner && col < dimBOuter) {
      ${O}
    }
    return ${Ve(i,m)}(0.0);`,R=`${v(l)}`,z=Ve(p,m),M=e?Ve(i,m):Ve(l,m),W=e?Ve(l,m):Ve(i,m),{activationFunction:K,applyActivation:ee}=kt(u,z);return`
    ${K}
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${M} {
      ${e?T:R}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${W} {
      ${e?R:T}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${z}) {
      let col = colIn * ${p};
      if (row < dimAOuter && col < dimBOuter)
      {
      var value = valueIn;
      let outWidth = ${e?"outShape[2]":"outShape[3]"};
      ${w}
      ${vn(o)}
      ${ee}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},Js=(e,t,r,a,o,u,i,l)=>{let p=t.format==="NHWC",m=p?e[0].dims[3]:e[0].dims[1],d=r[0],v=p?r[2]:r[3],y=p?r[1]:r[2],w=p?r[3]:r[1],x=p&&(m%4===0||m%3===0)&&w%4===0,$=p?w:v*y,A=p?v*y:w,k=[8,8,1],O=a<=8?[4,1,1]:[4,4,1],T=[Math.ceil($/k[0]/O[0]),Math.ceil(A/k[1]/O[1]),Math.ceil(d/k[2]/O[2])];Ee("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${T}`);let R=x?p&&m%4!==0?3:4:O[0],z=k[1]*O[1],M=k[0]*O[0],W=Math.max(k[0]*R,k[1]),K=a%z===0,ee=o%M===0,ae=u%W===0,D=x?[R,4,4]:[1,1,1],te=Me(e[0].dataType),_e=[`@group(0) @binding(0) var<storage, read> x: array<${x&&R===4?`vec4<${te}>`:te}>;`,`@group(0) @binding(1) var<storage, read> w: array<${x?`vec4<${te}>`:te}>;`],Z=`
      fn setOutputAtIndex(flatIndex : i32, value : ${x?`vec4<${te}>`:te}) {
        result[flatIndex] = ${x?`vec4<${te}>`:te}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${x?`vec4<${te}>`:te}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${x?"/ 4":""}, value);
      }`;return i&&(_e.push(`@group(0) @binding(2) var<storage, read> bias: array<${x?`vec4<${te}>`:te}>;`),Z+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${x?`vec4<${te}>`:te} {
          return bias[coords.${p?"w":"y"}${x?"/ 4":""}];
        }`),{name:"Conv2DMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:T[0],y:T[1],z:T[2]}}),getShaderSource:()=>`
        ${$n}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${_e.join("")}
        @group(0) @binding(${_e.length}) var<storage, read_write> result: array<${x?`vec4<${te}>`:te}>;
        //@group(0) @binding(${_e.length+1}) var<uniform> uniforms: Uniforms;

        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${V.computeStrides(r).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[0]}, ${t.kernelShape[1]});
        const pad : vec2<i32> = vec2<i32>(${t.pads[0]}, ${t.pads[1]});
        const stride : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});
        const dimAOuter : i32 = ${a};
        const dimBOuter : i32 = ${o};
        const dimInner : i32 = ${u};
        ${Z}
        ${Tc(p,K,ee,ae,i,t,D[0],D[1],D[2],te)}
            ${x?Tr(O,k,te,void 0,!p,W):Er(O,k,te,void 0,!p,W,!1,void 0,l)}`}}});var ya,Qs=j(()=>{"use strict";ge();$e();va();qt();ya=(e,t,r)=>{let a=e.length>2,o=a?"value += b[output_channel];":"",u=e[0].dims,i=e[1].dims,l=i[0]/t.group,p=t.format==="NHWC",m=ba(u,i,t.dilations,t.pads,t.strides,p),d=V.size(m),v=Y("output",e[0].dataType,m),{activationFunction:y,applyActivation:w}=kt(t,v.type.value),x=H("x",e[0].dataType,u),$=H("w",e[1].dataType,i),A=[x,$];a&&A.push(H("b",e[2].dataType,e[2].dims));let k=O=>`
  const strides: vec2<u32> = vec2(${t.strides[0]}u, ${t.strides[1]}u);
  const pads: vec2<u32> = vec2(${t.pads[0]}u, ${t.pads[1]}u);

  ${O.declareVariables(...A,v)}

  ${y}

  ${O.mainStart()}
    ${O.guardAgainstOutOfBoundsWorkgroupSizes(d)}

    let outputIndices = ${v.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${p?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${p?1:2}], outputIndices[${p?2:3}]) * strides - pads;
    let group_id: u32 = output_channel / ${l}u;

    var value: ${v.type.value} = ${v.type.value}(0);
    for (var wInChannel: u32 = 0u; wInChannel < ${i[1]}u; wInChannel++) {
      let input_channel = group_id * ${i[1]}u + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < ${i[2]}u; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * ${t.dilations[0]}u;

        if (xHeight < 0u || xHeight >= ${u[p?1:2]}u) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < ${i[3]}u; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * ${t.dilations[1]}u;
          if (xWidth < 0u || xWidth >= ${u[p?2:3]}u) {
            continue;
          }

          let xVal = ${p?x.get("batch","xHeight","xWidth","input_channel"):x.get("batch","input_channel","xHeight","xWidth")};
          let wVal = ${$.get("output_channel","wInChannel","wHeight","wWidth")};
          value += xVal*wVal;
        }
      }
    }
    ${o}
    ${w}
    ${v.setByOffset("global_idx","value")}
  }`;return{name:"GroupedConv",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r?r(m):m,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)}}),getShaderSource:k}}});var ba,eu,Ec,tu,wa,Rc,Pc,$a,va=j(()=>{"use strict";ge();Be();Zs();Rr();Qs();qt();Or();ba=(e,t,r,a,o,u)=>{let i=e[0],l=e.slice(u?1:2,u?3:4),p=l.length,m=t[0],v=t.slice(2).map((x,$)=>x+(x-1)*(r[$]-1)),w=l.map((x,$)=>x+a[$]+a[$+p]).map((x,$)=>Math.floor((x-v[$]+o[$])/o[$]));return w.splice(0,0,i),w.splice(u?3:1,0,m),w},eu=[2,3,1,0],Ec=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],a=e[1].dims[1]*t.group;if(r!==a)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let o=e[0].dims.length-2;if(t.dilations.length!==o)throw new Error(`dilations should be ${o}D`);if(t.strides.length!==o)throw new Error(`strides should be ${o}D`);if(t.pads.length!==o*2)throw new Error(`pads should be ${o*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},tu=(e,t)=>{let r=e.kernelShape.slice();for(let u=2;u<t[1].dims.length;++u)r[u-2]===0&&(r[u-2]=t[1].dims[u]);let a=e.pads.slice();Ht.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,a,e.format==="NHWC",e.autoPad);let o=Object.assign({},e);return Object.assign(o,{kernelShape:r,pads:a,cacheKey:e.cacheKey}),o},wa=e=>{let t=bn(e),r=e.format,a=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],o=e.dilations,u=e.group,i=e.kernel_shape,l=e.pads,p=e.strides,m=e.w_is_const();return ue({autoPad:a,format:r,dilations:o,group:u,kernelShape:i,pads:l,strides:p,wIsConst:m,...t})},Rc=(e,t,r)=>{let a=tu(r,t);if(r.group!==1){e.compute(ya(t,a));return}let o=r.format==="NHWC",u=t.length===3,i=t[0].dims[o?1:2],l=t[0].dims[o?2:3],p=t[0].dims[o?3:1],m=t[1].dims[2],d=t[1].dims[3],v=ba(t[0].dims,t[1].dims,r.dilations,a.pads,r.strides,o),y=v[o?1:2],w=v[o?2:3],x=v[o?3:1],$=o&&m===i&&d===l&&r.pads[0]===0&&r.pads[1]===0;if($||m===1&&d===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let M=v[0],W,K,ee,ae=[];if(o){let D=e.kernelCustomData.wT??e.compute(Pt(t[1],eu),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=D),$){let te=i*l*p;W=t[0].reshape([1,M,te]),K=D.reshape([1,te,x]),ee=[1,M,x]}else W=t[0].reshape([M,i*l,p]),K=D.reshape([1,p,x]),ee=[M,y*w,x];ae.push(W),ae.push(K)}else W=t[0].reshape([M,p,i*l]),K=t[1].reshape([1,x,p]),ee=[M,x,y*w],ae.push(K),ae.push(W);u&&ae.push(t[2]),e.compute(xn(ae,a,v,ee,o),{inputs:ae});return}let A=!0,k=e.kernelCustomData.wT??e.compute(Pt(t[1],eu),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=k);let O=[t[0],k];u&&O.push(t[2]);let T=o?y*w:x,R=o?x:y*w,z=m*d*p;e.compute(Js(O,a,v,T,R,z,u,A),{inputs:O})},Pc=(e,t)=>{let r=t.format==="NHWC",a=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&a.push(e.inputs[2]);let o=[0,t.pads[0],0,t.pads[1]],u=[1].concat(t.strides),i=[1].concat(t.dilations),l=[1].concat(t.kernelShape),p=tu({...t,pads:o,strides:u,dilations:i,kernelShape:l},a);e.compute(ya(a,p,m=>r?[m[0],m[2],m[3]]:[]))},$a=(e,t)=>{Ec(e.inputs,t),e.inputs[0].dims.length===3?Pc(e,t):Rc(e,e.inputs,t)}});var kc,ru,nu=j(()=>{"use strict";Et();ge();qt();wn();ga();Rr();kc=(e,t=!1,r,a=4)=>{let o=Ve(a,"f32"),u=O=>{switch(O){case 1:return"return W[getIndexFromCoords4D(coord, wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${O} is not supported.`)}},i=e?`
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `,l=e?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,p=e?"outBackprop[1]":"outBackprop[2]",m=e?"outBackprop[2]":"outBackprop[3]",d=e?"row":"col",v=e?"col":"row",y=`
      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};
      let outWidth = ${e?"outShape[2]":"outShape[3]"};
      let outRow = ${d} / outWidth;
      let outCol = ${d} % outWidth;

      let WRow = ${v} / (filterDims[1] * inChannels);
      let WCol = ${v} / inChannels % filterDims[1];
      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);
      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);
      if (xR < 0.0 || xR >= f32(${p}) || fract(xR) > 0.0) {
        return ${o}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${m}) || fract(xC) > 0.0) {
        return ${o}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${v} % inChannels;
      ${i}
      return x[getIndexFromCoords4D(coord, xShape)/${a}];`,w=e?`
      let col = colIn * ${a};
      if (row < dimAOuter && col < dimInner) {
        ${y}
      }
      return ${o}(0.0);`:`
      let col = colIn * ${a};
      if (row < dimInner && col < dimBOuter) {
        ${y}
      }
      return ${o}(0.0);`,x=`
      let col = colIn * ${a};
      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};
      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);
      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];
      if (${e?"row < dimInner && col < dimBOuter":"row < dimInner && col < dimAOuter"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${u(a)}
      }
      return ${o}(0.0);
      `,{activationFunction:$,applyActivation:A}=kt(r,o);return`
      ${$}
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${o} {
    ${e?w:x}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${o} {
    ${e?x:w}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${o}) {
    let col = colIn * ${a};
    if (row < dimAOuter && col < dimBOuter) {
      var value = valueInput;
      let outWidth = ${e?"outShape[2]":"outShape[3]"};
      ${l}
      ${vn(t)}
      ${A}
      result[getIndexFromCoords4D(coords, outShape)/${a}] = value;
    }
  }`},ru=(e,t,r,a,o,u,i,l)=>{let p=t.format==="NHWC",m=p?e[0].dims[3]:e[0].dims[1],d=r[0],v=p?r[2]:r[3],y=p?r[1]:r[2],w=p?r[3]:r[1],x=p?m%4===0&&w%4===0:v%4===0&&w%4===0,$=p?w:v*y,A=p?v*y:w,k=x?[8,8,1]:[$<=4||A<=4?4:16,$>4&&A<=4?4:16,1],O=x?[4,4,1]:[$<=4?1:4,$>4&&A<=4?1:4,1],T=[Math.ceil($/k[0]/O[0]),Math.ceil(A/k[1]/O[1]),Math.ceil(d/k[2]/O[2])];Ee("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${T}`);let R=x?4:1,z=Math.max(k[0]*R,k[1]),M=[`@group(0) @binding(0) var<storage, read> x: array<${x?"vec4<f32>":"f32"}>;`,"@group(0) @binding(1) var<storage, read> W: array<f32>;"],W="";return i&&(M.push(`@group(0) @binding(2) var<storage, read> bias: array<${x?"vec4<f32>":"f32"}>;`),W+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${x?"vec4<f32>":"f32"} {
          return bias[coords.${p?"w":"y"}${x?"/ 4":""}];
        }`),{name:"Conv2DTransposeMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:T[0],y:T[1],z:T[2]}}),getShaderSource:()=>`
        ${$n}
        ${M.join(`
`)}
        @group(0) @binding(${M.length}) var<storage, read_write> result: array<${x?"vec4<f32>":"f32"}>;
        const outBackprop : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});
        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${V.computeStrides(r).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[p?1:2]}, ${t.kernelShape[p?2:3]});
        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(
              ${t.dilations[0]<=1?0:(t.kernelShape[p?1:2]-1)*(t.dilations[0]-1)},
              ${t.dilations[1]<=1?0:(t.kernelShape[p?2:3]-1)*(t.dilations[1]-1)});
        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${t.pads[0]+t.pads[2]})/2,
                                         i32(effectiveFilterDims[1]) - 1 - (${t.pads[1]+t.pads[3]})/2);
        const strides : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});
        const dimAOuter : i32 = ${a};
        const dimBOuter : i32 = ${o};
        const dimInner : i32 = ${u};
        ${W}
        ${kc(p,i,t,R)}
        ${x?Tr(O,k,"f32",void 0,!p,z):Er(O,k,"f32",void 0,!p,z,!1,void 0,l)}`}}});var Bc,xa,au=j(()=>{"use strict";Et();ge();$e();Bc=(e,t,r,a,o,u,i=!1,l)=>{let p=r.format==="NHWC",m=p?1:2,d=p?2:3,v=p?3:1,y=V.size(a),w=i?2:1,x=r.group,$=t[1].dims,A=$[0]/x,k=$[1],O=`
  fn setOutputAtIndex(flatIndex : u32, value : ${i?`vec4<${l}>`:l}) {
    result[flatIndex] = ${i?`vec4<${l}>`:l}(value);
  }`;o&&(O+=`
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${i?`vec4<${l}>`:l} {
      return bias[coords.${p?"w":"y"}${i?"/ 4":""}];
    }`);let T=i?4:1,R=H("W",t[1].dataType,t[1].dims,T),z=H("Dy",t[0].dataType,t[0].dims,T),M=[z,R];o&&M.push(H("bias",t[2].dataType,[a[v]],T));let W=Y("result",t[0].dataType,a,T),K=`{
        let batch: u32 = ${u?"global_id.z":"workgroup_id.z"} / outShape[1];
        let r = ${u?"global_id.z":"workgroup_id.z"} % outShape[1];
        let c = ${u?"global_id.y":"workgroup_id.y"} * ${w};
        let d1: u32 = ${u?"global_id.x":"workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${l}>, ${w}>;
        for (var i = 0; i < ${w}; i++) {
          dotProd[i] = vec4<${l}>(0.0);
        }
        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {
          var dyR = (${l}(dyCorner.x) + ${l}(wR)) / ${l}(strides.x);
          let wRPerm = filterDims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${l}(outBackprop[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {
            let dyC = (${l}(dyCorner.y) + ${l}(wC)) / ${l}(strides.y);
            let dyC2 = (${l}(dyCorner.y) + 1.0 + ${l}(wC)) / ${l}(strides.y);
            let wCPerm = filterDims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${l}(outBackprop[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${l}(outBackprop[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${z.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${l}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${z.get("batch","idyR","idyC2","d2")};

                dotProd[1] = dotProd[1] + vec4<${l}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = outBackprop[${v}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${z.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${l}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${z.get("batch","idyR","idyC2","d2")};
                let tmpval = vec4<${l}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${w}; i = i + 1) {
          let value = dotProd[i] + ${o?"bias[c+i]":"0.0"};
          ${W.set("batch","r","c + i","d1","value")};
        }
      }`,ee=`
          let outputIndices = ${W.offsetToIndices("global_idx")};
          let batch = ${W.indicesGet("outputIndices",0)};
          let d1 = ${W.indicesGet("outputIndices",v)};
          let r = ${W.indicesGet("outputIndices",m)};
          let c = ${W.indicesGet("outputIndices",d)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / ${k};
          let wOutChannel = d1 - groupId * ${k};
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = 0.0;
          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {
            if (wR % dilations.x != 0) {
              continue;
            }
            let dyR = (${l}(dyRCorner) + ${l}(wR)) / ${l}(strides[0]);
            let wRPerm = filterDims.x - 1 - wR / dilations.x;
            if (dyR < 0.0 || dyR >= ${l}(outBackprop[${m}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {
              if (wC % dilations.y != 0) {
                continue;
              }
              let dyC = (${l}(dyCCorner) + ${l}(wC)) / ${l}(strides.y);
              let wCPerm = filterDims.y - 1 - wC / dilations.y;
              if (dyC < 0.0 || dyC >= ${l}(outBackprop[${d}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * ${A};
              for (var d2: u32 = 0; d2 < ${A}; d2 = d2 + 1) {
                let xValue = ${p?z.get("batch","idyR","idyC","inputChannel"):z.get("batch","inputChannel","idyR","idyC")};
                let wValue = ${R.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${o?"bias[d1]":"0.0"};
          ${W.setByOffset("global_idx","value")};
        `;return`
  ${e.declareVariables(...M,W)}
  ${O}
  const outShape : vec4<u32> = vec4<u32>(${a.join(",")});
  const outBackprop : vec4<u32> = vec4<u32>(${t[0].dims.join(",")});
  const strides : vec2<u32> = vec2<u32>(${r.strides[0]}, ${r.strides[1]});
  const filterDims : vec2<u32> = vec2<u32>(${r.kernelShape[p?1:2]}, ${r.kernelShape[p?2:3]});
  const dilations : vec2<u32> = vec2<u32>(${r.dilations[0]}, ${r.dilations[1]});
  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(
          ${r.dilations[0]<=1?0:(r.kernelShape[p?1:2]-1)*(r.dilations[0]-1)},
          ${r.dilations[1]<=1?0:(r.kernelShape[p?2:3]-1)*(r.dilations[1]-1)});
  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,
                                     i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);
    ${e.mainStart()}
    ${e.guardAgainstOutOfBoundsWorkgroupSizes(y)};
  ${i?K:ee}}`},xa=(e,t,r)=>{let a=e.length>2,o=t.outputShape,u=V.size(o),i=[Math.ceil(u/64),1,1];Ee("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${i}`);let l=Me(e[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:t.cacheKey},getRunData:()=>({dispatchGroup:{x:i[0],y:i[1],z:i[2]},outputs:[{dims:r?r(o):o,dataType:e[0].dataType}]}),getShaderSource:p=>Bc(p,e,t,o,a,i[1]===1&&i[2]===1,!1,l)}}});var Mc,Dc,zc,ou,iu,Wc,Vc,Nc,Uc,su,uu=j(()=>{"use strict";Be();nu();au();qt();Or();Mc=(e,t,r,a,o,u)=>(e-1)*t+r+(a-1)*o+1-u,Dc=(e,t,r,a,o)=>{let u=Math.floor(e/2);t==="SAME_UPPER"?(r[a]=u,r[o]=e-u):t==="SAME_LOWER"&&(r[a]=e-u,r[o]=u)},zc=(e,t,r,a,o,u,i,l,p,m)=>{let d=e.length-2,v=m.length===0;if(p.length===0)for(let x=0;x<d;++x)p.push(0);let y=e[0],w=t[l?3:1]*o;for(let x=0,$=e.length-d-(l?1:0);x<d;++x,++$){let A=e[$],k=v?A*i[x]:m[x],O=Mc(A,i[x],u[x],t[$],r[x],k);Dc(O,a,u,x,x+d),v&&m.push(i[x]*(A-1)+p[x]+(t[$]-1)*r[x]+1-u[x]-u[x+d])}m.splice(0,0,y),m.splice(l?3:1,0,w)},ou=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((y,w)=>y*w,1)===0){r.length=0;for(let y=2;y<t[1].dims.length;++y)r.push(t[1].dims[y])}let a=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(a?3:1,0,t[1].dims[1]);let o=e.pads.slice(),u=e.outputShape.slice(),i=e.outputPadding.slice(),l=t[0].dims,p=e.dilations.slice();if(p.reduce((y,w)=>y+w,0)===0){let y=t[0].dims.length-2;p=new Array(y).fill(1)}let m=e.strides.slice();if(m.reduce((y,w)=>y+w,0)===0){let y=t[0].dims.length-2;m=new Array(y).fill(1)}zc(l,r,p,e.autoPad,e.group,o,m,a,i,u);let d=Object.assign({},e),v=e.cacheKey+[r.join("n,"),o.join(","),m.join(","),i.join(","),u.join(","),p.join(",")].join("_");return Object.assign(d,{kernelShape:r,pads:o,outputPadding:i,outputShape:u,dilations:p,strides:m,cacheKey:v}),d},iu=e=>{let t=bn(e),r=e.format,a=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],o=e.dilations,u=e.group,i=e.kernelShape,l=e.pads,p=e.strides,m=e.wIsConst(),d=e.outputPadding,v=e.outputShape;return ue({autoPad:a,format:r,dilations:o,group:u,kernelShape:i,outputPadding:d,outputShape:v,pads:l,strides:p,wIsConst:m,...t})},Wc=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],a=e[1].dims[0];if(r!==a)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let o=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==o))throw new Error("invalid bias");let u=e[0].dims.length-2;if(t.dilations.reduce((d,v)=>d+v,0)>0&&t.dilations.length!==u)throw new Error(`dilations should be ${u}D`);if(t.strides.reduce((d,v)=>d+v,0)>0&&t.strides.length!==u)throw new Error(`strides should be ${u}D`);if(t.pads.reduce((d,v)=>d+v,0)>0&&t.pads.length!==u*2)throw new Error(`pads should be ${u*2}D`);if(t.outputPadding.length!==u&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${u}D`);if(t.kernelShape.reduce((d,v)=>d+v,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},Vc=[2,3,1,0],Nc=(e,t,r)=>{let a=ou(r,t),o=r.format==="NHWC",u=t.length===3;if(a.group!==1){e.compute(xa(t,a));return}let i=a.outputShape,l=i[o?1:2],p=i[o?2:3],m=i[o?3:1],d=t[1].dims[2],v=t[1].dims[3],y=t[0].dims[o?3:1],w=o?l*p:m,x=o?m:l*p,$=d*v*y,A=!0,k=e.kernelCustomData.wT??e.compute(Pt(t[1],Vc),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=k);let O=[t[0],k];u&&(!o&&t[2].dims.length===1?O.push(t[2].reshape([t[2].dims[0],1,1])):O.push(t[2])),e.compute(ru(O,a,i,w,x,$,u,A),{inputs:O})},Uc=(e,t)=>{let r=t.format==="NHWC",a=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];a.length===3&&a.push(e.inputs[2]);let o=t.kernelShape;(o.length===0||o[0]===0)&&(o=[e.inputs[1].dims[2]]);let u=t.dilations;(u.length===0||u[0]===0)&&(u=[1]);let i=t.strides;(i.length===0||i[0]===0)&&(i=[1]);let l=t.pads;l.length===0&&(l=[0,0]),l=[0,l[0],0,l[1]],i=[1].concat(i),u=[1].concat(u),o=[1].concat(o);let p=ou({...t,pads:l,strides:i,dilations:u,kernelShape:o},a);e.compute(xa(a,p,m=>r?[m[0],m[2],m[3]]:[m[0],m[1],m[3]]))},su=(e,t)=>{Wc(e.inputs,t),e.inputs[0].dims.length===3?Uc(e,t):Nc(e,e.inputs,t)}});var Sa,Sn,lu,Gc,Fc,Ca,Aa,Lc,du,cu,pu=j(()=>{"use strict";ge();Be();$e();Sa="[a-zA-Z]|\\.\\.\\.",Sn="("+Sa+")+",lu="^"+Sn+"$",Gc="("+Sn+",)*"+Sn,Fc="^"+Gc+"$",Ca=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let a=this.symbolToIndices.get(t);a===void 0?a=[r]:a.push(r),this.symbolToIndices.set(t,a)}},Aa=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[a,o]=r.includes("->")?r.split("->",2):[r,""];if(!a.match(RegExp(Fc)))throw new Error("Invalid LHS term");if(a.split(",").forEach((l,p)=>{let m=t[p].dims.slice();if(!l.match(RegExp(lu)))throw new Error("Invalid LHS term");let d=this.processTerm(l,!0,m,p);this.lhs.push(d)}),o==="")o+=[...this.symbolToInfo.entries()].filter(([l,p])=>p.count===1||l==="...").map(([l])=>l).join("");else if(!o.match(RegExp(Sn)))throw new Error("Invalid RHS");o.match(RegExp(Sa,"g"))?.forEach(l=>{if(l==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let p=this.symbolToInfo.get(l);if(p===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(p.dimValue)}}),this.rhs=this.processTerm(o,!0,this.outputDims)}addSymbol(t,r,a){let o=this.symbolToInfo.get(t);if(o!==void 0){if(o.dimValue!==r&&o.count!==1)throw new Error("Dimension mismatch");o.count++,o.inputIndices.push(a)}else o={count:1,dimValue:r,inputIndices:[a]};this.symbolToInfo.set(t,o)}processTerm(t,r,a,o=-1){let u=a.length,i=!1,l=[],p=0;if(!t.match(RegExp(lu))&&!r&&t!=="")throw new Error("Invalid LHS term");let m=t.match(RegExp(Sa,"g")),d=new Ca(o);return m?.forEach((v,y)=>{if(v==="..."){if(i)throw new Error("Only one ellipsis is allowed per input term");i=!0;let w=u-m.length+1;if(w<0)throw new Error("Ellipsis out of bounds");if(l=a.slice(p,p+w),this.hasEllipsis){if(this.ellipsisDims.length!==l.length||this.ellipsisDims.toString()!==l.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=l;else throw new Error("Ellipsis must be specified in the LHS");for(let x=0;x<l.length;x++){let $=String.fromCharCode("0".charCodeAt(0)+y);d.addSymbol($,y+x),this.addSymbol($,a[p++],o)}}else d.addSymbol(v,y),this.addSymbol(v,a[p++],o)}),d}},Lc=(e,t)=>{let r=e[0].dataType,a=new Array(e.length);for(let T=0;T<e.length;++T)a[T]=H(`input${T}`,r,e[T].dims);let o=t.outputDims,u=V.size(o),i=Y("output",r,o),l=[],p=Array.from(t.rhs.symbolToIndices.keys()),m="var prod = 1.0;",d="var sum = 0.0;",v="sum += prod;",y=[],w=[],x=[],$=[],A=t.symbolToInfo.size===p.length;t.symbolToInfo.forEach((T,R)=>{if(p.includes(R)){let z=p.indexOf(R);t.lhs.forEach((M,W)=>{if(T.inputIndices.includes(W)){let K=M.symbolToIndices.get(R);if(K===void 0)throw new Error("Invalid symbol error");K.forEach(ee=>{l.push(`${a[W].indicesSet(`input${W}Indices`,ee,i.indicesGet("outputIndices",z))}`)})}})}else t.lhs.forEach((z,M)=>{let W=t.symbolToInfo.get(R);if(W===void 0)throw new Error("Invalid symbol error");if(W.inputIndices.includes(M)){let K=z.symbolToIndices.get(R);if(K===void 0)throw new Error("Invalid symbol error");K.forEach(ee=>{y.push(`${a[M].indicesSet(`input${M}Indices`,ee,`${R}`)}`)}),$.push(`prod *= ${a[M].getByIndices(`input${M}Indices`)};`)}}),w.push(`for(var ${R}: u32 = 0; ${R} < ${t.symbolToInfo.get(R)?.dimValue}; ${R}++) {`),x.push("}")});let k=A?[...l,`let sum = ${a.map((T,R)=>T.getByIndices(`input${R}Indices`)).join(" * ")};`]:[...l,d,...w,...y,m,...$,v,...x],O=T=>`
      ${T.declareVariables(...a,i)}

      ${T.mainStart()}
        ${T.guardAgainstOutOfBoundsWorkgroupSizes(u)}
        var outputIndices = ${i.offsetToIndices("global_idx")};
        ${a.map((R,z)=>`var input${z}Indices: ${a[z].type.indices};`).join(`
`)}
        ${k.join(`
`)};
        ${i.setByOffset("global_idx","sum")};
      }`;return{name:"Einsum",shaderCache:{hint:t.equation},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:O}},du=(e,t)=>{let r=new Aa(e.inputs,t.equation);e.compute(Lc(e.inputs,r))},cu=e=>{let t=e.equation.replace(/\s+/g,"");return ue({equation:t})}});var Hc,fu,jc,qc,mu,hu=j(()=>{"use strict";ge();$e();Hc=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),a=r.length<t.length?0:r.length-t.length,o=t.length<r.length?0:t.length-r.length;for(;a<r.length&&o<t.length;++a,++o)if(r[a]!==t[o]&&r[a]!==1&&t[o]!==1)throw new Error("Expand requires shape to be broadcastable to input")},fu=(e,t)=>{let r=e.length-t.length,a=[];for(let o=0;o<r;++o)a.push(e[o]);for(let o=0;o<t.length;++o)a.push(t[o]===1?e[o+r]:t[o]);return a},jc=(e,t)=>e.length>t.length?fu(e,t):fu(t,e),qc=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),a=jc(t,r),o=V.size(a),u=e[0].dataType,i=H("input",u,t),l=Y("output",u,a),p=m=>`
  const inputShape = ${i.indices(...t)};
  ${m.declareVariables(i,l)}
  ${m.mainStart()}
  ${m.guardAgainstOutOfBoundsWorkgroupSizes(o)}
    let outputIndices = ${l.offsetToIndices("global_idx")};
    var inputIndices: ${i.type.indices};
    for (var i = 0; i < ${t.length}; i++) {
      if (${i.indicesGet("inputShape","i")} == 1) {
        ${i.indicesSet("inputIndices","i",0)}
      } else {
        ${i.indicesSet("inputIndices","i",l.indicesGet("outputIndices",`i + ${a.length-t.length}`))}
      }
    }
    ${l.setByOffset("global_idx",i.getByIndices("inputIndices"))}
  }`;return{name:"Expand",shaderCache:{hint:`${a}`},getShaderSource:p,getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}})}},mu=e=>{Hc(e.inputs),e.compute(qc(e.inputs),{inputs:[0]})}});var Kc,Yc,gu,yu,bu=j(()=>{"use strict";ge();Be();$e();Kc=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},Yc=(e,t)=>{let r=e[0].dims,a=e[1].dims,o=r.length,u=V.normalizeAxis(t.axis,o),i=r.slice(0);i.splice(u,1,...a);let l=r[u],p=V.size(i),m=H("data",e[0].dataType,e[0].dims),d=H("inputIndices",e[1].dataType,e[1].dims),v=Y("output",e[0].dataType,i),y=()=>{let x=a.length,$=`var indicesIndices  = ${d.type.indices}(0);`;for(let A=0;A<x;A++)$+=`${x>1?`indicesIndices[${A}]`:"indicesIndices"} = ${i.length>1?`outputIndices[${u+A}]`:"outputIndices"};`;$+=`
        var idx = ${d.getByIndices("indicesIndices")};
        if (idx < 0) {
          idx = idx + ${l};
        }
        var dataIndices = ${m.type.indices}(0);
      `;for(let A=0,k=0;A<o;A++)A===u?($+=`${o>1?`dataIndices[${A}]`:"dataIndices"} = u32(idx);`,k+=x):($+=`${o>1?`dataIndices[${A}]`:"dataIndices"} = ${i.length>1?`outputIndices[${k}]`:"outputIndices"};`,k++);return $},w=x=>`
      ${x.declareVariables(m,d,v)}
      ${x.mainStart()}
        ${x.guardAgainstOutOfBoundsWorkgroupSizes(p)}
        let outputIndices = ${v.offsetToIndices("global_idx")};
        ${y()};
        let value = ${m.getByIndices("dataIndices")};
        ${v.setByOffset("global_idx","value")};
      }`;return{name:"Gather",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)}}),getShaderSource:w}},gu=e=>ue({axis:e.axis}),yu=(e,t)=>{let r=e.inputs;Kc(r),e.compute(Yc(e.inputs,t))}});var Xc,Jc,vu,wu,$u=j(()=>{"use strict";ge();Be();$e();Xc=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},Jc=(e,t)=>{let r=e[0].dims,a=e[0].dataType,o=r.length,u=V.computeStrides(r),i=V.size(r),l=e[1].dims,p=e[1].dataType,m=V.size(l),d=V.normalizeAxis(t.axis,o),v=r[d],y=l.slice(0),w=V.size(y),x=H("input",a,r),$=H("indices",p,[m]),A=Y("output",a,y),k=O=>`
      const inputStrides = array<u32, ${u.length}>(${u.map(T=>`${T}u`).join(",")});
      ${O.declareVariables(x,$,A)}
      ${O.mainStart()}
      ${O.guardAgainstOutOfBoundsWorkgroupSizes(w)}

      let outputIndices = ${A.offsetToIndices("global_idx")};

      var idx = ${$.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + ${v};
      }

      var srcOffset = u32(0);

      for (var i = 0; i < ${r.length}; i++) {
        if (i == ${d}) {
          srcOffset +=  u32(idx) * inputStrides[i];
        } else {
          srcOffset += ${A.indicesGet("outputIndices","i")} * inputStrides[i];
        }
      }

      // Should never hit this with valid values in indices
      // This is a guard against malicious data in the indices input
      if (srcOffset < 0 || srcOffset >= ${i}) {
        return;
      }

      output[global_idx] = input[srcOffset];
  }`;return{name:"GatherElements",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:y,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)}}),getShaderSource:k}},vu=e=>ue({axis:e.axis}),wu=(e,t)=>{let r=e.inputs;Xc(r),e.compute(Jc(e.inputs,t))}});var Zc,Qc,ep,xu,Su,Cu=j(()=>{"use strict";ge();Be();$e();Zc=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},Qc=(e,t,r)=>{if(r.length===0)return"0u";let a=r.length===1&&e!==1||r.length===2&&r[0]!==e,o=r[r.length-1]!==t,u="0u";return a||(u+=`+ m * ${r[r.length-1]}u`),o||(u+="+n"),u},ep=(e,t)=>{let r=e[0].dims.slice(),a=e[1].dims.slice(),[o,u,i]=cn.getShapeOfGemmResult(r,t.transA,a,t.transB,e.length===3?e[2].dims:void 0),l=[o,u];if(!l)throw new Error("Can't use gemm on the given tensors");let p=V.size(l),m="";t.transA&&t.transB?m="value += a[k * M + m] * b[n * K + k];":t.transA&&!t.transB?m="value += a[k * M + m] * b[k * N + n];":!t.transA&&t.transB?m="value += a[m * K + k] * b[n * K + k];":!t.transA&&!t.transB&&(m="value += a[m * K + k] * b[k * N + n];");let d=Me(e[0].dataType),v=t.alpha===1?"":"value *= alpha;",y=e.length===3?`value += beta * c[${Qc(o,u,e[2].dims)}];`:"",w=[`@group(0) @binding(0) var<storage, read> a : array<${d}>;`,`@group(0) @binding(1) var<storage, read> b : array<${d}>;`];e.length===3&&w.push(`@group(0) @binding(2) var<storage, read> c : array<${d}>;`);let x=$=>`
  const M: u32 = ${o}u;
  const N: u32 = ${u}u;
  const K: u32 = ${i}u;
  const alpha = ${d}(${t.alpha});
  const beta = ${d}(${t.beta});

  ${w.join(`
`)}
  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${d}>;

  ${$.mainStart()}
    ${$.guardAgainstOutOfBoundsWorkgroupSizes(p)}

    let m = global_id.x / N;
    let n = global_id.x % N;

    var value = ${d}(0);
    for (var k: u32 = 0u; k<${i}u; k++) {
      ${m}
    }

    ${v}
    ${y}
    output[global_id.x] = value;

  }`;return{name:"Gemm",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:l,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)}}),getShaderSource:x}},xu=(e,t)=>{Zc(e.inputs),e.compute(ep(e.inputs,t))},Su=e=>ue(e)});var tp,rp,np,ap,Au,Iu,_u=j(()=>{"use strict";We();ge();Be();$e();tp={name:"InstanceNormalization"},rp=(e,t)=>{let r=e[0].dims,a=r,o=2,u=V.sizeToDimension(r,o),i=V.sizeFromDimension(r,o),l=r[1],p=H("x",e[0].dataType,[r[0],r[1],i]),m=H("scale",e[1].dataType,e[1].dims),d=H("bias",e[2].dataType,e[2].dims),v=Y("output",e[0].dataType,[r[0],r[1],i]),y=[p,m,d,v],w=p.type.value,x=64,$=A=>`

  const C: u32 = ${l};
  const normSize: u32 = ${i};
  const epsilon: f32 = ${t.epsilon};
  var<workgroup> meanShared : ${w};
  var<workgroup> squaredNormShared : ${w};
  var<workgroup> workgroupShared : array<${w}, ${x}>;
  const workgroupSize = ${x}u;
  ${A.declareVariables(...y)}
  ${A.mainStart(x)}
    let norm = global_idx / workgroupSize;
    let batch = norm / C;
    let channel = norm % C;
    let localIndex = local_id.x;

    // initialize workgroup memory
    var initial: ${w} = 0;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      initial = initial + ${p.get("batch","channel","h")};
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the mean of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      meanShared = workgroupShared[0] / ${w}(normSize);
    }
    workgroupBarrier();

    // reinitialize workgroup memory.
    initial = 0;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      let deviation =  ${p.get("batch","channel","h")} - meanShared;
      initial = initial + deviation * deviation;
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the sum of square of deviation of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      squaredNormShared = workgroupShared[0];
    }
    workgroupBarrier();

    let invStdDev = 1 / sqrt(squaredNormShared / ${w}(normSize) + epsilon);
    let channelScale = invStdDev * ${m.getByOffset("channel")};
    let channelShift = ${d.getByOffset("channel")} - meanShared * channelScale;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      let value = ${p.get("batch","channel","h")} * channelScale + channelShift;
      ${v.set("batch","channel","h","value")};
    }
  }`;return{...tp,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:u}}),getShaderSource:$}},np=(e,t,r,a,o,u,i,l)=>{let p=xt(i),m=H("input",t.dataType,t.dims,p),d=H("scale",r.dataType,r.dims,p),v=H("bias",a.dataType,a.dims,p),y=64,w=p===1?"vec2f":`mat2x${p}f`,x=p===1?"f32":`vec${p}f`,$=(z,M)=>`${w}(${z}, ${M})`,A=o*i/p,k=Math.ceil(u/y),O=z=>`
  const H: u32 = ${u};
  const C: u32 = ${i/p};
  const imageSize: u32 = ${u*i/p};

  ${z.declareVariables(m)}
  @group(0) @binding(1) var<storage, read_write> output : array<${w}>;

  ${z.mainStart(y)}
    let currentImageNumber = global_idx / ${y} / C;
    let currentChannelNumber = (global_idx / ${y}) % C;
    let wgId = global_idx % ${y};
    let wgOffset = wgId * ${k};
    if (wgOffset >= H) {
        return;
    }
    let wgMax = min(wgOffset + ${k}, H);

    let offset = currentImageNumber * imageSize + currentChannelNumber;
    var sum = ${ot("f32",p)};
    var squaredSum = ${ot("f32",p)};
    for (var i: u32 = wgOffset; i < wgMax; i++) {
        let value = ${x}(input[offset + i * C]);
        sum += value;
        squaredSum += value * value;
    }
    output[global_idx] = ${$("sum","squaredSum")};
  }`,T=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:p,n:o,h:u,c:i})},getRunData:()=>({outputs:[{dims:[o,i,y,2],dataType:1}],dispatchGroup:{x:o*i/p}}),getShaderSource:O},{inputs:[t],outputs:[-1]})[0],R=z=>`
  const H: u32 = ${u};
  const C: u32 = ${i/p};
  const imageSize: u32 = ${y*i/p};
  const epsilon: f32 = ${l};

  @group(0) @binding(0) var<storage, read> input : array<${w}>;
  @group(0) @binding(1) var<storage, read> scale : array<${d.type.storage}>;
  @group(0) @binding(2) var<storage, read> bias : array<${v.type.storage}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${w}>;

  ${z.mainStart()}
    ${z.guardAgainstOutOfBoundsWorkgroupSizes(A)}
    let currentImageNumber = global_idx / C;
    let currentChannelNumber = global_idx % C;

    let offset = currentImageNumber * imageSize;
    var sum = ${ot("f32",p)};
    var squaredSum = ${ot("f32",p)};
    for (var i: u32 = 0; i < ${y}; i++) {
        let value = input[offset + i + currentChannelNumber * ${y}];
        sum += value[0];
        squaredSum += value[1];
    }
    sum = sum / f32(H);
    squaredSum = squaredSum / f32(H);
    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);
    let channelScale = invStdDev * ${x}(scale[currentChannelNumber]);
    let channelShift = ${x}(bias[currentChannelNumber]) - sum * channelScale;

    output[global_idx] = ${$("channelScale","channelShift")};
  }`;return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:p,n:o,h:u,c:i,epsilon:l})},getRunData:()=>({outputs:[{dims:[o,i,2],dataType:1}],dispatchGroup:{x:Math.ceil(A/64)}}),getShaderSource:R},{inputs:[T,r,a],outputs:[-1]})[0]},ap=(e,t,r)=>{let a=t[0].dims,o=a,u=a[0],i=a[a.length-1],l=V.sizeFromDimension(a,1)/i,p=xt(i),m=V.size(o)/p,d=H("input",t[0].dataType,t[0].dims,p),v=Y("output",t[0].dataType,o,p),y=Me(t[0].dataType),w=p===1?"vec2f":`mat2x${p}f`,x=p===1?y:`vec${p}<${y}>`,$=np(e,t[0],t[1],t[2],u,l,i,r.epsilon),A=k=>`
  const H: u32 = ${l};
  const C: u32 = ${i/p};

  @group(0) @binding(0) var<storage, read> input : array<${d.type.storage}>;
  @group(0) @binding(1) var<storage, read> scaleInput : array<${w}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${v.type.storage}>;

  ${k.mainStart()}
    let currentImageNumber = global_idx / (C * H);
    let currentChannelNumber = global_idx % C;

    let scaleOffset = currentImageNumber * C + currentChannelNumber;
    let scale = scaleInput[scaleOffset];
    output[global_idx] = fma(input[global_idx], ${x}(scale[0]), ${x}(scale[1]));
  }`;e.compute({name:"InstanceNormalization",shaderCache:{hint:`${r.cacheKey}`},getRunData:()=>({outputs:[{dims:o,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)}}),getShaderSource:A},{inputs:[t[0],$]})},Au=e=>ue({epsilon:e.epsilon,format:e.format}),Iu=(e,t)=>{t.format==="NHWC"?ap(e,e.inputs,t):e.compute(rp(e.inputs,t))}});var op,ip,Ou,Tu,Eu=j(()=>{"use strict";We();ge();Be();$e();op=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},ip=(e,t,r)=>{let a=e[0].dims,o=e[1],u=e[2],i=a,l=V.normalizeAxis(t.axis,a.length),p=V.sizeToDimension(a,l),m=V.sizeFromDimension(a,l),d=V.size(o.dims),v=u?V.size(u.dims):0;if(d!==m||u&&v!==m)throw new Error(`Size of X.shape()[axis:] == ${m}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${d} and bias size of ${v}`);let y=[];for(let R=0;R<a.length;++R)R<l?y.push(a[R]):y.push(1);let w=xt(m),x=Me(e[0].dataType),$=[H("x",e[0].dataType,e[0].dims,w),H("scale",o.dataType,o.dims,w)];u&&$.push(H("bias",u.dataType,u.dims,w)),$.push(Y("output",e[0].dataType,i,w));let A=r>1,k=r>2;A&&$.push(Y("meanDataOutput",1,y)),k&&$.push(Y("invStdOutput",1,y));let O=R=>`
  const normSize: f32 = ${m};
  const normSizeVectorized: u32 = ${m/w};
  const epsilon: f32 = ${t.epsilon};

  ${R.declareVariables(...$)}
  ${R.mainStart()}
    ${R.guardAgainstOutOfBoundsWorkgroupSizes(p)}
    let offset = global_idx * normSizeVectorized;
    var meanVector = ${ot("f32",w)};
    var meanSquareVector = ${ot("f32",w)};

    for (var h: u32 = 0u; h < normSizeVectorized; h++) {
      let value = ${jt(x,w,"x[h + offset]")};
      meanVector += value;
      meanSquareVector += value * value;
    }
    let mean = ${Rt("meanVector",w)} / normSize;
    let meanSquare = sqrt(${Rt("meanSquareVector",w)} 
      / normSize - mean * mean + epsilon);

    for (var j: u32 = 0; j < normSizeVectorized; j++) {
      let f32input = ${jt(x,w,"x[j + offset]")};
      let f32scale = ${jt(x,w,"scale[j]")};
      output[j + offset] = ${$[0].type.value}((f32input - mean) / meanSquare * f32scale
        ${u?`+ ${jt(x,w,"bias[j]")}`:""}
      );
    }

    ${A?"meanDataOutput[global_idx] = mean":""};
    ${k?"invStdOutput[global_idx] = 1 / meanSquare":""};
  }`,T=[{dims:i,dataType:e[0].dataType}];return A&&T.push({dims:y,dataType:1}),k&&T.push({dims:y,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${t.cacheKey}|${r}|${e.length}`},getRunData:()=>({outputs:T,dispatchGroup:{x:Math.ceil(p/64)}}),getShaderSource:O}},Ou=e=>ue({axis:e.axis,epsilon:e.epsilon}),Tu=(e,t)=>{op(e.inputs),e.compute(ip(e.inputs,t,e.outputCount))}});var sp,Ru,Pu=j(()=>{"use strict";ge();Rr();sp=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},Ru=e=>{sp(e.inputs);let t=ct.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can't use matmul on the given tensors");e.compute(xn(e.inputs,{activation:"",activationCacheKey:""},t))}});var up,lp,dp,cp,pp,fp,mp,hp,gp,ku,Bu,Mu=j(()=>{"use strict";We();ge();Be();$e();up=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1)throw new Error("Input type must be float.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},lp=(e,t,r,a,o,u,i)=>{let l=r.length,p="";for(let m=l-1;m>=0;--m)p+=`
            k = i32(${e.indicesGet("indices",m)}) - ${o[m]};
            if (k < 0) {
              break;
            }
            if (k >= ${r[m]}) {
              break;
            }
            offset += k * ${a[m]};
        `;return`
          value = ${u}(${i});
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${p}
            value = x[offset];
          }
      `},dp=(e,t,r,a,o)=>{let u=r.length,i="";for(let l=u-1;l>=0;--l)i+=`
                k = i32(${e.indicesGet("indices",l)}) - ${o[l]};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = ${2*(r[l]-1)};
                  k = k % _2n_1;
                  if(k >= ${r[l]}) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * ${a[l]};
            `;return`
              var offset = 0;
              var k = 0;
              ${i}
              value = x[offset];
          `},cp=(e,t,r,a,o)=>{let u=r.length,i="";for(let l=u-1;l>=0;--l)i+=`
                k = i32(${e.indicesGet("indices",l)}) - ${o[l]};
                if (k < 0) {
                  k = 0;
                }
                if (k >= ${r[l]}) {
                  k = ${r[l]-1};
                }
                offset += k * ${a[l]};
            `;return`
              var offset = 0;
              var k = 0;
              ${i}
              value = x[offset];
          `},pp=(e,t,r,a,o)=>{let u=r.length,i="";for(let l=u-1;l>=0;--l)i+=`
                k = i32(${e.indicesGet("indices",l)}) - ${o[l]};
                if (k < 0)  {
                  k += ${r[l]};
                }
                if (k >= ${r[l]}) {
                  k -= ${r[l]};
                }
                offset += k * ${a[l]};
            `;return`
              var offset = 0;
              var k = 0;
              ${i}
              value = x[offset];
          `},fp=(e,t,r,a,o,u)=>{switch(o.mode){case 0:return lp(e,t,r,a,o.pads,u,o.value);case 1:return dp(e,t,r,a,o.pads);case 2:return cp(e,t,r,a,o.pads);case 3:return pp(e,t,r,a,o.pads);default:throw new Error("Invalid mode")}},mp=(e,t,r,a)=>{let o=t[0].dims,u=V.padShape(o.slice(),r.pads),i=V.size(u),l=V.computeStrides(o),p=Y("output",t[0].dataType,u),m=H("x",t[0].dataType,o),d=fp(p,u,o,l,r,a);return`
              ${e.declareVariables(m,p)}
              ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes(i)}

              let indices = ${p.offsetToIndices("global_idx")};

              var value = ${a}(0);
              ${d}
              output[global_idx] = value;
          }`},hp=(e,t)=>{let r=V.padShape(e[0].dims.slice(),t.pads);return{name:"Pad",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(V.size(r)/64)}}),getShaderSource:a=>mp(a,e,t,"f32")}},gp=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),a=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,o=e[0].dims.length,u=new Int32Array(2*o).fill(0);if(e.length>=4){let l=e[3].getBigInt64Array();for(let p=0;p<l.length;p++)u[Number(l[p])]=Number(r[p]),u[Number(l[p])+o]=Number(r[p+l.length])}else r.forEach((l,p)=>u[Number(p)]=Number(l));let i=[];return u.forEach(l=>i.push(l)),ue({mode:t.mode,value:a,pads:i})}else return t},ku=(e,t)=>{up(e.inputs);let r=gp(e.inputs,t);e.compute(hp(e.inputs,r),{inputs:[0]})},Bu=e=>{let t=e.mode,r=e.value,a=e.pads;return ue({mode:t,value:r,pads:a})}});var Cn,Du,zu,Wu,Vu,Nu,Uu,Gu,Fu,Lu,Hu,ju,qu,Ku,Yu,Xu=j(()=>{"use strict";ge();Be();$e();Cn=e=>{if(!e||e.length!==1)throw new Error("Pool ops requires 1 input.");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("Pool ops supports 1-D or 2-D inputs only for now.")},Du=(e,t,r)=>{let a=t.format==="NHWC",o=e.dims.slice();a&&o.splice(1,0,o.pop());let u=Object.hasOwnProperty.call(t,"dilations"),i=t.kernelShape.slice(),l=t.strides.slice(),p=u?t.dilations.slice():[],m=t.pads.slice();Ht.adjustPoolAttributes(r,o,i,l,p,m);let d=Ht.computePoolOutputShape(r,o,l,p,i,m,t.autoPad),v=Object.assign({},t);u?Object.assign(v,{kernelShape:i,strides:l,pads:m,dilations:p,cacheKey:t.cacheKey}):Object.assign(v,{kernelShape:i,strides:l,pads:m,cacheKey:t.cacheKey});let y=d.slice();return y.push(y.splice(1,1)[0]),[v,a?y:d]},zu=(e,t,r,a,o,u,i,l)=>{let p=o.format==="NHWC",m=r,d=t.type.value,v=m.length,y=V.size(a),w=Y("output",t.type.tensor,a);if(o.kernelShape.length<=2){let x=o.kernelShape[o.kernelShape.length-1],$=o.strides[o.strides.length-1],A=o.pads[o.pads.length/2-1],k=o.pads[o.pads.length-1],O=v-(p?2:1),T="",R="",z="";if(A+k!==0?T=`
                for (var i: u32 = 0u; i < ${x}u; i++) {
                  xIndices[${O}] = indices[${O}] * ${$} - ${A} + i;
                  if (xIndices[${O}] < 0 || xIndices[${O}] >= ${m[O]}) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${t.indicesToOffset("xIndices")}];
                  ${u}
                }`:T=`
                for (var i: u32 = 0u; i < ${x}u; i++) {
                  xIndices[${O}] = indices[${O}] * ${$} - ${A} + i;
                  let x_val = x[${t.indicesToOffset("xIndices")}];
                  ${u}
                }`,o.kernelShape.length===2){let W=o.kernelShape[o.kernelShape.length-2],K=o.strides[o.strides.length-2],ee=o.pads[o.pads.length/2-2],ae=o.pads[o.pads.length-2],D=v-(p?3:2),te=m[D];ee+ae!==0?R=`
                for (var j: u32 = 0u; j < ${W}u; j++) {
                  xIndices[${D}] = indices[${D}] * ${K} - ${ee} + j;
                  if (xIndices[${D}] < 0 || xIndices[${D}] >= ${te}) {
                    pad+= ${x};
                    continue;
                  }
              `:R=`
                for (var j: u32 = 0u; j < ${W}u; j++) {
                  xIndices[${D}] = indices[${D}] * ${K} - ${ee} + j;
                `,z=`
              }
            `}return`
            ${e.declareVariables(t,w)}

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes(y)}

              let indices = ${w.offsetToIndices("global_idx")};
              var xIndices = ${w.offsetToIndices("global_idx")};

              var value: ${d} = ${d}(${l});
              var pad = 0;
              ${R}
              ${T}
              ${z}
              ${i}

              output[global_idx] = value;
            }`}else{if(p)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let x=V.size(o.kernelShape),$=V.computeStrides(o.kernelShape),A=$.length,k=o.pads.length,O=o.pads.reduce((z,M)=>z+M),T="";return O?T=`
                if (xIndices[j] >= inputDims[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${t.indicesToOffset("xIndices")}];
                ${u}
              }`:T=`
              }
              let x_val = x[${t.indicesToOffset("xIndices")}];
              ${u}
            `,`
            ${e.declareVariables(t,w)}

            const pads = array<u32, ${k}>(${o.pads.map(z=>`${z}u`).join(",")});
            const inputDims = array<u32, ${v}>(${m.map(z=>`${z}u`).join(",")});
            const kernelStrides = array<u32, ${A}>(${$.map(z=>`${z}u`).join(",")});
            const strides = array<u32, ${A}>(${o.strides.map(z=>`${z}u`).join(",")});

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes(y)}

              let indices = ${w.offsetToIndices("global_idx")};
              let xIndices = ${w.offsetToIndices("global_idx")};

              var offsets: array<u32, ${A}>;

              var value = ${w.type.value}(${l});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < ${x}u; i++) {
                var offset = i;
                for (var j = 0u; j < ${A-1}u; j++) {
                  offsets[j] = offset / kernelStrides[j];
                  offset -= offsets[j] * kernelStrides[j];
                }
                offsets[${A-1}] = offset;

                isPad = false;
                for (var j = ${v-A}u; j < ${v}u; j++) {
                  xIndices[j] = indices[j] * strides[j - ${v-A}u]
                    + offsets[j - ${v-A}u] - pads[j - 2u];
                  ${T}
              }
              ${i}

              output[global_idx] = value;
            }`}},Wu=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Vu=(e,t,r,a)=>{let[o,u]=Du(t,a,r),i=V.size(o.kernelShape),l=H("x",t.dataType,t.dims),p=l.type.value,m="value += x_val;",d="";return o.countIncludePad?d+=`value /= ${p}(${i});`:d+=`value /= ${p}(${i} - pad);`,{name:e,shaderCache:{hint:a.cacheKey},getRunData:()=>({outputs:[{dims:u,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(V.size(u)/64)}}),getShaderSource:v=>zu(v,l,t.dims,u,o,m,d,"0.0")}},Nu=e=>{let t=e.count_include_pad!==0,r=Wu(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return ue({countIncludePad:t,...r})},Uu=(e,t)=>{Cn(e.inputs),e.compute(Vu("AveragePool",e.inputs[0],!1,t))},Gu={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},Fu=e=>{let t=e.format;return{format:t,...Gu,cacheKey:t}},Lu=(e,t)=>{Cn(e.inputs),e.compute(Vu("GlobalAveragePool",e.inputs[0],!0,t))},Hu=(e,t,r,a)=>{let[o,u]=Du(t,a,r),i=`
      value = max(x_val, value);
    `,l="",p=H("x",t.dataType,t.dims);return{name:e,shaderCache:{hint:a.cacheKey},getRunData:()=>({outputs:[{dims:u,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(V.size(u)/64)}}),getShaderSource:m=>zu(m,p,t.dims,u,o,i,l,"-1e5")}},ju=(e,t)=>{Cn(e.inputs),e.compute(Hu("MaxPool",e.inputs[0],!1,t))},qu=e=>{let t=e.storage_order,r=e.dilations,a=Wu(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(a.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return ue({storageOrder:t,dilations:r,...a})},Ku=e=>{let t=e.format;return{format:t,...Gu,cacheKey:t}},Yu=(e,t)=>{Cn(e.inputs),e.compute(Hu("GlobalMaxPool",e.inputs[0],!0,t))}});var bp,vp,Ju,Zu=j(()=>{"use strict";Tt();We();$e();bp=(e,t,r)=>{let a=e===t,o=e<t&&r<0,u=e>t&&r>0;if(a||o||u)throw new Error("Range these inputs' contents are invalid.")},vp=(e,t,r,a)=>{let o=Math.abs(Math.ceil((t-e)/r)),u=[o],i=o,l=Y("output",a,u),p=l.type.storage,m=d=>`
        ${d.declareVariables(l)}
        ${d.mainStart()}
        ${d.guardAgainstOutOfBoundsWorkgroupSizes(i)}
        output[global_idx] = ${p}(${e}) + ${p}(global_idx) * ${p}(${r});
      }`;return{name:"Range",shaderCache:{hint:[e,t,r].map(d=>d.toString()).join("_")},getShaderSource:m,getRunData:()=>({outputs:[{dims:u,dataType:a}],dispatchGroup:{x:Math.ceil(i/64)}})}},Ju=e=>{let t=0,r=0,a=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],a=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],a=e.inputs[2].getFloat32Array()[0]),Ie.webgpu.validateInputContent&&bp(t,r,a),e.compute(vp(t,r,a,e.inputs[0].dataType),{inputs:[]})}});var wp,$p,xp,Sp,Cp,Ap,Ip,_p,Op,Tp,Ep,Rp,Pp,kp,Bp,Qu,el,tl=j(()=>{"use strict";ge();Be();$e();wp=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},$p=(e,t,r)=>{t.every(o=>o>=0&&o<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let a=new Array(r).fill(1);return t.forEach((o,u)=>a[o]=e[u]),a},xp=(e,t,r,a,o,u)=>{let[i,l,p]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],m=e[0].dims.length;if(i>0&&e.length>i&&e[i].dims.length>0)e[i].getFloat32Array().forEach(d=>u.push(d));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(l>0&&e.length>l&&e[l].dims.length>0){if(e[l].getFloat32Array().forEach(d=>a.push(d)),a.length!==0&&a.length!==m&&r>=18&&a.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");wp(a,t),t.axes.length>0&&$p(a,t.axes,m).forEach((d,v)=>a[v]=d)}if(p>0&&e.length>p&&(e[p].getBigInt64Array().forEach(d=>o.push(Number(d))),o.length!==m||r>=18&&o.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(a.length!==t.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(o.length!==t.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof a<"u"&&typeof o<"u"&&a.length>0&&o.length>m)throw new Error("Resize requires only of scales or sizes to be specified")},Sp=e=>"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(e){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`
`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",Cp=(e,t)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",Ap=(e,t,r)=>{let a=new Array(r).fill(0).concat(new Array(r).fill(1)),o=e.length===0?a:e.slice();return t.length>0?(t.forEach((u,i)=>{a[u]=o[i],a[i+r]=o[t.length+i]}),a):o},Ip=(e,t,r,a)=>{let o=[];if(r.length>0)if(a.length>0){if(e.forEach(u=>o.push(u)),Math.max(...a)>e.length)throw new Error("axes is out of bound");a.forEach((u,i)=>o[u]=r[i])}else r.forEach(u=>o.push(u));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");o=e.map((u,i)=>Math.round(u*t[i]))}return o},_p=(e,t,r,a)=>{let o=(()=>{switch(a.keepAspectRatioPolicy){case"not_larger":return a.axes.length>0?Math.min(...a.axes.map(i=>r[i]),Number.MAX_VALUE):Math.min(...r,Number.MAX_VALUE);case"not_smaller":return a.axes.length>0?Math.max(...a.axes.map(i=>r[i]),Number.MIN_VALUE):Math.max(...r,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${a.keepAspectRatioPolicy} is not supported`)}})();r.fill(1,0,r.length);let u=e.slice();return a.axes.length>0?(a.axes.forEach(i=>r[i]=o),a.axes.forEach(i=>u[i]=Math.round(e[i]*r[i]))):(r.fill(o,0,r.length),u.forEach((i,l)=>u[l]=Math.round(i*r[l]))),u},Op=(e,t,r,a,o)=>`
    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> array<f32, ${r.length}> {
      const inputShape = array<u32, ${t.length}>(${t.map(u=>`${u}u`).join(",")});
      const outputShape = array<u32, ${r.length}>(${r.map(u=>`${u}u`).join(",")});
      const scales = array<f32, ${a.length}>(${a.map(u=>`${u}f`).join(",")});
      const roi = array<f32, ${o.length}>(${o.map(u=>`${u}f`).join(",")});
      var originalIndices: array<f32, ${r.length}>;
      for (var i:u32 = 0; i < ${r.length}; i++) {
        var outputIndex = ${r.length===1?"outputIndices":"outputIndices[i]"};
        if (scales[i] == 1.0) {
          originalIndices[i] = f32(outputIndex);
        } else {
          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],
                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${t.length}]);
        }
      }
      return originalIndices;
    }`,Tp=(e,t,r,a,o,u,i)=>`
    fn calculateInputIndicesFromOutputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {
        const inputShape = array<u32, ${r.length}>(${r.map(l=>`${l}u`).join(",")});
        const outputShape = array<u32, ${a.length}>(${a.map(l=>`${l}u`).join(",")});
        const scales = array<f32, ${o.length}>(${o.map(l=>`${l}f`).join(",")});
        const roi = array<f32, ${u.length}>(${u.map(l=>`${l}f`).join(",")});
        var inputIndices: ${e.type.indices};
        for (var i:u32 = 0; i < ${a.length}; i++) {
          var outputIndex = ${a.length===1?"outputIndices":"outputIndices[i]"};
          var inputIndex: u32;
          if (scales[i] == 1.0) {
            inputIndex = outputIndex;
          } else {
            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],
                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${r.length}]);
            if (!${i} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {
              if (original_idx < 0) {
                inputIndex = 0;
              } else if (original_idx > (f32(inputShape[i]) - 1)) {
                inputIndex = inputShape[i] - 1;
              } else {
                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));
              }
            } else {
              inputIndex = u32(original_idx);
            }
          }
          ${e.indicesSet("inputIndices","i","inputIndex")}
        }
        return inputIndices;
    }`,Ep=(e,t)=>`
    fn checkInputIndices(inputIndices: ${e.type.indices}) -> bool {
      const inputShape = array<u32, ${t.length}>(${t.map(r=>`${r}u`).join(",")});
      for (var i:u32 = 0; i < ${t.length}; i++) {
        var inputIndex = ${t.length===1?"inputIndices":"inputIndices[i]"};
        if (inputIndex < 0 || inputIndex >= inputShape[i]) {
          return false;
        }
      }
      return true;
    }`,Rp=(e,t,r,a,o,u,i)=>{let[l,p,m,d]=r.length===2?[-1,0,1,-1]:o[1]===1?[0,2,3,1]:[0,1,2,3];return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {
      var inputIndices: ${e.type.indices};
      inputIndices[${p}] = max(0, min(row, ${r[p]} - 1));
      inputIndices[${m}] = max(0, min(col, ${r[m]} - 1));
      if (${r.length} > 2) {
        inputIndices[${d}] = channel;
        inputIndices[${l}] = batch;
      };
      return input[${e.indicesToOffset("inputIndices")}];
    }

    fn bilinearInterpolation(outputIndices: ${t.type.indices}) -> f32 {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);
      var row:f32 = originalIndices[${p}];
      var col:f32 = originalIndices[${m}];
      if (${u} && (row < 0 || row > (${r[p]} - 1) || col < 0 || col > ${r[m]} - 1)) {
        return ${i};
      }
      row = max(0, min(row, ${r[p]} - 1));
      col = max(0, min(col, ${r[m]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = 0;
      var batch: u32 = 0;
      if (${r.length>2}) {
        channel = u32(originalIndices[${d}]);
        batch = u32(originalIndices[${l}]);
      }
      var x11: f32 = getInputValue(batch, channel, row1, col1);
      var x12: f32 = getInputValue(batch, channel, row1, col2);
      var x21: f32 = getInputValue(batch, channel, row2, col1);
      var x22: f32 = getInputValue(batch, channel, row2, col2);
      var dx1: f32 = row - f32(row1);
      var dx2: f32 = f32(row2 ) - row;
      var dy1 = col - f32(col1);
      var dy2 = f32(col2) - col;
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},Pp=(e,t,r,a,o,u,i,l,p,m)=>{let[d,v]=r.length===2?[0,1]:o[1]===1?[2,3]:[1,2],y=w=>{let x=w===d?"row":"col";return`
      fn ${x}CubicInterpolation(inputIndices: ${e.type.indices}, outputIndices: ${t.type.indices}) -> f32 {
        var outputIndex = ${a.length===1?"outputIndices":`outputIndices[${w}]`};
        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${o[w]},
        f32(${a[w]}), f32(${r[w]}), ${u[w]}, ${u[w]} + ${r.length});
        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${l} && (originalIdx < 0 || originalIdx > (${r[w]} - 1))) {
          return ${p};
        }
        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${x}: f32 = originalIdx + f32(i);
          if (${x} < 0 || ${x} >= ${r[w]}) {
            if (${m}) {
              coefs[i + 1] = 0.0;
              continue;
            } else if (${l}) {
              return ${p};
            } else {
              ${x} = max(0, min(${x}, ${r[w]} - 1));
            }
          }
          var inputIndicesCopy: ${e.type.indices} = inputIndices;
          inputIndicesCopy[${w}] = u32(${x});
          data[i + 1] = ${w===d?`input[${e.indicesToOffset("inputIndicesCopy")}];`:`
                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);`}
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${y(d)};
    ${y(v)};
  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {
    var absS = abs(s);
    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: f32 = 1.0 - absS;
    var twoMinusAbsS: f32 = 2.0 - absS;
    var onePlusAbsS: f32 = 1.0 + absS;
    coeffs[0] = ((${i} * onePlusAbsS - 5 * ${i}) * onePlusAbsS + 8 * ${i}) * onePlusAbsS - 4 * ${i};
    coeffs[1] = ((${i} + 2) * absS - (${i} + 3)) * absS * absS + 1;
    coeffs[2] = ((${i} + 2) * oneMinusAbsS - (${i} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${i} * twoMinusAbsS - 5 * ${i}) * twoMinusAbsS + 8 * ${i}) * twoMinusAbsS - 4 * ${i};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {
    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(outputIndices: ${t.type.indices}) -> f32 {
    var inputIndices: ${e.type.indices} = outputIndices;
    return colCubicInterpolation(inputIndices, outputIndices);
  }
    `},kp=(e,t,r,a,o,u)=>{let i=e.dims,l=Ap(u,t.axes,i.length),p=Ip(i,a,o,t.axes),m=a.slice();a.length===0&&(m=i.map((A,k)=>A===0?1:p[k]/A),t.keepAspectRatioPolicy!=="stretch"&&(p=_p(i,p,m,t)));let d=Y("output",e.dataType,p),v=H("input",e.dataType,i),y=V.size(p),w=i.length===p.length&&i.every((A,k)=>A===p[k]),x=t.coordinateTransformMode==="tf_crop_and_resize",$=A=>`
      ${w?"":`
      ${Sp(t.coordinateTransformMode)};
      ${(()=>{switch(t.mode){case"nearest":return`
              ${Ep(v,i)};
              ${Cp(t.nearestMode,r)};
              ${Tp(v,d,i,p,m,l,x)};
              `;case"linear":return`
              ${Op(d,i,p,m,l)};
              ${Rp(v,d,i,p,m,x,t.extrapolationValue)};
              `;case"cubic":return`
            ${Pp(v,d,i,p,m,l,t.cubicCoeffA,x,t.extrapolationValue,t.excludeOutside)};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${A.declareVariables(v,d)}
      ${A.mainStart()}
        ${A.guardAgainstOutOfBoundsWorkgroupSizes(y)}
        ${w?"output[global_idx] = input[global_idx];":`
        let outputIndices = ${d.offsetToIndices("global_idx")};
        var inputIndices: ${v.type.indices};
        ${(()=>{switch(t.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);
                if (checkInputIndices(inputIndices)) {
                  output[global_idx] = input[${v.indicesToOffset("inputIndices")}];
                } else {
                  output[global_idx] = ${t.extrapolationValue};
                }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};
        `}
      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${m.length>0?m:""}|${o.length>0?o:""}|${w}`},getShaderSource:$,getRunData:()=>({outputs:[{dims:p,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(y/64)}})}},Bp=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},Qu=(e,t)=>{let r=[],a=[],o=[],u=Bp(e);xp(e.inputs,t,u,r,a,o),e.compute(kp(e.inputs[0],t,u,r,a,o),{inputs:[0]})},el=e=>{let t=e.antialias,r=e.axes,a=e.coordinateTransformMode,o=e.cubicCoeffA,u=e.excludeOutside!==0,i=e.extrapolationValue,l=e.keepAspectRatioPolicy,p=e.mode,m=e.nearestMode===""?"simple":e.nearestMode;return ue({antialias:t,axes:r,coordinateTransformMode:a,cubicCoeffA:o,excludeOutside:u,extrapolationValue:i,keepAspectRatioPolicy:l,mode:p,nearestMode:m})}});var Mp,Dp,rl,nl,al=j(()=>{"use strict";We();ge();Be();$e();Mp=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],r=e[1],a=e[2];if(t.dataType!==r.dataType||t.dataType!==a.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let o=t.dims[t.dims.length-1],u=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==o)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==u)throw new Error("Skip must have the same sequence length as input");if(a.dims.length!==1)throw new Error("Gamma must be 1D");if(a.dims[a.dims.length-1]!==o)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let i=e[3];if(i.dims.length!==1)throw new Error("Beta must be 1D");if(i.dims[i.dims.length-1]!==o)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let i=e[4];if(i.dims.length!==1)throw new Error("Bias must be 1D");if(i.dims[i.dims.length-1]!==o)throw new Error("Bias must have the same hidden size as input")}},Dp=(e,t,r,a)=>{let o=e[0].dims,u=V.size(o),i=o,l=u,p=o.slice(-1)[0],m=a?o.slice(0,-1).concat(1):[],d=e.length>3,v=e.length>4,y=a&&r>1,w=a&&r>2,x=r>3,$=xt(p),A=[H("x",e[0].dataType,e[0].dims,$),H("skip",e[1].dataType,e[1].dims,$),H("gamma",e[2].dataType,e[2].dims,$)];d&&A.push(H("beta",e[3].dataType,e[3].dims,$)),v&&A.push(H("bias",e[4].dataType,e[4].dims,$)),A.push(Y("output",e[0].dataType,i,$)),y&&A.push(Y("meanOutput",1,m)),w&&A.push(Y("invStdOutput",1,m)),x&&A.push(Y("inputSkipBiasSum",e[0].dataType,i,$));let k=Me(e[0].dataType),O=R=>`
      const hiddenSize: f32 = ${p};
      const hiddenSizeVectorized: u32 = ${p/$};
      const epsilon: f32 = ${t.epsilon};

      ${R.declareVariables(...A)}

      ${R.mainStart()}
        ${R.guardAgainstOutOfBoundsWorkgroupSizes(l/p)}
        let offset = global_idx * hiddenSizeVectorized;
        var sum = ${ot("f32",$)};
        var squareSum = ${ot("f32",$)};
        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {
          let skipValue = skip[offset + i];
          let biasValue = ${v?"bias[i]":"0.0"};
          let inputValue = x[offset + i];
          let value = inputValue + skipValue + biasValue;
          ${x?"inputSkipBiasSum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32Value = ${jt(k,$,"value")};
          sum += f32Value;
          squareSum += f32Value * f32Value;
        }
        let mean = ${Rt("sum",$)} / hiddenSize;
        let variance = sqrt(${Rt("squareSum",$)} / hiddenSize - mean * mean + epsilon);
        ${y?"meanOutput[global_idx] = mean;":""}
        ${w?"invStdOutput[global_idx] = 1.0 / variance;":""}
        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {
          output[offset + i] = (output[offset + i] - ${k}(mean)) / ${k}(variance) * gamma[i]
           + ${d?"beta[i]":"0.0"};
        }
      }`,T=[{dims:i,dataType:e[0].dataType}];return r>1&&T.push({dims:m,dataType:1}),r>2&&T.push({dims:m,dataType:1}),r>3&&T.push({dims:o,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:t.cacheKey},getShaderSource:O,getRunData:()=>({outputs:T,dispatchGroup:{x:Math.ceil(l/p/64)}})}},rl=(e,t)=>{Mp(e.inputs);let a=[0];e.outputCount>1&&a.push(-3),e.outputCount>2&&a.push(-3),e.outputCount>3&&a.push(3),e.compute(Dp(e.inputs,t,e.outputCount,!1),{outputs:a})},nl=e=>{let t=e.epsilon;return ue({epsilon:t})}});var zp,An,Wp,ol,Vp,Np,il,sl,ul=j(()=>{"use strict";We();ge();Be();$e();zp=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,a)=>{if(e[a+1].dataType!==6&&e[a+1].dataType!==7)throw new Error(`Input ${a} must be an array of int32 or int64`)})},An=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(a=>r.push(Number(a)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(a=>r.push(Number(a)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},Wp=(e,t)=>{if(e.length>1){let r=An(e,1),a=An(e,2),o=An(e,3);return o.length===0&&(o=[...Array(e[0].dims.length).keys()]),ue({starts:r,ends:a,axes:o})}else return t},ol=(e,t,r,a,o)=>{let u=e;return e<0&&(u+=r[a[t]]),o[t]<0?Math.max(0,Math.min(u,r[a[t]]-1)):Math.max(0,Math.min(u,r[a[t]]))},Vp=(e,t,r,a)=>`fn calculateInputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {
          var inputIndices: ${e.type.indices};
          var carry = 0u;
          for (var i = ${r.length}; i >= 0; i--) {
            var outputIndex = ${a.length===1?"outputIndices":"outputIndices[i]"};
            var inputIndex = outputIndex * steps[i] + starts[i] + carry;
            carry = inputIndex / inputShape[i];
            inputIndex = inputIndex % inputShape[i];
            if (signs[i] < 0) {
              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];
            }
            ${r.length===1?"inputIndices":"inputIndices[i]"} = inputIndex;
          }
          return inputIndices;
      }`,Np=(e,t)=>{let r=e[0].dims,a=V.size(r),o=t.axes.length>0?V.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],u=An(e,4);u.forEach($=>$!==0||(()=>{throw new Error("step cannot be 0")})),u.length===0&&(u=Array(o.length).fill(1));let i=t.starts.map(($,A)=>ol($,A,r,o,u)),l=t.ends.map(($,A)=>ol($,A,r,o,u));if(o.length!==r.length)for(let $=0;$<r.length;++$)o.includes($)||(i.splice($,0,0),l.splice($,0,r[$]),u.splice($,0,1));let p=u.map($=>Math.sign($));u.forEach(($,A,k)=>{if($<0){let O=(l[A]-i[A])/$,T=i[A],R=T+O*u[A];i[A]=R,l[A]=T,k[A]=-$}});let m=r.slice(0);o.forEach(($,A)=>{m[$]=Math.ceil((l[$]-i[$])/u[$])});let d={dims:m,dataType:e[0].dataType},v=Y("output",e[0].dataType,m),y=H("input",e[0].dataType,r),w=V.size(m),x=$=>`
      ${$.declareVariables(y,v)}
        const signs = array<i32, ${p.length}>(${p.map(A=>`${A}i`).join(",")});
        const starts = array<u32, ${i.length}>(${i.map(A=>`${A}u`).join(",")});
        const ends = array<u32, ${l.length}>(${l.map(A=>`${A}u`).join(",")});
        const steps = array<u32, ${u.length}>(${u.map(A=>`${A}u`).join(",")});
        const inputShape = array<u32, ${r.length}>(${r.map(A=>`${A}u`).join(",")});

        ${Vp(y,v,r,m)}
        ${$.mainStart()}
          ${$.guardAgainstOutOfBoundsWorkgroupSizes(w)}
          let outputIndices = ${v.offsetToIndices("global_idx")};
          let inputIndices = calculateInputIndices(outputIndices);
          ${v.setByOffset("global_idx",y.getByIndices("inputIndices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${t.cacheKey}|${e[4]?.dims??""}`},getShaderSource:x,getRunData:()=>({outputs:[d],dispatchGroup:{x:Math.ceil(a/64)}})}},il=(e,t)=>{zp(e.inputs,t);let r=Wp(e.inputs,t);e.compute(Np(e.inputs,r),{inputs:[0]})},sl=e=>{let t=e.starts,r=e.ends,a=e.axes;return ue({starts:t,ends:r,axes:a})}});var Up,Gp,ll,dl,cl=j(()=>{"use strict";ge();Be();$e();Up=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},Gp=(e,t)=>{let r=e.dims,a=V.size(r),o=64,u=t.axis;if(u<0&&(u=r.length+u),u<r.length-1)throw new Error("softmax only supports last axis for now.");let i=r[u],l=a/i,p=xt(i),m=i/p,d=(A,k)=>k===4?`max(max(${A}.x, ${A}.y), max(${A}.z, ${A}.w))`:k===2?`max(${A}.x, ${A}.y)`:k===3?`max(max(${A}.x, ${A}.y), ${A}.z)`:A,v=H("x",e.dataType,e.dims,p),y=Y("result",e.dataType,e.dims,p),w=v.type.value,x=Me(e.dataType)==="f32"?`var threadMax = ${w}(-3.402823e+38f);`:`var threadMax = ${w}(-65504.0h);`,$=A=>`
      var<workgroup> rowMaxShared : ${w};
      var<workgroup> rowSumShared : ${w};
      var<workgroup> threadShared : array<${w}, ${o}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${w} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${w}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${A.registerUniform("packedCols","i32").declareVariables(v,y)}
      ${A.mainStart()}
        let gindex = i32(global_id.x);
        let lindex = i32(local_id.x);
        const wg = ${o};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${x}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${w}(${d("threadShared[0]",p)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${w}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${w}(${Rt("threadShared[0]",p)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`;return{name:"Softmax",shaderCache:{hint:`${p}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:r,dataType:e.dataType}],dispatchGroup:{x:l},programUniforms:[{type:"uint32",data:m}]}),getShaderSource:$}},ll=(e,t)=>{Up(e.inputs),e.compute(Gp(e.inputs[0],t))},dl=e=>ue({axis:e.axis})});var Fp,Lp,Hp,jp,qp,pl,fl,ml=j(()=>{"use strict";ge();Be();$e();Fp=e=>{if(!e||e.length<1)throw new Error("too few inputs")},Lp=(e,t)=>{let r=[],a=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(o=>r.push(Number(o))),a=r.length),ue({numOutputs:a,axis:t.axis,splitSizes:r})},Hp=e=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {
    if (index < sizeInConcatAxis[i]) {
        return i;
    }
    }
    return ${e}u;
}`,jp=e=>{let t=e.length,r=[];for(let a=0;a<t;++a){let o=e[a].setByIndices("indices","input[global_idx]");t===1?r.push(o):a===0?r.push(`if (outputNumber == ${a}u) { ${o} }`):a===t-1?r.push(`else { ${o} }`):r.push(`else if (outputNumber == ${a}) { ${o} }`)}return`
      fn writeBufferData(outputNumber: u32, indices: ${e[0].type.indices}, global_idx: u32) {
        ${r.join(`
`)}
      }`},qp=(e,t)=>{let r=e[0].dims,a=V.size(r),o=e[0].dataType,u=r.length,i=t.axis,l=i<0?r.length+i:i,p=new Array(t.numOutputs),m=H("input",o,r),d=new Array(t.numOutputs),v=[],y=[],w=0;for(let A=0;A<t.numOutputs;A++){w+=t.splitSizes[A],d[A]=w;let k=r.slice();k[t.axis]=t.splitSizes[A],y.push(k),p[A]=Y(`output${A}`,o,y[A]),v.push({dims:y[A],dataType:e[0].dataType})}let x=u<2?"indices":`indices[${l}]`,$=A=>`
  ${A.declareVariables(m,...p)}
  const sizeInConcatAxis = array<u32, ${d.length}>(${d.map(k=>`${k}u`).join(",")});
  ${Hp(d.length)}
  ${jp(p)}

  ${A.mainStart()}
    ${A.guardAgainstOutOfBoundsWorkgroupSizes(a)}

    var indices = ${m.offsetToIndices("global_idx")};
    let outputNumber = calculateOutputIndex(${x});
    if (outputNumber != 0) {
        ${x} -= sizeInConcatAxis[outputNumber - 1u];
    }
    writeBufferData(outputNumber, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:t.cacheKey},getShaderSource:$,getRunData:()=>({outputs:v,dispatchGroup:{x:Math.ceil(a/64)}})}},pl=(e,t)=>{Fp(e.inputs);let r=e.inputs.length===1?t:Lp(e.inputs,t);e.compute(qp(e.inputs,r),{inputs:[0]})},fl=e=>{let t=e.axis,r=e.splitSizes,a=e.numOutputs<0?r.length:e.numOutputs;if(a!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ue({axis:t,numOutputs:a,splitSizes:r})}});var hl,Kp,Yp,Xp,gl,yl=j(()=>{"use strict";We();ge();$e();hl=e=>Array.from(e.getBigInt64Array(),Number),Kp=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(hl(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Yp=(e,t)=>{let r=[];for(let a=0;a<e.length;++a)r.push(e[a]*t[a]);return r},Xp=e=>{let t=e[0].dims,r=hl(e[1]),a=Yp(t,r),o=V.size(a),u=e[0].dataType,i=H("input",u,t),l=Y("output",u,a),p=m=>`
      const inputShape = ${i.indices(...t)};
      ${m.declareVariables(i,l)}
      ${m.mainStart()}
      ${m.guardAgainstOutOfBoundsWorkgroupSizes(o)}
      let outputIndices = ${l.offsetToIndices("global_idx")};
      var inputIndices: ${i.type.indices};
      for (var i = 0; i < ${t.length}; i++) {
        let inputDimValue = ${l.indicesGet("outputIndices","i")}  % ${i.indicesGet("inputShape","i")};

        ${i.indicesSet("inputIndices","i","inputDimValue")}
      }
      ${l.setByOffset("global_idx",i.getByIndices("inputIndices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${r}`},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:p}},gl=e=>{Kp(e.inputs),e.compute(Xp(e.inputs),{inputs:[0]})}});var Jp,Zp,bl,vl=j(()=>{"use strict";We();ge();$e();Jp=(e,t,r,a,o)=>{let u=V.size(r),i=Math.ceil(u/4),l=Y("outputData",o,r,4),p=H("aData",t[1].dataType,t[1].dims,4),m=H("bData",t[2].dataType,t[2].dims,4),d=H("cData",t[0].dataType,t[0].dims,4),v,y=(w,x,$)=>`select(${x}, ${w}, ${$})`;if(!a)v=l.setByOffset("global_idx",y(p.getByOffset("global_idx"),m.getByOffset("global_idx"),d.getByOffset("global_idx")));else{let w=(x,$,A="")=>{let k=`aData[indexA${$}][componentA${$}]`,O=`bData[indexB${$}][componentB${$}]`,T=`bool(cData[indexC${$}] & ${4278190080>>>(3-$)*8}u)`;return`
            let outputIndices${$} = ${l.offsetToIndices(`global_idx * 4u + ${$}u`)};
            let offsetA${$} = ${p.broadcastedIndicesToOffset(`outputIndices${$}`,l)};
            let offsetB${$} = ${m.broadcastedIndicesToOffset(`outputIndices${$}`,l)};
            let offsetC${$} = ${d.broadcastedIndicesToOffset(`outputIndices${$}`,l)};
            let indexA${$} = offsetA${$} / 4u;
            let indexB${$} = offsetB${$} / 4u;
            let indexC${$} = offsetC${$} / 4u;
            let componentA${$} = offsetA${$} % 4u;
            let componentB${$} = offsetB${$} % 4u;
            ${x}[${$}] = ${A}(${y(k,O,T)});
          `};o===9?v=`
            var data = vec4<u32>(0);
            ${w("data",0,"u32")}
            ${w("data",1,"u32")}
            ${w("data",2,"u32")}
            ${w("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:v=`
            ${w("outputData[global_idx]",0)}
            ${w("outputData[global_idx]",1)}
            ${w("outputData[global_idx]",2)}
            ${w("outputData[global_idx]",3)}
          `}return`
        ${e.declareVariables(d,p,m,l)}
        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes(i)}
        ${v}
      }`},Zp=e=>{let t=e[1].dims,r=e[2].dims,a=e[0].dims,o=e[1].dataType,u=!(V.areEqual(t,r)&&V.areEqual(r,a)),i=t,l=V.size(t);if(u){let p=ct.calcShape(ct.calcShape(t,r,!1),a,!1);if(!p)throw new Error("Can't perform where op on the given tensors");i=p,l=V.size(i)}return{name:"Where",getShaderSource:p=>Jp(p,e,i,u,o),getRunData:()=>({outputs:[{dims:i,dataType:o}],dispatchGroup:{x:Math.ceil(l/64/4)}})}},bl=e=>{e.compute(Zp(e.inputs))}});var wl,$l=j(()=>{"use strict";es();rs();Ms();js();Ys();va();uu();pu();hu();bu();$u();Cu();_u();Eu();Pu();Mu();Xu();Zu();mn();tl();al();ul();cl();ml();yl();Or();ha();vl();wl=new Map([["Abs",[ns]],["Acos",[as]],["Acosh",[os]],["Add",[Ds]],["ArgMax",[Qi,fa]],["ArgMin",[Zi,fa]],["Asin",[is]],["Asinh",[ss]],["Atan",[us]],["Atanh",[ls]],["AveragePool",[Uu,Nu]],["BiasAdd",[ts]],["BiasSplitGelu",[Bs]],["Cast",[cs,ds]],["Ceil",[fs]],["ClipV10",[ma]],["Clip",[ps]],["Concat",[qs,Ks]],["Conv",[$a,wa]],["ConvTranspose",[su,iu]],["Cos",[ms]],["Cosh",[hs]],["Div",[zs]],["Einsum",[du,cu]],["Elu",[gs,gn]],["Equal",[Ws]],["Erf",[ys]],["Exp",[bs]],["Expand",[mu]],["Floor",[vs]],["FusedConv",[$a,wa]],["Gather",[yu,gu]],["GatherElements",[wu,vu]],["Gelu",[ws]],["Gemm",[xu,Su]],["GlobalAveragePool",[Lu,Fu]],["GlobalMaxPool",[Yu,Ku]],["Greater",[Gs]],["GreaterOrEqual",[Ls]],["InstanceNormalization",[Iu,Au]],["LayerNormalization",[Tu,Ou]],["LeakyRelu",[$s,gn]],["Less",[Fs]],["LessOrEqual",[Hs]],["Log",[ks]],["MatMul",[Ru]],["MaxPool",[ju,qu]],["Mul",[Vs]],["Neg",[Ss]],["Not",[xs]],["Pad",[ku,Bu]],["Pow",[Ns]],["Range",[Ju]],["Reciprocal",[Cs]],["ReduceMin",[Hi,it]],["ReduceMean",[Ni,it]],["ReduceMax",[Li,it]],["ReduceSum",[qi,it]],["ReduceProd",[ji,it]],["ReduceL1",[Ui,it]],["ReduceL2",[Gi,it]],["ReduceLogSum",[Yi,it]],["ReduceLogSumExp",[Fi,it]],["ReduceSumSquare",[Ki,it]],["Relu",[As]],["Resize",[Qu,el]],["Sigmoid",[Is]],["Sin",[_s]],["Sinh",[Os]],["Slice",[il,sl]],["SkipLayerNormalization",[rl,nl]],["Split",[pl,fl]],["Sqrt",[Ts]],["Softmax",[ll,dl]],["Sub",[Us]],["Tan",[Es]],["Tanh",[Rs]],["ThresholdedRelu",[Ps,gn]],["Tile",[gl]],["Transpose",[_i,Oi]],["Where",[bl]]])});var In,xl=j(()=>{"use strict";We();Et();$e();In=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,a,o,u,i,l){let p=this.backend.device,m=this.backend.getComputePassEncoder();m.setPipeline(t.computePipeline);let d=[];for(let y of o)d.push({binding:d.length,resource:{buffer:y.buffer}});for(let y of u)d.push({binding:d.length,resource:{buffer:y.buffer}});l&&d.push({binding:d.length,resource:l});let v=p.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:d,label:t.programInfo.name});if(m.setBindGroup(0,v),m.dispatchWorkgroups(...i),this.backend.pendingDispatchNumber++,this.backend.isQueryEnabled()){typeof this.backend.queryData>"u"&&(this.backend.queryData=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let y=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.querySet,0,2,this.backend.queryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.queryData.buffer,0,y.buffer,0,this.backend.querySetCount*8),this.backend.flush();let w=this.backend.currentKernelId,x=this.backend.kernels.get(w),$=`[${x[0]}] ${x[1]}`;y.buffer.mapAsync(GPUMapMode.READ).then(()=>{let A=new BigUint64Array(y.buffer.getMappedRange()),k=A[0],O=A[1];y.buffer.unmap(),typeof this.backend.queryTimeBase>"u"&&(this.backend.queryTimeBase=k);let T=Number(k-this.backend.queryTimeBase),R=Number(O-this.backend.queryTimeBase);if(!Number.isSafeInteger(T)||!Number.isSafeInteger(R))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(y.id);let z="";r.forEach((W,K)=>{z+=`input[${K}]: [${W.dims}] | ${Ar(W.dataType)}, `});let M="";a.forEach((W,K)=>{M+=`output[${K}]: [${W.dims}] | ${Ar(W.dataType)}, `}),console.log(`[profiling] kernel "${w}|${$}" ${z}${M}execution time: ${R-T} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(t,r){let a=this.backend.device,o=[];a.features.has("shader-f16")&&o.push("enable f16;");let u=Ai(r),i=t.getShaderSource(u),l=`${o.join(`
`)}
${u.additionalImplementations}
${i}`,p=a.createShaderModule({code:l,label:t.name});Ee("verbose",()=>`[WebGPU] ${t.name} shader code: ${l}`);let m=a.createComputePipeline({compute:{module:p,entryPoint:"main"},layout:"auto",label:t.name});return{programInfo:t,computePipeline:m}}normalizeDispatchGroupSize(t){let r=typeof t=="number"?t:t.x,a=typeof t=="number"?1:t.y||1,o=typeof t=="number"?1:t.z||1,u=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=u&&a<=u&&o<=u)return[r,a,o];let i=r*a*o,l=Math.ceil(Math.sqrt(i));if(l>u){if(l=Math.ceil(Math.cbrt(i)),l>u)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[l,l,l]}else return[l,l,1]}}});var Qp,ef,_n,Sl=j(()=>{"use strict";Et();bi();xi();$l();xl();Qp=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let a=0;a<e.length;++a){let o=e[a].dataType;switch(t[a]){case"none":{r.push("");break}case"type":{r.push(`${o}`);break}case"rank":{let u=e[a].dims.length;r.push(`${o};${u}`);break}case"dims":{let u=e[a].dims.join(",");r.push(`${o};${u}`);break}default:throw new Error(`unsupported input dependency: ${t[a]}`)}}return r.join("|")},ef=(e,t,r)=>{let a=e.name;return e.shaderCache?.hint&&(a+="["+e.shaderCache.hint+"]"),a+=":"+r+`:${Qp(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,a},_n=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.querySetCount=2;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let r=await navigator.gpu.requestAdapter();if(!r)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=t;let a=[],o={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:a};r.features.has("timestamp-query")&&a.push("timestamp-query"),r.features.has("shader-f16")&&a.push("shader-f16"),this.device=await r.requestDevice(o),this.gpuDataManager=$i(this),this.programManager=new In(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,gi(t.logLevel,!!t.debug),this.device.onuncapturederror=u=>{u.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${u.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t={};this.isQueryEnabled()&&(typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}isQueryEnabled(){return!!(this.device.features.has("timestamp-query")&&this.env.webgpu.profilingMode==="default")}run(t,r,a,o,u){let i=[];for(let O=0;O<r.length;++O){let T=this.gpuDataManager.get(r[O].data);if(!T)throw new Error(`no GPU data for input: ${r[O].data}`);i[O]=T}let{outputs:l,dispatchGroup:p,programUniforms:m}=t.getRunData(r),d=a.length===0?l.map((O,T)=>T):a;if(d.length!==l.length)throw new Error(`Output size ${d.length} must be equal to ${l.length}.`);let v=[],y=[];for(let O=0;O<l.length;++O){if(!Number.isInteger(d[O])||d[O]<-3||d[O]>=l.length)throw new Error(`Invalid output index: ${d[O]}`);if(d[O]===-3)continue;let T=d[O]===-1,R=d[O]===-2,z=T||R?u(l[O].dataType,l[O].dims):o(d[O],l[O].dataType,l[O].dims),M=this.gpuDataManager.get(z.data);if(!M)throw new Error(`no GPU data for output: ${z.data}`);if(T&&this.temporaryData.push(M),R){let W=this.kernelPersistentData.get(this.currentKernelId);W||(W=[],this.kernelPersistentData.set(this.currentKernelId,W)),W.push(M)}v.push(z),y.push(M)}let w;if(m){let O=0,T=0,R=[],z=1;m.forEach(K=>{let ee=typeof K.data=="number"?[K.data]:K.data;if(ee.length===0)return;let ae;switch(ee.length){case 1:ae=4;break;case 2:ae=8;break;case 3:ae=16;break;case 4:ae=16;break;case 5:ae=16;break;case 6:ae=16;break;default:throw new Error(`unsupported data length: ${ee.length}`)}(T===5||T===6)&&(ae=16),ae>z&&(z=ae),O=Math.ceil(O/ae)*ae,T=ee.length,R.push(O),O+=ee.length*4}),O=Math.ceil(O/z)*z;let M=new ArrayBuffer(O);m.forEach((K,ee)=>{let ae=R[ee],D=typeof K.data=="number"?[K.data]:K.data;K.type==="int32"?new Int32Array(M,ae,D.length).set(D):K.type==="uint32"?new Uint32Array(M,ae,D.length).set(D):new Float32Array(M,ae,D.length).set(D)});let W=this.gpuDataManager.create(O,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(W.buffer,0,M,0,O),this.gpuDataManager.release(W.id),w={offset:0,size:O,buffer:W.buffer}}let x=this.programManager.normalizeDispatchGroupSize(p),$=x[1]===1&&x[2]===1,A=ef(t,r,$),k=this.programManager.getArtifact(A);return k||(k=this.programManager.build(t,x),this.programManager.setArtifact(A,k)),Ee("info",()=>`[ProgramManager] run "${t.name}" (key=${A}) with ${x[0]}x${x[1]}x${x[2]}`),this.programManager.run(k,r,v,i,y,x,w),v}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,a,o){let u=wl.get(t);if(!u)throw new Error(`kernel not implemented: ${t}`);this.kernels.set(r,[t,o,u[0],[u[1],a]])}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let a of r)this.gpuDataManager.release(a.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,a){let o=this.kernels.get(t);if(!o)throw new Error(`kernel not created: ${t}`);let[u,i,l,p]=o;if(this.currentKernelId!==null)throw new Error(`kernel "[${u}] ${i}" is not allowed to be called recursively`);this.currentKernelId=t,p[0]&&(p[1]=p[0](p[1]),p[0]=void 0),Ee("info",()=>`[WebGPU] Start to run kernel "[${u}] ${i}"...`);let m=this.env.debug;this.temporaryData=[];try{return m&&this.device.pushErrorScope("validation"),l(r,p[1]),0}catch(d){return a.push(Promise.resolve(`[WebGPU] Kernel "[${u}] ${i}" failed. ${d}`)),1}finally{m&&a.push(this.device.popErrorScope().then(d=>d?`GPU validation error for kernel "[${u}] ${i}": ${d.message}`:null));for(let d of this.temporaryData)this.gpuDataManager.release(d.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,a,o){let u=this.sessionExternalDataMapping.get(t);u||(u=new Map,this.sessionExternalDataMapping.set(t,u));let i=u.get(r),l=this.gpuDataManager.registerExternalBuffer(a,o,i?.[1]);return u.set(r,[l,a]),l}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(a=>this.gpuDataManager.unregisterExternalBuffer(a[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,a){return async()=>{let o=await sa(this,t,r);return yi(o.buffer,a)}}}});var Cl={};ar(Cl,{init:()=>tf});var Pr,Ia,tf,Al=j(()=>{"use strict";We();Sl();Et();ge();Pr=class e{constructor(t,r,a,o){this.module=t;this.dataType=r;this.data=a;this.dims=o}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=V.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=V.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=V.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(V.size(t)!==V.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},Ia=class{constructor(t,r,a){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;let o=t.HEAPU32,u=a>>2;this.opKernelContext=o[u++];let i=o[u++];this.outputCount=o[u++],this.customDataOffset=o[u++],this.customDataSize=o[u++];let l=[];for(let p=0;p<i;p++){let m=o[u++],d=o[u++],v=o[u++],y=[];for(let w=0;w<v;w++)y.push(o[u++]);l.push(new Pr(t,m,d,y))}this.inputs=l}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,r){let a=r?.inputs?.map(l=>typeof l=="number"?this.inputs[l]:l)??this.inputs,o=r?.outputs??[],u=(l,p,m)=>new Pr(this.module,p,this.output(l,m),m),i=(l,p)=>{let m=Ir(l);if(!m)throw new Error(`Unsupported data type: ${l}`);let d=m*V.size(p);return new Pr(this.module,l,this.backend.gpuDataManager.create(d).id,p)};return this.backend.run(t,a,o,u,i)}output(t,r){let a=this.module.stackSave();try{let o=this.module.stackAlloc((1+r.length)*4),u=o>>2;this.module.HEAPU32[u++]=r.length;for(let i=0;i<r.length;i++)this.module.HEAPU32[u++]=r[i];return this.module._JsepOutput(this.opKernelContext,t,o)}catch(o){throw new Error(`Failed to generate kernel's output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${o}`)}finally{this.module.stackRestore(a)}}},tf=async(e,t)=>{let r=e.jsepInit;if(r&&navigator.gpu){if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let a=new _n;await a.initialize(t),r(a,o=>a.alloc(o),o=>a.free(o),(o,u,i,l=!1)=>{if(l)Ee("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${o}, dst=${u}, size=${i}`),a.memcpy(o,u);else{Ee("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${o}, gpuDataId=${u}, size=${i}`);let p=e.HEAPU8.subarray(o,o+i);a.upload(u,p)}},async(o,u,i)=>{Ee("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${o}, dataOffset=${u}, size=${i}`),await a.download(o,()=>e.HEAPU8.subarray(u,u+i))},(o,u,i)=>a.createKernel(o,u,i,t.debug||t.webgpu.profilingMode==="default"?e.UTF8ToString(e._JsepGetNodeName(u)):`${u}`),o=>a.releaseKernel(o),(o,u,i,l)=>{Ee("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${i}, kernel=${o}, contextDataOffset=${u}`);let p=new Ia(e,a,u);return a.computeKernel(o,p,l)})}}});var _l,rf,nf,Ol,kr,Tl,_a,Oa,El,Rl,Il,Pl,kl,Bl,Ml=j(()=>{"use strict";ci();fi();We();or();sn();_l=!1,rf=e=>{let t=Re(),r=t.stackSave();try{let a=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,a,a+4)!==0&&Ae("Can't get session input/output count."),[t.HEAP32[a/4],t.HEAP32[a/4+1]]}finally{t.stackRestore(r)}},nf=(e,t)=>{Re()._OrtInit(e,t)!==0&&Ae("Can't initialize onnxruntime.")},Ol=async e=>{nf(e.wasm.numThreads,_r(e.logLevel));{let t=(Al(),Ft(Cl)).init;await t(Re(),e)}_l=!0},kr=new Map,Tl=()=>_l,_a=e=>{let t=Re(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},Oa=(e,t)=>{let r=Re(),a=0,o=0,u=0,i=[],l=[],p=[];try{[o,i]=pi(t),a=r._OrtCreateSession(e[0],e[1],o),a===0&&Ae("Can't create a session.");let[m,d]=rf(a),v=[],y=[],w=[];for(let $=0;$<m;$++){let A=r._OrtGetInputName(a,$);A===0&&Ae("Can't get an input name."),l.push(A),v.push(r.UTF8ToString(A))}for(let $=0;$<d;$++){let A=r._OrtGetOutputName(a,$);A===0&&Ae("Can't get an output name."),p.push(A);let k=r.UTF8ToString(A);y.push(k);{let O=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[k]??"cpu";if(O!=="cpu"&&O!=="cpu-pinned"&&O!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${O}.`);w.push(O)}}let x=null;return w.some($=>$==="gpu-buffer")&&(u=r._OrtCreateBinding(a),u===0&&Ae("Can't create IO binding."),x={handle:u,outputPreferredLocations:w,outputPreferredLocationsEncoded:w.map($=>oa($))}),kr.set(a,[a,l,p,x]),[a,v,y]}catch(m){throw l.forEach(d=>r._OrtFree(d)),p.forEach(d=>r._OrtFree(d)),u!==0&&r._OrtReleaseBinding(u),a!==0&&r._OrtReleaseSession(a),m}finally{r._free(e[0]),o!==0&&r._OrtReleaseSessionOptions(o),i.forEach(m=>r._free(m))}},El=(e,t)=>{let r=_a(e);return Oa(r,t)},Rl=e=>{let t=Re(),r=kr.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[a,o,u,i]=r;i&&t._OrtReleaseBinding(i.handle),t.jsepUnregisterBuffers?.(e),o.forEach(l=>t._OrtFree(l)),u.forEach(l=>t._OrtFree(l)),t._OrtReleaseSession(a),kr.delete(e)},Il=(e,t,r,a,o)=>{if(!e){t.push(0);return}let u=Re(),i=e[0],l=e[1],p=e[3],m,d;if(i==="string"&&p==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(p==="gpu-buffer"){let w=e[2].gpuBuffer,x=Ir(aa(i));d=l.reduce(($,A)=>$*A,1)*x,m=u.jsepRegisterBuffer(a,o,w,d)}else{let w=e[2];if(Array.isArray(w)){d=4*w.length,m=u._malloc(d),r.push(m);let x=m/4;for(let $=0;$<w.length;$++){if(typeof w[$]!="string")throw new TypeError(`tensor data at index ${$} is not a string`);u.HEAPU32[x++]=ke(w[$],r)}}else d=w.byteLength,m=u._malloc(d),r.push(m),u.HEAPU8.set(new Uint8Array(w.buffer,w.byteOffset,d),m)}let v=u.stackSave(),y=u.stackAlloc(4*l.length);try{let w=y/4;l.forEach($=>u.HEAP32[w++]=$);let x=u._OrtCreateTensor(aa(i),m,d,y,l.length,oa(p));x===0&&Ae(`Can't create tensor for input/output. session=${a}, index=${o}.`),t.push(x)}finally{u.stackRestore(v)}},Pl=async(e,t,r,a,o,u)=>{let i=Re(),l=kr.get(e);if(!l)throw new Error(`cannot run inference. invalid session id: ${e}`);let[p,m,d,v]=l,y=t.length,w=a.length,x=0,$=[],A=[],k=[],O=[],T=i.stackSave(),R=i.stackAlloc(y*4),z=i.stackAlloc(y*4),M=i.stackAlloc(w*4),W=i.stackAlloc(w*4);try{[x,$]=di(u);for(let Z=0;Z<y;Z++)Il(r[Z],A,O,e,t[Z]);for(let Z=0;Z<w;Z++)Il(o[Z],k,O,e,y+a[Z]);let K=R/4,ee=z/4,ae=M/4,D=W/4;for(let Z=0;Z<y;Z++)i.HEAPU32[K++]=A[Z],i.HEAPU32[ee++]=m[t[Z]];for(let Z=0;Z<w;Z++)i.HEAPU32[ae++]=k[Z],i.HEAPU32[D++]=d[a[Z]];if(v){let{handle:Z,outputPreferredLocations:we,outputPreferredLocationsEncoded:Oe}=v;if(m.length!==y)throw new Error(`input count from feeds (${y}) is expected to be always equal to model's input count (${m.length}).`);for(let be=0;be<y;be++){let De=t[be];await i._OrtBindInput(Z,m[De],A[be])!==0&&Ae(`Can't bind input[${be}] for session=${e}.`)}for(let be=0;be<w;be++){let De=a[be];o[be]?.[3]?i._OrtBindOutput(Z,d[De],k[be],0)!==0&&Ae(`Can't bind pre-allocated output[${be}] for session=${e}.`):i._OrtBindOutput(Z,d[De],0,Oe[De])!==0&&Ae(`Can't bind output[${be}] to ${we[be]} for session=${e}.`)}}let te;v?te=await i._OrtRunWithBinding(p,v.handle,w,M,x):te=await i._OrtRun(p,z,R,y,W,w,M,x),te!==0&&Ae("failed to call OrtRun().");let _e=[];for(let Z=0;Z<w;Z++){let we=i.HEAPU32[M/4+Z];if(we===k[Z]){_e.push(o[Z]);continue}let Oe=i.stackSave(),be=i.stackAlloc(4*4),De=!1,Se,Ue=0;try{i._OrtGetTensorData(we,be,be+4,be+8,be+12)!==0&&Ae(`Can't access output tensor data on index ${Z}.`);let Ze=be/4,Qe=i.HEAPU32[Ze++];Ue=i.HEAPU32[Ze++];let G=i.HEAPU32[Ze++],pe=i.HEAPU32[Ze++],ce=[];for(let Ce=0;Ce<pe;Ce++)ce.push(i.HEAPU32[G/4+Ce]);i._OrtFree(G);let Fe=ce.reduce((Ce,Pe)=>Ce*Pe,1);Se=Ar(Qe);let He=v?.outputPreferredLocations[a[Z]];if(Se==="string"){if(He==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Ce=[],Pe=Ue/4;for(let At=0;At<Fe;At++){let Ye=i.HEAPU32[Pe++],Kt=At===Fe-1?void 0:i.HEAPU32[Pe]-Ye;Ce.push(i.UTF8ToString(Ye,Kt))}_e.push([Se,ce,Ce,"cpu"])}else if(He==="gpu-buffer"&&Fe>0){let Ce=i.jsepGetBuffer(Ue),Pe=Ir(Qe);if(Pe===void 0||!ln(Se))throw new Error(`Unsupported data type: ${Se}`);De=!0,_e.push([Se,ce,{gpuBuffer:Ce,download:i.jsepCreateDownloader(Ce,Fe*Pe,Se),dispose:()=>{i._OrtReleaseTensor(we)}},"gpu-buffer"])}else{let Ce=un(Se),Pe=new Ce(Fe);new Uint8Array(Pe.buffer,Pe.byteOffset,Pe.byteLength).set(i.HEAPU8.subarray(Ue,Ue+Pe.byteLength)),_e.push([Se,ce,Pe,"cpu"])}}finally{i.stackRestore(Oe),Se==="string"&&Ue&&i._free(Ue),De||i._OrtReleaseTensor(we)}}return v&&i._OrtClearBoundOutputs(v.handle),_e}finally{i.stackRestore(T),A.forEach(K=>i._OrtReleaseTensor(K)),k.forEach(K=>i._OrtReleaseTensor(K)),O.forEach(K=>i._free(K)),x!==0&&i._OrtReleaseRunOptions(x),$.forEach(K=>i._free(K))}},kl=e=>{let t=Re(),r=kr.get(e);if(!r)throw new Error("invalid session id");let a=r[0],o=t._OrtEndProfiling(a);o===0&&Ae("Can't get an profile file name."),t._OrtFree(o)},Bl=e=>{let t=[];for(let r of e){let a=r[2];!Array.isArray(a)&&"buffer"in a&&t.push(a.buffer)}return t}});var Dl=nr((_b,of)=>{of.exports='/*!\n * ONNX Runtime Web v1.17.0\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var Sn=Object.defineProperty;var ll=Object.getOwnPropertyDescriptor;var cl=Object.getOwnPropertyNames;var dl=Object.prototype.hasOwnProperty;var K=(e,t)=>()=>(e&&(t=e(e=0)),t);var dr=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Vr=(e,t)=>{for(var r in t)Sn(e,r,{get:t[r],enumerable:!0})},pl=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let a of cl(t))!dl.call(e,a)&&a!==r&&Sn(e,a,{get:()=>t[a],enumerable:!(o=ll(t,a))||o.enumerable});return e};var qt=e=>pl(Sn({},"__esModule",{value:!0}),e);var Cn={};Vr(Cn,{readFile:()=>fl});var fl,An=K(()=>{fl=void 0});var In={};Vr(In,{join:()=>ml});var ml,Tn=K(()=>{ml=void 0});var Go=dr((No,On)=>{"use strict";var Uo=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){var r=t,o,a;r.ready=new Promise((l,m)=>{o=l,a=m}),r.jsepInit=(l,m,y,w,I,U,F,re)=>{r.ab=l,r.Ra=m,r.Ta=y,r.La=w,r.Sa=I,r.xa=U,r.Ua=F,r.Va=re,m=(J,ae,ne)=>(...me)=>{let ye=je,_=ae?.();me=J(...me);let se=ae?.();return _!==se&&(J=se,ne(_),ae=ne=null),je!=ye?rr():me},y=J=>async(...ae)=>{try{if(r.Fa)throw Error("Session already started");let ne=r.Fa={Wa:ae[0],errors:[]},me=await J(...ae);if(r.Fa!==ne)throw Error("Session mismatch");l.flush();let ye=ne.errors;if(0<ye.length){let _=await Promise.all(ye);if(_=_.filter(se=>se),0<_.length)throw Error(_.join(`\n`))}return me}finally{r.Fa=null}},r._OrtRun=y(m(r._OrtRun,()=>r._OrtRun,J=>r._OrtRun=J)),r._OrtRunWithBinding=y(m(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,J=>r._OrtRunWithBinding=J)),r._OrtBindInput=m(r._OrtBindInput,()=>r._OrtBindInput,J=>r._OrtBindInput=J),r.jsepRegisterBuffer=(J,ae,ne,me)=>l.registerBuffer(J,ae,ne,me),r.jsepUnregisterBuffers=J=>{l.unregisterBuffers(J)},r.jsepGetBuffer=J=>l.getBuffer(J),r.jsepCreateDownloader=(J,ae,ne)=>l.createDownloader(J,ae,ne)};var u=Object.assign({},r),i="./this.program",d=(l,m)=>{throw m},f=typeof window=="object",h=typeof importScripts=="function",c=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",C="",b,$,S;if(c){var x=(An(),qt(Cn)),A=(Tn(),qt(In));C=h?A.dirname(C)+"/":__dirname+"/",b=(l,m)=>(l=l.startsWith("file://")?new URL(l):A.normalize(l),x.readFileSync(l,m?void 0:"utf8")),S=l=>(l=b(l,!0),l.buffer||(l=new Uint8Array(l)),l),$=(l,m,y,w=!0)=>{l=l.startsWith("file://")?new URL(l):A.normalize(l),x.readFile(l,w?void 0:"utf8",(I,U)=>{I?y(I):m(w?U.buffer:U)})},!r.thisProgram&&1<process.argv.length&&(i=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),d=(l,m)=>{throw process.exitCode=l,m},r.inspect=()=>"[Emscripten Module object]"}else(f||h)&&(h?C=self.location.href:typeof document<"u"&&document.currentScript&&(C=document.currentScript.src),e&&(C=e),C.indexOf("blob:")!==0?C=C.substr(0,C.replace(/[?#].*/,"").lastIndexOf("/")+1):C="",b=l=>{var m=new XMLHttpRequest;return m.open("GET",l,!1),m.send(null),m.responseText},h&&(S=l=>{var m=new XMLHttpRequest;return m.open("GET",l,!1),m.responseType="arraybuffer",m.send(null),new Uint8Array(m.response)}),$=(l,m,y)=>{var w=new XMLHttpRequest;w.open("GET",l,!0),w.responseType="arraybuffer",w.onload=()=>{w.status==200||w.status==0&&w.response?m(w.response):y()},w.onerror=y,w.send(null)});var k=r.print||console.log.bind(console),O=r.printErr||console.error.bind(console);Object.assign(r,u),u=null,r.thisProgram&&(i=r.thisProgram),r.quit&&(d=r.quit);var P;r.wasmBinary&&(P=r.wasmBinary);var R=r.noExitRuntime||!0;typeof WebAssembly!="object"&&G("no native wasm support detected");var V,B,W=!1,q,ee,oe,D,te,Ie,Z;function ve(){var l=V.buffer;r.HEAP8=ee=new Int8Array(l),r.HEAP16=new Int16Array(l),r.HEAP32=D=new Int32Array(l),r.HEAPU8=oe=new Uint8Array(l),r.HEAPU16=new Uint16Array(l),r.HEAPU32=te=new Uint32Array(l),r.HEAPF32=Ie=new Float32Array(l),r.HEAPF64=Z=new Float64Array(l)}var Te,be=[],Be=[],Se=[];function Ue(){var l=r.preRun.shift();be.unshift(l)}var qe=0,Ke=null,Ye=null;function G(l){throw r.onAbort&&r.onAbort(l),l="Aborted("+l+")",O(l),W=!0,q=1,l=new WebAssembly.RuntimeError(l+". Build with -sASSERTIONS for more info."),a(l),l}function pe(l){return l.startsWith("data:application/octet-stream;base64,")}var de;if(de="ort-wasm-simd.wasm",!pe(de)){var Ne=de;de=r.locateFile?r.locateFile(Ne,C):C+Ne}function Ge(l){if(l==de&&P)return new Uint8Array(P);if(S)return S(l);throw"both async and sync fetching of the wasm failed"}function Ce(l){if(!P&&(f||h)){if(typeof fetch=="function"&&!l.startsWith("file://"))return fetch(l,{credentials:"same-origin"}).then(m=>{if(!m.ok)throw"failed to load wasm binary file at \'"+l+"\'";return m.arrayBuffer()}).catch(()=>Ge(l));if($)return new Promise((m,y)=>{$(l,w=>m(new Uint8Array(w)),y)})}return Promise.resolve().then(()=>Ge(l))}function Pe(l,m,y){return Ce(l).then(w=>WebAssembly.instantiate(w,m)).then(w=>w).then(y,w=>{O("failed to asynchronously prepare wasm: "+w),G(w)})}function vt(l,m){var y=de;return P||typeof WebAssembly.instantiateStreaming!="function"||pe(y)||y.startsWith("file://")||c||typeof fetch!="function"?Pe(y,l,m):fetch(y,{credentials:"same-origin"}).then(w=>WebAssembly.instantiateStreaming(w,l).then(m,function(I){return O("wasm streaming compile failed: "+I),O("falling back to ArrayBuffer instantiation"),Pe(y,l,m)}))}var He,zt={916496:l=>{r.xa("Abs",l,void 0)},916547:l=>{r.xa("Neg",l,void 0)},916598:l=>{r.xa("Floor",l,void 0)},916651:l=>{r.xa("Ceil",l,void 0)},916703:l=>{r.xa("Reciprocal",l,void 0)},916761:l=>{r.xa("Sqrt",l,void 0)},916813:l=>{r.xa("Exp",l,void 0)},916864:l=>{r.xa("Erf",l,void 0)},916915:l=>{r.xa("Sigmoid",l,void 0)},916970:l=>{r.xa("Log",l,void 0)},917021:l=>{r.xa("Sin",l,void 0)},917072:l=>{r.xa("Cos",l,void 0)},917123:l=>{r.xa("Tan",l,void 0)},917174:l=>{r.xa("Asin",l,void 0)},917226:l=>{r.xa("Acos",l,void 0)},917278:l=>{r.xa("Atan",l,void 0)},917330:l=>{r.xa("Sinh",l,void 0)},917382:l=>{r.xa("Cosh",l,void 0)},917434:l=>{r.xa("Asinh",l,void 0)},917487:l=>{r.xa("Acosh",l,void 0)},917540:l=>{r.xa("Atanh",l,void 0)},917593:l=>{r.xa("Tanh",l,void 0)},917645:l=>{r.xa("Not",l,void 0)},917696:(l,m,y)=>{r.xa("ClipV10",l,{min:m,max:y})},917768:l=>{r.xa("Clip",l,void 0)},917820:(l,m)=>{r.xa("Elu",l,{alpha:m})},917878:l=>{r.xa("Relu",l,void 0)},917930:(l,m)=>{r.xa("LeakyRelu",l,{alpha:m})},917994:(l,m)=>{r.xa("ThresholdedRelu",l,{alpha:m})},918064:(l,m)=>{r.xa("Cast",l,{to:m})},918122:l=>{r.xa("Add",l,void 0)},918173:l=>{r.xa("Sub",l,void 0)},918224:l=>{r.xa("Mul",l,void 0)},918275:l=>{r.xa("Div",l,void 0)},918326:l=>{r.xa("Pow",l,void 0)},918377:l=>{r.xa("Equal",l,void 0)},918430:l=>{r.xa("Greater",l,void 0)},918485:l=>{r.xa("GreaterOrEqual",l,void 0)},918547:l=>{r.xa("Less",l,void 0)},918599:l=>{r.xa("LessOrEqual",l,void 0)},918658:(l,m,y,w,I)=>{r.xa("ReduceMean",l,{keepDims:!!m,noopWithEmptyAxes:!!y,axes:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[]})},918822:(l,m,y,w,I)=>{r.xa("ReduceMax",l,{keepDims:!!m,noopWithEmptyAxes:!!y,axes:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[]})},918985:(l,m,y,w,I)=>{r.xa("ReduceMin",l,{keepDims:!!m,noopWithEmptyAxes:!!y,axes:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[]})},919148:(l,m,y,w,I)=>{r.xa("ReduceProd",l,{keepDims:!!m,noopWithEmptyAxes:!!y,axes:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[]})},919312:(l,m,y,w,I)=>{r.xa("ReduceSum",l,{keepDims:!!m,noopWithEmptyAxes:!!y,axes:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[]})},919475:(l,m,y,w,I)=>{r.xa("ReduceL1",l,{keepDims:!!m,noopWithEmptyAxes:!!y,axes:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[]})},919637:(l,m,y,w,I)=>{r.xa("ReduceL2",l,{keepDims:!!m,noopWithEmptyAxes:!!y,axes:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[]})},919799:(l,m,y,w,I)=>{r.xa("ReduceLogSum",l,{keepDims:!!m,noopWithEmptyAxes:!!y,axes:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[]})},919965:(l,m,y,w,I)=>{r.xa("ReduceSumSquare",l,{keepDims:!!m,noopWithEmptyAxes:!!y,axes:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[]})},920134:(l,m,y,w,I)=>{r.xa("ReduceLogSumExp",l,{keepDims:!!m,noopWithEmptyAxes:!!y,axes:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[]})},920303:l=>{r.xa("Where",l,void 0)},920356:(l,m,y)=>{r.xa("Transpose",l,{perm:m?Array.from(D.subarray(y>>>0,y+m>>>0)):[]})},920469:(l,m,y,w,I,U,F,re,J,ae,ne,me,ye,_,se)=>{r.xa("ConvTranspose",l,{format:J?"NHWC":"NCHW",autoPad:m,dilations:[y],group:w,kernel_shape:[I],pads:[U,F],strides:[re],wIsConst:()=>!!ee[ae>>>0],outputPadding:ne?Array.from(D.subarray(me>>>0,me+ne>>>0)):[],outputShape:ye?Array.from(D.subarray(_>>>0,_+ye>>>0)):[],activation:De(se)})},920883:(l,m,y,w,I,U,F,re,J,ae,ne,me,ye,_)=>{r.xa("ConvTranspose",l,{format:re?"NHWC":"NCHW",autoPad:m,dilations:Array.from(D.subarray(y>>>0,y+2>>>0)),group:w,kernelShape:Array.from(D.subarray(I>>>0,I+2>>>0)),pads:Array.from(D.subarray(U>>>0,U+4>>>0)),strides:Array.from(D.subarray(F>>>0,F+2>>>0)),wIsConst:()=>!!ee[J>>>0],outputPadding:0<ae?Array.from(D.subarray(ne>>>0,ne+ae>>>0)):[],outputShape:0<me?Array.from(D.subarray(ye>>>0,ye+me>>>0)):[],activation:De(_)})},921440:(l,m,y,w,I,U,F,re,J,ae,ne,me,ye,_,se)=>{r.xa("ConvTranspose",l,{format:J?"NHWC":"NCHW",autoPad:m,dilations:[y],group:w,kernel_shape:[I],pads:[U,F],strides:[re],wIsConst:()=>!!ee[ae>>>0],outputPadding:ne?Array.from(D.subarray(me>>>0,me+ne>>>0)):[],outputShape:ye?Array.from(D.subarray(_>>>0,_+ye>>>0)):[],activation:De(se)})},921854:(l,m,y,w,I,U,F,re,J,ae,ne,me,ye,_)=>{r.xa("ConvTranspose",l,{format:re?"NHWC":"NCHW",autoPad:m,dilations:Array.from(D.subarray(y>>>0,y+2>>>0)),group:w,kernelShape:Array.from(D.subarray(I>>>0,I+2>>>0)),pads:Array.from(D.subarray(U>>>0,U+4>>>0)),strides:Array.from(D.subarray(F>>>0,F+2>>>0)),wIsConst:()=>!!ee[J>>>0],outputPadding:0<ae?Array.from(D.subarray(ne>>>0,ne+ae>>>0)):[],outputShape:0<me?Array.from(D.subarray(ye>>>0,ye+me>>>0)):[],activation:De(_)})},922411:(l,m)=>{r.xa("GlobalAveragePool",l,{format:m?"NHWC":"NCHW"})},922502:(l,m,y,w,I,U,F,re,J,ae,ne,me,ye,_,se,he)=>{r.xa("AveragePool",l,{format:he?"NHWC":"NCHW",auto_pad:m,ceil_mode:y,count_include_pad:w,storage_order:I,dilations:[U,F],kernel_shape:[re,J],pads:[ae,ne,me,ye],strides:[_,se]})},922786:(l,m)=>{r.xa("GlobalAveragePool",l,{format:m?"NHWC":"NCHW"})},922877:(l,m,y,w,I,U,F,re,J,ae,ne,me,ye,_,se,he)=>{r.xa("AveragePool",l,{format:he?"NHWC":"NCHW",auto_pad:m,ceil_mode:y,count_include_pad:w,storage_order:I,dilations:[U,F],kernel_shape:[re,J],pads:[ae,ne,me,ye],strides:[_,se]})},923161:(l,m)=>{r.xa("GlobalMaxPool",l,{format:m?"NHWC":"NCHW"})},923248:(l,m,y,w,I,U,F,re,J,ae,ne,me,ye,_,se,he)=>{r.xa("MaxPool",l,{format:he?"NHWC":"NCHW",auto_pad:m,ceil_mode:y,count_include_pad:w,storage_order:I,dilations:[U,F],kernel_shape:[re,J],pads:[ae,ne,me,ye],strides:[_,se]})},923528:(l,m)=>{r.xa("GlobalMaxPool",l,{format:m?"NHWC":"NCHW"})},923615:(l,m,y,w,I,U,F,re,J,ae,ne,me,ye,_,se,he)=>{r.xa("MaxPool",l,{format:he?"NHWC":"NCHW",auto_pad:m,ceil_mode:y,count_include_pad:w,storage_order:I,dilations:[U,F],kernel_shape:[re,J],pads:[ae,ne,me,ye],strides:[_,se]})},923895:(l,m,y,w,I)=>{r.xa("Gemm",l,{alpha:m,beta:y,transA:w,transB:I})},923999:l=>{r.xa("MatMul",l,void 0)},924053:(l,m,y,w)=>{r.xa("ArgMax",l,{keepDims:!!m,selectLastIndex:!!y,axis:w})},924161:(l,m,y,w)=>{r.xa("ArgMin",l,{keepDims:!!m,selectLastIndex:!!y,axis:w})},924269:(l,m)=>{r.xa("Softmax",l,{axis:m})},924332:(l,m)=>{r.xa("Concat",l,{axis:m})},924392:(l,m,y,w,I)=>{r.xa("Split",l,{axis:m,numOutputs:y,splitSizes:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[]})},924537:l=>{r.xa("Expand",l,void 0)},924591:(l,m)=>{r.xa("Gather",l,{axis:Number(m)})},924662:(l,m)=>{r.xa("GatherElements",l,{axis:Number(m)})},924741:(l,m,y,w,I,U,F,re,J,ae,ne)=>{r.xa("Resize",l,{antialias:m,axes:y?Array.from(D.subarray(w>>>0,w+y>>>0)):[],coordinateTransformMode:De(I),cubicCoeffA:U,excludeOutside:F,extrapolationValue:re,keepAspectRatioPolicy:De(J),mode:De(ae),nearestMode:De(ne)})},925092:(l,m,y,w,I,U,F)=>{r.xa("Slice",l,{starts:m?Array.from(D.subarray(y>>>0,y+m>>>0)):[],ends:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[],axes:U?Array.from(D.subarray(F>>>0,F+U>>>0)):[]})},925323:l=>{r.xa("Tile",l,void 0)},925375:(l,m,y)=>{r.xa("LayerNormalization",l,{axis:Number(m),epsilon:Number(y)})},925482:(l,m,y)=>{r.xa("InstanceNormalization",l,{epsilon:m,format:y?"NHWC":"NCHW"})},925596:(l,m,y)=>{r.xa("InstanceNormalization",l,{epsilon:m,format:y?"NHWC":"NCHW"})},925710:l=>{r.xa("Range",l,void 0)},925763:(l,m)=>{r.xa("Einsum",l,{equation:De(m)})},925844:(l,m,y,w,I)=>{r.xa("Pad",l,{mode:m,value:y,pads:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[]})},925976:l=>{r.xa("Gelu",l,void 0)},926028:l=>{r.xa("BiasAdd",l,void 0)},926083:l=>{r.xa("BiasSplitGelu",l,void 0)},926144:(l,m)=>{r.xa("SkipLayerNormalization",l,{epsilon:m})},926225:(l,m,y,w,I,U,F,re,J,ae,ne,me,ye)=>{r.xa("Conv",l,{format:J?"NHWC":"NCHW",auto_pad:m,dilations:[y],group:w,kernel_shape:[I],pads:U?Array.from(D.subarray(F>>>0,F+U>>>0)):[],strides:[re],w_is_const:()=>!!ee[ae>>>0],activation:De(ne),activation_params:me?Array.from(Ie.subarray(ye>>>0,ye+me>>>0)):[]})},926606:(l,m,y,w,I,U,F,re,J,ae,ne,me,ye,_,se,he)=>{r.xa("Conv",l,{format:me?"NHWC":"NCHW",auto_pad:m,dilations:[y,w],group:I,kernel_shape:[U,F],pads:re?Array.from(D.subarray(J>>>0,J+re>>>0)):[],strides:[ae,ne],w_is_const:()=>!!ee[ye>>>0],activation:De(_),activation_params:se?Array.from(Ie.subarray(he>>>0,he+se>>>0)):[]})},927008:l=>{r.Ua(l)},927042:(l,m)=>r.Va(l,m,r.Fa.Wa,r.Fa.errors),927154:l=>r.Ra(l),927187:l=>r.Ta(l),927219:(l,m,y)=>{r.La(l,m,y,!0)},927258:(l,m,y)=>{r.La(l,m,y)}};function nt(l){this.name="ExitStatus",this.message=`Program terminated with exit(${l})`,this.status=l}var Tt=l=>{for(;0<l.length;)l.shift()(r)};function Ot(l){this.Ka=l-24,this.Pa=function(m){te[this.Ka+4>>2>>>0]=m},this.Oa=function(m){te[this.Ka+8>>2>>>0]=m},this.Ma=function(m,y){this.Na(),this.Pa(m),this.Oa(y)},this.Na=function(){te[this.Ka+16>>2>>>0]=0}}var Kt=0,Xe=0,Yt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Et=(l,m,y)=>{m>>>=0;var w=m+y;for(y=m;l[y]&&!(y>=w);)++y;if(16<y-m&&l.buffer&&Yt)return Yt.decode(l.subarray(m,y));for(w="";m<y;){var I=l[m++];if(I&128){var U=l[m++]&63;if((I&224)==192)w+=String.fromCharCode((I&31)<<6|U);else{var F=l[m++]&63;I=(I&240)==224?(I&15)<<12|U<<6|F:(I&7)<<18|U<<12|F<<6|l[m++]&63,65536>I?w+=String.fromCharCode(I):(I-=65536,w+=String.fromCharCode(55296|I>>10,56320|I&1023))}}else w+=String.fromCharCode(I)}return w},De=(l,m)=>(l>>>=0)?Et(oe,l,m):"",Vt=l=>{for(var m=0,y=0;y<l.length;++y){var w=l.charCodeAt(y);127>=w?m++:2047>=w?m+=2:55296<=w&&57343>=w?(m+=4,++y):m+=3}return m},Jt=(l,m,y,w)=>{if(y>>>=0,!(0<w))return 0;var I=y;w=y+w-1;for(var U=0;U<l.length;++U){var F=l.charCodeAt(U);if(55296<=F&&57343>=F){var re=l.charCodeAt(++U);F=65536+((F&1023)<<10)|re&1023}if(127>=F){if(y>=w)break;m[y++>>>0]=F}else{if(2047>=F){if(y+1>=w)break;m[y++>>>0]=192|F>>6}else{if(65535>=F){if(y+2>=w)break;m[y++>>>0]=224|F>>12}else{if(y+3>=w)break;m[y++>>>0]=240|F>>18,m[y++>>>0]=128|F>>12&63}m[y++>>>0]=128|F>>6&63}m[y++>>>0]=128|F&63}}return m[y>>>0]=0,y-I},mt=l=>l%4===0&&(l%100!==0||l%400===0),xr=[0,31,60,91,121,152,182,213,244,274,305,335],Ut=[0,31,59,90,120,151,181,212,243,273,304,334],_t=l=>{var m=Vt(l)+1,y=Ft(m);return y&&Jt(l,oe,y,m),y},Pt=[],Xt=(l,m)=>{Pt.length=0;var y;for(m>>=2;y=oe[l++>>>0];)m+=y!=105&m,Pt.push(y==105?D[m>>>0]:Z[m++>>>1]),++m;return Pt},Ze={},Zt=()=>{if(!Nt){var l={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:i||"./this.program"},m;for(m in Ze)Ze[m]===void 0?delete l[m]:l[m]=Ze[m];var y=[];for(m in l)y.push(`${m}=${l[m]}`);Nt=y}return Nt},Nt,Ve=[null,[],[]],Qt=[31,29,31,30,31,30,31,31,30,31,30,31],Gt=[31,28,31,30,31,30,31,31,30,31,30,31];function cn(l){var m=Array(Vt(l)+1);return Jt(l,m,0,m.length),m}function le(l,m,y,w){function I(_,se,he){for(_=typeof _=="number"?_.toString():_||"";_.length<se;)_=he[0]+_;return _}function U(_,se){return I(_,se,"0")}function F(_,se){function he(Mt){return 0>Mt?-1:0<Mt?1:0}var et;return(et=he(_.getFullYear()-se.getFullYear()))===0&&(et=he(_.getMonth()-se.getMonth()))===0&&(et=he(_.getDate()-se.getDate())),et}function re(_){switch(_.getDay()){case 0:return new Date(_.getFullYear()-1,11,29);case 1:return _;case 2:return new Date(_.getFullYear(),0,3);case 3:return new Date(_.getFullYear(),0,2);case 4:return new Date(_.getFullYear(),0,1);case 5:return new Date(_.getFullYear()-1,11,31);case 6:return new Date(_.getFullYear()-1,11,30)}}function J(_){var se=_.Da;for(_=new Date(new Date(_.Ea+1900,0,1).getTime());0<se;){var he=_.getMonth(),et=(mt(_.getFullYear())?Qt:Gt)[he];if(se>et-_.getDate())se-=et-_.getDate()+1,_.setDate(1),11>he?_.setMonth(he+1):(_.setMonth(0),_.setFullYear(_.getFullYear()+1));else{_.setDate(_.getDate()+se);break}}return he=new Date(_.getFullYear()+1,0,4),se=re(new Date(_.getFullYear(),0,4)),he=re(he),0>=F(se,_)?0>=F(he,_)?_.getFullYear()+1:_.getFullYear():_.getFullYear()-1}l>>>=0,m>>>=0,y>>>=0,w>>>=0;var ae=D[w+40>>2>>>0];w={Za:D[w>>2>>>0],Ya:D[w+4>>2>>>0],Ga:D[w+8>>2>>>0],Ja:D[w+12>>2>>>0],Ha:D[w+16>>2>>>0],Ea:D[w+20>>2>>>0],Ca:D[w+24>>2>>>0],Da:D[w+28>>2>>>0],bb:D[w+32>>2>>>0],Xa:D[w+36>>2>>>0],$a:ae?De(ae):""},y=De(y),ae={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ne in ae)y=y.replace(new RegExp(ne,"g"),ae[ne]);var me="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),ye="January February March April May June July August September October November December".split(" ");ae={"%a":_=>me[_.Ca].substring(0,3),"%A":_=>me[_.Ca],"%b":_=>ye[_.Ha].substring(0,3),"%B":_=>ye[_.Ha],"%C":_=>U((_.Ea+1900)/100|0,2),"%d":_=>U(_.Ja,2),"%e":_=>I(_.Ja,2," "),"%g":_=>J(_).toString().substring(2),"%G":_=>J(_),"%H":_=>U(_.Ga,2),"%I":_=>(_=_.Ga,_==0?_=12:12<_&&(_-=12),U(_,2)),"%j":_=>{for(var se=0,he=0;he<=_.Ha-1;se+=(mt(_.Ea+1900)?Qt:Gt)[he++]);return U(_.Ja+se,3)},"%m":_=>U(_.Ha+1,2),"%M":_=>U(_.Ya,2),"%n":()=>`\n`,"%p":_=>0<=_.Ga&&12>_.Ga?"AM":"PM","%S":_=>U(_.Za,2),"%t":()=>"	","%u":_=>_.Ca||7,"%U":_=>U(Math.floor((_.Da+7-_.Ca)/7),2),"%V":_=>{var se=Math.floor((_.Da+7-(_.Ca+6)%7)/7);if(2>=(_.Ca+371-_.Da-2)%7&&se++,se)se==53&&(he=(_.Ca+371-_.Da)%7,he==4||he==3&&mt(_.Ea)||(se=1));else{se=52;var he=(_.Ca+7-_.Da-1)%7;(he==4||he==5&&mt(_.Ea%400-1))&&se++}return U(se,2)},"%w":_=>_.Ca,"%W":_=>U(Math.floor((_.Da+7-(_.Ca+6)%7)/7),2),"%y":_=>(_.Ea+1900).toString().substring(2),"%Y":_=>_.Ea+1900,"%z":_=>{_=_.Xa;var se=0<=_;return _=Math.abs(_)/60,(se?"+":"-")+("0000"+(_/60*100+_%60)).slice(-4)},"%Z":_=>_.$a,"%%":()=>"%"},y=y.replace(/%%/g,"\\0\\0");for(ne in ae)y.includes(ne)&&(y=y.replace(new RegExp(ne,"g"),ae[ne](w)));return y=y.replace(/\\0\\0/g,"%"),ne=cn(y),ne.length>m?0:(ee.set(ne,l>>>0),ne.length-1)}function ht(l){try{l()}catch(m){G(m)}}function Sr(l){var m={},y;for(y in l)(function(w){var I=l[w];m[w]=typeof I=="function"?function(){Rt.push(w);try{return I.apply(null,arguments)}finally{W||(Rt.pop()===w||G(),je&&ot===1&&Rt.length===0&&(ot=0,ht(Ht),typeof Fibers<"u"&&Fibers.cb()))}}:I})(y);return m}var ot=0,je=null,Cr=0,Rt=[],er={},tr={},Ar=0,$t=null,Ir=[];function rr(){return new Promise((l,m)=>{$t={resolve:l,reject:m}})}function Tr(){var l=Ft(65548),m=l+12;te[l>>2>>>0]=m,te[l+4>>2>>>0]=m+65536,m=Rt[0];var y=er[m];return y===void 0&&(y=Ar++,er[m]=y,tr[y]=m),D[l+8>>2>>>0]=y,l}function Or(l){if(!W){if(ot===0){var m=!1,y=!1;l((w=0)=>{if(!W&&(Cr=w,m=!0,y)){ot=2,ht(()=>Pr(je)),typeof Browser<"u"&&Browser.Ia.Qa&&Browser.Ia.resume(),w=!1;try{var I=(0,B[tr[D[je+8>>2>>>0]]])()}catch(re){I=re,w=!0}var U=!1;if(!je){var F=$t;F&&($t=null,(w?F.reject:F.resolve)(I),U=!0)}if(w&&!U)throw I}}),y=!0,m||(ot=1,je=Tr(),typeof Browser<"u"&&Browser.Ia.Qa&&Browser.Ia.pause(),ht(()=>Lt(je)))}else ot===2?(ot=0,ht(Qe),ar(je),je=null,Ir.forEach(w=>{if(!W)try{if(w(),!R)try{q=q=w=q,R||(r.onExit&&r.onExit(w),W=!0),d(w,new nt(w))}catch(I){I instanceof nt||I=="unwind"||d(1,I)}}catch(I){I instanceof nt||I=="unwind"||d(1,I)}})):G(`invalid state: ${ot}`);return Cr}}function Er(l){return Or(m=>{l().then(m)})}var gt=[],yt=void 0,nr=[];function or(l,m){if(!yt){yt=new WeakMap;var y=Te.length;if(yt)for(var w=0;w<0+y;w++){var I=w,U=gt[I];U||(I>=gt.length&&(gt.length=I+1),gt[I]=U=Te.get(I)),(I=U)&&yt.set(I,w)}}if(y=yt.get(l)||0)return y;if(nr.length)y=nr.pop();else{try{Te.grow(1)}catch(re){throw re instanceof RangeError?"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.":re}y=Te.length-1}try{w=y,Te.set(w,l),gt[w]=Te.get(w)}catch(re){if(!(re instanceof TypeError))throw re;if(typeof WebAssembly.Function=="function"){w=WebAssembly.Function,I={i:"i32",j:"i64",f:"f32",d:"f64",p:"i32"},U={parameters:[],results:m[0]=="v"?[]:[I[m[0]]]};for(var F=1;F<m.length;++F)U.parameters.push(I[m[F]]);m=new w(U,l)}else{for(w=[1],I=m.slice(0,1),m=m.slice(1),U={i:127,p:127,j:126,f:125,d:124},w.push(96),F=m.length,128>F?w.push(F):w.push(F%128|128,F>>7),F=0;F<m.length;++F)w.push(U[m[F]]);I=="v"?w.push(0):w.push(1,U[I]),m=[0,97,115,109,1,0,0,0,1],I=w.length,128>I?m.push(I):m.push(I%128|128,I>>7),m.push.apply(m,w),m.push(2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0),m=new WebAssembly.Module(new Uint8Array(m)),m=new WebAssembly.Instance(m,{e:{f:l}}).exports.f}w=y,Te.set(w,m),gt[w]=Te.get(w)}return yt.set(l,y),y}var _r={n:function(l,m,y){return Er(async()=>{await r.Sa(l,m,y)})},a:function(l,m,y){throw l>>>=0,new Ot(l).Ma(m>>>0,y>>>0),Kt=l,Xe++,Kt},g:function(){return 0},J:function(){},z:function(){},B:function(){},L:function(){return 0},H:function(){},C:function(){},F:function(){},m:function(){},A:function(){},x:function(){},I:function(){},y:function(){},M:()=>!0,q:function(l,m,y){l=m+2097152>>>0<4194305-!!l?(l>>>0)+4294967296*m:NaN,y>>>=0,l=new Date(1e3*l),D[y>>2>>>0]=l.getUTCSeconds(),D[y+4>>2>>>0]=l.getUTCMinutes(),D[y+8>>2>>>0]=l.getUTCHours(),D[y+12>>2>>>0]=l.getUTCDate(),D[y+16>>2>>>0]=l.getUTCMonth(),D[y+20>>2>>>0]=l.getUTCFullYear()-1900,D[y+24>>2>>>0]=l.getUTCDay(),D[y+28>>2>>>0]=(l.getTime()-Date.UTC(l.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(l,m,y){l=m+2097152>>>0<4194305-!!l?(l>>>0)+4294967296*m:NaN,y>>>=0,l=new Date(1e3*l),D[y>>2>>>0]=l.getSeconds(),D[y+4>>2>>>0]=l.getMinutes(),D[y+8>>2>>>0]=l.getHours(),D[y+12>>2>>>0]=l.getDate(),D[y+16>>2>>>0]=l.getMonth(),D[y+20>>2>>>0]=l.getFullYear()-1900,D[y+24>>2>>>0]=l.getDay(),D[y+28>>2>>>0]=(mt(l.getFullYear())?xr:Ut)[l.getMonth()]+l.getDate()-1|0,D[y+36>>2>>>0]=-(60*l.getTimezoneOffset()),m=new Date(l.getFullYear(),6,1).getTimezoneOffset();var w=new Date(l.getFullYear(),0,1).getTimezoneOffset();D[y+32>>2>>>0]=(m!=w&&l.getTimezoneOffset()==Math.min(w,m))|0},s:function(l){l>>>=0;var m=new Date(D[l+20>>2>>>0]+1900,D[l+16>>2>>>0],D[l+12>>2>>>0],D[l+8>>2>>>0],D[l+4>>2>>>0],D[l>>2>>>0],0),y=D[l+32>>2>>>0],w=m.getTimezoneOffset(),I=new Date(m.getFullYear(),6,1).getTimezoneOffset(),U=new Date(m.getFullYear(),0,1).getTimezoneOffset(),F=Math.min(U,I);return 0>y?D[l+32>>2>>>0]=+(I!=U&&F==w):0<y!=(F==w)&&(I=Math.max(U,I),m.setTime(m.getTime()+6e4*((0<y?F:I)-w))),D[l+24>>2>>>0]=m.getDay(),D[l+28>>2>>>0]=(mt(m.getFullYear())?xr:Ut)[m.getMonth()]+m.getDate()-1|0,D[l>>2>>>0]=m.getSeconds(),D[l+4>>2>>>0]=m.getMinutes(),D[l+8>>2>>>0]=m.getHours(),D[l+12>>2>>>0]=m.getDate(),D[l+16>>2>>>0]=m.getMonth(),D[l+20>>2>>>0]=m.getYear(),l=m.getTime()/1e3,ir((He=l,1<=+Math.abs(He)?0<He?+Math.floor(He/4294967296)>>>0:~~+Math.ceil((He-+(~~He>>>0))/4294967296)>>>0:0)),l>>>0},o:function(){return-52},p:function(){},v:function(l,m,y){function w(J){return(J=J.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?J[1]:"GMT"}y>>>=0;var I=new Date().getFullYear(),U=new Date(I,0,1),F=new Date(I,6,1);I=U.getTimezoneOffset();var re=F.getTimezoneOffset();te[l>>>0>>2>>>0]=60*Math.max(I,re),D[m>>>0>>2>>>0]=+(I!=re),l=w(U),m=w(F),l=_t(l),m=_t(m),re<I?(te[y>>2>>>0]=l,te[y+4>>2>>>0]=m):(te[y>>2>>>0]=m,te[y+4>>2>>>0]=l)},e:()=>{G("")},b:function(l,m,y){return l>>>=0,m=Xt(m>>>0,y>>>0),zt[l].apply(null,m)},j:function(l,m,y){return l>>>=0,m=Xt(m>>>0,y>>>0),zt[l].apply(null,m)},h:function(){return Date.now()},w:function(){return 4294901760},c:()=>performance.now(),K:function(l,m,y){return m>>>=0,oe.copyWithin(l>>>0>>>0,m>>>0,m+(y>>>0)>>>0)},u:function(l){l>>>=0;var m=oe.length;if(4294901760<l)return!1;for(var y=1;4>=y;y*=2){var w=m*(1+.2/y);w=Math.min(w,l+100663296);var I=Math;w=Math.max(l,w);e:{I=I.min.call(I,4294901760,w+(65536-w%65536)%65536)-V.buffer.byteLength+65535>>>16;try{V.grow(I),ve();var U=1;break e}catch{}U=void 0}if(U)return!0}return!1},D:function(l,m){l>>>=0,m>>>=0;var y=0;return Zt().forEach(function(w,I){var U=m+y;for(I=te[l+4*I>>2>>>0]=U,U=0;U<w.length;++U)ee[I++>>0>>>0]=w.charCodeAt(U);ee[I>>0>>>0]=0,y+=w.length+1}),0},E:function(l,m){l>>>=0,m>>>=0;var y=Zt();te[l>>2>>>0]=y.length;var w=0;return y.forEach(function(I){w+=I.length+1}),te[m>>2>>>0]=w,0},f:()=>52,l:function(){return 52},t:function(){return 70},k:function(l,m,y,w){m>>>=0,y>>>=0,w>>>=0;for(var I=0,U=0;U<y;U++){var F=te[m>>2>>>0],re=te[m+4>>2>>>0];m+=8;for(var J=0;J<re;J++){var ae=oe[F+J>>>0],ne=Ve[l];ae===0||ae===10?((l===1?k:O)(Et(ne,0)),ne.length=0):ne.push(ae)}I+=re}return te[w>>2>>>0]=I,0},G:le,d:function(l,m,y,w){return le(l>>>0,m>>>0,y>>>0,w>>>0)},i:function(l,m,y,w){let I=Te.length;l=new Uint8Array(oe.slice(l+m,l+y));try{var U=new WebAssembly.Module(l),F=new WebAssembly.Instance(U,{env:{memory:V}}),re;for(re in F.exports)or(F.exports[re]);return I<Te.length?I:w}catch(J){return console.log(J),w}}};(function(){function l(y){if(y=y.exports,y=Sr(y),B=y=dn(y),V=B.N,ve(),Te=B.sa,Be.unshift(B.O),qe--,r.monitorRunDependencies&&r.monitorRunDependencies(qe),qe==0&&(Ke!==null&&(clearInterval(Ke),Ke=null),Ye)){var w=Ye;Ye=null,w()}return y}var m={a:_r};if(qe++,r.monitorRunDependencies&&r.monitorRunDependencies(qe),r.instantiateWasm)try{return r.instantiateWasm(m,l)}catch(y){O("Module.instantiateWasm callback failed with error: "+y),a(y)}return vt(m,function(y){l(y.instance)}).catch(a),{}})(),r._OrtInit=(l,m)=>(r._OrtInit=B.P)(l,m),r._OrtGetLastError=(l,m)=>(r._OrtGetLastError=B.Q)(l,m),r._OrtCreateSessionOptions=(l,m,y,w,I,U,F,re,J,ae)=>(r._OrtCreateSessionOptions=B.R)(l,m,y,w,I,U,F,re,J,ae),r._OrtAppendExecutionProvider=(l,m)=>(r._OrtAppendExecutionProvider=B.S)(l,m),r._OrtAddFreeDimensionOverride=(l,m,y)=>(r._OrtAddFreeDimensionOverride=B.T)(l,m,y),r._OrtAddSessionConfigEntry=(l,m,y)=>(r._OrtAddSessionConfigEntry=B.U)(l,m,y),r._OrtReleaseSessionOptions=l=>(r._OrtReleaseSessionOptions=B.V)(l),r._OrtCreateSession=(l,m,y)=>(r._OrtCreateSession=B.W)(l,m,y),r._OrtReleaseSession=l=>(r._OrtReleaseSession=B.X)(l),r._OrtGetInputOutputCount=(l,m,y)=>(r._OrtGetInputOutputCount=B.Y)(l,m,y),r._OrtGetInputName=(l,m)=>(r._OrtGetInputName=B.Z)(l,m),r._OrtGetOutputName=(l,m)=>(r._OrtGetOutputName=B._)(l,m),r._OrtFree=l=>(r._OrtFree=B.$)(l),r._OrtCreateTensor=(l,m,y,w,I,U)=>(r._OrtCreateTensor=B.aa)(l,m,y,w,I,U),r._OrtGetTensorData=(l,m,y,w,I)=>(r._OrtGetTensorData=B.ba)(l,m,y,w,I),r._OrtReleaseTensor=l=>(r._OrtReleaseTensor=B.ca)(l),r._OrtCreateRunOptions=(l,m,y,w)=>(r._OrtCreateRunOptions=B.da)(l,m,y,w),r._OrtAddRunConfigEntry=(l,m,y)=>(r._OrtAddRunConfigEntry=B.ea)(l,m,y),r._OrtReleaseRunOptions=l=>(r._OrtReleaseRunOptions=B.fa)(l),r._OrtCreateBinding=l=>(r._OrtCreateBinding=B.ga)(l),r._OrtBindInput=(l,m,y)=>(r._OrtBindInput=B.ha)(l,m,y),r._OrtBindOutput=(l,m,y,w)=>(r._OrtBindOutput=B.ia)(l,m,y,w),r._OrtClearBoundOutputs=l=>(r._OrtClearBoundOutputs=B.ja)(l),r._OrtReleaseBinding=l=>(r._OrtReleaseBinding=B.ka)(l),r._OrtRunWithBinding=(l,m,y,w,I)=>(r._OrtRunWithBinding=B.la)(l,m,y,w,I),r._OrtRun=(l,m,y,w,I,U,F,re)=>(r._OrtRun=B.ma)(l,m,y,w,I,U,F,re),r._OrtEndProfiling=l=>(r._OrtEndProfiling=B.na)(l),r._JsepOutput=(l,m,y)=>(r._JsepOutput=B.oa)(l,m,y),r._JsepGetNodeName=l=>(r._JsepGetNodeName=B.pa)(l);var Ft=r._malloc=l=>(Ft=r._malloc=B.qa)(l),ar=r._free=l=>(ar=r._free=B.ra)(l),ir=l=>(ir=B.ta)(l),sr=()=>(sr=B.ua)(),ur=l=>(ur=B.va)(l),Fe=l=>(Fe=B.wa)(l),Lt=l=>(Lt=B.ya)(l),Ht=()=>(Ht=B.za)(),Pr=l=>(Pr=B.Aa)(l),Qe=()=>(Qe=B.Ba)();r.___start_em_js=927291,r.___stop_em_js=928064;function dn(l){l=Object.assign({},l);var m=w=>()=>w()>>>0,y=w=>I=>w(I)>>>0;return l.__errno_location=m(l.__errno_location),l.malloc=y(l.malloc),l.stackSave=m(l.stackSave),l.stackAlloc=y(l.stackAlloc),l}r.stackAlloc=Fe,r.stackSave=sr,r.stackRestore=ur,r.addFunction=or,r.UTF8ToString=De,r.stringToUTF8=(l,m,y)=>Jt(l,oe,m,y),r.lengthBytesUTF8=Vt;var Le;Ye=function l(){Le||lr(),Le||(Ye=l)};function lr(){function l(){if(!Le&&(Le=!0,r.calledRun=!0,!W)){if(Tt(Be),o(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),r.postRun)for(typeof r.postRun=="function"&&(r.postRun=[r.postRun]);r.postRun.length;){var m=r.postRun.shift();Se.unshift(m)}Tt(Se)}}if(!(0<qe)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;)Ue();Tt(be),0<qe||(r.setStatus?(r.setStatus("Running..."),setTimeout(function(){setTimeout(function(){r.setStatus("")},1),l()},1)):l())}}if(r.preInit)for(typeof r.preInit=="function"&&(r.preInit=[r.preInit]);0<r.preInit.length;)r.preInit.pop()();return lr(),t.ready}})();typeof No=="object"&&typeof On=="object"?On.exports=Uo:typeof define=="function"&&define.amd&&define([],()=>Uo)});var Fo=dr(()=>{});var Lo=dr(()=>{});var Ho={};Vr(Ho,{cpus:()=>hl});var hl,jo=K(()=>{hl=void 0});var Yo=dr((Ko,En)=>{"use strict";var qo=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){function r(){return ve.buffer!=Se.buffer&&Ce(),Se}function o(){return ve.buffer!=Se.buffer&&Ce(),Ue}function a(){return ve.buffer!=Se.buffer&&Ce(),qe}function u(){return ve.buffer!=Se.buffer&&Ce(),Ke}function i(){return ve.buffer!=Se.buffer&&Ce(),Ye}function d(){return ve.buffer!=Se.buffer&&Ce(),G}function f(){return ve.buffer!=Se.buffer&&Ce(),pe}function h(){return ve.buffer!=Se.buffer&&Ce(),Ge}var c=t,C,b;c.ready=new Promise((n,s)=>{C=n,b=s}),c.jsepInit=(n,s,p,g,v,T,M,N)=>{c.oc=n,c.Wb=s,c.Yb=p,c.Lb=g,c.Xb=v,c.cb=T,c.Zb=M,c.$b=N,s=(L,j,Q)=>(...ce)=>{let fe=at,E=j?.();ce=L(...ce);let ie=j?.();return E!==ie&&(L=ie,Q(E),j=Q=null),at!=fe?tl():ce},p=L=>async(...j)=>{try{if(c.Cb)throw Error("Session already started");let Q=c.Cb={cc:j[0],errors:[]},ce=await L(...j);if(c.Cb!==Q)throw Error("Session mismatch");n.flush();let fe=Q.errors;if(0<fe.length){let E=await Promise.all(fe);if(E=E.filter(ie=>ie),0<E.length)throw Error(E.join(`\n`))}return ce}finally{c.Cb=null}},c._OrtRun=p(s(c._OrtRun,()=>c._OrtRun,L=>c._OrtRun=L)),c._OrtRunWithBinding=p(s(c._OrtRunWithBinding,()=>c._OrtRunWithBinding,L=>c._OrtRunWithBinding=L)),c._OrtBindInput=s(c._OrtBindInput,()=>c._OrtBindInput,L=>c._OrtBindInput=L),c.jsepRegisterBuffer=(L,j,Q,ce)=>n.registerBuffer(L,j,Q,ce),c.jsepUnregisterBuffers=L=>{n.unregisterBuffers(L)},c.jsepGetBuffer=L=>n.getBuffer(L),c.jsepCreateDownloader=(L,j,Q)=>n.createDownloader(L,j,Q)};var $=Object.assign({},c),S="./this.program",x=(n,s)=>{throw s},A=typeof window=="object",k=typeof importScripts=="function",O=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",P=c.ENVIRONMENT_IS_PTHREAD||!1,R="";function V(n){return c.locateFile?c.locateFile(n,R):R+n}var B,W,q;if(O){var ee=(An(),qt(Cn)),oe=(Tn(),qt(In));R=k?oe.dirname(R)+"/":__dirname+"/",B=(s,p)=>(s=Et(s)?new URL(s):oe.normalize(s),ee.readFileSync(s,p?void 0:"utf8")),q=s=>(s=B(s,!0),s.buffer||(s=new Uint8Array(s)),s),W=(s,p,g,v=!0)=>{s=Et(s)?new URL(s):oe.normalize(s),ee.readFile(s,v?void 0:"utf8",(T,M)=>{T?g(T):p(v?M.buffer:M)})},!c.thisProgram&&1<process.argv.length&&(S=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),x=(s,p)=>{throw process.exitCode=s,p},c.inspect=()=>"[Emscripten Module object]";let n;try{n=Fo()}catch(s){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),s}global.Worker=n.Worker}else(A||k)&&(k?R=self.location.href:typeof document<"u"&&document.currentScript&&(R=document.currentScript.src),typeof e<"u"&&e&&(R=e),R.indexOf("blob:")!==0?R=R.substr(0,R.replace(/[?#].*/,"").lastIndexOf("/")+1):R="",O||(B=n=>{var s=new XMLHttpRequest;return s.open("GET",n,!1),s.send(null),s.responseText},k&&(q=n=>{var s=new XMLHttpRequest;return s.open("GET",n,!1),s.responseType="arraybuffer",s.send(null),new Uint8Array(s.response)}),W=(n,s,p)=>{var g=new XMLHttpRequest;g.open("GET",n,!0),g.responseType="arraybuffer",g.onload=()=>{g.status==200||g.status==0&&g.response?s(g.response):p()},g.onerror=p,g.send(null)}));O&&typeof performance>"u"&&(global.performance=Lo().performance);var D=console.log.bind(console),te=console.error.bind(console);O&&(D=(...n)=>ee.writeSync(1,n.join(" ")+`\n`),te=(...n)=>ee.writeSync(2,n.join(" ")+`\n`));var Ie=D,Z=te;Object.assign(c,$),$=null,typeof WebAssembly!="object"&&Xe("no native wasm support detected");var ve,Te,be=!1,Be,Se,Ue,qe,Ke,Ye,G,pe,de,Ne,Ge;function Ce(){var n=ve.buffer;c.HEAP8=Se=new Int8Array(n),c.HEAP16=qe=new Int16Array(n),c.HEAPU8=Ue=new Uint8Array(n),c.HEAPU16=Ke=new Uint16Array(n),c.HEAP32=Ye=new Int32Array(n),c.HEAPU32=G=new Uint32Array(n),c.HEAPF32=pe=new Float32Array(n),c.HEAPF64=Ge=new Float64Array(n),c.HEAP64=de=new BigInt64Array(n),c.HEAPU64=Ne=new BigUint64Array(n)}var Pe=16777216;if(5242880<=Pe||Xe("INITIAL_MEMORY should be larger than STACK_SIZE, was "+Pe+"! (STACK_SIZE=5242880)"),P)ve=c.wasmMemory;else if(ve=new WebAssembly.Memory({initial:Pe/65536,maximum:65536,shared:!0}),!(ve.buffer instanceof SharedArrayBuffer))throw Z("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),O&&Z("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Ce(),Pe=ve.buffer.byteLength;var vt=[],He=[],zt=[],nt=0,Tt=null,Ot=null;function Kt(){if(nt--,nt==0&&(Tt!==null&&(clearInterval(Tt),Tt=null),Ot)){var n=Ot;Ot=null,n()}}function Xe(n){throw n="Aborted("+n+")",Z(n),be=!0,Be=1,n=new WebAssembly.RuntimeError(n+". Build with -sASSERTIONS for more info."),b(n),n}var Yt=n=>n.startsWith("data:application/octet-stream;base64,"),Et=n=>n.startsWith("file://"),De;De="ort-wasm-simd-threaded.wasm",Yt(De)||(De=V(De));function Vt(n){if(q)return q(n);throw"both async and sync fetching of the wasm failed"}function Jt(n){if(A||k){if(typeof fetch=="function"&&!Et(n))return fetch(n,{credentials:"same-origin"}).then(s=>{if(!s.ok)throw"failed to load wasm binary file at \'"+n+"\'";return s.arrayBuffer()}).catch(()=>Vt(n));if(W)return new Promise((s,p)=>{W(n,g=>s(new Uint8Array(g)),p)})}return Promise.resolve().then(()=>Vt(n))}function mt(n,s,p){return Jt(n).then(g=>WebAssembly.instantiate(g,s)).then(g=>g).then(p,g=>{Z(`failed to asynchronously prepare wasm: ${g}`),Xe(g)})}function xr(n,s){var p=De;return typeof WebAssembly.instantiateStreaming!="function"||Yt(p)||Et(p)||O||typeof fetch!="function"?mt(p,n,s):fetch(p,{credentials:"same-origin"}).then(g=>WebAssembly.instantiateStreaming(g,n).then(s,function(v){return Z(`wasm streaming compile failed: ${v}`),Z("falling back to ArrayBuffer instantiation"),mt(p,n,s)}))}var Ut={1441368:n=>{c.cb("Abs",n,void 0)},1441419:n=>{c.cb("Neg",n,void 0)},1441470:n=>{c.cb("Floor",n,void 0)},1441523:n=>{c.cb("Ceil",n,void 0)},1441575:n=>{c.cb("Reciprocal",n,void 0)},1441633:n=>{c.cb("Sqrt",n,void 0)},1441685:n=>{c.cb("Exp",n,void 0)},1441736:n=>{c.cb("Erf",n,void 0)},1441787:n=>{c.cb("Sigmoid",n,void 0)},1441842:n=>{c.cb("Log",n,void 0)},1441893:n=>{c.cb("Sin",n,void 0)},1441944:n=>{c.cb("Cos",n,void 0)},1441995:n=>{c.cb("Tan",n,void 0)},1442046:n=>{c.cb("Asin",n,void 0)},1442098:n=>{c.cb("Acos",n,void 0)},1442150:n=>{c.cb("Atan",n,void 0)},1442202:n=>{c.cb("Sinh",n,void 0)},1442254:n=>{c.cb("Cosh",n,void 0)},1442306:n=>{c.cb("Asinh",n,void 0)},1442359:n=>{c.cb("Acosh",n,void 0)},1442412:n=>{c.cb("Atanh",n,void 0)},1442465:n=>{c.cb("Tanh",n,void 0)},1442517:n=>{c.cb("Not",n,void 0)},1442568:(n,s,p)=>{c.cb("ClipV10",n,{min:s,max:p})},1442640:n=>{c.cb("Clip",n,void 0)},1442692:(n,s)=>{c.cb("Elu",n,{alpha:s})},1442750:n=>{c.cb("Relu",n,void 0)},1442802:(n,s)=>{c.cb("LeakyRelu",n,{alpha:s})},1442866:(n,s)=>{c.cb("ThresholdedRelu",n,{alpha:s})},1442936:n=>{c.Zb(n)},1442970:(n,s)=>c.$b(n,s,c.Cb.cc,c.Cb.errors),1443082:(n,s)=>{c.cb("Cast",n,{to:s})},1443140:n=>{c.cb("Add",n,void 0)},1443191:n=>{c.cb("Sub",n,void 0)},1443242:n=>{c.cb("Mul",n,void 0)},1443293:n=>{c.cb("Div",n,void 0)},1443344:n=>{c.cb("Pow",n,void 0)},1443395:n=>{c.cb("Equal",n,void 0)},1443448:n=>{c.cb("Greater",n,void 0)},1443503:n=>{c.cb("GreaterOrEqual",n,void 0)},1443565:n=>{c.cb("Less",n,void 0)},1443617:n=>{c.cb("LessOrEqual",n,void 0)},1443676:(n,s,p,g,v)=>{c.cb("ReduceMean",n,{keepDims:!!s,noopWithEmptyAxes:!!p,axes:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[]})},1443840:(n,s,p,g,v)=>{c.cb("ReduceMax",n,{keepDims:!!s,noopWithEmptyAxes:!!p,axes:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[]})},1444003:(n,s,p,g,v)=>{c.cb("ReduceMin",n,{keepDims:!!s,noopWithEmptyAxes:!!p,axes:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[]})},1444166:(n,s,p,g,v)=>{c.cb("ReduceProd",n,{keepDims:!!s,noopWithEmptyAxes:!!p,axes:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[]})},1444330:(n,s,p,g,v)=>{c.cb("ReduceSum",n,{keepDims:!!s,noopWithEmptyAxes:!!p,axes:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[]})},1444493:(n,s,p,g,v)=>{c.cb("ReduceL1",n,{keepDims:!!s,noopWithEmptyAxes:!!p,axes:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[]})},1444655:(n,s,p,g,v)=>{c.cb("ReduceL2",n,{keepDims:!!s,noopWithEmptyAxes:!!p,axes:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[]})},1444817:(n,s,p,g,v)=>{c.cb("ReduceLogSum",n,{keepDims:!!s,noopWithEmptyAxes:!!p,axes:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[]})},1444983:(n,s,p,g,v)=>{c.cb("ReduceSumSquare",n,{keepDims:!!s,noopWithEmptyAxes:!!p,axes:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[]})},1445152:(n,s,p,g,v)=>{c.cb("ReduceLogSumExp",n,{keepDims:!!s,noopWithEmptyAxes:!!p,axes:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[]})},1445321:n=>{c.cb("Where",n,void 0)},1445374:(n,s,p)=>{c.cb("Transpose",n,{perm:s?Array.from(i().subarray(p>>>0,p+s>>>0)):[]})},1445487:(n,s,p,g,v,T,M,N,L,j,Q,ce,fe)=>{c.cb("Conv",n,{format:L?"NHWC":"NCHW",auto_pad:s,dilations:[p],group:g,kernel_shape:[v],pads:T?Array.from(i().subarray(M>>>0,M+T>>>0)):[],strides:[N],w_is_const:()=>!!r()[j>>>0],activation:Ve(Q),activation_params:ce?Array.from(f().subarray(fe>>>0,fe+ce>>>0)):[]})},1445868:(n,s,p,g,v,T,M,N,L,j,Q,ce,fe,E,ie,we)=>{c.cb("Conv",n,{format:ce?"NHWC":"NCHW",auto_pad:s,dilations:[p,g],group:v,kernel_shape:[T,M],pads:N?Array.from(i().subarray(L>>>0,L+N>>>0)):[],strides:[j,Q],w_is_const:()=>!!r()[fe>>>0],activation:Ve(E),activation_params:ie?Array.from(f().subarray(we>>>0,we+ie>>>0)):[]})},1446270:(n,s,p,g,v,T,M,N,L,j,Q,ce,fe,E,ie)=>{c.cb("ConvTranspose",n,{format:L?"NHWC":"NCHW",autoPad:s,dilations:[p],group:g,kernel_shape:[v],pads:[T,M],strides:[N],wIsConst:()=>!!r()[j>>>0],outputPadding:Q?Array.from(i().subarray(ce>>>0,ce+Q>>>0)):[],outputShape:fe?Array.from(i().subarray(E>>>0,E+fe>>>0)):[],activation:Ve(ie)})},1446684:(n,s,p,g,v,T,M,N,L,j,Q,ce,fe,E)=>{c.cb("ConvTranspose",n,{format:N?"NHWC":"NCHW",autoPad:s,dilations:Array.from(i().subarray(p>>>0,p+2>>>0)),group:g,kernelShape:Array.from(i().subarray(v>>>0,v+2>>>0)),pads:Array.from(i().subarray(T>>>0,T+4>>>0)),strides:Array.from(i().subarray(M>>>0,M+2>>>0)),wIsConst:()=>!!r()[L>>>0],outputPadding:0<j?Array.from(i().subarray(Q>>>0,Q+j>>>0)):[],outputShape:0<ce?Array.from(i().subarray(fe>>>0,fe+ce>>>0)):[],activation:Ve(E)})},1447241:(n,s,p,g,v,T,M,N,L,j,Q,ce,fe,E,ie)=>{c.cb("ConvTranspose",n,{format:L?"NHWC":"NCHW",autoPad:s,dilations:[p],group:g,kernel_shape:[v],pads:[T,M],strides:[N],wIsConst:()=>!!r()[j>>>0],outputPadding:Q?Array.from(i().subarray(ce>>>0,ce+Q>>>0)):[],outputShape:fe?Array.from(i().subarray(E>>>0,E+fe>>>0)):[],activation:Ve(ie)})},1447655:(n,s,p,g,v,T,M,N,L,j,Q,ce,fe,E)=>{c.cb("ConvTranspose",n,{format:N?"NHWC":"NCHW",autoPad:s,dilations:Array.from(i().subarray(p>>>0,p+2>>>0)),group:g,kernelShape:Array.from(i().subarray(v>>>0,v+2>>>0)),pads:Array.from(i().subarray(T>>>0,T+4>>>0)),strides:Array.from(i().subarray(M>>>0,M+2>>>0)),wIsConst:()=>!!r()[L>>>0],outputPadding:0<j?Array.from(i().subarray(Q>>>0,Q+j>>>0)):[],outputShape:0<ce?Array.from(i().subarray(fe>>>0,fe+ce>>>0)):[],activation:Ve(E)})},1448212:(n,s)=>{c.cb("GlobalAveragePool",n,{format:s?"NHWC":"NCHW"})},1448303:(n,s,p,g,v,T,M,N,L,j,Q,ce,fe,E,ie,we)=>{c.cb("AveragePool",n,{format:we?"NHWC":"NCHW",auto_pad:s,ceil_mode:p,count_include_pad:g,storage_order:v,dilations:[T,M],kernel_shape:[N,L],pads:[j,Q,ce,fe],strides:[E,ie]})},1448587:(n,s)=>{c.cb("GlobalAveragePool",n,{format:s?"NHWC":"NCHW"})},1448678:(n,s,p,g,v,T,M,N,L,j,Q,ce,fe,E,ie,we)=>{c.cb("AveragePool",n,{format:we?"NHWC":"NCHW",auto_pad:s,ceil_mode:p,count_include_pad:g,storage_order:v,dilations:[T,M],kernel_shape:[N,L],pads:[j,Q,ce,fe],strides:[E,ie]})},1448962:(n,s)=>{c.cb("GlobalMaxPool",n,{format:s?"NHWC":"NCHW"})},1449049:(n,s,p,g,v,T,M,N,L,j,Q,ce,fe,E,ie,we)=>{c.cb("MaxPool",n,{format:we?"NHWC":"NCHW",auto_pad:s,ceil_mode:p,count_include_pad:g,storage_order:v,dilations:[T,M],kernel_shape:[N,L],pads:[j,Q,ce,fe],strides:[E,ie]})},1449329:(n,s)=>{c.cb("GlobalMaxPool",n,{format:s?"NHWC":"NCHW"})},1449416:(n,s,p,g,v,T,M,N,L,j,Q,ce,fe,E,ie,we)=>{c.cb("MaxPool",n,{format:we?"NHWC":"NCHW",auto_pad:s,ceil_mode:p,count_include_pad:g,storage_order:v,dilations:[T,M],kernel_shape:[N,L],pads:[j,Q,ce,fe],strides:[E,ie]})},1449696:(n,s,p,g,v)=>{c.cb("Gemm",n,{alpha:s,beta:p,transA:g,transB:v})},1449800:n=>{c.cb("MatMul",n,void 0)},1449854:(n,s,p,g)=>{c.cb("ArgMax",n,{keepDims:!!s,selectLastIndex:!!p,axis:g})},1449962:(n,s,p,g)=>{c.cb("ArgMin",n,{keepDims:!!s,selectLastIndex:!!p,axis:g})},1450070:(n,s)=>{c.cb("Softmax",n,{axis:s})},1450133:(n,s)=>{c.cb("Concat",n,{axis:s})},1450193:(n,s,p,g,v)=>{c.cb("Split",n,{axis:s,numOutputs:p,splitSizes:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[]})},1450338:n=>{c.cb("Expand",n,void 0)},1450392:(n,s)=>{c.cb("Gather",n,{axis:Number(s)})},1450463:(n,s)=>{c.cb("GatherElements",n,{axis:Number(s)})},1450542:(n,s,p,g,v,T,M,N,L,j,Q)=>{c.cb("Resize",n,{antialias:s,axes:p?Array.from(i().subarray(g>>>0,g+p>>>0)):[],coordinateTransformMode:Ve(v),cubicCoeffA:T,excludeOutside:M,extrapolationValue:N,keepAspectRatioPolicy:Ve(L),mode:Ve(j),nearestMode:Ve(Q)})},1450893:(n,s,p,g,v,T,M)=>{c.cb("Slice",n,{starts:s?Array.from(i().subarray(p>>>0,p+s>>>0)):[],ends:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[],axes:T?Array.from(i().subarray(M>>>0,M+T>>>0)):[]})},1451124:n=>{c.cb("Tile",n,void 0)},1451176:(n,s,p)=>{c.cb("LayerNormalization",n,{axis:Number(s),epsilon:Number(p)})},1451283:(n,s,p)=>{c.cb("InstanceNormalization",n,{epsilon:s,format:p?"NHWC":"NCHW"})},1451397:(n,s,p)=>{c.cb("InstanceNormalization",n,{epsilon:s,format:p?"NHWC":"NCHW"})},1451511:n=>{c.cb("Range",n,void 0)},1451564:(n,s)=>{c.cb("Einsum",n,{equation:Ve(s)})},1451645:(n,s,p,g,v)=>{c.cb("Pad",n,{mode:s,value:p,pads:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[]})},1451777:n=>{c.cb("Gelu",n,void 0)},1451829:n=>{c.cb("BiasAdd",n,void 0)},1451884:n=>{c.cb("BiasSplitGelu",n,void 0)},1451945:(n,s)=>{c.cb("SkipLayerNormalization",n,{epsilon:s})},1452026:n=>c.Wb(n),1452059:n=>c.Yb(n),1452091:(n,s,p)=>{c.Lb(n,s,p,!0)},1452130:(n,s,p)=>{c.Lb(n,s,p)}};function _t(n){this.name="ExitStatus",this.message=`Program terminated with exit(${n})`,this.status=n}var Pt=n=>{n.terminate(),n.onmessage=()=>{}},Xt=n=>{if(le.zb.length==0){var s=V("ort-wasm-simd-threaded.worker.js");s=new Worker(s),le.zb.push(s),le.ac(le.zb[0])}if(s=le.zb.pop(),!s)return 6;le.wb.push(s),le.nb[n.vb]=s,s.vb=n.vb;var p={cmd:"run",start_routine:n.dc,arg:n.Rb,pthread_ptr:n.vb};return O&&s.unref(),s.postMessage(p,n.kc),0},Ze=0,Zt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Nt=(n,s,p)=>{s>>>=0;var g=s+p;for(p=s;n[p]&&!(p>=g);)++p;if(16<p-s&&n.buffer&&Zt)return Zt.decode(n.buffer instanceof SharedArrayBuffer?n.slice(s,p):n.subarray(s,p));for(g="";s<p;){var v=n[s++];if(v&128){var T=n[s++]&63;if((v&224)==192)g+=String.fromCharCode((v&31)<<6|T);else{var M=n[s++]&63;v=(v&240)==224?(v&15)<<12|T<<6|M:(v&7)<<18|T<<12|M<<6|n[s++]&63,65536>v?g+=String.fromCharCode(v):(v-=65536,g+=String.fromCharCode(55296|v>>10,56320|v&1023))}}else g+=String.fromCharCode(v)}return g},Ve=(n,s)=>(n>>>=0)?Nt(o(),n,s):"";function Qt(n){if(P)return Oe(0,1,n);Be=n,0<Ze||(le.ec(),be=!0),x(n,new _t(n))}var Gt=n=>{if(Be=n,P)throw Sr(n),"unwind";Qt(n)};function cn(){vt.unshift(()=>{nt++,Kt()})}var le={zb:[],wb:[],Qb:[],nb:{},Fb(){P?(le.receiveObjectTransfer=le.bc,le.threadInitTLS=le.Pb,le.setExitStatus=le.Ob):cn()},Ob:n=>{Be=n},pc:["$terminateWorker"],ec:()=>{for(var n of le.wb)Pt(n);for(n of le.zb)Pt(n);le.zb=[],le.wb=[],le.nb=[]},Nb:n=>{var s=n.vb;delete le.nb[s],le.zb.push(n),le.wb.splice(le.wb.indexOf(n),1),n.vb=0,wn(s)},bc(){},Pb(){le.Qb.forEach(n=>n())},ac:n=>new Promise(s=>{n.onmessage=T=>{T=T.data;var M=T.cmd;if(T.targetThread&&T.targetThread!=Dr()){var N=le.nb[T.targetThread];N?N.postMessage(T,T.transferList):Z(`Internal error! Worker sent a message "${M}" to target pthread ${T.targetThread}, but that thread no longer exists!`)}else M==="checkMailbox"?Mt():M==="spawnThread"?Xt(T):M==="cleanupThread"?((T=le.nb[T.thread])||Xe(),le.Nb(T)):M==="killThread"?(T=T.thread,M=le.nb[T],delete le.nb[T],Pt(M),wn(T),le.wb.splice(le.wb.indexOf(M),1),M.vb=0):M==="cancelThread"?le.nb[T.thread].postMessage({cmd:"cancel"}):M==="loaded"?(n.loaded=!0,s(n)):M==="alert"?alert(`Thread ${T.threadId}: ${T.text}`):T.target==="setimmediate"?n.postMessage(T):M==="callHandler"?c[T.handler](...T.args):M&&Z(`worker sent an unknown command ${M}`)},n.onerror=T=>{throw Z(`worker sent an error! ${T.filename}:${T.lineno}: ${T.message}`),T},O&&(n.on("message",T=>n.onmessage({data:T})),n.on("error",T=>n.onerror(T)));var p=[],g=[],v;for(v of g)c.hasOwnProperty(v)&&p.push(v);n.postMessage({cmd:"load",handlers:p,urlOrBlob:c.mainScriptUrlOrBlob||e,wasmMemory:ve,wasmModule:Te})})};c.PThread=le;var ht=n=>{for(;0<n.length;)n.shift()(c)};c.establishStackSpace=()=>{var n=Dr(),s=d()[n+52>>>2>>>0];n=d()[n+56>>>2>>>0],Ro(s,s-n),Wr(s)};function Sr(n){if(P)return Oe(1,0,n);Gt(n)}c.invokeEntryPoint=(n,s)=>{n=Mo.apply(null,[n,s]),0<Ze?le.Ob(n):vn(n)};function ot(n){this.Ab=n-24,this.lc=function(s){d()[this.Ab+4>>>2>>>0]=s},this.Ib=function(s){d()[this.Ab+8>>>2>>>0]=s},this.Fb=function(s,p){this.Hb(),this.lc(s),this.Ib(p)},this.Hb=function(){d()[this.Ab+16>>>2>>>0]=0}}var je=0,Cr=0;function Rt(n,s,p,g){return P?Oe(2,1,n,s,p,g):er(n,s,p,g)}function er(n,s,p,g){if(n>>>=0,s>>>=0,p>>>=0,g>>>=0,typeof SharedArrayBuffer>"u")return Z("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var v=[];return P&&v.length===0?Rt(n,s,p,g):(n={dc:p,vb:n,Rb:g,kc:v},P?(n.nc="spawnThread",postMessage(n,v),0):Xt(n))}function tr(n,s,p){return P?Oe(3,1,n,s,p):0}function Ar(n,s){if(P)return Oe(4,1,n,s)}var $t=n=>{for(var s=0,p=0;p<n.length;++p){var g=n.charCodeAt(p);127>=g?s++:2047>=g?s+=2:55296<=g&&57343>=g?(s+=4,++p):s+=3}return s},Ir=(n,s,p,g)=>{if(p>>>=0,!(0<g))return 0;var v=p;g=p+g-1;for(var T=0;T<n.length;++T){var M=n.charCodeAt(T);if(55296<=M&&57343>=M){var N=n.charCodeAt(++T);M=65536+((M&1023)<<10)|N&1023}if(127>=M){if(p>=g)break;s[p++>>>0]=M}else{if(2047>=M){if(p+1>=g)break;s[p++>>>0]=192|M>>6}else{if(65535>=M){if(p+2>=g)break;s[p++>>>0]=224|M>>12}else{if(p+3>=g)break;s[p++>>>0]=240|M>>18,s[p++>>>0]=128|M>>12&63}s[p++>>>0]=128|M>>6&63}s[p++>>>0]=128|M&63}}return s[p>>>0]=0,p-v},rr=(n,s,p)=>Ir(n,o(),s,p);function Tr(n,s){if(P)return Oe(5,1,n,s)}function Or(n,s,p){if(P)return Oe(6,1,n,s,p)}function Er(n,s,p){return P?Oe(7,1,n,s,p):0}function gt(n,s){if(P)return Oe(8,1,n,s)}function yt(n,s,p){if(P)return Oe(9,1,n,s,p)}function nr(n,s,p,g){if(P)return Oe(10,1,n,s,p,g)}function or(n,s,p,g){if(P)return Oe(11,1,n,s,p,g)}function _r(n,s,p,g){if(P)return Oe(12,1,n,s,p,g)}function Ft(n){if(P)return Oe(13,1,n)}function ar(n,s){if(P)return Oe(14,1,n,s)}function ir(n,s,p){if(P)return Oe(15,1,n,s,p)}var sr=n=>{if(n===null)return"null";var s=typeof n;return s==="object"||s==="array"||s==="function"?n.toString():""+n},ur,Fe=n=>{for(var s="";o()[n>>>0];)s+=ur[o()[n++>>>0]];return s},Lt={},Ht={},Pr={},Qe;function dn(n,s,p={}){var g=s.name;if(!n)throw new Qe(`type "${g}" must have a positive integer typeid pointer`);if(Ht.hasOwnProperty(n)){if(p.Ub)return;throw new Qe(`Cannot register type \'${g}\' twice`)}Ht[n]=s,delete Pr[n],Lt.hasOwnProperty(n)&&(s=Lt[n],delete Lt[n],s.forEach(v=>v()))}function Le(n,s,p={}){if(!("argPackAdvance"in s))throw new TypeError("registerType registeredInstance requires argPackAdvance");dn(n,s,p)}var lr=(n,s,p)=>{switch(s){case 1:return p?g=>r()[g>>>0>>>0]:g=>o()[g>>>0>>>0];case 2:return p?g=>a()[g>>>1>>>0]:g=>u()[g>>>1>>>0];case 4:return p?g=>i()[g>>>2>>>0]:g=>d()[g>>>2>>>0];case 8:return p?g=>de[g>>>3]:g=>Ne[g>>>3];default:throw new TypeError(`invalid integer width (${s}): ${n}`)}};function l(){this.ub=[void 0],this.Kb=[]}var m=new l;function y(n){n>>>=0,n>=m.Ab&&--m.get(n).Mb===0&&m.Ib(n)}var w=n=>{if(!n)throw new Qe("Cannot use deleted val. handle = "+n);return m.get(n).value},I=n=>{switch(n){case void 0:return 1;case null:return 2;case!0:return 3;case!1:return 4;default:return m.Hb({Mb:1,value:n})}};function U(n){return this.fromWireType(i()[n>>>2>>>0])}var F=(n,s)=>{switch(s){case 4:return function(p){return this.fromWireType(f()[p>>>2>>>0])};case 8:return function(p){return this.fromWireType(h()[p>>>3>>>0])};default:throw new TypeError(`invalid float width (${s}): ${n}`)}};function re(n){return this.fromWireType(d()[n>>>2>>>0])}var J=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,ae=(n,s)=>{for(var p=n>>1,g=p+s/2;!(p>=g)&&u()[p>>>0];)++p;if(p<<=1,32<p-n&&J)return J.decode(o().slice(n,p));for(p="",g=0;!(g>=s/2);++g){var v=a()[n+2*g>>>1>>>0];if(v==0)break;p+=String.fromCharCode(v)}return p},ne=(n,s,p)=>{if(p===void 0&&(p=2147483647),2>p)return 0;p-=2;var g=s;p=p<2*n.length?p/2:n.length;for(var v=0;v<p;++v){var T=n.charCodeAt(v);a()[s>>>1>>>0]=T,s+=2}return a()[s>>>1>>>0]=0,s-g},me=n=>2*n.length,ye=(n,s)=>{for(var p=0,g="";!(p>=s/4);){var v=i()[n+4*p>>>2>>>0];if(v==0)break;++p,65536<=v?(v-=65536,g+=String.fromCharCode(55296|v>>10,56320|v&1023)):g+=String.fromCharCode(v)}return g},_=(n,s,p)=>{if(s>>>=0,p===void 0&&(p=2147483647),4>p)return 0;var g=s;p=g+p-4;for(var v=0;v<n.length;++v){var T=n.charCodeAt(v);if(55296<=T&&57343>=T){var M=n.charCodeAt(++v);T=65536+((T&1023)<<10)|M&1023}if(i()[s>>>2>>>0]=T,s+=4,s+4>p)break}return i()[s>>>2>>>0]=0,s-g},se=n=>{for(var s=0,p=0;p<n.length;++p){var g=n.charCodeAt(p);55296<=g&&57343>=g&&++p,s+=4}return s},he=n=>{if(!be)try{if(n(),!(0<Ze))try{P?vn(Be):Gt(Be)}catch(s){s instanceof _t||s=="unwind"||x(1,s)}}catch(s){s instanceof _t||s=="unwind"||x(1,s)}};function et(n){n>>>=0,typeof Atomics.mc=="function"&&(Atomics.mc(i(),n>>>2,n).value.then(Mt),n+=128,Atomics.store(i(),n>>>2,1))}c.__emscripten_thread_mailbox_await=et;var Mt=()=>{var n=Dr();n&&(et(n),he(()=>Po()))};c.checkMailbox=Mt;var Gu=n=>{var s=$n();return n=n(),Wr(s),n};function Oe(n,s){var p=arguments.length-2,g=arguments;return Gu(()=>{for(var v=2*p,T=xn(8*v),M=T>>>3,N=0;N<p;N++){var L=g[2+N];typeof L=="bigint"?(de[M+2*N]=1n,de[M+2*N+1]=L):(de[M+2*N]=0n,h()[M+2*N+1>>>0]=L)}return _o(n,v,T,s)})}var pn=[],Rr=(n,s)=>{var p=Ht[n];if(p===void 0)throw n=Oo(n),p=Fe(n),it(n),new Qe(s+" has unknown type "+p);return p},Fu={},fn=n=>{var s=Fu[n];return s===void 0?Fe(n):s},mn=[],oo=()=>typeof globalThis=="object"?globalThis:Function("return this")(),Lu=n=>{var s=mn.length;return mn.push(n),s},Hu=(n,s)=>{for(var p=Array(n),g=0;g<n;++g)p[g]=Rr(d()[s+4*g>>>2>>>0],"parameter "+g);return p},ao=n=>{if(n===void 0)return"_unknown";n=n.replace(/[^a-zA-Z0-9_]/g,"$");var s=n.charCodeAt(0);return 48<=s&&57>=s?`_${n}`:n};function ju(n,s){return n=ao(n),{[n]:function(){return s.apply(this,arguments)}}[n]}function qu(n){var s=Function;if(!(s instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof s} which is not a function`);var p=ju(s.name||"unknownFunctionName",function(){});return p.prototype=s.prototype,p=new p,n=s.apply(p,n),n instanceof Object?n:p}var Ku=n=>{for(var s="",p=0;p<n;++p)s+=(p!==0?", ":"")+"arg"+p;var g="return function emval_allocator_"+n+`(constructor, argTypes, args) {\n  var HEAPU32 = getMemory();\n`;for(p=0;p<n;++p)g+="var argType"+p+" = requireRegisteredType(HEAPU32[((argTypes)>>>2)], \'parameter "+p+`\');\nvar arg`+p+" = argType"+p+`.readValueFromPointer(args);\nargs += argType`+p+`[\'argPackAdvance\'];\nargTypes += 4;\n`;return new Function("requireRegisteredType","Module","valueToHandle","getMemory",g+("var obj = new constructor("+s+`);\nreturn valueToHandle(obj);\n}\n`))(Rr,c,I,()=>d())},io={},jt=n=>n%4===0&&(n%100!==0||n%400===0),so=[0,31,60,91,121,152,182,213,244,274,305,335],uo=[0,31,59,90,120,151,181,212,243,273,304,334];function lo(n,s,p,g,v,T,M){return P?Oe(16,1,n,s,p,g,v,T,M):-52}function co(n,s,p,g,v,T){if(P)return Oe(17,1,n,s,p,g,v,T)}var po=n=>{var s=$t(n)+1,p=cr(s);return p&&rr(n,p,s),p},hn=[],fo=(n,s)=>{hn.length=0;for(var p;p=o()[n++>>>0];){var g=p!=105;g&=p!=112,s+=g&&s%8?4:0,hn.push(p==112?d()[s>>>2>>>0]:p==106?de[s>>>3]:p==105?i()[s>>>2>>>0]:h()[s>>>3>>>0]),s+=g?8:4}return hn},gn={},mo=()=>{if(!yn){var n={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:S||"./this.program"},s;for(s in gn)gn[s]===void 0?delete n[s]:n[s]=gn[s];var p=[];for(s in n)p.push(`${s}=${n[s]}`);yn=p}return yn},yn;function ho(n,s){if(P)return Oe(18,1,n,s);n>>>=0,s>>>=0;var p=0;return mo().forEach((g,v)=>{var T=s+p;for(v=d()[n+4*v>>>2>>>0]=T,T=0;T<g.length;++T)r()[v++>>>0>>>0]=g.charCodeAt(T);r()[v>>>0>>>0]=0,p+=g.length+1}),0}function go(n,s){if(P)return Oe(19,1,n,s);n>>>=0,s>>>=0;var p=mo();d()[n>>>2>>>0]=p.length;var g=0;return p.forEach(v=>g+=v.length+1),d()[s>>>2>>>0]=g,0}function yo(n){return P?Oe(20,1,n):52}function bo(n,s,p,g){return P?Oe(21,1,n,s,p,g):52}function wo(n,s,p,g){return P?Oe(22,1,n,s,p,g):70}var Yu=[null,[],[]];function vo(n,s,p,g){if(P)return Oe(23,1,n,s,p,g);s>>>=0,p>>>=0,g>>>=0;for(var v=0,T=0;T<p;T++){var M=d()[s>>>2>>>0],N=d()[s+4>>>2>>>0];s+=8;for(var L=0;L<N;L++){var j=o()[M+L>>>0],Q=Yu[n];j===0||j===10?((n===1?Ie:Z)(Nt(Q,0)),Q.length=0):Q.push(j)}v+=N}return d()[g>>>2>>>0]=v,0}var $o=[31,29,31,30,31,30,31,31,30,31,30,31],xo=[31,28,31,30,31,30,31,31,30,31,30,31];function Ju(n){var s=Array($t(n)+1);return Ir(n,s,0,s.length),s}var Xu=(n,s)=>{r().set(n,s>>>0)};function So(n,s,p,g){function v(E,ie,we){for(E=typeof E=="number"?E.toString():E||"";E.length<ie;)E=we[0]+E;return E}function T(E,ie){return v(E,ie,"0")}function M(E,ie){function we(Vo){return 0>Vo?-1:0<Vo?1:0}var kt;return(kt=we(E.getFullYear()-ie.getFullYear()))===0&&(kt=we(E.getMonth()-ie.getMonth()))===0&&(kt=we(E.getDate()-ie.getDate())),kt}function N(E){switch(E.getDay()){case 0:return new Date(E.getFullYear()-1,11,29);case 1:return E;case 2:return new Date(E.getFullYear(),0,3);case 3:return new Date(E.getFullYear(),0,2);case 4:return new Date(E.getFullYear(),0,1);case 5:return new Date(E.getFullYear()-1,11,31);case 6:return new Date(E.getFullYear()-1,11,30)}}function L(E){var ie=E.xb;for(E=new Date(new Date(E.yb+1900,0,1).getTime());0<ie;){var we=E.getMonth(),kt=(jt(E.getFullYear())?$o:xo)[we];if(ie>kt-E.getDate())ie-=kt-E.getDate()+1,E.setDate(1),11>we?E.setMonth(we+1):(E.setMonth(0),E.setFullYear(E.getFullYear()+1));else{E.setDate(E.getDate()+ie);break}}return we=new Date(E.getFullYear()+1,0,4),ie=N(new Date(E.getFullYear(),0,4)),we=N(we),0>=M(ie,E)?0>=M(we,E)?E.getFullYear()+1:E.getFullYear():E.getFullYear()-1}n>>>=0,s>>>=0,p>>>=0,g>>>=0;var j=d()[g+40>>>2>>>0];g={ic:i()[g>>>2>>>0],hc:i()[g+4>>>2>>>0],Db:i()[g+8>>>2>>>0],Jb:i()[g+12>>>2>>>0],Eb:i()[g+16>>>2>>>0],yb:i()[g+20>>>2>>>0],tb:i()[g+24>>>2>>>0],xb:i()[g+28>>>2>>>0],qc:i()[g+32>>>2>>>0],fc:i()[g+36>>>2>>>0],jc:j?Ve(j):""},p=Ve(p),j={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var Q in j)p=p.replace(new RegExp(Q,"g"),j[Q]);var ce="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),fe="January February March April May June July August September October November December".split(" ");j={"%a":E=>ce[E.tb].substring(0,3),"%A":E=>ce[E.tb],"%b":E=>fe[E.Eb].substring(0,3),"%B":E=>fe[E.Eb],"%C":E=>T((E.yb+1900)/100|0,2),"%d":E=>T(E.Jb,2),"%e":E=>v(E.Jb,2," "),"%g":E=>L(E).toString().substring(2),"%G":E=>L(E),"%H":E=>T(E.Db,2),"%I":E=>(E=E.Db,E==0?E=12:12<E&&(E-=12),T(E,2)),"%j":E=>{for(var ie=0,we=0;we<=E.Eb-1;ie+=(jt(E.yb+1900)?$o:xo)[we++]);return T(E.Jb+ie,3)},"%m":E=>T(E.Eb+1,2),"%M":E=>T(E.hc,2),"%n":()=>`\n`,"%p":E=>0<=E.Db&&12>E.Db?"AM":"PM","%S":E=>T(E.ic,2),"%t":()=>"	","%u":E=>E.tb||7,"%U":E=>T(Math.floor((E.xb+7-E.tb)/7),2),"%V":E=>{var ie=Math.floor((E.xb+7-(E.tb+6)%7)/7);if(2>=(E.tb+371-E.xb-2)%7&&ie++,ie)ie==53&&(we=(E.tb+371-E.xb)%7,we==4||we==3&&jt(E.yb)||(ie=1));else{ie=52;var we=(E.tb+7-E.xb-1)%7;(we==4||we==5&&jt(E.yb%400-1))&&ie++}return T(ie,2)},"%w":E=>E.tb,"%W":E=>T(Math.floor((E.xb+7-(E.tb+6)%7)/7),2),"%y":E=>(E.yb+1900).toString().substring(2),"%Y":E=>E.yb+1900,"%z":E=>{E=E.fc;var ie=0<=E;return E=Math.abs(E)/60,(ie?"+":"-")+("0000"+(E/60*100+E%60)).slice(-4)},"%Z":E=>E.jc,"%%":()=>"%"},p=p.replace(/%%/g,"\\0\\0");for(Q in j)p.includes(Q)&&(p=p.replace(new RegExp(Q,"g"),j[Q](g)));return p=p.replace(/\\0\\0/g,"%"),Q=Ju(p),Q.length>s?0:(Xu(Q,n),Q.length-1)}var Mr=n=>{try{n()}catch(s){Xe(s)}};function Zu(){var n=X,s={},p;for(p in n)(function(g){var v=n[g];s[g]=typeof v=="function"?function(){kr.push(g);try{return v.apply(null,arguments)}finally{be||(kr.pop()===g||Xe(),at&&xt===1&&kr.length===0&&(xt=0,Ze+=1,Mr(Bo),typeof Fibers<"u"&&Fibers.rc()))}}:v})(p);return s}var xt=0,at=null,Co=0,kr=[],Ao={},Io={},Qu=0,bn=null,el=[];function tl(){return new Promise((n,s)=>{bn={resolve:n,reject:s}})}function rl(){var n=cr(65548),s=n+12;d()[n>>>2>>>0]=s,d()[n+4>>>2>>>0]=s+65536,s=kr[0];var p=Ao[s];return p===void 0&&(p=Qu++,Ao[s]=p,Io[p]=s),s=p,i()[n+8>>>2>>>0]=s,n}function nl(){var n=i()[at+8>>>2>>>0];return n=X[Io[n]],--Ze,n()}function ol(n){if(!be){if(xt===0){var s=!1,p=!1;n((g=0)=>{if(!be&&(Co=g,s=!0,p)){xt=2,Mr(()=>Do(at)),typeof Browser<"u"&&Browser.Gb.Tb&&Browser.Gb.resume(),g=!1;try{var v=nl()}catch(N){v=N,g=!0}var T=!1;if(!at){var M=bn;M&&(bn=null,(g?M.reject:M.resolve)(v),T=!0)}if(g&&!T)throw v}}),p=!0,s||(xt=1,at=rl(),typeof Browser<"u"&&Browser.Gb.Tb&&Browser.Gb.pause(),Mr(()=>ko(at)))}else xt===2?(xt=0,Mr(Wo),it(at),at=null,el.forEach(g=>he(g))):Xe(`invalid state: ${xt}`);return Co}}function al(n){return ol(s=>{n().then(s)})}le.Fb();for(var To=Array(256),Br=0;256>Br;++Br)To[Br]=String.fromCharCode(Br);ur=To,Qe=c.BindingError=class extends Error{constructor(n){super(n),this.name="BindingError"}},c.InternalError=class extends Error{constructor(n){super(n),this.name="InternalError"}},Object.assign(l.prototype,{get(n){return this.ub[n]},has(n){return this.ub[n]!==void 0},Hb(n){var s=this.Kb.pop()||this.ub.length;return this.ub[s]=n,s},Ib(n){this.ub[n]=void 0,this.Kb.push(n)}}),m.ub.push({value:void 0},{value:null},{value:!0},{value:!1}),m.Ab=m.ub.length,c.count_emval_handles=()=>{for(var n=0,s=m.Ab;s<m.ub.length;++s)m.ub[s]!==void 0&&++n;return n};var il=[Qt,Sr,Rt,tr,Ar,Tr,Or,Er,gt,yt,nr,or,_r,Ft,ar,ir,lo,co,ho,go,yo,bo,wo,vo],sl={ta:function(n,s,p){return al(async()=>{await c.Xb(n,s,p)})},b:function(n,s,p){throw n>>>=0,new ot(n).Fb(s>>>0,p>>>0),je=n,Cr++,je},fa:function(n){Eo(n>>>0,!k,1,!A,131072,!1),le.Pb()},D:function(n){n>>>=0,P?postMessage({cmd:"cleanupThread",thread:n}):((n=le.nb[n])||Xe(),le.Nb(n))},X:er,u:tr,la:Ar,T:Tr,V:Or,M:Er,ja:gt,ca:yt,ia:nr,F:or,U:_r,R:Ft,ka:ar,S:ir,I:function(n,s,p,g,v){n>>>=0,s>>>=0,p>>>=0,s=Fe(s);var T=s.indexOf("u")!=-1;T&&(v=(1n<<64n)-1n),Le(n,{name:s,fromWireType:M=>M,toWireType:function(M,N){if(typeof N!="bigint"&&typeof N!="number")throw new TypeError(`Cannot convert "${sr(N)}" to ${this.name}`);if(N<g||N>v)throw new TypeError(`Passing a number "${sr(N)}" from JS side to C/C++ side to an argument of type "${s}", which is outside the valid range [${g}, ${v}]!`);return N},argPackAdvance:8,readValueFromPointer:lr(s,p,!T),Bb:null})},ra:function(n,s,p,g){n>>>=0,s=Fe(s>>>0),Le(n,{name:s,fromWireType:function(v){return!!v},toWireType:function(v,T){return T?p:g},argPackAdvance:8,readValueFromPointer:function(v){return this.fromWireType(o()[v>>>0])},Bb:null})},qa:function(n,s){n>>>=0,s=Fe(s>>>0),Le(n,{name:s,fromWireType:p=>{var g=w(p);return y(p),g},toWireType:(p,g)=>I(g),argPackAdvance:8,readValueFromPointer:U,Bb:null})},H:function(n,s,p){n>>>=0,p>>>=0,s=Fe(s>>>0),Le(n,{name:s,fromWireType:g=>g,toWireType:(g,v)=>v,argPackAdvance:8,readValueFromPointer:F(s,p),Bb:null})},w:function(n,s,p,g,v){if(n>>>=0,p>>>=0,s=Fe(s>>>0),v===-1&&(v=4294967295),v=N=>N,g===0){var T=32-8*p;v=N=>N<<T>>>T}var M=s.includes("unsigned")?function(N,L){return L>>>0}:function(N,L){return L};Le(n,{name:s,fromWireType:v,toWireType:M,argPackAdvance:8,readValueFromPointer:lr(s,p,g!==0),Bb:null})},p:function(n,s,p){function g(T){var M=d()[T>>>2>>>0];return T=d()[T+4>>>2>>>0],new v(r().buffer,T,M)}n>>>=0;var v=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][s];p=Fe(p>>>0),Le(n,{name:p,fromWireType:g,argPackAdvance:8,readValueFromPointer:g},{Ub:!0})},J:function(n,s){n>>>=0,s=Fe(s>>>0);var p=s==="std::string";Le(n,{name:s,fromWireType:function(g){var v=d()[g>>>2>>>0],T=g+4;if(p)for(var M=T,N=0;N<=v;++N){var L=T+N;if(N==v||o()[L>>>0]==0){if(M=Ve(M,L-M),j===void 0)var j=M;else j+=String.fromCharCode(0),j+=M;M=L+1}}else{for(j=Array(v),N=0;N<v;++N)j[N]=String.fromCharCode(o()[T+N>>>0]);j=j.join("")}return it(g),j},toWireType:function(g,v){v instanceof ArrayBuffer&&(v=new Uint8Array(v));var T=typeof v=="string";if(!(T||v instanceof Uint8Array||v instanceof Uint8ClampedArray||v instanceof Int8Array))throw new Qe("Cannot pass non-string to std::string");var M=p&&T?$t(v):v.length,N=cr(4+M+1),L=N+4;if(d()[N>>>2>>>0]=M,p&&T)rr(v,L,M+1);else if(T)for(T=0;T<M;++T){var j=v.charCodeAt(T);if(255<j)throw it(L),new Qe("String has UTF-16 code units that do not fit in 8 bits");o()[L+T>>>0]=j}else for(T=0;T<M;++T)o()[L+T>>>0]=v[T];return g!==null&&g.push(it,N),N},argPackAdvance:8,readValueFromPointer:re,Bb(g){it(g)}})},B:function(n,s,p){if(n>>>=0,s>>>=0,p>>>=0,p=Fe(p),s===2)var g=ae,v=ne,T=me,M=()=>u(),N=1;else s===4&&(g=ye,v=_,T=se,M=()=>d(),N=2);Le(n,{name:p,fromWireType:L=>{for(var j=d()[L>>>2>>>0],Q=M(),ce,fe=L+4,E=0;E<=j;++E){var ie=L+4+E*s;(E==j||Q[ie>>>N]==0)&&(fe=g(fe,ie-fe),ce===void 0?ce=fe:(ce+=String.fromCharCode(0),ce+=fe),fe=ie+s)}return it(L),ce},toWireType:(L,j)=>{if(typeof j!="string")throw new Qe(`Cannot pass non-string to C++ string type ${p}`);var Q=T(j),ce=cr(4+Q+s);return d()[ce>>>2]=Q>>N,v(j,ce+4,Q+s),L!==null&&L.push(it,ce),ce},argPackAdvance:8,readValueFromPointer:U,Bb(L){it(L)}})},sa:function(n,s){n>>>=0,s=Fe(s>>>0),Le(n,{Vb:!0,name:s,argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})},oa:()=>!0,P:function(n,s){n>>>=0,n==s>>>0?setTimeout(()=>Mt()):P?postMessage({targetThread:n,cmd:"checkMailbox"}):(n=le.nb[n])&&n.postMessage({cmd:"checkMailbox"})},Y:function(n,s,p,g){s>>>=0,p/=2,pn.length=p,g=g>>>0>>>3;for(var v=0;v<p;v++)pn[v]=de[g+2*v]?de[g+2*v+1]:h()[g+2*v+1>>>0];return n=0>n?Ut[-n-1]:il[n],le.Sb=s,s=n.apply(null,pn),le.Sb=0,s},ea:et,na:function(n){O&&le.nb[n>>>0].ref()},v:function(n,s,p){s>>>=0,p>>>=0,n=w(n>>>0),s=Rr(s,"emval::as");var g=[],v=I(g);return d()[p>>>2>>>0]=v,s.toWireType(g,n)},l:function(n,s,p,g,v){p>>>=0,g>>>=0,v>>>=0,n=mn[n>>>0],s=w(s>>>0),p=fn(p);var T=[];return n=n(s,p,T,v),T.length&&(d()[g>>>2>>>0]=I(T)),n},c:y,L:function(n,s){return s>>>=0,n=w(n>>>0),s=w(s),n==s},q:function(n){return n>>>=0,n===0?I(oo()):(n=fn(n),I(oo()[n]))},k:function(n,s){s=Hu(n,s>>>0);var p=s.shift();n--;for(var g=["retType"],v=[p],T="",M=0;M<n;++M)T+=(M!==0?", ":"")+"arg"+M,g.push("argType"+M),v.push(s[M]);M=p.name+"_$"+s.map(j=>j.name).join("_")+"$";var N="return function "+ao("methodCaller_"+M)+`(handle, name, destructors, args) {\n`,L=0;for(M=0;M<n;++M)N+="    var arg"+M+" = argType"+M+".readValueFromPointer(args"+(L?"+"+L:"")+`);\n`,L+=s[M].argPackAdvance;for(N+="    var rv = handle[name]("+T+`);\n`,M=0;M<n;++M)s[M].deleteObject&&(N+="    argType"+M+".deleteObject(arg"+M+`);\n`);return p.Vb||(N+=`    return retType.toWireType(destructors, rv);\n`),g.push(N+`};\n`),n=qu(g).apply(null,v),Lu(n)},t:function(n,s){return s>>>=0,n=w(n>>>0),s=w(s),I(n[s])},h:function(n){n>>>=0,4<n&&(m.get(n).Mb+=1)},r:function(n,s,p,g){p>>>=0,g>>>=0,n=w(n>>>0);var v=io[s];return v||(v=Ku(s),io[s]=v),v(n,p,g)},x:function(){return I([])},m:function(n){n=w(n>>>0);for(var s=Array(n.length),p=0;p<n.length;p++)s[p]=n[p];return I(s)},e:function(n){return I(fn(n>>>0))},j:function(){return I({})},i:function(n){n>>>=0;for(var s=w(n);s.length;){var p=s.pop();s.pop()(p)}y(n)},g:function(n,s,p){s>>>=0,p>>>=0,n=w(n>>>0),s=w(s),p=w(p),n[s]=p},d:function(n,s){return s>>>=0,n=Rr(n>>>0,"_emval_take_value"),n=n.readValueFromPointer(s),I(n)},$:function(n,s){n=-9007199254740992>n||9007199254740992<n?NaN:Number(n),s>>>=0,n=new Date(1e3*n),i()[s>>>2>>>0]=n.getUTCSeconds(),i()[s+4>>>2>>>0]=n.getUTCMinutes(),i()[s+8>>>2>>>0]=n.getUTCHours(),i()[s+12>>>2>>>0]=n.getUTCDate(),i()[s+16>>>2>>>0]=n.getUTCMonth(),i()[s+20>>>2>>>0]=n.getUTCFullYear()-1900,i()[s+24>>>2>>>0]=n.getUTCDay(),n=(n.getTime()-Date.UTC(n.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,i()[s+28>>>2>>>0]=n},aa:function(n,s){n=-9007199254740992>n||9007199254740992<n?NaN:Number(n),s>>>=0,n=new Date(1e3*n),i()[s>>>2>>>0]=n.getSeconds(),i()[s+4>>>2>>>0]=n.getMinutes(),i()[s+8>>>2>>>0]=n.getHours(),i()[s+12>>>2>>>0]=n.getDate(),i()[s+16>>>2>>>0]=n.getMonth(),i()[s+20>>>2>>>0]=n.getFullYear()-1900,i()[s+24>>>2>>>0]=n.getDay();var p=(jt(n.getFullYear())?so:uo)[n.getMonth()]+n.getDate()-1|0;i()[s+28>>>2>>>0]=p,i()[s+36>>>2>>>0]=-(60*n.getTimezoneOffset()),p=new Date(n.getFullYear(),6,1).getTimezoneOffset();var g=new Date(n.getFullYear(),0,1).getTimezoneOffset();n=(p!=g&&n.getTimezoneOffset()==Math.min(g,p))|0,i()[s+32>>>2>>>0]=n},ba:function(n){n>>>=0;var s=new Date(i()[n+20>>>2>>>0]+1900,i()[n+16>>>2>>>0],i()[n+12>>>2>>>0],i()[n+8>>>2>>>0],i()[n+4>>>2>>>0],i()[n>>>2>>>0],0),p=i()[n+32>>>2>>>0],g=s.getTimezoneOffset(),v=new Date(s.getFullYear(),6,1).getTimezoneOffset(),T=new Date(s.getFullYear(),0,1).getTimezoneOffset(),M=Math.min(T,v);return 0>p?i()[n+32>>>2>>>0]=+(v!=T&&M==g):0<p!=(M==g)&&(v=Math.max(T,v),s.setTime(s.getTime()+6e4*((0<p?M:v)-g))),i()[n+24>>>2>>>0]=s.getDay(),p=(jt(s.getFullYear())?so:uo)[s.getMonth()]+s.getDate()-1|0,i()[n+28>>>2>>>0]=p,i()[n>>>2>>>0]=s.getSeconds(),i()[n+4>>>2>>>0]=s.getMinutes(),i()[n+8>>>2>>>0]=s.getHours(),i()[n+12>>>2>>>0]=s.getDate(),i()[n+16>>>2>>>0]=s.getMonth(),i()[n+20>>>2>>>0]=s.getYear(),BigInt(s.getTime()/1e3)},Z:lo,_:co,O:function(n,s,p){function g(j){return(j=j.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?j[1]:"GMT"}n>>>=0,s>>>=0,p>>>=0;var v=new Date().getFullYear(),T=new Date(v,0,1),M=new Date(v,6,1);v=T.getTimezoneOffset();var N=M.getTimezoneOffset(),L=Math.max(v,N);d()[n>>>2>>>0]=60*L,i()[s>>>2>>>0]=+(v!=N),n=g(T),s=g(M),n=po(n),s=po(s),N<v?(d()[p>>>2>>>0]=n,d()[p+4>>>2>>>0]=s):(d()[p>>>2>>>0]=s,d()[p+4>>>2>>>0]=n)},o:()=>{Xe("")},f:function(n,s,p){return n>>>=0,s=fo(s>>>0,p>>>0),Ut[n].apply(null,s)},K:function(n,s,p){return n>>>=0,s=fo(s>>>0,p>>>0),Ut[n].apply(null,s)},E:()=>{},G:()=>Date.now(),ma:()=>{throw Ze+=1,"unwind"},Q:function(){return 4294901760},n:()=>performance.timeOrigin+performance.now(),z:()=>O?(jo(),qt(Ho)).cpus().length:navigator.hardwareConcurrency,N:function(n){n>>>=0;var s=o().length;if(n<=s||4294901760<n)return!1;for(var p=1;4>=p;p*=2){var g=s*(1+.2/p);g=Math.min(g,n+100663296);var v=Math;g=Math.max(n,g);e:{v=(v.min.call(v,4294901760,g+(65536-g%65536)%65536)-ve.buffer.byteLength+65535)/65536;try{ve.grow(v),Ce();var T=1;break e}catch{}T=void 0}if(T)return!0}return!1},ga:ho,ha:go,W:Gt,y:yo,C:bo,da:wo,A:vo,a:ve||c.wasmMemory,pa:So,s:function(n,s,p,g){return So(n>>>0,s>>>0,p>>>0,g>>>0)}},X=function(){var n={a:sl};return nt++,xr(n,function(s){var p=s.module;X=s.instance.exports,X=Zu(),X=ul(),le.Qb.push(X.$a),He.unshift(X.ua),Te=p,Kt()}).catch(b),{}}();c._OrtInit=(n,s)=>(c._OrtInit=X.va)(n,s),c._OrtGetLastError=(n,s)=>(c._OrtGetLastError=X.wa)(n,s),c._OrtCreateSessionOptions=(n,s,p,g,v,T,M,N,L,j)=>(c._OrtCreateSessionOptions=X.xa)(n,s,p,g,v,T,M,N,L,j),c._OrtAppendExecutionProvider=(n,s)=>(c._OrtAppendExecutionProvider=X.ya)(n,s),c._OrtAddFreeDimensionOverride=(n,s,p)=>(c._OrtAddFreeDimensionOverride=X.za)(n,s,p),c._OrtAddSessionConfigEntry=(n,s,p)=>(c._OrtAddSessionConfigEntry=X.Aa)(n,s,p),c._OrtReleaseSessionOptions=n=>(c._OrtReleaseSessionOptions=X.Ba)(n),c._OrtCreateSession=(n,s,p)=>(c._OrtCreateSession=X.Ca)(n,s,p),c._OrtReleaseSession=n=>(c._OrtReleaseSession=X.Da)(n),c._OrtGetInputOutputCount=(n,s,p)=>(c._OrtGetInputOutputCount=X.Ea)(n,s,p),c._OrtGetInputName=(n,s)=>(c._OrtGetInputName=X.Fa)(n,s),c._OrtGetOutputName=(n,s)=>(c._OrtGetOutputName=X.Ga)(n,s),c._OrtFree=n=>(c._OrtFree=X.Ha)(n),c._OrtCreateTensor=(n,s,p,g,v,T)=>(c._OrtCreateTensor=X.Ia)(n,s,p,g,v,T),c._OrtGetTensorData=(n,s,p,g,v)=>(c._OrtGetTensorData=X.Ja)(n,s,p,g,v),c._OrtReleaseTensor=n=>(c._OrtReleaseTensor=X.Ka)(n),c._OrtCreateRunOptions=(n,s,p,g)=>(c._OrtCreateRunOptions=X.La)(n,s,p,g),c._OrtAddRunConfigEntry=(n,s,p)=>(c._OrtAddRunConfigEntry=X.Ma)(n,s,p),c._OrtReleaseRunOptions=n=>(c._OrtReleaseRunOptions=X.Na)(n),c._OrtCreateBinding=n=>(c._OrtCreateBinding=X.Oa)(n),c._OrtBindInput=(n,s,p)=>(c._OrtBindInput=X.Pa)(n,s,p),c._OrtBindOutput=(n,s,p,g)=>(c._OrtBindOutput=X.Qa)(n,s,p,g),c._OrtClearBoundOutputs=n=>(c._OrtClearBoundOutputs=X.Ra)(n),c._OrtReleaseBinding=n=>(c._OrtReleaseBinding=X.Sa)(n),c._OrtRunWithBinding=(n,s,p,g,v)=>(c._OrtRunWithBinding=X.Ta)(n,s,p,g,v),c._OrtRun=(n,s,p,g,v,T,M,N)=>(c._OrtRun=X.Ua)(n,s,p,g,v,T,M,N),c._OrtEndProfiling=n=>(c._OrtEndProfiling=X.Va)(n),c._JsepOutput=(n,s,p)=>(c._JsepOutput=X.Wa)(n,s,p),c._JsepGetNodeName=n=>(c._JsepGetNodeName=X.Xa)(n);var Dr=c._pthread_self=()=>(Dr=c._pthread_self=X.Ya)(),cr=c._malloc=n=>(cr=c._malloc=X.Za)(n),it=c._free=n=>(it=c._free=X._a)(n);c.__emscripten_tls_init=()=>(c.__emscripten_tls_init=X.$a)();var Oo=n=>(Oo=X.ab)(n);c.__embind_initialize_bindings=()=>(c.__embind_initialize_bindings=X.bb)();var Eo=c.__emscripten_thread_init=(n,s,p,g,v,T)=>(Eo=c.__emscripten_thread_init=X.db)(n,s,p,g,v,T);c.__emscripten_thread_crashed=()=>(c.__emscripten_thread_crashed=X.eb)();var _o=(n,s,p,g)=>(_o=X.fb)(n,s,p,g),wn=n=>(wn=X.gb)(n),vn=c.__emscripten_thread_exit=n=>(vn=c.__emscripten_thread_exit=X.hb)(n),Po=c.__emscripten_check_mailbox=()=>(Po=c.__emscripten_check_mailbox=X.ib)(),Ro=(n,s)=>(Ro=X.jb)(n,s),$n=()=>($n=X.kb)(),Wr=n=>(Wr=X.lb)(n),xn=n=>(xn=X.mb)(n),Mo=c.dynCall_ii=(n,s)=>(Mo=c.dynCall_ii=X.ob)(n,s),ko=n=>(ko=X.pb)(n),Bo=()=>(Bo=X.qb)(),Do=n=>(Do=X.rb)(n),Wo=()=>(Wo=X.sb)();c.___start_em_js=1452163,c.___stop_em_js=1452324;function ul(){var n=X;n=Object.assign({},n);var s=g=>()=>g()>>>0,p=g=>v=>g(v)>>>0;return n.__errno_location=s(n.__errno_location),n.Ya=s(n.Ya),n.Za=p(n.Za),n.ab=p(n.ab),n.kb=s(n.kb),n.mb=p(n.mb),n}c.wasmMemory=ve,c.stackAlloc=xn,c.stackSave=$n,c.stackRestore=Wr,c.keepRuntimeAlive=()=>0<Ze,c.UTF8ToString=Ve,c.stringToUTF8=rr,c.lengthBytesUTF8=$t,c.ExitStatus=_t,c.PThread=le;var zr;Ot=function n(){zr||zo(),zr||(Ot=n)};function zo(){0<nt||(P?(C(c),P||ht(He),startWorker(c)):(ht(vt),0<nt||zr||(zr=!0,c.calledRun=!0,be||(P||ht(He),C(c),P||ht(zt)))))}return zo(),t.ready}})();typeof Ko=="object"&&typeof En=="object"?En.exports=qo:typeof define=="function"&&define.amd&&define([],()=>qo)});var Jo=dr((rp,gl)=>{gl.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\\n\'});var Rn,fr,mr,Nr,hr,ra,Mn,We=K(()=>{"use strict";Rn=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},fr=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},mr=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],Nr=e=>{switch(e){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},hr=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},ra=e=>e==="float32"||e==="int32"||e==="int64"||e==="bool"||e==="float16"||e==="uint32",Mn=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var Al,Il,na,oa,aa,Tl,Ee,St=K(()=>{"use strict";We();Al=["V","I","W","E","F"],Il=(e,t)=>{console.log(`[${Al[e]},${new Date().toISOString()}]${t}`)},aa=(e,t)=>{na=e,oa=t},Tl=(e,t)=>{let r=hr(e),o=hr(na);r>=o&&Il(r,typeof t=="function"?t():t)},Ee=(...e)=>{oa&&Tl(...e)}});var ia,sa=K(()=>{"use strict";We();ia=(e,t)=>new(Nr(t))(e)});var ua=K(()=>{"use strict"});var Gr,Ol,la,Bn,kn,ca,da=K(()=>{"use strict";St();ua();Gr=e=>Math.ceil(e/16)*16,Ol=1,la=()=>Ol++,Bn=async(e,t,r,o)=>{let a=Gr(r),u=e.device.createBuffer({size:a,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let i=e.getCommandEncoder();e.endComputePass(),i.copyBufferToBuffer(t,0,u,0,a),e.flush(),await u.mapAsync(GPUMapMode.READ);let d=u.getMappedRange();if(o){let f=o();return f.set(new Uint8Array(d,0,r)),f}else return new Uint8Array(d.slice(0,r))}finally{u.destroy()}},kn=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(t,r){let o=r.buffer,a=r.byteOffset,u=r.byteLength,i=Gr(u),d=this.storageCache.get(t);if(!d)throw new Error("gpu data for uploading does not exist");if(d.originalSize!==u)throw new Error(`inconsistent data size. gpu data size=${d.originalSize}, data size=${u}`);let f=this.backend.device.createBuffer({mappedAtCreation:!0,size:i,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),h=f.getMappedRange();new Uint8Array(h).set(new Uint8Array(o,a,u)),f.unmap();let c=this.backend.getCommandEncoder();this.backend.endComputePass(),c.copyBufferToBuffer(f,0,d.gpuData.buffer,0,i),Ee("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(f)}memcpy(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("source gpu data for memcpy does not exist");let a=this.storageCache.get(r);if(!a)throw new Error("destination gpu data for memcpy does not exist");if(o.originalSize!==a.originalSize)throw new Error("inconsistent source and destination gpu data size");let u=Gr(o.originalSize),i=this.backend.getCommandEncoder();this.backend.endComputePass(),i.copyBufferToBuffer(o.gpuData.buffer,0,a.gpuData.buffer,0,u)}registerExternalBuffer(t,r,o){let a;if(o){if(a=this.externalBuffers.get(o),a===void 0)throw new Error("previous buffer is not registered");if(t===o)return Ee("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${a}, buffer is the same, skip.`),a;this.externalBuffers.delete(o)}else a=la();return this.storageCache.set(a,{gpuData:{id:a,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,a),Ee("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${a}, registered.`),a}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),Ee("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let o=Gr(t),a,u=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,i=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(u||i){let f=u?this.freeBuffers:this.freeUniformBuffers,h=f.get(o);h||(h=[],f.set(o,h)),h.length>0?a=h.pop():a=this.backend.device.createBuffer({size:o,usage:r})}else a=this.backend.device.createBuffer({size:o,usage:r});let d={id:la(),type:0,buffer:a};return this.storageCache.set(d.id,{gpuData:d,originalSize:t}),Ee("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${d.id}`),d}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error("releasing data does not exist");return Ee("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("data does not exist");await Bn(this.backend,o.gpuData.buffer,o.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();this.buffersForUploadingPending=[];for(let t of this.buffersPending)(t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(t.size).push(t):(t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(t.size).push(t):t.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},ca=(...e)=>new kn(...e)});var Dn,ue,Me=K(()=>{"use strict";Dn=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this._cacheKey}},ue=e=>new Dn(e)});var Wn,st,z,Bt,Fr,Lr,Hr,ge=K(()=>{"use strict";Wn=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},st=class{static calcShape(t,r,o=!1){let a=t.length,u=r.length;if(a===0)return r;if(u===0)return t;let i=Math.max(t.length,r.length),d=new Array(i);if(o){if(a<2||u<2)return;let f=Wn.calcMatMulShape([t[a-2],t[a-1]],[r[u-2],r[u-1]]);if(f===void 0)return;[d[i-2],d[i-1]]=f}for(let f=o?3:1;f<=i;f++){let h=a-f<0?1:t[a-f],c=u-f<0?1:r[u-f];if(h!==c&&h>1&&c>1)return;d[i-f]=Math.max(h,c)}return d}static isValidBroadcast(t,r){let o=t.length,a=r.length;if(o>a)return!1;for(let u=1;u<=o;u++)if(t[o-u]!==1&&t[o-u]!==r[a-u])return!1;return!0}},z=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,o){let a=1;for(let u=r;u<o;u++){if(t[u]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");a*=t[u]}return a}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let o=new Array(r);o[r-1]=1,o[r-2]=t[r-1];for(let a=r-3;a>=0;--a)o[a]=o[a+1]*t[a+1];return o}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(o=>this.normalizeAxis(o,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(o=>t[o]):t.slice().reverse()}static padShape(t,r){let o=t.length;return t.map((a,u)=>a+r[u]+r[u+o])}static areEqual(t,r){return t.length!==r.length?!1:t.every((o,a)=>o===r[a])}},Bt=class e{static adjustPoolAttributes(t,r,o,a,u,i){if(!t&&o.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let d=0;d<r.length-2;d++)d>=o.length?o.push(r[d+2]):o[d]=r[d+2];for(let d=0;d<o.length;d++)if(d<a.length){if(a[d]<0)throw new Error("strides should be greater than or equal to 1")}else a.push(1);for(let d=0;d<o.length;d++)if(d<u.length){if(u[d]<0)throw new Error("dilations should be greater than or equal to 1")}else u.push(1);for(let d=0;d<o.length*2;d++)if(d<i.length){if(i[d]<0)throw new Error("pad should be greater than or equal to 1")}else i.push(0);for(let d=0;d<o.length;d++){if(o[d]<=0)throw new Error("kernel shapes need to be greater than 0");if(i[d]>=o[d]||i[d+o.length]>=o[d])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,o,a,u,i,d){if(d){if(u.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(a.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let f=0;f<t.length-2;f++)e.adjustPadAndReturnShape(t[f+(i?1:2)],r[f],o[f],a[f],u,f,f+t.length-2,d)}}static computePoolOutputShape(t,r,o,a,u,i,d){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let f=[r[0],r[1]];return e.computeShapeHelper(t,r,f,o,a,u,i,d),f}static computeConvOutputShape(t,r,o,a,u,i,d){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let f=[t[0],r[0]];return e.computeShapeHelper(!1,t,f,o,a,u,i,d),f}static computeShapeHelper(t,r,o,a,u,i,d,f){if(t)for(let h=0;h<r.length-2;h++)o.push(1);else for(let h=0;h<r.length-2;h++)o.push(e.adjustPadAndReturnShape(r[h+2],a[h],u[h],i[h],d,h,h+r.length-2,f))}static adjustPadAndReturnShape(t,r,o,a,u,i,d,f){let h=o*(a-1)+1;if(f&&f!=="NOTSET")switch(f){case"VALID":return u[i]=0,u[d]=0,Math.floor((t-h)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(o!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let C=((t+r-1)/r-1)*r+a-t;return u[i]=Math.floor(f==="SAME_LOWER"?(C+1)/2:C/2),u[d]=C-u[i],Math.floor((t+C-a)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+u[i]+u[d]-h)/r+1)}},Fr=class{static getShapeOfGemmResult(t,r,o,a,u){if(t.length!==2||o.length!==2)throw new Error("shape need to be of size 2");let i,d,f;r?(i=t[1],d=t[0]):(i=t[0],d=t[1]);let h=-1;if(a?(f=o[0],h=1):(f=o[1],h=0),o[h]!==d)throw new Error("dimension mismatch");if(i<=0||f<=0||d<=0)throw new Error("invalid shape specified");if(u&&!st.isValidBroadcast(u,[i,f]))throw new Error("gemm: invalid bias shape for broadcast");return[i,f,d]}},Lr=-34028234663852886e22,Hr=34028234663852886e22});var El,pa,ke,ut,bt,tt,Dt,Ct,fa,H,Y,zn,ma,Vn,wt,$e=K(()=>{"use strict";We();ge();El=64,pa=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},ke=(e,t=1)=>{let r=pa(e,t);return typeof r=="string"?r:r[0]},ut=e=>e.length===0?[]:[{type:"uint32",data:e},{type:"uint32",data:z.computeStrides(e)}],bt=e=>e%4===0?4:e%2===0?2:1,tt=(e="f32",t,r="0")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,Dt=(e,t,r)=>e==="f32"?r:t===1?`f32(${r})`:`vec${t}f(${r})`,Ct=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,fa=(e,t,r,o,a)=>{let u=typeof r=="number",i=u?r:r.length,d=[...new Array(i).keys()],f=i<2?"u32":i<=4?`vec${i}<u32>`:`array<u32, ${i}>`,h=pa(t,a),c=typeof h=="string"?h:h[1],C=typeof h=="string"?h:h[0],b={indices:f,value:c,storage:C,tensor:t},$=G=>typeof G=="string"?G:`${G}u`,S={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},x=u?"uniforms.":"",A=`${x}${e}_shape`,k=`${x}${e}_strides`,O="";for(let G=0;G<i-1;G++)O+=`\n    let dim${G} = current / ${k}[${G}];\n    let rest${G} = current % ${k}[${G}];\n    indices[${G}] = dim${G};\n    current = rest${G};\n    `;O+=`indices[${i-1}] = current;`;let P=i<2?"":`\n  fn o2i_${e}(offset: u32) -> ${b.indices} {\n    var indices: ${b.indices};\n    var current = offset;\n    ${O}\n    return indices;\n  }`,R=G=>(S.offsetToIndices=!0,i<2?G:`o2i_${e}(${G})`),V=[];if(i>=2)for(let G=i-1;G>=0;G--)V.push(`${k}[${G}] * (indices[${G}])`);let B=i<2?"":`\n  fn i2o_${e}(indices: ${b.indices}) -> u32 {\n    return ${V.join("+")};\n  }`,W=G=>(S.indicesToOffset=!0,i<2?G:`i2o_${e}(${G})`),q=(...G)=>i===0?"0u":`${b.indices}(${G.map($).join(",")})`,ee=(G,pe)=>i<2?`${G}`:`${G}[${pe}]`,oe=(G,pe,de)=>i<2?`${G}=${de};`:`${G}[${pe}]=${de};`,D={},te=(G,pe)=>{S.broadcastedIndicesToOffset=!0;let de=`${pe.name}broadcastedIndicesTo${e}Offset`;if(de in D)return`${de}(${G})`;let Ne=[];for(let Ge=i-1;Ge>=0;Ge--){let Ce=pe.indicesGet("outputIndices",Ge+pe.rank-i);Ne.push(`${ee(k,Ge)} * (${Ce} % ${ee(A,Ge)})`)}return D[de]=`fn ${de}(outputIndices: ${pe.type.indices}) -> u32 {\n             return ${Ne.length>0?Ne.join("+"):"0u"};\n           }`,`${de}(${G})`},Ie=(G,pe)=>(()=>{if(b.storage===b.value)return`${e}[${G}]=${pe};`;if(b.storage==="vec2<u32>"&&b.value==="i32")return`${e}[${G}]=vec2<u32>(u32(${pe}), select(0u, 0xFFFFFFFFu, ${pe} < 0));`;if(b.storage==="vec2<u32>"&&b.value==="u32")return`${e}[${G}]=vec2<u32>(u32(${pe}), 0u);`;if(b.storage==="u32"&&b.value==="vec4<bool>")return`${e}[${G}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${pe}));`;throw new Error(`not supported combination of storage type ${b.storage} and value type ${b.value} yet`)})(),Z=G=>(()=>{if(b.storage===b.value)return`${e}[${G}]`;if(b.storage==="vec2<u32>"&&b.value==="i32")return`i32(${e}[${G}].x)`;if(b.storage==="vec2<u32>"&&b.value==="u32")return`u32(${e}[${G}].x)`;if(b.storage==="u32"&&b.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${G}] & 0xFFu), bool(${e}[${G}] & 0xFF00u), bool(${e}[${G}] & 0xFF0000u), bool(${e}[${G}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${b.storage} and value type ${b.value} yet`)})(),ve=i<2?"":`\n  fn get_${e}ByIndices(indices: ${b.indices}) -> ${c} {\n    return ${Z(`i2o_${e}(indices)`)};\n  }`,Te=i<2?"":(()=>{let G=d.map(de=>`d${de}: u32`).join(", "),pe=d.map(de=>`d${de}`).join(", ");return`\n  fn get_${e}(${G}) -> ${c} {\n    return get_${e}ByIndices(${q(pe)});\n  }`})(),be=(...G)=>{if(G.length!==i)throw new Error(`indices length must be ${i}`);let pe=G.map($).join(",");return i===0?Z("0u"):i===1?Z(pe[0]):(S.get=!0,S.getByIndices=!0,S.indicesToOffset=!0,`get_${e}(${pe})`)},Be=G=>i<2?Z(G):(S.getByIndices=!0,S.indicesToOffset=!0,`get_${e}ByIndices(${G})`),Se=i<2?"":`\n  fn set_${e}ByIndices(indices: ${b.indices}, value: ${c}) {\n    ${Ie(`i2o_${e}(indices)`,"value")}\n  }`,Ue=i<2?"":(()=>{let G=d.map(de=>`d${de}: u32`).join(", "),pe=d.map(de=>`d${de}`).join(", ");return`\n  fn set_${e}(${G}, value: ${c}) {\n    set_${e}ByIndices(${q(pe)}, value);\n  }`})();return{impl:()=>{let G=[];return u||(G.push(`const ${A} = ${b.indices}(${r.join(",")});`),G.push(`const ${k} = ${b.indices}(${z.computeStrides(r).join(",")});`)),S.offsetToIndices&&G.push(P),S.indicesToOffset&&G.push(B),S.broadcastedIndicesToOffset&&Object.values(D).forEach(pe=>G.push(pe)),S.set&&G.push(Ue),S.setByIndices&&G.push(Se),S.get&&G.push(Te),S.getByIndices&&G.push(ve),G.join(`\n`)},type:b,offsetToIndices:R,indicesToOffset:W,broadcastedIndicesToOffset:te,indices:q,indicesGet:ee,indicesSet:oe,set:(...G)=>{if(G.length!==i+1)throw new Error(`indices length must be ${i}`);let pe=G[i];if(typeof pe!="string")throw new Error("value must be string");let de=G.slice(0,i).map($).join(",");return i===0?Ie("0u",pe):i===1?Ie(de[0],pe):(S.set=!0,S.setByIndices=!0,S.indicesToOffset=!0,`set_${e}(${de}, ${pe})`)},setByOffset:Ie,setByIndices:(G,pe)=>i<2?Ie(G,pe):(S.setByIndices=!0,S.indicesToOffset=!0,`set_${e}ByIndices(${G}, ${pe});`),get:be,getByOffset:Z,getByIndices:Be,usage:o?"input":"output",name:e,strides:k,shape:A,rank:i}},H=(e,t,r,o=1)=>fa(e,t,r,!0,o),Y=(e,t,r,o=1)=>fa(e,t,r,!1,o),zn=class{constructor(t){this.normalizedDispatchGroup=t;this.indicesHelpers=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=El){let r=typeof t=="number"?t:t[0],o=typeof t=="number"?1:t[1],a=typeof t=="number"?1:t[2],u=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,i=u?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>`,d=u?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${r*o*a}u + local_index;`;return`@compute @workgroup_size(${r}, ${o}, ${a})\n  fn main(${i}) {\n    ${d}\n  `}declareVariable(t,r){this.indicesHelpers.push(t),t.rank!==0&&(t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:t.type.indices}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:t.type.indices}));let o=t.usage==="input"?"read":"read_write",a=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${o}> ${t.name}: array<${a}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`\n`)}registerUniform(t,r){return this.uniforms.push({name:t,type:r}),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:r,type:o}of this.uniforms)t.push(`${r}:${o}`);return`\n      struct Uniforms { ${t.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.indicesHelpers.map(t=>t.impl()).join(`\n`)}},ma=e=>new zn(e),Vn=(e,t)=>{let r=e.length,o=[];for(let a=0;a<r;a++){let u=r-1-a,i=e[u]||1;(t[t.length-1-a]||1)>1&&i===1&&o.unshift(u)}return o},wt=e=>e<=4});var _l,ha,Pl,Rl,At,ga,ya,gr=K(()=>{"use strict";ge();Me();$e();_l=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},ha=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,Pl=(e,t)=>z.sortBasedOnPerm(e,ha(e.length,t)),Rl=(e,t,r,o)=>{let a=[];a.push(`fn perm(i: ${o.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let u=0;u<t;++u)a.push(r.indicesSet("a",e[u],`i[${u}]`));return a.push("return a;}"),a.join(`\n`)},At=(e,t)=>{let r=e.dataType,o=e.dims.length,a=ha(o,t),u=wt(o),i=Pl(e.dims,a),d=u?i.length:i,f=u?o:e.dims,h=Y("output",r,d),c=H("a",r,f),C=b=>`\n  ${b.registerUniform("output_size","u32").declareVariables(c,h)}\n\n  ${Rl(a,o,c,h)}\n\n  ${b.mainStart()}\n    ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${h.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${h.setByOffset("global_idx",c.getByIndices("aIndices"))}\n  }`;return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:u?["rank"]:["dims"]},getRunData:b=>{let $=z.size(i);return{outputs:[{dims:i,dataType:b[0].dataType}],dispatchGroup:{x:Math.ceil($/64)},programUniforms:u?[{type:"uint32",data:$},...ut(b[0].dims),...ut(i)]:[{type:"uint32",data:$}]}},getShaderSource:C}},ga=(e,t)=>{_l(e.inputs),e.compute(At(e.inputs[0],t.perm))},ya=e=>ue({perm:e.perm})});var Ml,kl,Bl,Dl,Wl,zl,Vl,Ul,Nl,Gl,lt,ba,wa,va,$a,xa,Sa,Ca,Aa,Ia,Ta,Oa=K(()=>{"use strict";ge();$e();jr();gr();Ml={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},kl={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Bl={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Dl={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Wl=(e,t)=>{let r=[];for(let o=t-e;o<t;++o)r.push(o);return r},zl=(e,t)=>{let r=[],o=e.length;for(let u=0;u<o;u++)t.indexOf(u)===-1&&r.push(e[u]);let a=t.map(u=>e[u]);return[r,a]},Vl=(e,t)=>{let r=e.length+t.length,o=[],a=0;for(let u=0;u<r;u++)t.indexOf(u)===-1?o.push(e[a++]):o.push(1);return o},Ul=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},Nl=(e,t)=>{let r=[];if(!Ul(e,t)){for(let o=0;o<t;++o)e.indexOf(o)===-1&&r.push(o);e.forEach(o=>r.push(o))}return r},Gl=(e,t,r,o,a,u,i)=>{let d=r[0].dims,f=z.size(u),h=z.size(i),c=H("_A",r[0].dataType,d),C=Y("output",a,u),b=32,$=`\n          var<workgroup> aBestValues : array<${C.type.storage}, ${b}>;\n       `;return{name:e,shaderCache:t,getShaderSource:x=>`\n        ${x.registerUniform("reduceSize","u32").declareVariables(c,C)}\n        ${$}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${x.mainStart(b)}\n          let local_idx = local_id.x;\n\n          let outputIndex = global_idx / ${b};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = ${C.type.storage}(${Bl[o]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${b}) {\n           let candidate = ${C.type.storage}(${c.getByOffset("offset + k")});\n           bestValue = ${Ml[o]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${b}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${kl[o]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${C.setByOffset("outputIndex",`${o==="mean"?`bestValue / ${C.type.storage}(uniforms.reduceSize)`:`${Dl[o]}`}`)};\n         }\n        }`,getRunData:()=>({outputs:[{dims:u,dataType:a}],dispatchGroup:{x:f},programUniforms:[{type:"uint32",data:h}]})}},lt=(e,t,r,o)=>{let a=e.inputs.length===1?r:Un(e.inputs,r),u=a.axes;u.length===0&&!a.noopWithEmptyAxes&&(u=e.inputs[0].dims.map(($,S)=>S));let i=z.normalizeAxes(u,e.inputs[0].dims.length),d=i,f=e.inputs[0],h=Nl(d,e.inputs[0].dims.length);h.length>0&&(f=e.compute(At(e.inputs[0],h),{inputs:[0],outputs:[-1]})[0],d=Wl(d.length,f.dims.length));let[c,C]=zl(f.dims,d),b=c;a.keepDims&&(b=Vl(c,i)),e.compute(Gl(t,{hint:a.cacheKey,inputDependencies:["type"]},[f],o,e.inputs[0].dataType,b,C),{inputs:[f]})},ba=(e,t)=>{lt(e,"ReduceMeanShared",t,"mean")},wa=(e,t)=>{lt(e,"ReduceL1Shared",t,"l1")},va=(e,t)=>{lt(e,"ReduceL2Shared",t,"l2")},$a=(e,t)=>{lt(e,"ReduceLogSumExpShared",t,"logSumExp")},xa=(e,t)=>{lt(e,"ReduceMaxShared",t,"max")},Sa=(e,t)=>{lt(e,"ReduceMinShared",t,"min")},Ca=(e,t)=>{lt(e,"ReduceProdShared",t,"prod")},Aa=(e,t)=>{lt(e,"ReduceSumShared",t,"sum")},Ia=(e,t)=>{lt(e,"ReduceSumSquareShared",t,"sumSquare")},Ta=(e,t)=>{lt(e,"ReduceLogSumShared",t,"logSum")}});var ct,Fl,qr,Un,dt,Ll,Hl,jl,ql,Kl,Yl,Jl,Xl,Zl,Ql,pt,Ea,_a,Pa,Ra,Ma,ka,Ba,Da,Wa,za,rt,jr=K(()=>{"use strict";ge();Me();$e();Oa();ct=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Fl=e=>["","",`var value = ${e.getByOffset("inputOffset")};`,""],qr=(e,t,r,o,a,u,i=!1,d=!1)=>{let f=[],h=r[0].dims,c=z.normalizeAxes(a,r[0].dims.length),C=!d&&c.length===0;h.forEach((W,q)=>{C||c.indexOf(q)>=0?i&&f.push(1):f.push(W)});let b=[],$=H("_A",r[0].dataType,h),S=Y("output",u,f),x=o($,S,c),A=`inputOffset = ${$.indicesToOffset("inputIndices")};`,k=`let ${A};`,O=`var ${A};`,P=x[1]===""?"":O,R=(x[1]===""?k:A)+`\n`+x[2];for(let W=0,q=0;W<r[0].dims.length;W++)C||c.indexOf(W)>=0?(i&&q++,R=`for(var j${W}: u32 = 0; j${W} < ${r[0].dims[W]}; j${W}++) {\n                ${x[2].includes("lastIndex")?`let lastIndex = j${W};`:""}\n                ${$.indicesSet("inputIndices",W,`j${W}`)}\n                ${R}\n              }`):(b.push(`${$.indicesSet("inputIndices",W,S.indicesGet("outputIndices",q))};`),q++);let V=z.size(f);return{name:e,shaderCache:t,getShaderSource:W=>`\n        ${W.declareVariables($,S)}\n\n        ${W.mainStart()}\n          ${W.guardAgainstOutOfBoundsWorkgroupSizes(V)}\n          var inputIndices: ${$.type.indices};\n          let outputIndices = ${S.offsetToIndices("global_idx")};\n\n          ${b.join(`\n`)}\n          ${x[0]}       // init ops for reduce max/min\n          ${P}\n          ${x[1]}\n          ${R}\n          ${x[3]}\n          ${x.length===4?S.setByOffset("global_idx","value"):x.slice(4).join(`\n`)}\n        }`,getRunData:()=>({outputs:[{dims:f,dataType:u}],dispatchGroup:{x:Math.ceil(V/64)}})}},Un=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(o=>r.push(Number(o))),ue({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},dt=(e,t,r,o)=>{let a=e.inputs,u=a.length===1?r:Un(a,r);e.compute(qr(t,{hint:u.cacheKey},[a[0]],u.noopWithEmptyAxes&&u.axes.length===0?Fl:o,u.axes,a[0].dataType,u.keepDims,u.noopWithEmptyAxes),{inputs:[0]})},Ll=(e,t)=>{ct(e.inputs),dt(e,"ReduceLogSum",t,(o,a)=>[`var value = ${a.type.storage}(0);`,"",`value += ${o.getByOffset("inputOffset")};`,"value = log(value);"])},Hl=(e,t)=>{ct(e.inputs),dt(e,"ReduceL1",t,(o,a)=>[`var value = ${a.type.storage}(0);`,"",`value += abs(${o.getByOffset("inputOffset")});`,""])},jl=(e,t)=>{ct(e.inputs),dt(e,"ReduceL2",t,(o,a)=>[`var t = ${a.type.value}(0); var value = ${a.type.value}(0);`,"",`t = ${o.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])},ql=(e,t)=>{ct(e.inputs),dt(e,"ReduceLogSumExp",t,(o,a)=>[`var value = ${a.type.storage}(0);`,"",`value += exp(${o.getByOffset("inputOffset")});`,"value = log(value);"])},Kl=(e,t)=>{ct(e.inputs),dt(e,"ReduceMax",t,(o,a,u)=>{let i=[];for(let d=0;d<o.rank;d++)(u.indexOf(d)>=0||u.length===0)&&i.push(o.indicesSet("inputIndices",d,0));return[`${i.join(`\n`)}`,`var value = ${o.getByOffset("inputOffset")};`,`value = max(value, ${o.getByOffset("inputOffset")});`,""]})},Yl=(e,t)=>{ct(e.inputs),dt(e,"ReduceMean",t,(o,a,u)=>{let i=1;for(let d=0;d<o.rank;d++)(u.indexOf(d)>=0||u.length===0)&&(i*=e.inputs[0].dims[d]);return["var sum = f32(0);","",`sum += f32(${o.getByOffset("inputOffset")});`,`let value = ${a.type.value}(sum / ${i});`]})},Jl=(e,t)=>{ct(e.inputs),dt(e,"ReduceMin",t,(o,a,u)=>{let i=[];for(let d=0;d<o.rank;d++)(u.indexOf(d)>=0||u.length===0)&&i.push(`inputIndices[${d}] = 0;`);return[`${i.join(`\n`)}`,`var value = ${o.getByOffset("inputOffset")};`,`value = min(value, ${o.getByOffset("inputOffset")});`,""]})},Xl=(e,t)=>{ct(e.inputs),dt(e,"ReduceProd",t,(o,a)=>[`var value = ${a.type.storage}(1);`,"",`value *= ${o.getByOffset("inputOffset")};`,""])},Zl=(e,t)=>{ct(e.inputs),dt(e,"ReduceSum",t,(o,a)=>[`var value = ${a.type.storage}(0);`,"",`value += ${o.getByOffset("inputOffset")};`,""])},Ql=(e,t)=>{ct(e.inputs),dt(e,"ReduceSumSquare",t,(o,a)=>[`var t = ${a.type.value}(0); var value = ${a.type.value}(0);`,"",`t = ${o.getByOffset("inputOffset")}; value += t * t;`,""])},pt=(e,t,r)=>{if(t.length===0)return!!r;let o=1,a=1;for(let u=0;u<t.length;u++)t.indexOf(u)===-1?o*=e[u]:a*=e[u];return a<32&&o>1024},Ea=(e,t)=>{pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Yl(e,t):ba(e,t)},_a=(e,t)=>{pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Hl(e,t):wa(e,t)},Pa=(e,t)=>{pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?jl(e,t):va(e,t)},Ra=(e,t)=>{pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ql(e,t):$a(e,t)},Ma=(e,t)=>{pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Kl(e,t):xa(e,t)},ka=(e,t)=>{pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Jl(e,t):Sa(e,t)},Ba=(e,t)=>{pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Xl(e,t):Ca(e,t)},Da=(e,t)=>{pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Zl(e,t):Aa(e,t)},Wa=(e,t)=>{pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Ql(e,t):Ia(e,t)},za=(e,t)=>{pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Ll(e,t):Ta(e,t)},rt=e=>ue(e)});var Va,Ua,Na,Ga,Nn,Fa=K(()=>{"use strict";We();Me();jr();Va=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},Ua=(e,t)=>ue({axis:t.axis,keepDims:t.keepDims,selectLastIndex:t.selectLastIndex}),Na=(e,t)=>{Va(e.inputs);let r=(a,u,i)=>{let d=[];for(let f=0;f<a.rank;f++)(i.indexOf(f)>=0||i.length===0)&&d.push(`inputIndices[${f}] = 0;`);return[`${d.join(`\n`)}`,`var value = ${a.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${a.getByOffset("inputOffset")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${a.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",u.setByOffset("global_idx","bestIndex")]},o=e.inputs.length===1?t:Ua(e.inputs,t);e.compute(qr("ArgMin",{hint:o.cacheKey},[e.inputs[0]],r,[o.axis],7,o.keepDims),{inputs:[0]})},Ga=(e,t)=>{Va(e.inputs);let r=(a,u,i)=>{let d=[];for(let f=0;f<a.rank;f++)(i.indexOf(f)>=0||i.length===0)&&d.push(`inputIndices[${f}] = 0;`);return[`${d.join(`\n`)}`,`var value = ${a.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${a.getByOffset("inputOffset")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${a.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",u.setByOffset("global_idx","bestIndex")]},o=e.inputs.length===1?t:Ua(e.inputs,t);e.compute(qr("argMax",{hint:o.cacheKey},[e.inputs[0]],r,[o.axis],7,o.keepDims),{inputs:[0]})},Nn=e=>ue(e)});var ec,tc,La,Ha=K(()=>{"use strict";ge();$e();ec=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},tc=e=>{let t=e[0].dims,r=e[0].dims[2],o=z.size(t)/4,a=e[0].dataType,u=H("input",a,t,4),i=H("bias",a,[r],4),d=H("residual",a,t,4),f=Y("output",a,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:c=>`\n  const channels = ${r}u / 4;\n  ${c.declareVariables(u,i,d,f)}\n\n  ${c.mainStart()}\n    ${c.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n    let value = ${u.getByOffset("global_idx")}\n      + ${i.getByOffset("global_idx % channels")} + ${d.getByOffset("global_idx")};\n    ${f.setByOffset("global_idx","value")}\n  }`}},La=e=>{ec(e.inputs),e.compute(tc(e.inputs))}});var rc,xe,ja,qa,Ka,Ya,Ja,Xa,Za,Qa,ei,Gn,nc,ti,ri,ni,oi,Kr,ai,Yr,ii,si,ui,li,ci,di,pi,fi,mi,hi,gi,yi,bi,wi,vi,$i,xi,Fn=K(()=>{"use strict";We();ge();Me();$e();rc=(e,t,r,o,a,u)=>{let i=Math.ceil(t/4),d="";typeof a=="string"?d=`${a}(a)`:d=a("a");let f=H("inputData",r,[i],4),h=Y("outputData",o,[i],4);return`\n      ${e.registerUniform("vec_size","u32").declareVariables(f,h)}\n\n  ${u??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n\n    let a = ${f.getByOffset("global_idx")};\n    ${h.setByOffset("global_idx",d)}\n  }`},xe=(e,t,r,o,a,u=e.dataType)=>({name:t,shaderCache:{hint:a,inputDependencies:["type"]},getShaderSource:i=>rc(i,z.size(e.dims),e.dataType,u,r,o),getRunData:i=>({outputs:[{dims:e.dims,dataType:u}],dispatchGroup:{x:Math.ceil(z.size(i[0].dims)/64/4)},programUniforms:[{type:"uint32",data:Math.ceil(z.size(e.dims)/4)}]})}),ja=e=>{e.compute(xe(e.inputs[0],"Abs","abs"))},qa=e=>{e.compute(xe(e.inputs[0],"Acos","acos"))},Ka=e=>{e.compute(xe(e.inputs[0],"Acosh","acosh"))},Ya=e=>{e.compute(xe(e.inputs[0],"Asin","asin"))},Ja=e=>{e.compute(xe(e.inputs[0],"Asinh","asinh"))},Xa=e=>{e.compute(xe(e.inputs[0],"Atan","atan"))},Za=e=>{e.compute(xe(e.inputs[0],"Atanh","atanh"))},Qa=e=>ue(e),ei=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${t.to}`)}e.compute(xe(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},Gn=(e,t)=>{let r=ke(e.inputs[0].dataType);e.compute(xe(e.inputs[0],"Clip",o=>`clamp(${o}, clip_min_, clip_max_)`,`\n    const clip_min_: vec4<${r}> = vec4(${r}(${t.min}));\n    const clip_max_: vec4<${r}> = vec4(${r}(${t.max}));\n`,t.cacheKey),{inputs:[0]})},nc=e=>{let t=e.length>=2?e[1].getFloat32Array()[0]:Lr,r=e.length>=3?e[2].getFloat32Array()[0]:Hr;return ue({min:t,max:r})},ti=e=>{let t=nc(e.inputs);Gn(e,t)},ri=e=>{e.compute(xe(e.inputs[0],"Ceil","ceil"))},ni=e=>{e.compute(xe(e.inputs[0],"Cos","cos"))},oi=e=>{e.compute(xe(e.inputs[0],"Cosh","cosh"))},Kr=e=>ue(e),ai=(e,t)=>{e.compute(xe(e.inputs[0],"Elu",r=>`elu_vf32(${r})`,`\n  const elu_alpha_: f32 = f32(${t.alpha});\n\n  fn elu_f32(a: f32) -> f32 {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},Yr=(e,t="f32")=>`\nconst r0: ${t} = 0.3275911;\nconst r1: ${t} = 0.254829592;\nconst r2: ${t} = -0.284496736;\nconst r3: ${t} = 1.421413741;\nconst r4: ${t} = -1.453152027;\nconst r5: ${t} = 1.061405429;\n\nfn erf_vf32(v: ${e}) -> ${e} {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,ii=e=>{let t=ke(e.inputs[0].dataType);e.compute(xe(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,Yr(`vec4<${t}>`,t)))},si=e=>{e.compute(xe(e.inputs[0],"Exp","exp"))},ui=e=>{e.compute(xe(e.inputs[0],"Floor","floor"))},li=e=>{let t=ke(e.inputs[0].dataType);e.compute(xe(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,Yr(`vec4<${t}>`,t)))},ci=(e,t)=>{e.compute(xe(e.inputs[0],"LeakyRelu",r=>`select(leaky_relu_alpha_ * ${r}, ${r}, ${r} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${t.alpha});`,t.cacheKey))},di=e=>{e.compute(xe(e.inputs[0],"Not",t=>`!${t}`))},pi=e=>{e.compute(xe(e.inputs[0],"Neg",t=>`-${t}`))},fi=e=>{e.compute(xe(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},mi=e=>{e.compute(xe(e.inputs[0],"Relu",t=>`select(vec4<f32>(0.0), ${t}, ${t} > vec4<f32>(0.0))`))},hi=e=>{e.compute(xe(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},gi=e=>{e.compute(xe(e.inputs[0],"Sin","sin"))},yi=e=>{e.compute(xe(e.inputs[0],"Sinh","sinh"))},bi=e=>{e.compute(xe(e.inputs[0],"Sqrt","sqrt"))},wi=e=>{e.compute(xe(e.inputs[0],"Tan","tan"))},vi=e=>{e.compute(xe(e.inputs[0],"Tanh","tanh"))},$i=(e,t)=>(e.compute(xe(e.inputs[0],"ThresholdedRelu",r=>`select(vec4<f32>(0.0), ${r}, ${r} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${t.alpha});`,t.cacheKey)),0),xi=e=>{e.compute(xe(e.inputs[0],"Log","log"))}});var ac,ic,Si,Ci=K(()=>{"use strict";ge();$e();Fn();ac=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},ic=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=H("input",e[0].dataType,e[0].dims,4),o=H("bias",e[0].dataType,[e[0].dims[2]],4),a=Y("output",e[0].dataType,t,4),u=z.size(t)/4;return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:d=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${d.declareVariables(r,o,a)}\n\n  ${Yr("vec4f")}\n\n  ${d.mainStart()}\n    ${d.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${a.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},Si=e=>{ac(e.inputs),e.compute(ic(e.inputs))}});var sc,uc,ft,Ai,Ii,Ti,Oi,Ei,_i,Pi,Ri,Mi,ki,Bi=K(()=>{"use strict";We();ge();$e();sc=(e,t,r,o,a,u,i,d,f,h,c,C)=>{let b,$;typeof i=="string"?b=$=(V,B)=>`${i}((${V}),(${B}))`:typeof i=="function"?b=$=i:(b=i.scalar,$=i.vector);let S=c?t.length:t,x=c?r.length:r,A=c?o.length:o,k=Y("outputData",h,A,4),O=H("aData",d,S,4),P=H("bData",f,x,4),R;if(a)if(u){let V=z.size(t)===1,B=z.size(r)===1;V||B?R=k.setByOffset("global_idx",$(V?`${O.type.value}(${O.getByOffset("0")}.x)`:O.getByOffset("global_idx"),B?`${P.type.value}(${P.getByOffset("0")}.x)`:P.getByOffset("global_idx"))):R=`\n            let outputIndices = ${k.offsetToIndices("global_idx * 4u")};\n            let offsetA = ${O.broadcastedIndicesToOffset("outputIndices",k)};\n            let offsetB = ${P.broadcastedIndicesToOffset("outputIndices",k)};\n            ${k.setByOffset("global_idx",$(O.getByOffset("offsetA / 4u"),P.getByOffset("offsetB / 4u")))}\n          `}else R=k.setByOffset("global_idx",$(O.getByOffset("global_idx"),P.getByOffset("global_idx")));else{if(!u)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let V=(B,W,q="")=>{let ee=`aData[indexA${W}][componentA${W}]`,oe=`bData[indexB${W}][componentB${W}]`;return`\n            let outputIndices${W} = ${k.offsetToIndices(`global_idx * 4u + ${W}u`)};\n            let offsetA${W} = ${O.broadcastedIndicesToOffset(`outputIndices${W}`,k)};\n            let offsetB${W} = ${P.broadcastedIndicesToOffset(`outputIndices${W}`,k)};\n            let indexA${W} = offsetA${W} / 4u;\n            let indexB${W} = offsetB${W} / 4u;\n            let componentA${W} = offsetA${W} % 4u;\n            let componentB${W} = offsetB${W} % 4u;\n            ${B}[${W}] = ${q}(${b(ee,oe)});\n          `};h===9?R=`\n            var data = vec4<u32>(0);\n            ${V("data",0,"u32")}\n            ${V("data",1,"u32")}\n            ${V("data",2,"u32")}\n            ${V("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:R=`\n            ${V("outputData[global_idx]",0)}\n            ${V("outputData[global_idx]",1)}\n            ${V("outputData[global_idx]",2)}\n            ${V("outputData[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(O,P,k)}\n\n        ${C??""}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${R}\n      }`},uc=(e,t,r,o,a,u,i=r.dataType)=>{let d=!z.areEqual(r.dims,o.dims),f=r.dims,h=z.size(r.dims),c=!1,C=[d];if(d){let $=st.calcShape(r.dims,o.dims,!1);if(!$)throw new Error("Can\'t perform binary op on the given tensors");f=$,h=z.size(f);let S=z.size(r.dims)===1,x=z.size(o.dims)===1;C.push(S),C.push(x);let A=1;for(let k=1;k<f.length;k++){let O=r.dims[r.dims.length-k]??1,P=o.dims[o.dims.length-k]??1;if(O===P)A*=O;else break}(A%4===0||S||x)&&(c=!0)}else c=!0;C.push(c);let b=wt(r.dims.length)&&wt(o.dims.length)&&wt(f.length);return{name:e,shaderCache:{hint:t+C.map($=>$.toString()).join("_"),inputDependencies:b?["rank","rank"]:["dims","dims"]},getShaderSource:$=>sc($,r.dims,o.dims,f,c,d,a,r.dataType,o.dataType,i,b,u),getRunData:()=>({outputs:[{dims:f,dataType:i}],dispatchGroup:{x:Math.ceil(h/64/4)},programUniforms:b?[{type:"uint32",data:Math.ceil(z.size(f)/4)},...ut(r.dims),...ut(o.dims),...ut(f)]:[{type:"uint32",data:Math.ceil(z.size(f)/4)}]})}},ft=(e,t,r,o,a,u)=>{e.compute(uc(t,a??"",e.inputs[0],e.inputs[1],r,o,u))},Ai=e=>{ft(e,"Add",(t,r)=>`${t}+${r}`)},Ii=e=>{ft(e,"Div",(t,r)=>`${t}/${r}`)},Ti=e=>{ft(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Oi=e=>{ft(e,"Mul",(t,r)=>`${t}*${r}`)},Ei=e=>{let t=H("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;ft(e,"Pow",{scalar:(o,a)=>`pow_custom(${o},${a})`,vector:(o,a)=>`pow_vector_custom(${o},${a})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},_i=e=>{ft(e,"Sub",(t,r)=>`${t}-${r}`)},Pi=e=>{ft(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},Ri=e=>{ft(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},Mi=e=>{ft(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},ki=e=>{ft(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var cc,dc,pc,fc,Di,Wi,zi=K(()=>{"use strict";ge();Me();$e();cc=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].dataType,r=e[0].dims.length;for(let o of e){if(o.dataType!==t)throw new Error("input tensors should be one type");if(o.dims.length!==r)throw new Error("input tensors should have the same shape")}},dc=(e,t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,pc=(e,t)=>{let r=e.length,o=[];for(let a=0;a<r;++a){let u=t.setByOffset("global_idx",e[a].getByIndices("indices"));r===1?o.push(u):a===0?o.push(`if (inputIndex == ${a}u) { ${u} }`):a===r-1?o.push(`else { ${u} }`):o.push(`else if (inputIndex == ${a}) { ${u} }`)}return o.join(`\n`)},fc=(e,t)=>{let r=e[0].dims.slice();if(t>=r.length||t<-1*r.length)throw new Error("axis specified for concat doesn\'t match input dimensionality");let o=t<0?r.length+t:t,a=r.slice(0);for(let R=1;R<e.length;R++){let V=e[R].dims.slice();for(let B=0;B<r.length;B++)if(B===o)a[o]+=V[B];else if(r[B]!==V[B])throw new Error("non concat dimensions must match")}let u=z.size(a),i=new Array(e.length),d=new Array(e.length),f=e[0].dataType,h=0,c=[],C=[],b=[],$=[{type:"uint32",data:u}];for(let R=0;R<e.length;++R)h+=e[R].dims[o],i[R]=h,b.push(wt(e[R].dims.length)),C.push(b[R]?e[R].dims.length:e[R].dims),d[R]=H(`input${R}`,f,C[R]),c.push(b[R]?"rank":"dims"),$.push({type:"uint32",data:i[R]});for(let R=0;R<e.length;++R)b[R]&&$.push(...ut(e[R].dims));let S=wt(a.length);S&&$.push(...ut(a));let x=S?a.length:a,A=Y("output",f,x),k=A.indicesGet("indices",o),O=Array.from(Array(i.length).keys()).map(R=>`uniforms.sizeInConcatAxis${R}`).join(","),P=R=>`\n\n  ${(()=>{R.registerUniform("outputSize","u32");for(let V=0;V<e.length;V++)R.registerUniform(`sizeInConcatAxis${V}`,"u32");return R.declareVariables(...d,A)})()}\n\n  ${dc(i.length,O)}\n\n  ${R.mainStart()}\n    ${R.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n    var indices = ${A.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${k});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${i.length}u>(${O});\n      ${k} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${pc(d,A)}\n  }`;return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:c},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:$}),getShaderSource:P}},Di=(e,t)=>{cc(e.inputs),e.compute(fc(e.inputs,t.axis))},Wi=e=>ue({axis:e.axis})});var It,Jr,Wt=K(()=>{"use strict";ge();It=(e,t)=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:`value = max(value, ${t}(0.0));`};case"Sigmoid":return{activationFunction:"",applyActivation:`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`};case"Clip":return{activationFunction:`const clip_min_=${t}(${e.clipMin});const clip_max_=${t}(${e.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},Jr=e=>{let t=e?.activation||"";if(t==="Clip"){let[r,o]=e?.activation_params||[Lr,Hr];return{activation:t,clipMax:o,clipMin:r,activationCacheKey:`${t}:${r},${o}`}}return{activation:t,activationCacheKey:t}}});var ze,Xr,Zr=K(()=>{"use strict";ze=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Xr=e=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      `});var Qr,Ln=K(()=>{"use strict";Qr=`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));\n}\n`});var mc,hc,yr,Vi,gc,br,yc,en,wr=K(()=>{"use strict";ge();$e();Wt();Zr();mc=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,hc=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,yr=(e,t,r="f32",o,a=!1,u=32,i=!1,d=32)=>{let f=t[1]*e[1],h=t[0]*e[0],c=a?f:u,C=a?u:f,b=c/t[0],$=u/t[1];if(!((a&&b===4&&e[1]===4||!a&&(b===3||b===4))&&c%t[0]===0&&u%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${a} is true, innerElementSize ${b} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${b} must be 3 or 4.\n  tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}. tileInner ${u} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${b}<${r}>, ${c/b}>, ${C}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${r}>, ${h/e[0]}>, ${u}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${b};\nconst tileInner = ${u};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${i?"0":"i32(globalId.z)"};\n  ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${f};\n\n  let numTiles = ${i?`${Math.ceil(d/u)}`:"(dimInner - 1) / tileInner + 1"};\n  var kStart = ${i?`i32(globalId.z) * ${d}`:"0"};\n\n  var acc: array<vec4<${r}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${$};\n  for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${mc(a,o)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${$}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${o?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${b===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${hc(a,b)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},Vi=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,gc=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",br=(e,t,r="f32",o,a=!1,u=32,i=!1,d=32,f=!1)=>{let h=e[1]*t[1],c=e[0]*t[0],C=a?h:u,b=a?u:h;if(!(b%t[1]===0&&C%t[0]===0&&u%t[1]===0))throw new Error(`tileAHight ${b} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${C} must be divisible by workgroupSize[0]${t[0]}, tileInner ${u} must be divisible by workgroupSize[1]${t[1]}`);let $=b/t[1],S=C/t[0],x=u/t[1],A=f?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${h};\n    let globalColStart = i32(workgroupId.x) * ${c};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${b}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${C}; inputCol = inputCol + ${t[0]}) {\n          ${Vi(a,o)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${u}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${o?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${r}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${a?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${h};\n\nlet tileRowA = i32(localId.y) * ${$};\nlet tileColA = i32(localId.x) * ${S};\nlet tileRowB = i32(localId.y) * ${x};\n// Loop over shared dimension.\nfor (var t = 0; t < numTiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${$}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${S}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Vi(a,o)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${x}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${o?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${r}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${gc(a)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${r}, ${C}>, ${b}>;\n  var<workgroup> mm_Bsub : array<array<${r}, ${c}>, ${u}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${u};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${i?"0":"i32(globalId.z)"};\n    ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n    let numTiles = ${i?`${Math.ceil(d/u)}`:"(dimInner - 1) / tileInner + 1"};\n    var kStart = ${i?`i32(globalId.z) * ${d}`:"0"};\n\n    var acc : array<array<${r}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${A}\n  }\n`},yc=(e,t,r,o,a,u=!1)=>{let i=a[0],d=a[1],f=a[2],h=o[0],c=o[1],C=o[2],b=o[3],$=Vn(i,f),S=Vn(d,f),x=ke(o[0].type.tensor),A=()=>{let P=c.rank,R=h.rank,V=`var aIndices: ${c.type.indices};`;for(let B=P-2-1,W=R-1;B>=0;B--,W--)V+=`\naIndices[${B}] = ${R>1?`batchIndices[${W}]`:"batchIndices"};`;return $.forEach(B=>{V+=`\naIndices[${B}] = 0;`}),V+=`\naIndices[${P-2}] = u32(row);\n                   aIndices[${P-1}] = u32(colIn);`,V},k=()=>{let P=C.rank,R=h.rank,V=`var bIndices: ${C.type.indices};`;for(let B=P-2-1,W=R-1;B>=0;B--,W--)V+=`\nbIndices[${B}] = ${R>1?`batchIndices[${W}]`:"batchIndices"};`;return S.forEach(B=>{V+=`\nbIndices[${B}] = 0;`}),V+=`\nbIndices[${P-2}] = u32(row);\n                   bIndices[${P-1}] = u32(colIn);`,V};return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${h.type.indices}) -> ${ze(e,x)} {\n      var value = ${ze(e,x)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimAOuter && col < dimInner)\n      {\n        ${A()}\n        value = ${c.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${h.type.indices}) -> ${ze(e,x)} {\n      var value = ${ze(e,x)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimInner && col < dimBOuter)\n      {\n        ${k()}\n        value = ${C.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${ze(e,x)}) {\n      let col = colIn * ${e};\n      if (row < dimAOuter && col < dimBOuter) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${u?"bias[colIn]":`${ze(e,x)}(bias[row])`};`:""}\n        ${r}\n        ${b.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},en=(e,t,r,o,a=!1)=>{let u=e[0].dims,i=e[1].dims,d=u.slice(0,-2),f=i.slice(0,-2),h=o?o.slice(0,-2):r.slice(0,-2),c=H("batchDims",e[0].dataType,h),C=[c],b=[d,f,h],$=z.size(h),S=u[u.length-2],x=u[u.length-1],A=i[i.length-1],k=x%4===0&&A%4===0,O=S<=8?[4,1,1]:[4,4,1],P=[8,8,1],R=[Math.ceil(A/P[0]/O[0]),Math.ceil(S/P[1]/O[1]),Math.ceil($/P[2]/O[2])],V=ke(e[0].dataType),B=k?4:1,W=H("a",e[0].dataType,[...d,S,x/B],B),q=H("b",e[1].dataType,[...f,x,A/B],B),ee=Y("result",e[0].dataType,[$,S,A/B],B);C.push(W),C.push(q),C.push(ee);let oe=[W,q],D=e.length>2,{activationFunction:te,applyActivation:Ie}=It(t,ee.type.value),Z=yc(B,D,Ie,C,b,a);if(D){let Te=a?B:1;oe.push(H("bias",e[2].dataType,e[2].dims,Te))}let ve=Te=>`\n  const dimAOuter: i32 = ${S};\n  const dimBOuter: i32 = ${A};\n  const dimInner: i32 = ${x};\n  ${Te.declareVariables(...oe,ee)}\n  ${te}\n  ${Z}\n  ${k?yr(O,P,V,c):br(O,P,V,c)}\n                   ${c.impl()}`;return{name:"MatMul",shaderCache:{hint:t.activationCacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:R[0],y:R[1],z:R[2]}}),getShaderSource:ve}}});var bc,Ui,Ni=K(()=>{"use strict";St();ge();$e();Wt();Zr();Ln();wr();bc=(e,t,r,o,a=!1,u,i=4,d=4,f=4,h="f32")=>{let c=D=>{switch(D){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${h}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${D} is not supported.`)}},C=D=>{switch(D){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${D} is not supported.`)}},b=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,$=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,S=e?"xShape[1]":"xShape[2]",x=e?"xShape[2]":"xShape[3]",A=e?"row":"col",k=e?"col":"row",O=`\n    let inChannels = wShape[2];\n    let outWidth = ${e?"outShape[2]":"outShape[3]"};\n    let outRow = ${A} / outWidth;\n    let outCol = ${A} % outWidth;\n\n    let WRow = ${k} / (filterDims[1] * inChannels);\n    let WCol = ${k} / inChannels % filterDims[1];\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\n    let xCh = ${k} % inChannels;\n    var resData = ${ze(i,h)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the \'same\' padding type.\n    if (xRow >= 0 && xRow < ${S} && xCol >= 0 && xCol < ${x}) {\n      ${b}\n      let xIndex = getIndexFromCoords4D(coord, xShape);\n      ${c(i)}\n    }\n    return resData;`,P=e?t&&o?`\n    let col = colIn * ${i};\n    ${O}`:`\n    let col = colIn * ${i};\n    if (row < dimAOuter && col < dimInner) {\n      ${O}\n    }\n    return ${ze(i,h)}(0.0);`:o&&r?`\n    let col = colIn * ${i};\n    ${O}`:`\n    let col = colIn * ${i};\n    if (row < dimInner && col < dimBOuter) {\n      ${O}\n    }\n    return ${ze(i,h)}(0.0);`,R=`${C(d)}`,V=ze(f,h),B=e?ze(i,h):ze(d,h),W=e?ze(d,h):ze(i,h),{activationFunction:q,applyActivation:ee}=It(u,V);return`\n    ${q}\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${B} {\n      ${e?P:R}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${W} {\n      ${e?R:P}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${V}) {\n      let col = colIn * ${f};\n      if (row < dimAOuter && col < dimBOuter)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${$}\n      ${Xr(a)}\n      ${ee}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},Ui=(e,t,r,o,a,u,i,d)=>{let f=t.format==="NHWC",h=f?e[0].dims[3]:e[0].dims[1],c=r[0],C=f?r[2]:r[3],b=f?r[1]:r[2],$=f?r[3]:r[1],S=f&&(h%4===0||h%3===0)&&$%4===0,x=f?$:C*b,A=f?C*b:$,k=[8,8,1],O=o<=8?[4,1,1]:[4,4,1],P=[Math.ceil(x/k[0]/O[0]),Math.ceil(A/k[1]/O[1]),Math.ceil(c/k[2]/O[2])];Ee("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${P}`);let R=S?f&&h%4!==0?3:4:O[0],V=k[1]*O[1],B=k[0]*O[0],W=Math.max(k[0]*R,k[1]),q=o%V===0,ee=a%B===0,oe=u%W===0,D=S?[R,4,4]:[1,1,1],te=ke(e[0].dataType),Ie=[`@group(0) @binding(0) var<storage, read> x: array<${S&&R===4?`vec4<${te}>`:te}>;`,`@group(0) @binding(1) var<storage, read> w: array<${S?`vec4<${te}>`:te}>;`],Z=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${S?`vec4<${te}>`:te}) {\n        result[flatIndex] = ${S?`vec4<${te}>`:te}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${S?`vec4<${te}>`:te}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${S?"/ 4":""}, value);\n      }`;return i&&(Ie.push(`@group(0) @binding(2) var<storage, read> bias: array<${S?`vec4<${te}>`:te}>;`),Z+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${S?`vec4<${te}>`:te} {\n          return bias[coords.${f?"w":"y"}${S?"/ 4":""}];\n        }`),{name:"Conv2DMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:P[0],y:P[1],z:P[2]}}),getShaderSource:()=>`\n        ${Qr}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${Ie.join("")}\n        @group(0) @binding(${Ie.length}) var<storage, read_write> result: array<${S?`vec4<${te}>`:te}>;\n        //@group(0) @binding(${Ie.length+1}) var<uniform> uniforms: Uniforms;\n\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${z.computeStrides(r).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[0]}, ${t.kernelShape[1]});\n        const pad : vec2<i32> = vec2<i32>(${t.pads[0]}, ${t.pads[1]});\n        const stride : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${o};\n        const dimBOuter : i32 = ${a};\n        const dimInner : i32 = ${u};\n        ${Z}\n        ${bc(f,q,ee,oe,i,t,D[0],D[1],D[2],te)}\n            ${S?yr(O,k,te,void 0,!f,W):br(O,k,te,void 0,!f,W,!1,void 0,d)}`}}});var Hn,Gi=K(()=>{"use strict";ge();$e();qn();Wt();Hn=(e,t,r)=>{let o=e.length>2,a=o?"value += b[output_channel];":"",u=e[0].dims,i=e[1].dims,d=i[0]/t.group,f=t.format==="NHWC",h=jn(u,i,t.dilations,t.pads,t.strides,f),c=z.size(h),C=Y("output",e[0].dataType,h),{activationFunction:b,applyActivation:$}=It(t,C.type.value),S=H("x",e[0].dataType,u),x=H("w",e[1].dataType,i),A=[S,x];o&&A.push(H("b",e[2].dataType,e[2].dims));let k=O=>`\n  const strides: vec2<u32> = vec2(${t.strides[0]}u, ${t.strides[1]}u);\n  const pads: vec2<u32> = vec2(${t.pads[0]}u, ${t.pads[1]}u);\n\n  ${O.declareVariables(...A,C)}\n\n  ${b}\n\n  ${O.mainStart()}\n    ${O.guardAgainstOutOfBoundsWorkgroupSizes(c)}\n\n    let outputIndices = ${C.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${f?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${f?1:2}], outputIndices[${f?2:3}]) * strides - pads;\n    let group_id: u32 = output_channel / ${d}u;\n\n    var value: ${C.type.value} = ${C.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < ${i[1]}u; wInChannel++) {\n      let input_channel = group_id * ${i[1]}u + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < ${i[2]}u; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * ${t.dilations[0]}u;\n\n        if (xHeight < 0u || xHeight >= ${u[f?1:2]}u) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < ${i[3]}u; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * ${t.dilations[1]}u;\n          if (xWidth < 0u || xWidth >= ${u[f?2:3]}u) {\n            continue;\n          }\n\n          let xVal = ${f?S.get("batch","xHeight","xWidth","input_channel"):S.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${x.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${a}\n    ${$}\n    ${C.setByOffset("global_idx","value")}\n  }`;return{name:"GroupedConv",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r?r(h):h,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)}}),getShaderSource:k}}});var jn,Fi,wc,Li,Kn,vc,$c,Yn,qn=K(()=>{"use strict";ge();Me();Ni();wr();Gi();Wt();gr();jn=(e,t,r,o,a,u)=>{let i=e[0],d=e.slice(u?1:2,u?3:4),f=d.length,h=t[0],C=t.slice(2).map((S,x)=>S+(S-1)*(r[x]-1)),$=d.map((S,x)=>S+o[x]+o[x+f]).map((S,x)=>Math.floor((S-C[x]+a[x])/a[x]));return $.splice(0,0,i),$.splice(u?3:1,0,h),$},Fi=[2,3,1,0],wc=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[1]*t.group;if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let a=e[0].dims.length-2;if(t.dilations.length!==a)throw new Error(`dilations should be ${a}D`);if(t.strides.length!==a)throw new Error(`strides should be ${a}D`);if(t.pads.length!==a*2)throw new Error(`pads should be ${a*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},Li=(e,t)=>{let r=e.kernelShape.slice();for(let u=2;u<t[1].dims.length;++u)r[u-2]===0&&(r[u-2]=t[1].dims[u]);let o=e.pads.slice();Bt.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,o,e.format==="NHWC",e.autoPad);let a=Object.assign({},e);return Object.assign(a,{kernelShape:r,pads:o,cacheKey:e.cacheKey}),a},Kn=e=>{let t=Jr(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],a=e.dilations,u=e.group,i=e.kernel_shape,d=e.pads,f=e.strides,h=e.w_is_const();return ue({autoPad:o,format:r,dilations:a,group:u,kernelShape:i,pads:d,strides:f,wIsConst:h,...t})},vc=(e,t,r)=>{let o=Li(r,t);if(r.group!==1){e.compute(Hn(t,o));return}let a=r.format==="NHWC",u=t.length===3,i=t[0].dims[a?1:2],d=t[0].dims[a?2:3],f=t[0].dims[a?3:1],h=t[1].dims[2],c=t[1].dims[3],C=jn(t[0].dims,t[1].dims,r.dilations,o.pads,r.strides,a),b=C[a?1:2],$=C[a?2:3],S=C[a?3:1],x=a&&h===i&&c===d&&r.pads[0]===0&&r.pads[1]===0;if(x||h===1&&c===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let B=C[0],W,q,ee,oe=[];if(a){let D=e.kernelCustomData.wT??e.compute(At(t[1],Fi),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=D),x){let te=i*d*f;W=t[0].reshape([1,B,te]),q=D.reshape([1,te,S]),ee=[1,B,S]}else W=t[0].reshape([B,i*d,f]),q=D.reshape([1,f,S]),ee=[B,b*$,S];oe.push(W),oe.push(q)}else W=t[0].reshape([B,f,i*d]),q=t[1].reshape([1,S,f]),ee=[B,S,b*$],oe.push(q),oe.push(W);u&&oe.push(t[2]),e.compute(en(oe,o,C,ee,a),{inputs:oe});return}let A=!0,k=e.kernelCustomData.wT??e.compute(At(t[1],Fi),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=k);let O=[t[0],k];u&&O.push(t[2]);let P=a?b*$:S,R=a?S:b*$,V=h*c*f;e.compute(Ui(O,o,C,P,R,V,u,A),{inputs:O})},$c=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&o.push(e.inputs[2]);let a=[0,t.pads[0],0,t.pads[1]],u=[1].concat(t.strides),i=[1].concat(t.dilations),d=[1].concat(t.kernelShape),f=Li({...t,pads:a,strides:u,dilations:i,kernelShape:d},o);e.compute(Hn(o,f,h=>r?[h[0],h[2],h[3]]:[]))},Yn=(e,t)=>{wc(e.inputs,t),e.inputs[0].dims.length===3?$c(e,t):vc(e,e.inputs,t)}});var xc,Hi,ji=K(()=>{"use strict";St();ge();Wt();Zr();Ln();wr();xc=(e,t=!1,r,o=4)=>{let a=ze(o,"f32"),u=O=>{switch(O){case 1:return"return W[getIndexFromCoords4D(coord, wShape)];";case 4:return`\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            `;default:throw new Error(`innerElementSize ${O} is not supported.`)}},i=e?`\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      `:`\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      `,d=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,f=e?"outBackprop[1]":"outBackprop[2]",h=e?"outBackprop[2]":"outBackprop[3]",c=e?"row":"col",C=e?"col":"row",b=`\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      let outRow = ${c} / outWidth;\n      let outCol = ${c} % outWidth;\n\n      let WRow = ${C} / (filterDims[1] * inChannels);\n      let WCol = ${C} / inChannels % filterDims[1];\n      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);\n      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);\n      if (xR < 0.0 || xR >= f32(${f}) || fract(xR) > 0.0) {\n        return ${a}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${h}) || fract(xC) > 0.0) {\n        return ${a}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${C} % inChannels;\n      ${i}\n      return x[getIndexFromCoords4D(coord, xShape)/${o}];`,$=e?`\n      let col = colIn * ${o};\n      if (row < dimAOuter && col < dimInner) {\n        ${b}\n      }\n      return ${a}(0.0);`:`\n      let col = colIn * ${o};\n      if (row < dimInner && col < dimBOuter) {\n        ${b}\n      }\n      return ${a}(0.0);`,S=`\n      let col = colIn * ${o};\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);\n      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];\n      if (${e?"row < dimInner && col < dimBOuter":"row < dimInner && col < dimAOuter"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${u(o)}\n      }\n      return ${a}(0.0);\n      `,{activationFunction:x,applyActivation:A}=It(r,a);return`\n      ${x}\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${a} {\n    ${e?$:S}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${a} {\n    ${e?S:$}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${a}) {\n    let col = colIn * ${o};\n    if (row < dimAOuter && col < dimBOuter) {\n      var value = valueInput;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${d}\n      ${Xr(t)}\n      ${A}\n      result[getIndexFromCoords4D(coords, outShape)/${o}] = value;\n    }\n  }`},Hi=(e,t,r,o,a,u,i,d)=>{let f=t.format==="NHWC",h=f?e[0].dims[3]:e[0].dims[1],c=r[0],C=f?r[2]:r[3],b=f?r[1]:r[2],$=f?r[3]:r[1],S=f?h%4===0&&$%4===0:C%4===0&&$%4===0,x=f?$:C*b,A=f?C*b:$,k=S?[8,8,1]:[x<=4||A<=4?4:16,x>4&&A<=4?4:16,1],O=S?[4,4,1]:[x<=4?1:4,x>4&&A<=4?1:4,1],P=[Math.ceil(x/k[0]/O[0]),Math.ceil(A/k[1]/O[1]),Math.ceil(c/k[2]/O[2])];Ee("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${P}`);let R=S?4:1,V=Math.max(k[0]*R,k[1]),B=[`@group(0) @binding(0) var<storage, read> x: array<${S?"vec4<f32>":"f32"}>;`,"@group(0) @binding(1) var<storage, read> W: array<f32>;"],W="";return i&&(B.push(`@group(0) @binding(2) var<storage, read> bias: array<${S?"vec4<f32>":"f32"}>;`),W+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${S?"vec4<f32>":"f32"} {\n          return bias[coords.${f?"w":"y"}${S?"/ 4":""}];\n        }`),{name:"Conv2DTransposeMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:P[0],y:P[1],z:P[2]}}),getShaderSource:()=>`\n        ${Qr}\n        ${B.join(`\n`)}\n        @group(0) @binding(${B.length}) var<storage, read_write> result: array<${S?"vec4<f32>":"f32"}>;\n        const outBackprop : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${z.computeStrides(r).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[f?1:2]}, ${t.kernelShape[f?2:3]});\n        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(\n              ${t.dilations[0]<=1?0:(t.kernelShape[f?1:2]-1)*(t.dilations[0]-1)},\n              ${t.dilations[1]<=1?0:(t.kernelShape[f?2:3]-1)*(t.dilations[1]-1)});\n        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${t.pads[0]+t.pads[2]})/2,\n                                         i32(effectiveFilterDims[1]) - 1 - (${t.pads[1]+t.pads[3]})/2);\n        const strides : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${o};\n        const dimBOuter : i32 = ${a};\n        const dimInner : i32 = ${u};\n        ${W}\n        ${xc(f,i,t,R)}\n        ${S?yr(O,k,"f32",void 0,!f,V):br(O,k,"f32",void 0,!f,V,!1,void 0,d)}`}}});var Sc,Jn,qi=K(()=>{"use strict";St();ge();$e();Sc=(e,t,r,o,a,u,i=!1,d)=>{let f=r.format==="NHWC",h=f?1:2,c=f?2:3,C=f?3:1,b=z.size(o),$=i?2:1,S=r.group,x=t[1].dims,A=x[0]/S,k=x[1],O=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${i?`vec4<${d}>`:d}) {\n    result[flatIndex] = ${i?`vec4<${d}>`:d}(value);\n  }`;a&&(O+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${i?`vec4<${d}>`:d} {\n      return bias[coords.${f?"w":"y"}${i?"/ 4":""}];\n    }`);let P=i?4:1,R=H("W",t[1].dataType,t[1].dims,P),V=H("Dy",t[0].dataType,t[0].dims,P),B=[V,R];a&&B.push(H("bias",t[2].dataType,[o[C]],P));let W=Y("result",t[0].dataType,o,P),q=`{\n        let batch: u32 = ${u?"global_id.z":"workgroup_id.z"} / outShape[1];\n        let r = ${u?"global_id.z":"workgroup_id.z"} % outShape[1];\n        let c = ${u?"global_id.y":"workgroup_id.y"} * ${$};\n        let d1: u32 = ${u?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${d}>, ${$}>;\n        for (var i = 0; i < ${$}; i++) {\n          dotProd[i] = vec4<${d}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {\n          var dyR = (${d}(dyCorner.x) + ${d}(wR)) / ${d}(strides.x);\n          let wRPerm = filterDims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${d}(outBackprop[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {\n            let dyC = (${d}(dyCorner.y) + ${d}(wC)) / ${d}(strides.y);\n            let dyC2 = (${d}(dyCorner.y) + 1.0 + ${d}(wC)) / ${d}(strides.y);\n            let wCPerm = filterDims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${d}(outBackprop[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${d}(outBackprop[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${V.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${V.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${d}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = outBackprop[${C}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${V.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${V.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${$}; i = i + 1) {\n          let value = dotProd[i] + ${a?"bias[c+i]":"0.0"};\n          ${W.set("batch","r","c + i","d1","value")};\n        }\n      }`,ee=`\n          let outputIndices = ${W.offsetToIndices("global_idx")};\n          let batch = ${W.indicesGet("outputIndices",0)};\n          let d1 = ${W.indicesGet("outputIndices",C)};\n          let r = ${W.indicesGet("outputIndices",h)};\n          let c = ${W.indicesGet("outputIndices",c)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / ${k};\n          let wOutChannel = d1 - groupId * ${k};\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = 0.0;\n          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {\n            if (wR % dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${d}(dyRCorner) + ${d}(wR)) / ${d}(strides[0]);\n            let wRPerm = filterDims.x - 1 - wR / dilations.x;\n            if (dyR < 0.0 || dyR >= ${d}(outBackprop[${h}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {\n              if (wC % dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${d}(dyCCorner) + ${d}(wC)) / ${d}(strides.y);\n              let wCPerm = filterDims.y - 1 - wC / dilations.y;\n              if (dyC < 0.0 || dyC >= ${d}(outBackprop[${c}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * ${A};\n              for (var d2: u32 = 0; d2 < ${A}; d2 = d2 + 1) {\n                let xValue = ${f?V.get("batch","idyR","idyC","inputChannel"):V.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${R.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${a?"bias[d1]":"0.0"};\n          ${W.setByOffset("global_idx","value")};\n        `;return`\n  ${e.declareVariables(...B,W)}\n  ${O}\n  const outShape : vec4<u32> = vec4<u32>(${o.join(",")});\n  const outBackprop : vec4<u32> = vec4<u32>(${t[0].dims.join(",")});\n  const strides : vec2<u32> = vec2<u32>(${r.strides[0]}, ${r.strides[1]});\n  const filterDims : vec2<u32> = vec2<u32>(${r.kernelShape[f?1:2]}, ${r.kernelShape[f?2:3]});\n  const dilations : vec2<u32> = vec2<u32>(${r.dilations[0]}, ${r.dilations[1]});\n  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(\n          ${r.dilations[0]<=1?0:(r.kernelShape[f?1:2]-1)*(r.dilations[0]-1)},\n          ${r.dilations[1]<=1?0:(r.kernelShape[f?2:3]-1)*(r.dilations[1]-1)});\n  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,\n                                     i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)};\n  ${i?q:ee}}`},Jn=(e,t,r)=>{let o=e.length>2,a=t.outputShape,u=z.size(a),i=[Math.ceil(u/64),1,1];Ee("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${i}`);let d=ke(e[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:t.cacheKey},getRunData:()=>({dispatchGroup:{x:i[0],y:i[1],z:i[2]},outputs:[{dims:r?r(a):a,dataType:e[0].dataType}]}),getShaderSource:f=>Sc(f,e,t,a,o,i[1]===1&&i[2]===1,!1,d)}}});var Cc,Ac,Ic,Ki,Yi,Tc,Oc,Ec,_c,Ji,Xi=K(()=>{"use strict";Me();ji();qi();Wt();gr();Cc=(e,t,r,o,a,u)=>(e-1)*t+r+(o-1)*a+1-u,Ac=(e,t,r,o,a)=>{let u=Math.floor(e/2);t==="SAME_UPPER"?(r[o]=u,r[a]=e-u):t==="SAME_LOWER"&&(r[o]=e-u,r[a]=u)},Ic=(e,t,r,o,a,u,i,d,f,h)=>{let c=e.length-2,C=h.length===0;if(f.length===0)for(let S=0;S<c;++S)f.push(0);let b=e[0],$=t[d?3:1]*a;for(let S=0,x=e.length-c-(d?1:0);S<c;++S,++x){let A=e[x],k=C?A*i[S]:h[S],O=Cc(A,i[S],u[S],t[x],r[S],k);Ac(O,o,u,S,S+c),C&&h.push(i[S]*(A-1)+f[S]+(t[x]-1)*r[S]+1-u[S]-u[S+c])}h.splice(0,0,b),h.splice(d?3:1,0,$)},Ki=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((b,$)=>b*$,1)===0){r.length=0;for(let b=2;b<t[1].dims.length;++b)r.push(t[1].dims[b])}let o=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(o?3:1,0,t[1].dims[1]);let a=e.pads.slice(),u=e.outputShape.slice(),i=e.outputPadding.slice(),d=t[0].dims,f=e.dilations.slice();if(f.reduce((b,$)=>b+$,0)===0){let b=t[0].dims.length-2;f=new Array(b).fill(1)}let h=e.strides.slice();if(h.reduce((b,$)=>b+$,0)===0){let b=t[0].dims.length-2;h=new Array(b).fill(1)}Ic(d,r,f,e.autoPad,e.group,a,h,o,i,u);let c=Object.assign({},e),C=e.cacheKey+[r.join("n,"),a.join(","),h.join(","),i.join(","),u.join(","),f.join(",")].join("_");return Object.assign(c,{kernelShape:r,pads:a,outputPadding:i,outputShape:u,dilations:f,strides:h,cacheKey:C}),c},Yi=e=>{let t=Jr(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],a=e.dilations,u=e.group,i=e.kernelShape,d=e.pads,f=e.strides,h=e.wIsConst(),c=e.outputPadding,C=e.outputShape;return ue({autoPad:o,format:r,dilations:a,group:u,kernelShape:i,outputPadding:c,outputShape:C,pads:d,strides:f,wIsConst:h,...t})},Tc=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[0];if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let a=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==a))throw new Error("invalid bias");let u=e[0].dims.length-2;if(t.dilations.reduce((c,C)=>c+C,0)>0&&t.dilations.length!==u)throw new Error(`dilations should be ${u}D`);if(t.strides.reduce((c,C)=>c+C,0)>0&&t.strides.length!==u)throw new Error(`strides should be ${u}D`);if(t.pads.reduce((c,C)=>c+C,0)>0&&t.pads.length!==u*2)throw new Error(`pads should be ${u*2}D`);if(t.outputPadding.length!==u&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${u}D`);if(t.kernelShape.reduce((c,C)=>c+C,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},Oc=[2,3,1,0],Ec=(e,t,r)=>{let o=Ki(r,t),a=r.format==="NHWC",u=t.length===3;if(o.group!==1){e.compute(Jn(t,o));return}let i=o.outputShape,d=i[a?1:2],f=i[a?2:3],h=i[a?3:1],c=t[1].dims[2],C=t[1].dims[3],b=t[0].dims[a?3:1],$=a?d*f:h,S=a?h:d*f,x=c*C*b,A=!0,k=e.kernelCustomData.wT??e.compute(At(t[1],Oc),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=k);let O=[t[0],k];u&&(!a&&t[2].dims.length===1?O.push(t[2].reshape([t[2].dims[0],1,1])):O.push(t[2])),e.compute(Hi(O,o,i,$,S,x,u,A),{inputs:O})},_c=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];o.length===3&&o.push(e.inputs[2]);let a=t.kernelShape;(a.length===0||a[0]===0)&&(a=[e.inputs[1].dims[2]]);let u=t.dilations;(u.length===0||u[0]===0)&&(u=[1]);let i=t.strides;(i.length===0||i[0]===0)&&(i=[1]);let d=t.pads;d.length===0&&(d=[0,0]),d=[0,d[0],0,d[1]],i=[1].concat(i),u=[1].concat(u),a=[1].concat(a);let f=Ki({...t,pads:d,strides:i,dilations:u,kernelShape:a},o);e.compute(Jn(o,f,h=>r?[h[0],h[2],h[3]]:[h[0],h[1],h[3]]))},Ji=(e,t)=>{Tc(e.inputs,t),e.inputs[0].dims.length===3?_c(e,t):Ec(e,e.inputs,t)}});var Xn,tn,Zi,Pc,Rc,Zn,Qn,Mc,Qi,es,ts=K(()=>{"use strict";ge();Me();$e();Xn="[a-zA-Z]|\\\\.\\\\.\\\\.",tn="("+Xn+")+",Zi="^"+tn+"$",Pc="("+tn+",)*"+tn,Rc="^"+Pc+"$",Zn=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let o=this.symbolToIndices.get(t);o===void 0?o=[r]:o.push(r),this.symbolToIndices.set(t,o)}},Qn=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[o,a]=r.includes("->")?r.split("->",2):[r,""];if(!o.match(RegExp(Rc)))throw new Error("Invalid LHS term");if(o.split(",").forEach((d,f)=>{let h=t[f].dims.slice();if(!d.match(RegExp(Zi)))throw new Error("Invalid LHS term");let c=this.processTerm(d,!0,h,f);this.lhs.push(c)}),a==="")a+=[...this.symbolToInfo.entries()].filter(([d,f])=>f.count===1||d==="...").map(([d])=>d).join("");else if(!a.match(RegExp(tn)))throw new Error("Invalid RHS");a.match(RegExp(Xn,"g"))?.forEach(d=>{if(d==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let f=this.symbolToInfo.get(d);if(f===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(f.dimValue)}}),this.rhs=this.processTerm(a,!0,this.outputDims)}addSymbol(t,r,o){let a=this.symbolToInfo.get(t);if(a!==void 0){if(a.dimValue!==r&&a.count!==1)throw new Error("Dimension mismatch");a.count++,a.inputIndices.push(o)}else a={count:1,dimValue:r,inputIndices:[o]};this.symbolToInfo.set(t,a)}processTerm(t,r,o,a=-1){let u=o.length,i=!1,d=[],f=0;if(!t.match(RegExp(Zi))&&!r&&t!=="")throw new Error("Invalid LHS term");let h=t.match(RegExp(Xn,"g")),c=new Zn(a);return h?.forEach((C,b)=>{if(C==="..."){if(i)throw new Error("Only one ellipsis is allowed per input term");i=!0;let $=u-h.length+1;if($<0)throw new Error("Ellipsis out of bounds");if(d=o.slice(f,f+$),this.hasEllipsis){if(this.ellipsisDims.length!==d.length||this.ellipsisDims.toString()!==d.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=d;else throw new Error("Ellipsis must be specified in the LHS");for(let S=0;S<d.length;S++){let x=String.fromCharCode("0".charCodeAt(0)+b);c.addSymbol(x,b+S),this.addSymbol(x,o[f++],a)}}else c.addSymbol(C,b),this.addSymbol(C,o[f++],a)}),c}},Mc=(e,t)=>{let r=e[0].dataType,o=new Array(e.length);for(let P=0;P<e.length;++P)o[P]=H(`input${P}`,r,e[P].dims);let a=t.outputDims,u=z.size(a),i=Y("output",r,a),d=[],f=Array.from(t.rhs.symbolToIndices.keys()),h="var prod = 1.0;",c="var sum = 0.0;",C="sum += prod;",b=[],$=[],S=[],x=[],A=t.symbolToInfo.size===f.length;t.symbolToInfo.forEach((P,R)=>{if(f.includes(R)){let V=f.indexOf(R);t.lhs.forEach((B,W)=>{if(P.inputIndices.includes(W)){let q=B.symbolToIndices.get(R);if(q===void 0)throw new Error("Invalid symbol error");q.forEach(ee=>{d.push(`${o[W].indicesSet(`input${W}Indices`,ee,i.indicesGet("outputIndices",V))}`)})}})}else t.lhs.forEach((V,B)=>{let W=t.symbolToInfo.get(R);if(W===void 0)throw new Error("Invalid symbol error");if(W.inputIndices.includes(B)){let q=V.symbolToIndices.get(R);if(q===void 0)throw new Error("Invalid symbol error");q.forEach(ee=>{b.push(`${o[B].indicesSet(`input${B}Indices`,ee,`${R}`)}`)}),x.push(`prod *= ${o[B].getByIndices(`input${B}Indices`)};`)}}),$.push(`for(var ${R}: u32 = 0; ${R} < ${t.symbolToInfo.get(R)?.dimValue}; ${R}++) {`),S.push("}")});let k=A?[...d,`let sum = ${o.map((P,R)=>P.getByIndices(`input${R}Indices`)).join(" * ")};`]:[...d,c,...$,...b,h,...x,C,...S],O=P=>`\n      ${P.declareVariables(...o,i)}\n\n      ${P.mainStart()}\n        ${P.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n        var outputIndices = ${i.offsetToIndices("global_idx")};\n        ${o.map((R,V)=>`var input${V}Indices: ${o[V].type.indices};`).join(`\n`)}\n        ${k.join(`\n`)};\n        ${i.setByOffset("global_idx","sum")};\n      }`;return{name:"Einsum",shaderCache:{hint:t.equation},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:O}},Qi=(e,t)=>{let r=new Qn(e.inputs,t.equation);e.compute(Mc(e.inputs,r))},es=e=>{let t=e.equation.replace(/\\s+/g,"");return ue({equation:t})}});var kc,rs,Bc,Dc,ns,os=K(()=>{"use strict";ge();$e();kc=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=r.length<t.length?0:r.length-t.length,a=t.length<r.length?0:t.length-r.length;for(;o<r.length&&a<t.length;++o,++a)if(r[o]!==t[a]&&r[o]!==1&&t[a]!==1)throw new Error("Expand requires shape to be broadcastable to input")},rs=(e,t)=>{let r=e.length-t.length,o=[];for(let a=0;a<r;++a)o.push(e[a]);for(let a=0;a<t.length;++a)o.push(t[a]===1?e[a+r]:t[a]);return o},Bc=(e,t)=>e.length>t.length?rs(e,t):rs(t,e),Dc=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=Bc(t,r),a=z.size(o),u=e[0].dataType,i=H("input",u,t),d=Y("output",u,o),f=h=>`\n  const inputShape = ${i.indices(...t)};\n  ${h.declareVariables(i,d)}\n  ${h.mainStart()}\n  ${h.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n    let outputIndices = ${d.offsetToIndices("global_idx")};\n    var inputIndices: ${i.type.indices};\n    for (var i = 0; i < ${t.length}; i++) {\n      if (${i.indicesGet("inputShape","i")} == 1) {\n        ${i.indicesSet("inputIndices","i",0)}\n      } else {\n        ${i.indicesSet("inputIndices","i",d.indicesGet("outputIndices",`i + ${o.length-t.length}`))}\n      }\n    }\n    ${d.setByOffset("global_idx",i.getByIndices("inputIndices"))}\n  }`;return{name:"Expand",shaderCache:{hint:`${o}`},getShaderSource:f,getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}})}},ns=e=>{kc(e.inputs),e.compute(Dc(e.inputs),{inputs:[0]})}});var Wc,zc,as,is,ss=K(()=>{"use strict";ge();Me();$e();Wc=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},zc=(e,t)=>{let r=e[0].dims,o=e[1].dims,a=r.length,u=z.normalizeAxis(t.axis,a),i=r.slice(0);i.splice(u,1,...o);let d=r[u],f=z.size(i),h=H("data",e[0].dataType,e[0].dims),c=H("inputIndices",e[1].dataType,e[1].dims),C=Y("output",e[0].dataType,i),b=()=>{let S=o.length,x=`var indicesIndices  = ${c.type.indices}(0);`;for(let A=0;A<S;A++)x+=`${S>1?`indicesIndices[${A}]`:"indicesIndices"} = ${i.length>1?`outputIndices[${u+A}]`:"outputIndices"};`;x+=`\n        var idx = ${c.getByIndices("indicesIndices")};\n        if (idx < 0) {\n          idx = idx + ${d};\n        }\n        var dataIndices = ${h.type.indices}(0);\n      `;for(let A=0,k=0;A<a;A++)A===u?(x+=`${a>1?`dataIndices[${A}]`:"dataIndices"} = u32(idx);`,k+=S):(x+=`${a>1?`dataIndices[${A}]`:"dataIndices"} = ${i.length>1?`outputIndices[${k}]`:"outputIndices"};`,k++);return x},$=S=>`\n      ${S.declareVariables(h,c,C)}\n      ${S.mainStart()}\n        ${S.guardAgainstOutOfBoundsWorkgroupSizes(f)}\n        let outputIndices = ${C.offsetToIndices("global_idx")};\n        ${b()};\n        let value = ${h.getByIndices("dataIndices")};\n        ${C.setByOffset("global_idx","value")};\n      }`;return{name:"Gather",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)}}),getShaderSource:$}},as=e=>ue({axis:e.axis}),is=(e,t)=>{let r=e.inputs;Wc(r),e.compute(zc(e.inputs,t))}});var Vc,Uc,us,ls,cs=K(()=>{"use strict";ge();Me();$e();Vc=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},Uc=(e,t)=>{let r=e[0].dims,o=e[0].dataType,a=r.length,u=z.computeStrides(r),i=z.size(r),d=e[1].dims,f=e[1].dataType,h=z.size(d),c=z.normalizeAxis(t.axis,a),C=r[c],b=d.slice(0),$=z.size(b),S=H("input",o,r),x=H("indices",f,[h]),A=Y("output",o,b),k=O=>`\n      const inputStrides = array<u32, ${u.length}>(${u.map(P=>`${P}u`).join(",")});\n      ${O.declareVariables(S,x,A)}\n      ${O.mainStart()}\n      ${O.guardAgainstOutOfBoundsWorkgroupSizes($)}\n\n      let outputIndices = ${A.offsetToIndices("global_idx")};\n\n      var idx = ${x.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + ${C};\n      }\n\n      var srcOffset = u32(0);\n\n      for (var i = 0; i < ${r.length}; i++) {\n        if (i == ${c}) {\n          srcOffset +=  u32(idx) * inputStrides[i];\n        } else {\n          srcOffset += ${A.indicesGet("outputIndices","i")} * inputStrides[i];\n        }\n      }\n\n      // Should never hit this with valid values in indices\n      // This is a guard against malicious data in the indices input\n      if (srcOffset < 0 || srcOffset >= ${i}) {\n        return;\n      }\n\n      output[global_idx] = input[srcOffset];\n  }`;return{name:"GatherElements",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:b,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil($/64)}}),getShaderSource:k}},us=e=>ue({axis:e.axis}),ls=(e,t)=>{let r=e.inputs;Vc(r),e.compute(Uc(e.inputs,t))}});var Nc,Gc,Fc,ds,ps,fs=K(()=>{"use strict";ge();Me();$e();Nc=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},Gc=(e,t,r)=>{if(r.length===0)return"0u";let o=r.length===1&&e!==1||r.length===2&&r[0]!==e,a=r[r.length-1]!==t,u="0u";return o||(u+=`+ m * ${r[r.length-1]}u`),a||(u+="+n"),u},Fc=(e,t)=>{let r=e[0].dims.slice(),o=e[1].dims.slice(),[a,u,i]=Fr.getShapeOfGemmResult(r,t.transA,o,t.transB,e.length===3?e[2].dims:void 0),d=[a,u];if(!d)throw new Error("Can\'t use gemm on the given tensors");let f=z.size(d),h="";t.transA&&t.transB?h="value += a[k * M + m] * b[n * K + k];":t.transA&&!t.transB?h="value += a[k * M + m] * b[k * N + n];":!t.transA&&t.transB?h="value += a[m * K + k] * b[n * K + k];":!t.transA&&!t.transB&&(h="value += a[m * K + k] * b[k * N + n];");let c=ke(e[0].dataType),C=t.alpha===1?"":"value *= alpha;",b=e.length===3?`value += beta * c[${Gc(a,u,e[2].dims)}];`:"",$=[`@group(0) @binding(0) var<storage, read> a : array<${c}>;`,`@group(0) @binding(1) var<storage, read> b : array<${c}>;`];e.length===3&&$.push(`@group(0) @binding(2) var<storage, read> c : array<${c}>;`);let S=x=>`\n  const M: u32 = ${a}u;\n  const N: u32 = ${u}u;\n  const K: u32 = ${i}u;\n  const alpha = ${c}(${t.alpha});\n  const beta = ${c}(${t.beta});\n\n  ${$.join(`\n`)}\n  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${c}>;\n\n  ${x.mainStart()}\n    ${x.guardAgainstOutOfBoundsWorkgroupSizes(f)}\n\n    let m = global_id.x / N;\n    let n = global_id.x % N;\n\n    var value = ${c}(0);\n    for (var k: u32 = 0u; k<${i}u; k++) {\n      ${h}\n    }\n\n    ${C}\n    ${b}\n    output[global_id.x] = value;\n\n  }`;return{name:"Gemm",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)}}),getShaderSource:S}},ds=(e,t)=>{Nc(e.inputs),e.compute(Fc(e.inputs,t))},ps=e=>ue(e)});var Lc,Hc,jc,qc,ms,hs,gs=K(()=>{"use strict";We();ge();Me();$e();Lc={name:"InstanceNormalization"},Hc=(e,t)=>{let r=e[0].dims,o=r,a=2,u=z.sizeToDimension(r,a),i=z.sizeFromDimension(r,a),d=r[1],f=H("x",e[0].dataType,[r[0],r[1],i]),h=H("scale",e[1].dataType,e[1].dims),c=H("bias",e[2].dataType,e[2].dims),C=Y("output",e[0].dataType,[r[0],r[1],i]),b=[f,h,c,C],$=f.type.value,S=64,x=A=>`\n\n  const C: u32 = ${d};\n  const normSize: u32 = ${i};\n  const epsilon: f32 = ${t.epsilon};\n  var<workgroup> meanShared : ${$};\n  var<workgroup> squaredNormShared : ${$};\n  var<workgroup> workgroupShared : array<${$}, ${S}>;\n  const workgroupSize = ${S}u;\n  ${A.declareVariables(...b)}\n  ${A.mainStart(S)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / C;\n    let channel = norm % C;\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial: ${$} = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      initial = initial + ${f.get("batch","channel","h")};\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = workgroupShared[0] / ${$}(normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let deviation =  ${f.get("batch","channel","h")} - meanShared;\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = workgroupShared[0];\n    }\n    workgroupBarrier();\n\n    let invStdDev = 1 / sqrt(squaredNormShared / ${$}(normSize) + epsilon);\n    let channelScale = invStdDev * ${h.getByOffset("channel")};\n    let channelShift = ${c.getByOffset("channel")} - meanShared * channelScale;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let value = ${f.get("batch","channel","h")} * channelScale + channelShift;\n      ${C.set("batch","channel","h","value")};\n    }\n  }`;return{...Lc,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:u}}),getShaderSource:x}},jc=(e,t,r,o,a,u,i,d)=>{let f=bt(i),h=H("input",t.dataType,t.dims,f),c=H("scale",r.dataType,r.dims,f),C=H("bias",o.dataType,o.dims,f),b=64,$=f===1?"vec2f":`mat2x${f}f`,S=f===1?"f32":`vec${f}f`,x=(V,B)=>`${$}(${V}, ${B})`,A=a*i/f,k=Math.ceil(u/b),O=V=>`\n  const H: u32 = ${u};\n  const C: u32 = ${i/f};\n  const imageSize: u32 = ${u*i/f};\n\n  ${V.declareVariables(h)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${$}>;\n\n  ${V.mainStart(b)}\n    let currentImageNumber = global_idx / ${b} / C;\n    let currentChannelNumber = (global_idx / ${b}) % C;\n    let wgId = global_idx % ${b};\n    let wgOffset = wgId * ${k};\n    if (wgOffset >= H) {\n        return;\n    }\n    let wgMax = min(wgOffset + ${k}, H);\n\n    let offset = currentImageNumber * imageSize + currentChannelNumber;\n    var sum = ${tt("f32",f)};\n    var squaredSum = ${tt("f32",f)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${S}(input[offset + i * C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${x("sum","squaredSum")};\n  }`,P=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:f,n:a,h:u,c:i})},getRunData:()=>({outputs:[{dims:[a,i,b,2],dataType:1}],dispatchGroup:{x:a*i/f}}),getShaderSource:O},{inputs:[t],outputs:[-1]})[0],R=V=>`\n  const H: u32 = ${u};\n  const C: u32 = ${i/f};\n  const imageSize: u32 = ${b*i/f};\n  const epsilon: f32 = ${d};\n\n  @group(0) @binding(0) var<storage, read> input : array<${$}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${c.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${C.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${$}>;\n\n  ${V.mainStart()}\n    ${V.guardAgainstOutOfBoundsWorkgroupSizes(A)}\n    let currentImageNumber = global_idx / C;\n    let currentChannelNumber = global_idx % C;\n\n    let offset = currentImageNumber * imageSize;\n    var sum = ${tt("f32",f)};\n    var squaredSum = ${tt("f32",f)};\n    for (var i: u32 = 0; i < ${b}; i++) {\n        let value = input[offset + i + currentChannelNumber * ${b}];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(H);\n    squaredSum = squaredSum / f32(H);\n    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);\n    let channelScale = invStdDev * ${S}(scale[currentChannelNumber]);\n    let channelShift = ${S}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${x("channelScale","channelShift")};\n  }`;return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:f,n:a,h:u,c:i,epsilon:d})},getRunData:()=>({outputs:[{dims:[a,i,2],dataType:1}],dispatchGroup:{x:Math.ceil(A/64)}}),getShaderSource:R},{inputs:[P,r,o],outputs:[-1]})[0]},qc=(e,t,r)=>{let o=t[0].dims,a=o,u=o[0],i=o[o.length-1],d=z.sizeFromDimension(o,1)/i,f=bt(i),h=z.size(a)/f,c=H("input",t[0].dataType,t[0].dims,f),C=Y("output",t[0].dataType,a,f),b=ke(t[0].dataType),$=f===1?"vec2f":`mat2x${f}f`,S=f===1?b:`vec${f}<${b}>`,x=jc(e,t[0],t[1],t[2],u,d,i,r.epsilon),A=k=>`\n  const H: u32 = ${d};\n  const C: u32 = ${i/f};\n\n  @group(0) @binding(0) var<storage, read> input : array<${c.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${$}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${C.type.storage}>;\n\n  ${k.mainStart()}\n    let currentImageNumber = global_idx / (C * H);\n    let currentChannelNumber = global_idx % C;\n\n    let scaleOffset = currentImageNumber * C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${S}(scale[0]), ${S}(scale[1]));\n  }`;e.compute({name:"InstanceNormalization",shaderCache:{hint:`${r.cacheKey}`},getRunData:()=>({outputs:[{dims:a,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)}}),getShaderSource:A},{inputs:[t[0],x]})},ms=e=>ue({epsilon:e.epsilon,format:e.format}),hs=(e,t)=>{t.format==="NHWC"?qc(e,e.inputs,t):e.compute(Hc(e.inputs,t))}});var Kc,Yc,ys,bs,ws=K(()=>{"use strict";We();ge();Me();$e();Kc=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},Yc=(e,t,r)=>{let o=e[0].dims,a=e[1],u=e[2],i=o,d=z.normalizeAxis(t.axis,o.length),f=z.sizeToDimension(o,d),h=z.sizeFromDimension(o,d),c=z.size(a.dims),C=u?z.size(u.dims):0;if(c!==h||u&&C!==h)throw new Error(`Size of X.shape()[axis:] == ${h}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${c} and bias size of ${C}`);let b=[];for(let R=0;R<o.length;++R)R<d?b.push(o[R]):b.push(1);let $=bt(h),S=ke(e[0].dataType),x=[H("x",e[0].dataType,e[0].dims,$),H("scale",a.dataType,a.dims,$)];u&&x.push(H("bias",u.dataType,u.dims,$)),x.push(Y("output",e[0].dataType,i,$));let A=r>1,k=r>2;A&&x.push(Y("meanDataOutput",1,b)),k&&x.push(Y("invStdOutput",1,b));let O=R=>`\n  const normSize: f32 = ${h};\n  const normSizeVectorized: u32 = ${h/$};\n  const epsilon: f32 = ${t.epsilon};\n\n  ${R.declareVariables(...x)}\n  ${R.mainStart()}\n    ${R.guardAgainstOutOfBoundsWorkgroupSizes(f)}\n    let offset = global_idx * normSizeVectorized;\n    var meanVector = ${tt("f32",$)};\n    var meanSquareVector = ${tt("f32",$)};\n\n    for (var h: u32 = 0u; h < normSizeVectorized; h++) {\n      let value = ${Dt(S,$,"x[h + offset]")};\n      meanVector += value;\n      meanSquareVector += value * value;\n    }\n    let mean = ${Ct("meanVector",$)} / normSize;\n    let meanSquare = sqrt(${Ct("meanSquareVector",$)} \n      / normSize - mean * mean + epsilon);\n\n    for (var j: u32 = 0; j < normSizeVectorized; j++) {\n      let f32input = ${Dt(S,$,"x[j + offset]")};\n      let f32scale = ${Dt(S,$,"scale[j]")};\n      output[j + offset] = ${x[0].type.value}((f32input - mean) / meanSquare * f32scale\n        ${u?`+ ${Dt(S,$,"bias[j]")}`:""}\n      );\n    }\n\n    ${A?"meanDataOutput[global_idx] = mean":""};\n    ${k?"invStdOutput[global_idx] = 1 / meanSquare":""};\n  }`,P=[{dims:i,dataType:e[0].dataType}];return A&&P.push({dims:b,dataType:1}),k&&P.push({dims:b,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${t.cacheKey}|${r}|${e.length}`},getRunData:()=>({outputs:P,dispatchGroup:{x:Math.ceil(f/64)}}),getShaderSource:O}},ys=e=>ue({axis:e.axis,epsilon:e.epsilon}),bs=(e,t)=>{Kc(e.inputs),e.compute(Yc(e.inputs,t,e.outputCount))}});var Jc,vs,$s=K(()=>{"use strict";ge();wr();Jc=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},vs=e=>{Jc(e.inputs);let t=st.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can\'t use matmul on the given tensors");e.compute(en(e.inputs,{activation:"",activationCacheKey:""},t))}});var Xc,Zc,Qc,ed,td,rd,nd,od,ad,xs,Ss,Cs=K(()=>{"use strict";We();ge();Me();$e();Xc=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1)throw new Error("Input type must be float.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},Zc=(e,t,r,o,a,u,i)=>{let d=r.length,f="";for(let h=d-1;h>=0;--h)f+=`\n            k = i32(${e.indicesGet("indices",h)}) - ${a[h]};\n            if (k < 0) {\n              break;\n            }\n            if (k >= ${r[h]}) {\n              break;\n            }\n            offset += k * ${o[h]};\n        `;return`\n          value = ${u}(${i});\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${f}\n            value = x[offset];\n          }\n      `},Qc=(e,t,r,o,a)=>{let u=r.length,i="";for(let d=u-1;d>=0;--d)i+=`\n                k = i32(${e.indicesGet("indices",d)}) - ${a[d]};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = ${2*(r[d]-1)};\n                  k = k % _2n_1;\n                  if(k >= ${r[d]}) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * ${o[d]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${i}\n              value = x[offset];\n          `},ed=(e,t,r,o,a)=>{let u=r.length,i="";for(let d=u-1;d>=0;--d)i+=`\n                k = i32(${e.indicesGet("indices",d)}) - ${a[d]};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= ${r[d]}) {\n                  k = ${r[d]-1};\n                }\n                offset += k * ${o[d]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${i}\n              value = x[offset];\n          `},td=(e,t,r,o,a)=>{let u=r.length,i="";for(let d=u-1;d>=0;--d)i+=`\n                k = i32(${e.indicesGet("indices",d)}) - ${a[d]};\n                if (k < 0)  {\n                  k += ${r[d]};\n                }\n                if (k >= ${r[d]}) {\n                  k -= ${r[d]};\n                }\n                offset += k * ${o[d]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${i}\n              value = x[offset];\n          `},rd=(e,t,r,o,a,u)=>{switch(a.mode){case 0:return Zc(e,t,r,o,a.pads,u,a.value);case 1:return Qc(e,t,r,o,a.pads);case 2:return ed(e,t,r,o,a.pads);case 3:return td(e,t,r,o,a.pads);default:throw new Error("Invalid mode")}},nd=(e,t,r,o)=>{let a=t[0].dims,u=z.padShape(a.slice(),r.pads),i=z.size(u),d=z.computeStrides(a),f=Y("output",t[0].dataType,u),h=H("x",t[0].dataType,a),c=rd(f,u,a,d,r,o);return`\n              ${e.declareVariables(h,f)}\n              ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n\n              let indices = ${f.offsetToIndices("global_idx")};\n\n              var value = ${o}(0);\n              ${c}\n              output[global_idx] = value;\n          }`},od=(e,t)=>{let r=z.padShape(e[0].dims.slice(),t.pads);return{name:"Pad",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(z.size(r)/64)}}),getShaderSource:o=>nd(o,e,t,"f32")}},ad=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),o=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,a=e[0].dims.length,u=new Int32Array(2*a).fill(0);if(e.length>=4){let d=e[3].getBigInt64Array();for(let f=0;f<d.length;f++)u[Number(d[f])]=Number(r[f]),u[Number(d[f])+a]=Number(r[f+d.length])}else r.forEach((d,f)=>u[Number(f)]=Number(d));let i=[];return u.forEach(d=>i.push(d)),ue({mode:t.mode,value:o,pads:i})}else return t},xs=(e,t)=>{Xc(e.inputs);let r=ad(e.inputs,t);e.compute(od(e.inputs,r),{inputs:[0]})},Ss=e=>{let t=e.mode,r=e.value,o=e.pads;return ue({mode:t,value:r,pads:o})}});var rn,As,Is,Ts,Os,Es,_s,Ps,Rs,Ms,ks,Bs,Ds,Ws,zs,Vs=K(()=>{"use strict";ge();Me();$e();rn=e=>{if(!e||e.length!==1)throw new Error("Pool ops requires 1 input.");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("Pool ops supports 1-D or 2-D inputs only for now.")},As=(e,t,r)=>{let o=t.format==="NHWC",a=e.dims.slice();o&&a.splice(1,0,a.pop());let u=Object.hasOwnProperty.call(t,"dilations"),i=t.kernelShape.slice(),d=t.strides.slice(),f=u?t.dilations.slice():[],h=t.pads.slice();Bt.adjustPoolAttributes(r,a,i,d,f,h);let c=Bt.computePoolOutputShape(r,a,d,f,i,h,t.autoPad),C=Object.assign({},t);u?Object.assign(C,{kernelShape:i,strides:d,pads:h,dilations:f,cacheKey:t.cacheKey}):Object.assign(C,{kernelShape:i,strides:d,pads:h,cacheKey:t.cacheKey});let b=c.slice();return b.push(b.splice(1,1)[0]),[C,o?b:c]},Is=(e,t,r,o,a,u,i,d)=>{let f=a.format==="NHWC",h=r,c=t.type.value,C=h.length,b=z.size(o),$=Y("output",t.type.tensor,o);if(a.kernelShape.length<=2){let S=a.kernelShape[a.kernelShape.length-1],x=a.strides[a.strides.length-1],A=a.pads[a.pads.length/2-1],k=a.pads[a.pads.length-1],O=C-(f?2:1),P="",R="",V="";if(A+k!==0?P=`\n                for (var i: u32 = 0u; i < ${S}u; i++) {\n                  xIndices[${O}] = indices[${O}] * ${x} - ${A} + i;\n                  if (xIndices[${O}] < 0 || xIndices[${O}] >= ${h[O]}) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${u}\n                }`:P=`\n                for (var i: u32 = 0u; i < ${S}u; i++) {\n                  xIndices[${O}] = indices[${O}] * ${x} - ${A} + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${u}\n                }`,a.kernelShape.length===2){let W=a.kernelShape[a.kernelShape.length-2],q=a.strides[a.strides.length-2],ee=a.pads[a.pads.length/2-2],oe=a.pads[a.pads.length-2],D=C-(f?3:2),te=h[D];ee+oe!==0?R=`\n                for (var j: u32 = 0u; j < ${W}u; j++) {\n                  xIndices[${D}] = indices[${D}] * ${q} - ${ee} + j;\n                  if (xIndices[${D}] < 0 || xIndices[${D}] >= ${te}) {\n                    pad+= ${S};\n                    continue;\n                  }\n              `:R=`\n                for (var j: u32 = 0u; j < ${W}u; j++) {\n                  xIndices[${D}] = indices[${D}] * ${q} - ${ee} + j;\n                `,V=`\n              }\n            `}return`\n            ${e.declareVariables(t,$)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n\n              let indices = ${$.offsetToIndices("global_idx")};\n              var xIndices = ${$.offsetToIndices("global_idx")};\n\n              var value: ${c} = ${c}(${d});\n              var pad = 0;\n              ${R}\n              ${P}\n              ${V}\n              ${i}\n\n              output[global_idx] = value;\n            }`}else{if(f)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let S=z.size(a.kernelShape),x=z.computeStrides(a.kernelShape),A=x.length,k=a.pads.length,O=a.pads.reduce((V,B)=>V+B),P="";return O?P=`\n                if (xIndices[j] >= inputDims[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${u}\n              }`:P=`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${u}\n            `,`\n            ${e.declareVariables(t,$)}\n\n            const pads = array<u32, ${k}>(${a.pads.map(V=>`${V}u`).join(",")});\n            const inputDims = array<u32, ${C}>(${h.map(V=>`${V}u`).join(",")});\n            const kernelStrides = array<u32, ${A}>(${x.map(V=>`${V}u`).join(",")});\n            const strides = array<u32, ${A}>(${a.strides.map(V=>`${V}u`).join(",")});\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n\n              let indices = ${$.offsetToIndices("global_idx")};\n              let xIndices = ${$.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${A}>;\n\n              var value = ${$.type.value}(${d});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < ${S}u; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${A-1}u; j++) {\n                  offsets[j] = offset / kernelStrides[j];\n                  offset -= offsets[j] * kernelStrides[j];\n                }\n                offsets[${A-1}] = offset;\n\n                isPad = false;\n                for (var j = ${C-A}u; j < ${C}u; j++) {\n                  xIndices[j] = indices[j] * strides[j - ${C-A}u]\n                    + offsets[j - ${C-A}u] - pads[j - 2u];\n                  ${P}\n              }\n              ${i}\n\n              output[global_idx] = value;\n            }`}},Ts=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Os=(e,t,r,o)=>{let[a,u]=As(t,o,r),i=z.size(a.kernelShape),d=H("x",t.dataType,t.dims),f=d.type.value,h="value += x_val;",c="";return a.countIncludePad?c+=`value /= ${f}(${i});`:c+=`value /= ${f}(${i} - pad);`,{name:e,shaderCache:{hint:o.cacheKey},getRunData:()=>({outputs:[{dims:u,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(z.size(u)/64)}}),getShaderSource:C=>Is(C,d,t.dims,u,a,h,c,"0.0")}},Es=e=>{let t=e.count_include_pad!==0,r=Ts(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return ue({countIncludePad:t,...r})},_s=(e,t)=>{rn(e.inputs),e.compute(Os("AveragePool",e.inputs[0],!1,t))},Ps={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},Rs=e=>{let t=e.format;return{format:t,...Ps,cacheKey:t}},Ms=(e,t)=>{rn(e.inputs),e.compute(Os("GlobalAveragePool",e.inputs[0],!0,t))},ks=(e,t,r,o)=>{let[a,u]=As(t,o,r),i=`\n      value = max(x_val, value);\n    `,d="",f=H("x",t.dataType,t.dims);return{name:e,shaderCache:{hint:o.cacheKey},getRunData:()=>({outputs:[{dims:u,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(z.size(u)/64)}}),getShaderSource:h=>Is(h,f,t.dims,u,a,i,d,"-1e5")}},Bs=(e,t)=>{rn(e.inputs),e.compute(ks("MaxPool",e.inputs[0],!1,t))},Ds=e=>{let t=e.storage_order,r=e.dilations,o=Ts(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(o.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return ue({storageOrder:t,dilations:r,...o})},Ws=e=>{let t=e.format;return{format:t,...Ps,cacheKey:t}},zs=(e,t)=>{rn(e.inputs),e.compute(ks("GlobalMaxPool",e.inputs[0],!0,t))}});var nn=K(()=>{});var Us=K(()=>{nn()});var Ns,Gs=K(()=>{Ns="1.17.0"});var Fs,eo,Ls=K(()=>{Gs();Fs="warning",eo={wasm:{},webgl:{},webgpu:{},versions:{common:Ns},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);Fs=e}},get logLevel(){return Fs}};Object.defineProperty(eo,"logLevel",{enumerable:!0})});var Hs,js=K(()=>{Ls();Hs=eo});var qs=K(()=>{});var Ks=K(()=>{on()});var Js=K(()=>{});var Xs=K(()=>{on()});var on=K(()=>{qs();Ks();Js();Xs()});var an=K(()=>{on()});var Zs=K(()=>{nn();an()});var Qs=K(()=>{Zs()});var eu=K(()=>{});var tu=K(()=>{nn();an()});var ru=K(()=>{tu()});var nu=K(()=>{Us();js();Qs();an();eu();ru()});var ld,cd,ou,au=K(()=>{"use strict";nu();We();$e();ld=(e,t,r)=>{let o=e===t,a=e<t&&r<0,u=e>t&&r>0;if(o||a||u)throw new Error("Range these inputs\' contents are invalid.")},cd=(e,t,r,o)=>{let a=Math.abs(Math.ceil((t-e)/r)),u=[a],i=a,d=Y("output",o,u),f=d.type.storage,h=c=>`\n        ${c.declareVariables(d)}\n        ${c.mainStart()}\n        ${c.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n        output[global_idx] = ${f}(${e}) + ${f}(global_idx) * ${f}(${r});\n      }`;return{name:"Range",shaderCache:{hint:[e,t,r].map(c=>c.toString()).join("_")},getShaderSource:h,getRunData:()=>({outputs:[{dims:u,dataType:o}],dispatchGroup:{x:Math.ceil(i/64)}})}},ou=e=>{let t=0,r=0,o=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],o=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],o=e.inputs[2].getFloat32Array()[0]),Hs.webgpu.validateInputContent&&ld(t,r,o),e.compute(cd(t,r,o,e.inputs[0].dataType),{inputs:[]})}});var dd,pd,fd,md,hd,gd,yd,bd,wd,vd,$d,xd,Sd,Cd,Ad,iu,su,uu=K(()=>{"use strict";ge();Me();$e();dd=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},pd=(e,t,r)=>{t.every(a=>a>=0&&a<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let o=new Array(r).fill(1);return t.forEach((a,u)=>o[a]=e[u]),o},fd=(e,t,r,o,a,u)=>{let[i,d,f]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],h=e[0].dims.length;if(i>0&&e.length>i&&e[i].dims.length>0)e[i].getFloat32Array().forEach(c=>u.push(c));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(d>0&&e.length>d&&e[d].dims.length>0){if(e[d].getFloat32Array().forEach(c=>o.push(c)),o.length!==0&&o.length!==h&&r>=18&&o.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");dd(o,t),t.axes.length>0&&pd(o,t.axes,h).forEach((c,C)=>o[C]=c)}if(f>0&&e.length>f&&(e[f].getBigInt64Array().forEach(c=>a.push(Number(c))),a.length!==h||r>=18&&a.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(o.length!==t.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(a.length!==t.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(typeof o<"u"&&typeof a<"u"&&o.length>0&&a.length>h)throw new Error("Resize requires only of scales or sizes to be specified")},md=e=>"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(e){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`\n`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",hd=(e,t)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",gd=(e,t,r)=>{let o=new Array(r).fill(0).concat(new Array(r).fill(1)),a=e.length===0?o:e.slice();return t.length>0?(t.forEach((u,i)=>{o[u]=a[i],o[i+r]=a[t.length+i]}),o):a},yd=(e,t,r,o)=>{let a=[];if(r.length>0)if(o.length>0){if(e.forEach(u=>a.push(u)),Math.max(...o)>e.length)throw new Error("axes is out of bound");o.forEach((u,i)=>a[u]=r[i])}else r.forEach(u=>a.push(u));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");a=e.map((u,i)=>Math.round(u*t[i]))}return a},bd=(e,t,r,o)=>{let a=(()=>{switch(o.keepAspectRatioPolicy){case"not_larger":return o.axes.length>0?Math.min(...o.axes.map(i=>r[i]),Number.MAX_VALUE):Math.min(...r,Number.MAX_VALUE);case"not_smaller":return o.axes.length>0?Math.max(...o.axes.map(i=>r[i]),Number.MIN_VALUE):Math.max(...r,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${o.keepAspectRatioPolicy} is not supported`)}})();r.fill(1,0,r.length);let u=e.slice();return o.axes.length>0?(o.axes.forEach(i=>r[i]=a),o.axes.forEach(i=>u[i]=Math.round(e[i]*r[i]))):(r.fill(a,0,r.length),u.forEach((i,d)=>u[d]=Math.round(i*r[d]))),u},wd=(e,t,r,o,a)=>`\n    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> array<f32, ${r.length}> {\n      const inputShape = array<u32, ${t.length}>(${t.map(u=>`${u}u`).join(",")});\n      const outputShape = array<u32, ${r.length}>(${r.map(u=>`${u}u`).join(",")});\n      const scales = array<f32, ${o.length}>(${o.map(u=>`${u}f`).join(",")});\n      const roi = array<f32, ${a.length}>(${a.map(u=>`${u}f`).join(",")});\n      var originalIndices: array<f32, ${r.length}>;\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var outputIndex = ${r.length===1?"outputIndices":"outputIndices[i]"};\n        if (scales[i] == 1.0) {\n          originalIndices[i] = f32(outputIndex);\n        } else {\n          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${t.length}]);\n        }\n      }\n      return originalIndices;\n    }`,vd=(e,t,r,o,a,u,i)=>`\n    fn calculateInputIndicesFromOutputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n        const inputShape = array<u32, ${r.length}>(${r.map(d=>`${d}u`).join(",")});\n        const outputShape = array<u32, ${o.length}>(${o.map(d=>`${d}u`).join(",")});\n        const scales = array<f32, ${a.length}>(${a.map(d=>`${d}f`).join(",")});\n        const roi = array<f32, ${u.length}>(${u.map(d=>`${d}f`).join(",")});\n        var inputIndices: ${e.type.indices};\n        for (var i:u32 = 0; i < ${o.length}; i++) {\n          var outputIndex = ${o.length===1?"outputIndices":"outputIndices[i]"};\n          var inputIndex: u32;\n          if (scales[i] == 1.0) {\n            inputIndex = outputIndex;\n          } else {\n            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${r.length}]);\n            if (!${i} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {\n              if (original_idx < 0) {\n                inputIndex = 0;\n              } else if (original_idx > (f32(inputShape[i]) - 1)) {\n                inputIndex = inputShape[i] - 1;\n              } else {\n                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));\n              }\n            } else {\n              inputIndex = u32(original_idx);\n            }\n          }\n          ${e.indicesSet("inputIndices","i","inputIndex")}\n        }\n        return inputIndices;\n    }`,$d=(e,t)=>`\n    fn checkInputIndices(inputIndices: ${e.type.indices}) -> bool {\n      const inputShape = array<u32, ${t.length}>(${t.map(r=>`${r}u`).join(",")});\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var inputIndex = ${t.length===1?"inputIndices":"inputIndices[i]"};\n        if (inputIndex < 0 || inputIndex >= inputShape[i]) {\n          return false;\n        }\n      }\n      return true;\n    }`,xd=(e,t,r,o,a,u,i)=>{let[d,f,h,c]=r.length===2?[-1,0,1,-1]:a[1]===1?[0,2,3,1]:[0,1,2,3];return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {\n      var inputIndices: ${e.type.indices};\n      inputIndices[${f}] = max(0, min(row, ${r[f]} - 1));\n      inputIndices[${h}] = max(0, min(col, ${r[h]} - 1));\n      if (${r.length} > 2) {\n        inputIndices[${c}] = channel;\n        inputIndices[${d}] = batch;\n      };\n      return input[${e.indicesToOffset("inputIndices")}];\n    }\n\n    fn bilinearInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);\n      var row:f32 = originalIndices[${f}];\n      var col:f32 = originalIndices[${h}];\n      if (${u} && (row < 0 || row > (${r[f]} - 1) || col < 0 || col > ${r[h]} - 1)) {\n        return ${i};\n      }\n      row = max(0, min(row, ${r[f]} - 1));\n      col = max(0, min(col, ${r[h]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = 0;\n      var batch: u32 = 0;\n      if (${r.length>2}) {\n        channel = u32(originalIndices[${c}]);\n        batch = u32(originalIndices[${d}]);\n      }\n      var x11: f32 = getInputValue(batch, channel, row1, col1);\n      var x12: f32 = getInputValue(batch, channel, row1, col2);\n      var x21: f32 = getInputValue(batch, channel, row2, col1);\n      var x22: f32 = getInputValue(batch, channel, row2, col2);\n      var dx1: f32 = row - f32(row1);\n      var dx2: f32 = f32(row2 ) - row;\n      var dy1 = col - f32(col1);\n      var dy2 = f32(col2) - col;\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},Sd=(e,t,r,o,a,u,i,d,f,h)=>{let[c,C]=r.length===2?[0,1]:a[1]===1?[2,3]:[1,2],b=$=>{let S=$===c?"row":"col";return`\n      fn ${S}CubicInterpolation(inputIndices: ${e.type.indices}, outputIndices: ${t.type.indices}) -> f32 {\n        var outputIndex = ${o.length===1?"outputIndices":`outputIndices[${$}]`};\n        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${a[$]},\n        f32(${o[$]}), f32(${r[$]}), ${u[$]}, ${u[$]} + ${r.length});\n        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${d} && (originalIdx < 0 || originalIdx > (${r[$]} - 1))) {\n          return ${f};\n        }\n        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${S}: f32 = originalIdx + f32(i);\n          if (${S} < 0 || ${S} >= ${r[$]}) {\n            if (${h}) {\n              coefs[i + 1] = 0.0;\n              continue;\n            } else if (${d}) {\n              return ${f};\n            } else {\n              ${S} = max(0, min(${S}, ${r[$]} - 1));\n            }\n          }\n          var inputIndicesCopy: ${e.type.indices} = inputIndices;\n          inputIndicesCopy[${$}] = u32(${S});\n          data[i + 1] = ${$===c?`input[${e.indicesToOffset("inputIndicesCopy")}];`:`\n                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);`}\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${b(c)};\n    ${b(C)};\n  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {\n    var absS = abs(s);\n    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: f32 = 1.0 - absS;\n    var twoMinusAbsS: f32 = 2.0 - absS;\n    var onePlusAbsS: f32 = 1.0 + absS;\n    coeffs[0] = ((${i} * onePlusAbsS - 5 * ${i}) * onePlusAbsS + 8 * ${i}) * onePlusAbsS - 4 * ${i};\n    coeffs[1] = ((${i} + 2) * absS - (${i} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${i} + 2) * oneMinusAbsS - (${i} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${i} * twoMinusAbsS - 5 * ${i}) * twoMinusAbsS + 8 * ${i}) * twoMinusAbsS - 4 * ${i};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {\n    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n    var inputIndices: ${e.type.indices} = outputIndices;\n    return colCubicInterpolation(inputIndices, outputIndices);\n  }\n    `},Cd=(e,t,r,o,a,u)=>{let i=e.dims,d=gd(u,t.axes,i.length),f=yd(i,o,a,t.axes),h=o.slice();o.length===0&&(h=i.map((A,k)=>A===0?1:f[k]/A),t.keepAspectRatioPolicy!=="stretch"&&(f=bd(i,f,h,t)));let c=Y("output",e.dataType,f),C=H("input",e.dataType,i),b=z.size(f),$=i.length===f.length&&i.every((A,k)=>A===f[k]),S=t.coordinateTransformMode==="tf_crop_and_resize",x=A=>`\n      ${$?"":`\n      ${md(t.coordinateTransformMode)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${$d(C,i)};\n              ${hd(t.nearestMode,r)};\n              ${vd(C,c,i,f,h,d,S)};\n              `;case"linear":return`\n              ${wd(c,i,f,h,d)};\n              ${xd(C,c,i,f,h,S,t.extrapolationValue)};\n              `;case"cubic":return`\n            ${Sd(C,c,i,f,h,d,t.cubicCoeffA,S,t.extrapolationValue,t.excludeOutside)};\n            `;default:throw Error("Invalid resize mode")}})()};\n      `}\n      ${A.declareVariables(C,c)}\n      ${A.mainStart()}\n        ${A.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n        ${$?"output[global_idx] = input[global_idx];":`\n        let outputIndices = ${c.offsetToIndices("global_idx")};\n        var inputIndices: ${C.type.indices};\n        ${(()=>{switch(t.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);\n                if (checkInputIndices(inputIndices)) {\n                  output[global_idx] = input[${C.indicesToOffset("inputIndices")}];\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n        `}\n      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${h.length>0?h:""}|${a.length>0?a:""}|${$}`},getShaderSource:x,getRunData:()=>({outputs:[{dims:f,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(b/64)}})}},Ad=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},iu=(e,t)=>{let r=[],o=[],a=[],u=Ad(e);fd(e.inputs,t,u,r,o,a),e.compute(Cd(e.inputs[0],t,u,r,o,a),{inputs:[0]})},su=e=>{let t=e.antialias,r=e.axes,o=e.coordinateTransformMode,a=e.cubicCoeffA,u=e.excludeOutside!==0,i=e.extrapolationValue,d=e.keepAspectRatioPolicy,f=e.mode,h=e.nearestMode===""?"simple":e.nearestMode;return ue({antialias:t,axes:r,coordinateTransformMode:o,cubicCoeffA:a,excludeOutside:u,extrapolationValue:i,keepAspectRatioPolicy:d,mode:f,nearestMode:h})}});var Id,Td,lu,cu,du=K(()=>{"use strict";We();ge();Me();$e();Id=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],r=e[1],o=e[2];if(t.dataType!==r.dataType||t.dataType!==o.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let a=t.dims[t.dims.length-1],u=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==a)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==u)throw new Error("Skip must have the same sequence length as input");if(o.dims.length!==1)throw new Error("Gamma must be 1D");if(o.dims[o.dims.length-1]!==a)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let i=e[3];if(i.dims.length!==1)throw new Error("Beta must be 1D");if(i.dims[i.dims.length-1]!==a)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let i=e[4];if(i.dims.length!==1)throw new Error("Bias must be 1D");if(i.dims[i.dims.length-1]!==a)throw new Error("Bias must have the same hidden size as input")}},Td=(e,t,r,o)=>{let a=e[0].dims,u=z.size(a),i=a,d=u,f=a.slice(-1)[0],h=o?a.slice(0,-1).concat(1):[],c=e.length>3,C=e.length>4,b=o&&r>1,$=o&&r>2,S=r>3,x=bt(f),A=[H("x",e[0].dataType,e[0].dims,x),H("skip",e[1].dataType,e[1].dims,x),H("gamma",e[2].dataType,e[2].dims,x)];c&&A.push(H("beta",e[3].dataType,e[3].dims,x)),C&&A.push(H("bias",e[4].dataType,e[4].dims,x)),A.push(Y("output",e[0].dataType,i,x)),b&&A.push(Y("meanOutput",1,h)),$&&A.push(Y("invStdOutput",1,h)),S&&A.push(Y("inputSkipBiasSum",e[0].dataType,i,x));let k=ke(e[0].dataType),O=R=>`\n      const hiddenSize: f32 = ${f};\n      const hiddenSizeVectorized: u32 = ${f/x};\n      const epsilon: f32 = ${t.epsilon};\n\n      ${R.declareVariables(...A)}\n\n      ${R.mainStart()}\n        ${R.guardAgainstOutOfBoundsWorkgroupSizes(d/f)}\n        let offset = global_idx * hiddenSizeVectorized;\n        var sum = ${tt("f32",x)};\n        var squareSum = ${tt("f32",x)};\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          let skipValue = skip[offset + i];\n          let biasValue = ${C?"bias[i]":"0.0"};\n          let inputValue = x[offset + i];\n          let value = inputValue + skipValue + biasValue;\n          ${S?"inputSkipBiasSum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32Value = ${Dt(k,x,"value")};\n          sum += f32Value;\n          squareSum += f32Value * f32Value;\n        }\n        let mean = ${Ct("sum",x)} / hiddenSize;\n        let variance = sqrt(${Ct("squareSum",x)} / hiddenSize - mean * mean + epsilon);\n        ${b?"meanOutput[global_idx] = mean;":""}\n        ${$?"invStdOutput[global_idx] = 1.0 / variance;":""}\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          output[offset + i] = (output[offset + i] - ${k}(mean)) / ${k}(variance) * gamma[i]\n           + ${c?"beta[i]":"0.0"};\n        }\n      }`,P=[{dims:i,dataType:e[0].dataType}];return r>1&&P.push({dims:h,dataType:1}),r>2&&P.push({dims:h,dataType:1}),r>3&&P.push({dims:a,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:t.cacheKey},getShaderSource:O,getRunData:()=>({outputs:P,dispatchGroup:{x:Math.ceil(d/f/64)}})}},lu=(e,t)=>{Id(e.inputs);let o=[0];e.outputCount>1&&o.push(-3),e.outputCount>2&&o.push(-3),e.outputCount>3&&o.push(3),e.compute(Td(e.inputs,t,e.outputCount,!1),{outputs:o})},cu=e=>{let t=e.epsilon;return ue({epsilon:t})}});var Od,sn,Ed,pu,_d,Pd,fu,mu,hu=K(()=>{"use strict";We();ge();Me();$e();Od=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,o)=>{if(e[o+1].dataType!==6&&e[o+1].dataType!==7)throw new Error(`Input ${o} must be an array of int32 or int64`)})},sn=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(o=>r.push(Number(o)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(o=>r.push(Number(o)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},Ed=(e,t)=>{if(e.length>1){let r=sn(e,1),o=sn(e,2),a=sn(e,3);return a.length===0&&(a=[...Array(e[0].dims.length).keys()]),ue({starts:r,ends:o,axes:a})}else return t},pu=(e,t,r,o,a)=>{let u=e;return e<0&&(u+=r[o[t]]),a[t]<0?Math.max(0,Math.min(u,r[o[t]]-1)):Math.max(0,Math.min(u,r[o[t]]))},_d=(e,t,r,o)=>`fn calculateInputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n          var inputIndices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${r.length}; i >= 0; i--) {\n            var outputIndex = ${o.length===1?"outputIndices":"outputIndices[i]"};\n            var inputIndex = outputIndex * steps[i] + starts[i] + carry;\n            carry = inputIndex / inputShape[i];\n            inputIndex = inputIndex % inputShape[i];\n            if (signs[i] < 0) {\n              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];\n            }\n            ${r.length===1?"inputIndices":"inputIndices[i]"} = inputIndex;\n          }\n          return inputIndices;\n      }`,Pd=(e,t)=>{let r=e[0].dims,o=z.size(r),a=t.axes.length>0?z.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],u=sn(e,4);u.forEach(x=>x!==0||(()=>{throw new Error("step cannot be 0")})),u.length===0&&(u=Array(a.length).fill(1));let i=t.starts.map((x,A)=>pu(x,A,r,a,u)),d=t.ends.map((x,A)=>pu(x,A,r,a,u));if(a.length!==r.length)for(let x=0;x<r.length;++x)a.includes(x)||(i.splice(x,0,0),d.splice(x,0,r[x]),u.splice(x,0,1));let f=u.map(x=>Math.sign(x));u.forEach((x,A,k)=>{if(x<0){let O=(d[A]-i[A])/x,P=i[A],R=P+O*u[A];i[A]=R,d[A]=P,k[A]=-x}});let h=r.slice(0);a.forEach((x,A)=>{h[x]=Math.ceil((d[x]-i[x])/u[x])});let c={dims:h,dataType:e[0].dataType},C=Y("output",e[0].dataType,h),b=H("input",e[0].dataType,r),$=z.size(h),S=x=>`\n      ${x.declareVariables(b,C)}\n        const signs = array<i32, ${f.length}>(${f.map(A=>`${A}i`).join(",")});\n        const starts = array<u32, ${i.length}>(${i.map(A=>`${A}u`).join(",")});\n        const ends = array<u32, ${d.length}>(${d.map(A=>`${A}u`).join(",")});\n        const steps = array<u32, ${u.length}>(${u.map(A=>`${A}u`).join(",")});\n        const inputShape = array<u32, ${r.length}>(${r.map(A=>`${A}u`).join(",")});\n\n        ${_d(b,C,r,h)}\n        ${x.mainStart()}\n          ${x.guardAgainstOutOfBoundsWorkgroupSizes($)}\n          let outputIndices = ${C.offsetToIndices("global_idx")};\n          let inputIndices = calculateInputIndices(outputIndices);\n          ${C.setByOffset("global_idx",b.getByIndices("inputIndices"))}\n      }`;return{name:"Slice",shaderCache:{hint:`${t.cacheKey}|${e[4]?.dims??""}`},getShaderSource:S,getRunData:()=>({outputs:[c],dispatchGroup:{x:Math.ceil(o/64)}})}},fu=(e,t)=>{Od(e.inputs,t);let r=Ed(e.inputs,t);e.compute(Pd(e.inputs,r),{inputs:[0]})},mu=e=>{let t=e.starts,r=e.ends,o=e.axes;return ue({starts:t,ends:r,axes:o})}});var Rd,Md,gu,yu,bu=K(()=>{"use strict";ge();Me();$e();Rd=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},Md=(e,t)=>{let r=e.dims,o=z.size(r),a=64,u=t.axis;if(u<0&&(u=r.length+u),u<r.length-1)throw new Error("softmax only supports last axis for now.");let i=r[u],d=o/i,f=bt(i),h=i/f,c=(A,k)=>k===4?`max(max(${A}.x, ${A}.y), max(${A}.z, ${A}.w))`:k===2?`max(${A}.x, ${A}.y)`:k===3?`max(max(${A}.x, ${A}.y), ${A}.z)`:A,C=H("x",e.dataType,e.dims,f),b=Y("result",e.dataType,e.dims,f),$=C.type.value,S=ke(e.dataType)==="f32"?`var threadMax = ${$}(-3.402823e+38f);`:`var threadMax = ${$}(-65504.0h);`,x=A=>`\n      var<workgroup> rowMaxShared : ${$};\n      var<workgroup> rowSumShared : ${$};\n      var<workgroup> threadShared : array<${$}, ${a}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${$} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${$}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${A.registerUniform("packedCols","i32").declareVariables(C,b)}\n      ${A.mainStart()}\n        let gindex = i32(global_id.x);\n        let lindex = i32(local_id.x);\n        const wg = ${a};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${S}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${$}(${c("threadShared[0]",f)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${$}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${$}(${Ct("threadShared[0]",f)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`;return{name:"Softmax",shaderCache:{hint:`${f}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:r,dataType:e.dataType}],dispatchGroup:{x:d},programUniforms:[{type:"uint32",data:h}]}),getShaderSource:x}},gu=(e,t)=>{Rd(e.inputs),e.compute(Md(e.inputs[0],t))},yu=e=>ue({axis:e.axis})});var kd,Bd,Dd,Wd,zd,wu,vu,$u=K(()=>{"use strict";ge();Me();$e();kd=e=>{if(!e||e.length<1)throw new Error("too few inputs")},Bd=(e,t)=>{let r=[],o=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(a=>r.push(Number(a))),o=r.length),ue({numOutputs:o,axis:t.axis,splitSizes:r})},Dd=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < sizeInConcatAxis[i]) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,Wd=e=>{let t=e.length,r=[];for(let o=0;o<t;++o){let a=e[o].setByIndices("indices","input[global_idx]");t===1?r.push(a):o===0?r.push(`if (outputNumber == ${o}u) { ${a} }`):o===t-1?r.push(`else { ${a} }`):r.push(`else if (outputNumber == ${o}) { ${a} }`)}return`\n      fn writeBufferData(outputNumber: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${r.join(`\n`)}\n      }`},zd=(e,t)=>{let r=e[0].dims,o=z.size(r),a=e[0].dataType,u=r.length,i=t.axis,d=i<0?r.length+i:i,f=new Array(t.numOutputs),h=H("input",a,r),c=new Array(t.numOutputs),C=[],b=[],$=0;for(let A=0;A<t.numOutputs;A++){$+=t.splitSizes[A],c[A]=$;let k=r.slice();k[t.axis]=t.splitSizes[A],b.push(k),f[A]=Y(`output${A}`,a,b[A]),C.push({dims:b[A],dataType:e[0].dataType})}let S=u<2?"indices":`indices[${d}]`,x=A=>`\n  ${A.declareVariables(h,...f)}\n  const sizeInConcatAxis = array<u32, ${c.length}>(${c.map(k=>`${k}u`).join(",")});\n  ${Dd(c.length)}\n  ${Wd(f)}\n\n  ${A.mainStart()}\n    ${A.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n\n    var indices = ${h.offsetToIndices("global_idx")};\n    let outputNumber = calculateOutputIndex(${S});\n    if (outputNumber != 0) {\n        ${S} -= sizeInConcatAxis[outputNumber - 1u];\n    }\n    writeBufferData(outputNumber, indices, global_idx);\n  }`;return{name:"Split",shaderCache:{hint:t.cacheKey},getShaderSource:x,getRunData:()=>({outputs:C,dispatchGroup:{x:Math.ceil(o/64)}})}},wu=(e,t)=>{kd(e.inputs);let r=e.inputs.length===1?t:Bd(e.inputs,t);e.compute(zd(e.inputs,r),{inputs:[0]})},vu=e=>{let t=e.axis,r=e.splitSizes,o=e.numOutputs<0?r.length:e.numOutputs;if(o!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ue({axis:t,numOutputs:o,splitSizes:r})}});var xu,Vd,Ud,Nd,Su,Cu=K(()=>{"use strict";We();ge();$e();xu=e=>Array.from(e.getBigInt64Array(),Number),Vd=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(xu(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Ud=(e,t)=>{let r=[];for(let o=0;o<e.length;++o)r.push(e[o]*t[o]);return r},Nd=e=>{let t=e[0].dims,r=xu(e[1]),o=Ud(t,r),a=z.size(o),u=e[0].dataType,i=H("input",u,t),d=Y("output",u,o),f=h=>`\n      const inputShape = ${i.indices(...t)};\n      ${h.declareVariables(i,d)}\n      ${h.mainStart()}\n      ${h.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n      let outputIndices = ${d.offsetToIndices("global_idx")};\n      var inputIndices: ${i.type.indices};\n      for (var i = 0; i < ${t.length}; i++) {\n        let inputDimValue = ${d.indicesGet("outputIndices","i")}  % ${i.indicesGet("inputShape","i")};\n\n        ${i.indicesSet("inputIndices","i","inputDimValue")}\n      }\n      ${d.setByOffset("global_idx",i.getByIndices("inputIndices"))}\n    }`;return{name:"Tile",shaderCache:{hint:`${r}`},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:f}},Su=e=>{Vd(e.inputs),e.compute(Nd(e.inputs),{inputs:[0]})}});var Gd,Fd,Au,Iu=K(()=>{"use strict";We();ge();$e();Gd=(e,t,r,o,a)=>{let u=z.size(r),i=Math.ceil(u/4),d=Y("outputData",a,r,4),f=H("aData",t[1].dataType,t[1].dims,4),h=H("bData",t[2].dataType,t[2].dims,4),c=H("cData",t[0].dataType,t[0].dims,4),C,b=($,S,x)=>`select(${S}, ${$}, ${x})`;if(!o)C=d.setByOffset("global_idx",b(f.getByOffset("global_idx"),h.getByOffset("global_idx"),c.getByOffset("global_idx")));else{let $=(S,x,A="")=>{let k=`aData[indexA${x}][componentA${x}]`,O=`bData[indexB${x}][componentB${x}]`,P=`bool(cData[indexC${x}] & ${4278190080>>>(3-x)*8}u)`;return`\n            let outputIndices${x} = ${d.offsetToIndices(`global_idx * 4u + ${x}u`)};\n            let offsetA${x} = ${f.broadcastedIndicesToOffset(`outputIndices${x}`,d)};\n            let offsetB${x} = ${h.broadcastedIndicesToOffset(`outputIndices${x}`,d)};\n            let offsetC${x} = ${c.broadcastedIndicesToOffset(`outputIndices${x}`,d)};\n            let indexA${x} = offsetA${x} / 4u;\n            let indexB${x} = offsetB${x} / 4u;\n            let indexC${x} = offsetC${x} / 4u;\n            let componentA${x} = offsetA${x} % 4u;\n            let componentB${x} = offsetB${x} % 4u;\n            ${S}[${x}] = ${A}(${b(k,O,P)});\n          `};a===9?C=`\n            var data = vec4<u32>(0);\n            ${$("data",0,"u32")}\n            ${$("data",1,"u32")}\n            ${$("data",2,"u32")}\n            ${$("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:C=`\n            ${$("outputData[global_idx]",0)}\n            ${$("outputData[global_idx]",1)}\n            ${$("outputData[global_idx]",2)}\n            ${$("outputData[global_idx]",3)}\n          `}return`\n        ${e.declareVariables(c,f,h,d)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n        ${C}\n      }`},Fd=e=>{let t=e[1].dims,r=e[2].dims,o=e[0].dims,a=e[1].dataType,u=!(z.areEqual(t,r)&&z.areEqual(r,o)),i=t,d=z.size(t);if(u){let f=st.calcShape(st.calcShape(t,r,!1),o,!1);if(!f)throw new Error("Can\'t perform where op on the given tensors");i=f,d=z.size(i)}return{name:"Where",getShaderSource:f=>Gd(f,e,i,u,a),getRunData:()=>({outputs:[{dims:i,dataType:a}],dispatchGroup:{x:Math.ceil(d/64/4)}})}},Au=e=>{e.compute(Fd(e.inputs))}});var Tu,Ou=K(()=>{"use strict";Fa();Ha();Ci();Bi();zi();qn();Xi();ts();os();ss();cs();fs();gs();ws();$s();Cs();Vs();au();jr();uu();du();hu();bu();$u();Cu();gr();Fn();Iu();Tu=new Map([["Abs",[ja]],["Acos",[qa]],["Acosh",[Ka]],["Add",[Ai]],["ArgMax",[Ga,Nn]],["ArgMin",[Na,Nn]],["Asin",[Ya]],["Asinh",[Ja]],["Atan",[Xa]],["Atanh",[Za]],["AveragePool",[_s,Es]],["BiasAdd",[La]],["BiasSplitGelu",[Si]],["Cast",[ei,Qa]],["Ceil",[ri]],["ClipV10",[Gn]],["Clip",[ti]],["Concat",[Di,Wi]],["Conv",[Yn,Kn]],["ConvTranspose",[Ji,Yi]],["Cos",[ni]],["Cosh",[oi]],["Div",[Ii]],["Einsum",[Qi,es]],["Elu",[ai,Kr]],["Equal",[Ti]],["Erf",[ii]],["Exp",[si]],["Expand",[ns]],["Floor",[ui]],["FusedConv",[Yn,Kn]],["Gather",[is,as]],["GatherElements",[ls,us]],["Gelu",[li]],["Gemm",[ds,ps]],["GlobalAveragePool",[Ms,Rs]],["GlobalMaxPool",[zs,Ws]],["Greater",[Pi]],["GreaterOrEqual",[Mi]],["InstanceNormalization",[hs,ms]],["LayerNormalization",[bs,ys]],["LeakyRelu",[ci,Kr]],["Less",[Ri]],["LessOrEqual",[ki]],["Log",[xi]],["MatMul",[vs]],["MaxPool",[Bs,Ds]],["Mul",[Oi]],["Neg",[pi]],["Not",[di]],["Pad",[xs,Ss]],["Pow",[Ei]],["Range",[ou]],["Reciprocal",[fi]],["ReduceMin",[ka,rt]],["ReduceMean",[Ea,rt]],["ReduceMax",[Ma,rt]],["ReduceSum",[Da,rt]],["ReduceProd",[Ba,rt]],["ReduceL1",[_a,rt]],["ReduceL2",[Pa,rt]],["ReduceLogSum",[za,rt]],["ReduceLogSumExp",[Ra,rt]],["ReduceSumSquare",[Wa,rt]],["Relu",[mi]],["Resize",[iu,su]],["Sigmoid",[hi]],["Sin",[gi]],["Sinh",[yi]],["Slice",[fu,mu]],["SkipLayerNormalization",[lu,cu]],["Split",[wu,vu]],["Sqrt",[bi]],["Softmax",[gu,yu]],["Sub",[_i]],["Tan",[wi]],["Tanh",[vi]],["ThresholdedRelu",[$i,Kr]],["Tile",[Su]],["Transpose",[ga,ya]],["Where",[Au]]])});var un,Eu=K(()=>{"use strict";We();St();$e();un=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,o,a,u,i,d){let f=this.backend.device,h=this.backend.getComputePassEncoder();h.setPipeline(t.computePipeline);let c=[];for(let b of a)c.push({binding:c.length,resource:{buffer:b.buffer}});for(let b of u)c.push({binding:c.length,resource:{buffer:b.buffer}});d&&c.push({binding:c.length,resource:d});let C=f.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:c,label:t.programInfo.name});if(h.setBindGroup(0,C),h.dispatchWorkgroups(...i),this.backend.pendingDispatchNumber++,this.backend.isQueryEnabled()){typeof this.backend.queryData>"u"&&(this.backend.queryData=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let b=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.querySet,0,2,this.backend.queryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.queryData.buffer,0,b.buffer,0,this.backend.querySetCount*8),this.backend.flush();let $=this.backend.currentKernelId,S=this.backend.kernels.get($),x=`[${S[0]}] ${S[1]}`;b.buffer.mapAsync(GPUMapMode.READ).then(()=>{let A=new BigUint64Array(b.buffer.getMappedRange()),k=A[0],O=A[1];b.buffer.unmap(),typeof this.backend.queryTimeBase>"u"&&(this.backend.queryTimeBase=k);let P=Number(k-this.backend.queryTimeBase),R=Number(O-this.backend.queryTimeBase);if(!Number.isSafeInteger(P)||!Number.isSafeInteger(R))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(b.id);let V="";r.forEach((W,q)=>{V+=`input[${q}]: [${W.dims}] | ${fr(W.dataType)}, `});let B="";o.forEach((W,q)=>{B+=`output[${q}]: [${W.dims}] | ${fr(W.dataType)}, `}),console.log(`[profiling] kernel "${$}|${x}" ${V}${B}execution time: ${R-P} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(t,r){let o=this.backend.device,a=[];o.features.has("shader-f16")&&a.push("enable f16;");let u=ma(r),i=t.getShaderSource(u),d=`${a.join(`\n`)}\n${u.additionalImplementations}\n${i}`,f=o.createShaderModule({code:d,label:t.name});Ee("verbose",()=>`[WebGPU] ${t.name} shader code: ${d}`);let h=o.createComputePipeline({compute:{module:f,entryPoint:"main"},layout:"auto",label:t.name});return{programInfo:t,computePipeline:h}}normalizeDispatchGroupSize(t){let r=typeof t=="number"?t:t.x,o=typeof t=="number"?1:t.y||1,a=typeof t=="number"?1:t.z||1,u=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=u&&o<=u&&a<=u)return[r,o,a];let i=r*o*a,d=Math.ceil(Math.sqrt(i));if(d>u){if(d=Math.ceil(Math.cbrt(i)),d>u)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[d,d,d]}else return[d,d,1]}}});var Ld,Hd,ln,_u=K(()=>{"use strict";St();sa();da();Ou();Eu();Ld=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let o=0;o<e.length;++o){let a=e[o].dataType;switch(t[o]){case"none":{r.push("");break}case"type":{r.push(`${a}`);break}case"rank":{let u=e[o].dims.length;r.push(`${a};${u}`);break}case"dims":{let u=e[o].dims.join(",");r.push(`${a};${u}`);break}default:throw new Error(`unsupported input dependency: ${t[o]}`)}}return r.join("|")},Hd=(e,t,r)=>{let o=e.name;return e.shaderCache?.hint&&(o+="["+e.shaderCache.hint+"]"),o+=":"+r+`:${Ld(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,o},ln=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.querySetCount=2;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let r=await navigator.gpu.requestAdapter();if(!r)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=t;let o=[],a={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:o};r.features.has("timestamp-query")&&o.push("timestamp-query"),r.features.has("shader-f16")&&o.push("shader-f16"),this.device=await r.requestDevice(a),this.gpuDataManager=ca(this),this.programManager=new un(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,aa(t.logLevel,!!t.debug),this.device.onuncapturederror=u=>{u.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${u.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t={};this.isQueryEnabled()&&(typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}isQueryEnabled(){return!!(this.device.features.has("timestamp-query")&&this.env.webgpu.profilingMode==="default")}run(t,r,o,a,u){let i=[];for(let O=0;O<r.length;++O){let P=this.gpuDataManager.get(r[O].data);if(!P)throw new Error(`no GPU data for input: ${r[O].data}`);i[O]=P}let{outputs:d,dispatchGroup:f,programUniforms:h}=t.getRunData(r),c=o.length===0?d.map((O,P)=>P):o;if(c.length!==d.length)throw new Error(`Output size ${c.length} must be equal to ${d.length}.`);let C=[],b=[];for(let O=0;O<d.length;++O){if(!Number.isInteger(c[O])||c[O]<-3||c[O]>=d.length)throw new Error(`Invalid output index: ${c[O]}`);if(c[O]===-3)continue;let P=c[O]===-1,R=c[O]===-2,V=P||R?u(d[O].dataType,d[O].dims):a(c[O],d[O].dataType,d[O].dims),B=this.gpuDataManager.get(V.data);if(!B)throw new Error(`no GPU data for output: ${V.data}`);if(P&&this.temporaryData.push(B),R){let W=this.kernelPersistentData.get(this.currentKernelId);W||(W=[],this.kernelPersistentData.set(this.currentKernelId,W)),W.push(B)}C.push(V),b.push(B)}let $;if(h){let O=0,P=0,R=[],V=1;h.forEach(q=>{let ee=typeof q.data=="number"?[q.data]:q.data;if(ee.length===0)return;let oe;switch(ee.length){case 1:oe=4;break;case 2:oe=8;break;case 3:oe=16;break;case 4:oe=16;break;case 5:oe=16;break;case 6:oe=16;break;default:throw new Error(`unsupported data length: ${ee.length}`)}(P===5||P===6)&&(oe=16),oe>V&&(V=oe),O=Math.ceil(O/oe)*oe,P=ee.length,R.push(O),O+=ee.length*4}),O=Math.ceil(O/V)*V;let B=new ArrayBuffer(O);h.forEach((q,ee)=>{let oe=R[ee],D=typeof q.data=="number"?[q.data]:q.data;q.type==="int32"?new Int32Array(B,oe,D.length).set(D):q.type==="uint32"?new Uint32Array(B,oe,D.length).set(D):new Float32Array(B,oe,D.length).set(D)});let W=this.gpuDataManager.create(O,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(W.buffer,0,B,0,O),this.gpuDataManager.release(W.id),$={offset:0,size:O,buffer:W.buffer}}let S=this.programManager.normalizeDispatchGroupSize(f),x=S[1]===1&&S[2]===1,A=Hd(t,r,x),k=this.programManager.getArtifact(A);return k||(k=this.programManager.build(t,S),this.programManager.setArtifact(A,k)),Ee("info",()=>`[ProgramManager] run "${t.name}" (key=${A}) with ${S[0]}x${S[1]}x${S[2]}`),this.programManager.run(k,r,C,i,b,S,$),C}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,o,a){let u=Tu.get(t);if(!u)throw new Error(`kernel not implemented: ${t}`);this.kernels.set(r,[t,a,u[0],[u[1],o]])}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let o of r)this.gpuDataManager.release(o.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,o){let a=this.kernels.get(t);if(!a)throw new Error(`kernel not created: ${t}`);let[u,i,d,f]=a;if(this.currentKernelId!==null)throw new Error(`kernel "[${u}] ${i}" is not allowed to be called recursively`);this.currentKernelId=t,f[0]&&(f[1]=f[0](f[1]),f[0]=void 0),Ee("info",()=>`[WebGPU] Start to run kernel "[${u}] ${i}"...`);let h=this.env.debug;this.temporaryData=[];try{return h&&this.device.pushErrorScope("validation"),d(r,f[1]),0}catch(c){return o.push(Promise.resolve(`[WebGPU] Kernel "[${u}] ${i}" failed. ${c}`)),1}finally{h&&o.push(this.device.popErrorScope().then(c=>c?`GPU validation error for kernel "[${u}] ${i}": ${c.message}`:null));for(let c of this.temporaryData)this.gpuDataManager.release(c.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,o,a){let u=this.sessionExternalDataMapping.get(t);u||(u=new Map,this.sessionExternalDataMapping.set(t,u));let i=u.get(r),d=this.gpuDataManager.registerExternalBuffer(o,a,i?.[1]);return u.set(r,[d,o]),d}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(o=>this.gpuDataManager.unregisterExternalBuffer(o[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,o){return async()=>{let a=await Bn(this,t,r);return ia(a.buffer,o)}}}});var Pu={};Vr(Pu,{init:()=>jd});var vr,to,jd,Ru=K(()=>{"use strict";We();_u();St();ge();vr=class e{constructor(t,r,o,a){this.module=t;this.dataType=r;this.data=o;this.dims=a}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=z.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=z.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=z.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(z.size(t)!==z.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},to=class{constructor(t,r,o){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;let a=t.HEAPU32,u=o>>2;this.opKernelContext=a[u++];let i=a[u++];this.outputCount=a[u++],this.customDataOffset=a[u++],this.customDataSize=a[u++];let d=[];for(let f=0;f<i;f++){let h=a[u++],c=a[u++],C=a[u++],b=[];for(let $=0;$<C;$++)b.push(a[u++]);d.push(new vr(t,h,c,b))}this.inputs=d}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,r){let o=r?.inputs?.map(d=>typeof d=="number"?this.inputs[d]:d)??this.inputs,a=r?.outputs??[],u=(d,f,h)=>new vr(this.module,f,this.output(d,h),h),i=(d,f)=>{let h=mr(d);if(!h)throw new Error(`Unsupported data type: ${d}`);let c=h*z.size(f);return new vr(this.module,d,this.backend.gpuDataManager.create(c).id,f)};return this.backend.run(t,o,a,u,i)}output(t,r){let o=this.module.stackSave();try{let a=this.module.stackAlloc((1+r.length)*4),u=a>>2;this.module.HEAPU32[u++]=r.length;for(let i=0;i<r.length;i++)this.module.HEAPU32[u++]=r[i];return this.module._JsepOutput(this.opKernelContext,t,a)}catch(a){throw new Error(`Failed to generate kernel\'s output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${a}`)}finally{this.module.stackRestore(o)}}},jd=async(e,t)=>{let r=e.jsepInit;if(r&&navigator.gpu){if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let o=new ln;await o.initialize(t),r(o,a=>o.alloc(a),a=>o.free(a),(a,u,i,d=!1)=>{if(d)Ee("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${a}, dst=${u}, size=${i}`),o.memcpy(a,u);else{Ee("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${a}, gpuDataId=${u}, size=${i}`);let f=e.HEAPU8.subarray(a,a+i);o.upload(u,f)}},async(a,u,i)=>{Ee("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${a}, dataOffset=${u}, size=${i}`),await o.download(a,()=>e.HEAPU8.subarray(u,u+i))},(a,u,i)=>o.createKernel(a,u,i,t.debug||t.webgpu.profilingMode==="default"?e.UTF8ToString(e._JsepGetNodeName(u)):`${u}`),a=>o.releaseKernel(a),(a,u,i,d)=>{Ee("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${i}, kernel=${a}, contextDataOffset=${u}`);let f=new to(e,o,u);return o.computeKernel(a,f,d)})}}});var Zo;Zo=Go();var yl=Yo(),_n,Pn=!1,Ur=!1,Xo=!1,bl=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},wl=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},vl=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Qo=async e=>{if(Pn)return Promise.resolve();if(Ur)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(Xo)throw new Error("previous call to \'initializeWebAssembly()\' failed.");Ur=!0;let t=e.initTimeout,r=e.numThreads,o=e.simd,a=r>1&&bl(),u=o&&wl(),i=e.wasmPaths,d=typeof i=="string"?i:void 0,f=vl(u,a),h=typeof i=="object"?i[f]:void 0,c=!1,C=[];if(t>0&&C.push(new Promise(b=>{setTimeout(()=>{c=!0,b()},t)})),C.push(new Promise((b,$)=>{let S=a?yl:Zo,x={locateFile:(A,k)=>{if(a&&A.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Jo()],{type:"text/javascript"}));if(A.endsWith(".wasm")){if(h)return h;let O=d??k;return f==="ort-wasm-simd.wasm"?O+"ort-wasm-simd.jsep.wasm":f==="ort-wasm-simd-threaded.wasm"?O+"ort-wasm-simd-threaded.jsep.wasm":O+f}return k+A}};if(a)if(typeof Blob>"u")x.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let A=`var ortWasmThreaded=${S.toString()};`;x.mainScriptUrlOrBlob=new Blob([A],{type:"text/javascript"})}S(x).then(A=>{Ur=!1,Pn=!0,_n=A,b()},A=>{Ur=!1,Xo=!0,$(A)})})),await Promise.race(C),c)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},_e=()=>{if(Pn&&_n)return _n;throw new Error("WebAssembly is not initialized yet.")};var Re=(e,t)=>{let r=_e(),o=r.lengthBytesUTF8(e)+1,a=r._malloc(o);return r.stringToUTF8(e,a,o),t.push(a),a},pr=(e,t,r,o)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([a,u])=>{let i=t?t+a:a;if(typeof u=="object")pr(u,i+".",r,o);else if(typeof u=="string"||typeof u=="number")o(i,u.toString());else if(typeof u=="boolean")o(i,u?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof u}`)})},Ae=e=>{let t=_e(),r=t.stackSave();try{let o=t.stackAlloc(8);t._OrtGetLastError(o,o+4);let a=t.HEAP32[o/4],u=t.HEAPU32[o/4+1],i=u?t.UTF8ToString(u):"";throw new Error(`${e} ERROR_CODE: ${a}, ERROR_MESSAGE: ${i}`)}finally{t.stackRestore(r)}};var ea=e=>{let t=_e(),r=0,o=[],a=e||{};try{if(e?.logSeverityLevel===void 0)a.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)a.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(a.terminate=!1);let u=0;return e?.tag!==void 0&&(u=Re(e.tag,o)),r=t._OrtCreateRunOptions(a.logSeverityLevel,a.logVerbosityLevel,!!a.terminate,u),r===0&&Ae("Can\'t create run options."),e?.extra!==void 0&&pr(e.extra,"",new WeakSet,(i,d)=>{let f=Re(i,o),h=Re(d,o);t._OrtAddRunConfigEntry(r,f,h)!==0&&Ae(`Can\'t set a run config entry: ${i} - ${d}.`)}),[r,o]}catch(u){throw r!==0&&t._OrtReleaseRunOptions(r),o.forEach(i=>t._free(i)),u}};var $l=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},xl=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Sl=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},Cl=(e,t,r)=>{for(let o of t){let a=typeof o=="string"?o:o.name;switch(a){case"xnnpack":a="XNNPACK";break;case"webnn":if(a="WEBNN",typeof o!="string"){let i=o;if(i?.deviceType){let d=Re("deviceType",r),f=Re(i.deviceType,r);_e()._OrtAddSessionConfigEntry(e,d,f)!==0&&Ae(`Can\'t set a session config entry: \'deviceType\' - ${i.deviceType}.`)}if(i?.numThreads){let d=i.numThreads;(typeof d!="number"||!Number.isInteger(d)||d<0)&&(d=0);let f=Re("numThreads",r),h=Re(d.toString(),r);_e()._OrtAddSessionConfigEntry(e,f,h)!==0&&Ae(`Can\'t set a session config entry: \'numThreads\' - ${i.numThreads}.`)}if(i?.powerPreference){let d=Re("powerPreference",r),f=Re(i.powerPreference,r);_e()._OrtAddSessionConfigEntry(e,d,f)!==0&&Ae(`Can\'t set a session config entry: \'powerPreference\' - ${i.powerPreference}.`)}}break;case"webgpu":if(a="JS",typeof o!="string"){let i=o;if(i?.preferredLayout){if(i.preferredLayout!=="NCHW"&&i.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${i.preferredLayout}`);let d=Re("preferredLayout",r),f=Re(i.preferredLayout,r);_e()._OrtAddSessionConfigEntry(e,d,f)!==0&&Ae(`Can\'t set a session config entry: \'preferredLayout\' - ${i.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${a}`)}let u=Re(a,r);_e()._OrtAppendExecutionProvider(e,u)!==0&&Ae(`Can\'t append execution provider: ${a}.`)}},ta=e=>{let t=_e(),r=0,o=[],a=e||{};Sl(a);try{let u=$l(a.graphOptimizationLevel??"all"),i=xl(a.executionMode??"sequential"),d=typeof a.logId=="string"?Re(a.logId,o):0,f=a.logSeverityLevel??2;if(!Number.isInteger(f)||f<0||f>4)throw new Error(`log serverity level is not valid: ${f}`);let h=a.logVerbosityLevel??0;if(!Number.isInteger(h)||h<0||h>4)throw new Error(`log verbosity level is not valid: ${h}`);let c=typeof a.optimizedModelFilePath=="string"?Re(a.optimizedModelFilePath,o):0;if(r=t._OrtCreateSessionOptions(u,!!a.enableCpuMemArena,!!a.enableMemPattern,i,!!a.enableProfiling,0,d,f,h,c),r===0&&Ae("Can\'t create session options."),a.executionProviders&&Cl(r,a.executionProviders,o),a.freeDimensionOverrides)for(let[C,b]of Object.entries(a.freeDimensionOverrides)){if(typeof C!="string")throw new Error(`free dimension override name must be a string: ${C}`);if(typeof b!="number"||!Number.isInteger(b)||b<0)throw new Error(`free dimension override value must be a non-negative integer: ${b}`);let $=Re(C,o);t._OrtAddFreeDimensionOverride(r,$,b)!==0&&Ae(`Can\'t set a free dimension override: ${C} - ${b}.`)}return a.extra!==void 0&&pr(a.extra,"",new WeakSet,(C,b)=>{let $=Re(C,o),S=Re(b,o);t._OrtAddSessionConfigEntry(r,$,S)!==0&&Ae(`Can\'t set a session config entry: ${C} - ${b}.`)}),[r,o]}catch(u){throw r!==0&&t._OrtReleaseSessionOptions(r),o.forEach(i=>t._free(i)),u}};We();var ku=!1,qd=e=>{let t=_e(),r=t.stackSave();try{let o=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,o,o+4)!==0&&Ae("Can\'t get session input/output count."),[t.HEAP32[o/4],t.HEAP32[o/4+1]]}finally{t.stackRestore(r)}},Kd=(e,t)=>{_e()._OrtInit(e,t)!==0&&Ae("Can\'t initialize onnxruntime.")},Bu=async e=>{Kd(e.wasm.numThreads,hr(e.logLevel));{let t=(Ru(),qt(Pu)).init;await t(_e(),e)}ku=!0},$r=new Map,Du=()=>ku,ro=e=>{let t=_e(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},no=(e,t)=>{let r=_e(),o=0,a=0,u=0,i=[],d=[],f=[];try{[a,i]=ta(t),o=r._OrtCreateSession(e[0],e[1],a),o===0&&Ae("Can\'t create a session.");let[h,c]=qd(o),C=[],b=[],$=[];for(let x=0;x<h;x++){let A=r._OrtGetInputName(o,x);A===0&&Ae("Can\'t get an input name."),d.push(A),C.push(r.UTF8ToString(A))}for(let x=0;x<c;x++){let A=r._OrtGetOutputName(o,x);A===0&&Ae("Can\'t get an output name."),f.push(A);let k=r.UTF8ToString(A);b.push(k);{let O=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[k]??"cpu";if(O!=="cpu"&&O!=="cpu-pinned"&&O!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${O}.`);$.push(O)}}let S=null;return $.some(x=>x==="gpu-buffer")&&(u=r._OrtCreateBinding(o),u===0&&Ae("Can\'t create IO binding."),S={handle:u,outputPreferredLocations:$,outputPreferredLocationsEncoded:$.map(x=>Mn(x))}),$r.set(o,[o,d,f,S]),[o,C,b]}catch(h){throw d.forEach(c=>r._OrtFree(c)),f.forEach(c=>r._OrtFree(c)),u!==0&&r._OrtReleaseBinding(u),o!==0&&r._OrtReleaseSession(o),h}finally{r._free(e[0]),a!==0&&r._OrtReleaseSessionOptions(a),i.forEach(h=>r._free(h))}},Wu=(e,t)=>{let r=ro(e);return no(r,t)},zu=e=>{let t=_e(),r=$r.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[o,a,u,i]=r;i&&t._OrtReleaseBinding(i.handle),t.jsepUnregisterBuffers?.(e),a.forEach(d=>t._OrtFree(d)),u.forEach(d=>t._OrtFree(d)),t._OrtReleaseSession(o),$r.delete(e)},Mu=(e,t,r,o,a)=>{if(!e){t.push(0);return}let u=_e(),i=e[0],d=e[1],f=e[3],h,c;if(i==="string"&&f==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(f==="gpu-buffer"){let $=e[2].gpuBuffer,S=mr(Rn(i));c=d.reduce((x,A)=>x*A,1)*S,h=u.jsepRegisterBuffer(o,a,$,c)}else{let $=e[2];if(Array.isArray($)){c=4*$.length,h=u._malloc(c),r.push(h);let S=h/4;for(let x=0;x<$.length;x++){if(typeof $[x]!="string")throw new TypeError(`tensor data at index ${x} is not a string`);u.HEAPU32[S++]=Re($[x],r)}}else c=$.byteLength,h=u._malloc(c),r.push(h),u.HEAPU8.set(new Uint8Array($.buffer,$.byteOffset,c),h)}let C=u.stackSave(),b=u.stackAlloc(4*d.length);try{let $=b/4;d.forEach(x=>u.HEAP32[$++]=x);let S=u._OrtCreateTensor(Rn(i),h,c,b,d.length,Mn(f));S===0&&Ae(`Can\'t create tensor for input/output. session=${o}, index=${a}.`),t.push(S)}finally{u.stackRestore(C)}},Vu=async(e,t,r,o,a,u)=>{let i=_e(),d=$r.get(e);if(!d)throw new Error(`cannot run inference. invalid session id: ${e}`);let[f,h,c,C]=d,b=t.length,$=o.length,S=0,x=[],A=[],k=[],O=[],P=i.stackSave(),R=i.stackAlloc(b*4),V=i.stackAlloc(b*4),B=i.stackAlloc($*4),W=i.stackAlloc($*4);try{[S,x]=ea(u);for(let Z=0;Z<b;Z++)Mu(r[Z],A,O,e,t[Z]);for(let Z=0;Z<$;Z++)Mu(a[Z],k,O,e,b+o[Z]);let q=R/4,ee=V/4,oe=B/4,D=W/4;for(let Z=0;Z<b;Z++)i.HEAPU32[q++]=A[Z],i.HEAPU32[ee++]=h[t[Z]];for(let Z=0;Z<$;Z++)i.HEAPU32[oe++]=k[Z],i.HEAPU32[D++]=c[o[Z]];if(C){let{handle:Z,outputPreferredLocations:ve,outputPreferredLocationsEncoded:Te}=C;if(h.length!==b)throw new Error(`input count from feeds (${b}) is expected to be always equal to model\'s input count (${h.length}).`);for(let be=0;be<b;be++){let Be=t[be];await i._OrtBindInput(Z,h[Be],A[be])!==0&&Ae(`Can\'t bind input[${be}] for session=${e}.`)}for(let be=0;be<$;be++){let Be=o[be];a[be]?.[3]?i._OrtBindOutput(Z,c[Be],k[be],0)!==0&&Ae(`Can\'t bind pre-allocated output[${be}] for session=${e}.`):i._OrtBindOutput(Z,c[Be],0,Te[Be])!==0&&Ae(`Can\'t bind output[${be}] to ${ve[be]} for session=${e}.`)}}let te;C?te=await i._OrtRunWithBinding(f,C.handle,$,B,S):te=await i._OrtRun(f,V,R,b,W,$,B,S),te!==0&&Ae("failed to call OrtRun().");let Ie=[];for(let Z=0;Z<$;Z++){let ve=i.HEAPU32[B/4+Z];if(ve===k[Z]){Ie.push(a[Z]);continue}let Te=i.stackSave(),be=i.stackAlloc(4*4),Be=!1,Se,Ue=0;try{i._OrtGetTensorData(ve,be,be+4,be+8,be+12)!==0&&Ae(`Can\'t access output tensor data on index ${Z}.`);let Ke=be/4,Ye=i.HEAPU32[Ke++];Ue=i.HEAPU32[Ke++];let G=i.HEAPU32[Ke++],pe=i.HEAPU32[Ke++],de=[];for(let Ce=0;Ce<pe;Ce++)de.push(i.HEAPU32[G/4+Ce]);i._OrtFree(G);let Ne=de.reduce((Ce,Pe)=>Ce*Pe,1);Se=fr(Ye);let Ge=C?.outputPreferredLocations[o[Z]];if(Se==="string"){if(Ge==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Ce=[],Pe=Ue/4;for(let vt=0;vt<Ne;vt++){let He=i.HEAPU32[Pe++],zt=vt===Ne-1?void 0:i.HEAPU32[Pe]-He;Ce.push(i.UTF8ToString(He,zt))}Ie.push([Se,de,Ce,"cpu"])}else if(Ge==="gpu-buffer"&&Ne>0){let Ce=i.jsepGetBuffer(Ue),Pe=mr(Ye);if(Pe===void 0||!ra(Se))throw new Error(`Unsupported data type: ${Se}`);Be=!0,Ie.push([Se,de,{gpuBuffer:Ce,download:i.jsepCreateDownloader(Ce,Ne*Pe,Se),dispose:()=>{i._OrtReleaseTensor(ve)}},"gpu-buffer"])}else{let Ce=Nr(Se),Pe=new Ce(Ne);new Uint8Array(Pe.buffer,Pe.byteOffset,Pe.byteLength).set(i.HEAPU8.subarray(Ue,Ue+Pe.byteLength)),Ie.push([Se,de,Pe,"cpu"])}}finally{i.stackRestore(Te),Se==="string"&&Ue&&i._free(Ue),Be||i._OrtReleaseTensor(ve)}}return C&&i._OrtClearBoundOutputs(C.handle),Ie}finally{i.stackRestore(P),A.forEach(q=>i._OrtReleaseTensor(q)),k.forEach(q=>i._OrtReleaseTensor(q)),O.forEach(q=>i._free(q)),S!==0&&i._OrtReleaseRunOptions(S),x.forEach(q=>i._free(q))}},Uu=e=>{let t=_e(),r=$r.get(e);if(!r)throw new Error("invalid session id");let o=r[0],a=t._OrtEndProfiling(o);a===0&&Ae("Can\'t get an profile file name."),t._OrtFree(a)},Nu=e=>{let t=[];for(let r of e){let o=r[2];!Array.isArray(o)&&"buffer"in o&&t.push(o.buffer)}return t};self.onmessage=e=>{switch(e.data.type){case"init-wasm":try{Qo(e.data.in).then(()=>postMessage({type:"init-wasm"}),t=>postMessage({type:"init-wasm",err:t}))}catch(t){postMessage({type:"init-wasm",err:t})}break;case"init-ort":try{Bu(e.data.in).then(()=>postMessage({type:"init-ort"}),t=>postMessage({type:"init-ort",err:t}))}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{let{model:t}=e.data.in,r=ro(t);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{let{modeldata:t,options:r}=e.data.in,o=no(t,r);postMessage({type:"create_finalize",out:o})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{let{model:t,options:r}=e.data.in,o=Wu(t,r);postMessage({type:"create",out:o})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{let t=e.data.in;zu(t),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{let{sessionId:t,inputIndices:r,inputs:o,outputIndices:a,options:u}=e.data.in;Vu(t,r,o,a,u).then(i=>{postMessage({type:"run",out:i},Nu(i))},i=>{postMessage({type:"run",err:i})})}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{let t=e.data.in;Uu(t),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}break;case"is-ort-env-initialized":try{let t=Du();postMessage({type:"is-ort-env-initialized",out:t})}catch(t){postMessage({type:"is-ort-env-initialized",err:t})}break;default:}};})();\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n'});var Ct,Ke,Tn,Wa,Va,Ta,Ea,Ra,Pa,ka,Ba,Ma,Da,za,Bt,sf,On,zl,Wl,Vl,Nl,Na,Ul,Gl,Fl,Ll,Ua=j(()=>{"use strict";Tt();Ml();or();Ct=()=>!!Ie.wasm.proxy&&typeof document<"u",Tn=!1,Wa=!1,Va=!1,Ra=[],Pa=[],ka=[],Ba=[],Ma=[],Da=[],za=[],Bt=()=>{if(Tn||!Wa||Va||!Ke)throw new Error("worker not ready")},sf=e=>{switch(e.data.type){case"init-wasm":Tn=!1,e.data.err?(Va=!0,Ta[1](e.data.err)):(Wa=!0,Ta[0]());break;case"init-ort":e.data.err?Ea[1](e.data.err):Ea[0]();break;case"create_allocate":e.data.err?Ra.shift()[1](e.data.err):Ra.shift()[0](e.data.out);break;case"create_finalize":e.data.err?Pa.shift()[1](e.data.err):Pa.shift()[0](e.data.out);break;case"create":e.data.err?ka.shift()[1](e.data.err):ka.shift()[0](e.data.out);break;case"release":e.data.err?Ba.shift()[1](e.data.err):Ba.shift()[0]();break;case"run":e.data.err?Ma.shift()[1](e.data.err):Ma.shift()[0](e.data.out);break;case"end-profiling":e.data.err?Da.shift()[1](e.data.err):Da.shift()[0]();break;case"is-ort-env-initialized":e.data.err?za.shift()[1](e.data.err):za.shift()[0](e.data.out);break;default:}},On=typeof document<"u"?document?.currentScript?.src:void 0,zl=async()=>{if(Ct()){if(Wa)return;if(Tn)throw new Error("multiple calls to 'initWasm()' detected.");if(Va)throw new Error("previous call to 'initWasm()' failed.");return Tn=!0,Ie.wasm.wasmPaths===void 0&&On&&On.indexOf("blob:")!==0&&(Ie.wasm.wasmPaths=On.substr(0,+On.lastIndexOf("/")+1)),new Promise((e,t)=>{Ke?.terminate();let r=URL.createObjectURL(new Blob([Dl()],{type:"text/javascript"}));Ke=new Worker(r,{name:"ort-wasm-proxy-worker"}),Ke.onerror=o=>t(o),Ke.onmessage=sf,URL.revokeObjectURL(r),Ta=[e,t];let a={type:"init-wasm",in:Ie.wasm};Ke.postMessage(a)})}else return li(Ie.wasm)},Wl=async e=>{if(Ct())return Bt(),new Promise((t,r)=>{Ea=[t,r];let a={type:"init-ort",in:e};Ke.postMessage(a)});await Ol(e)},Vl=async e=>Ct()?(Bt(),new Promise((t,r)=>{Ra.push([t,r]);let a={type:"create_allocate",in:{model:e}};Ke.postMessage(a,[e.buffer])})):_a(e),Nl=async(e,t)=>Ct()?(Bt(),new Promise((r,a)=>{Pa.push([r,a]);let o={type:"create_finalize",in:{modeldata:e,options:t}};Ke.postMessage(o)})):Oa(e,t),Na=async(e,t)=>{if(Ct()){if(t?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Bt(),new Promise((r,a)=>{ka.push([r,a]);let o={type:"create",in:{model:e,options:t}};Ke.postMessage(o,[e.buffer])})}else return El(e,t)},Ul=async e=>{if(Ct())return Bt(),new Promise((t,r)=>{Ba.push([t,r]);let a={type:"release",in:e};Ke.postMessage(a)});Rl(e)},Gl=async(e,t,r,a,o,u)=>{if(Ct()){if(r.some(i=>i[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(o.some(i=>i))throw new Error("pre-allocated output tensor is not supported for proxy.");return Bt(),new Promise((i,l)=>{Ma.push([i,l]);let p=r,m={type:"run",in:{sessionId:e,inputIndices:t,inputs:p,outputIndices:a,options:u}};Ke.postMessage(m,Bl(p))})}else return Pl(e,t,r,a,o,u)},Fl=async e=>{if(Ct())return Bt(),new Promise((t,r)=>{Da.push([t,r]);let a={type:"end-profiling",in:e};Ke.postMessage(a)});kl(e)},Ll=async()=>Ct()?(Bt(),new Promise((e,t)=>{za.push([e,t]);let r={type:"is-ort-env-initialized"};Ke.postMessage(r)})):Tl()});var En,Hl,uf,Rn,jl=j(()=>{"use strict";Tt();Ua();We();Hl=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},uf=e=>{switch(e[3]){case"cpu":return new Ge(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!ln(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:r,download:a,dispose:o}=e[2];return Ge.fromGpuBuffer(r,{dataType:t,dims:e[1],download:a,dispose:o})}default:throw new Error(`invalid data location: ${e[3]}`)}},Rn=class{async createSessionAllocate(t){let r=await fetch(t);if(r.status!==200)throw new Error(`failed to load model: ${t}`);let a=await r.arrayBuffer();return Vl(new Uint8Array(a))}async loadModel(t,r){if(await Ll()||(En||(En=Wl(Ie)),await En,En=void 0),typeof t=="string")if(typeof process<"u"&&process.versions&&process.versions.node){let a=await(void 0)(t);[this.sessionId,this.inputNames,this.outputNames]=await Na(a,r)}else{let a=await this.createSessionAllocate(t);[this.sessionId,this.inputNames,this.outputNames]=await Nl(a,r)}else[this.sessionId,this.inputNames,this.outputNames]=await Na(t,r)}async dispose(){return Ul(this.sessionId)}async run(t,r,a){let o=[],u=[];Object.entries(t).forEach(y=>{let w=y[0],x=y[1],$=this.inputNames.indexOf(w);if($===-1)throw new Error(`invalid input '${w}'`);o.push(x),u.push($)});let i=[],l=[];Object.entries(r).forEach(y=>{let w=y[0],x=y[1],$=this.outputNames.indexOf(w);if($===-1)throw new Error(`invalid output '${w}'`);i.push(x),l.push($)});let p=o.map((y,w)=>Hl(y,()=>`input "${this.inputNames[u[w]]}"`)),m=i.map((y,w)=>y?Hl(y,()=>`output "${this.outputNames[l[w]]}"`):null),d=await Gl(this.sessionId,u,p,l,m,a),v={};for(let y=0;y<d.length;y++)v[this.outputNames[l[y]]]=i[y]??uf(d[y]);return v}startProfiling(){}endProfiling(){Fl(this.sessionId)}}});var lf,Pn,ql=j(()=>{"use strict";Tt();Ua();jl();lf=()=>{if((typeof Ie.wasm.initTimeout!="number"||Ie.wasm.initTimeout<0)&&(Ie.wasm.initTimeout=0),typeof Ie.wasm.simd!="boolean"&&(Ie.wasm.simd=!0),typeof Ie.wasm.proxy!="boolean"&&(Ie.wasm.proxy=!1),typeof Ie.wasm.numThreads!="number"||!Number.isInteger(Ie.wasm.numThreads)||Ie.wasm.numThreads<=0){let e=typeof navigator>"u"?(void 0)().length:navigator.hardwareConcurrency;Ie.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},Pn=class{async init(){lf(),await zl()}async createInferenceSessionHandler(t,r){let a=new Rn;return await a.loadModel(t,r),Promise.resolve(a)}}});var Kl={};ar(Kl,{wasmBackend:()=>df});var df,Yl=j(()=>{"use strict";ql();df=new Pn});Tt();Tt();Tt();var Yo="1.17.0";var Xb=Yn;{let e=(Yl(),Ft(Kl)).wasmBackend;typeof navigator<"u"&&navigator.gpu&&Ot("webgpu",e,5),Ot("cpu",e,10),Ot("wasm",e,10),Ot("xnnpack",e,9),Ot("webnn",e,9)}Object.defineProperty(Ie.versions,"web",{value:Yo,enumerable:!0});export{$d as InferenceSession,Ge as Tensor,Sd as TrainingSession,Xb as default,Ie as env,Ot as registerBackend};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
//# sourceMappingURL=ort.webgpu.min.js.map
