/*!
 * ONNX Runtime Web v1.17.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
"use strict";var ort=(()=>{var m0=Object.create;var Xo=Object.defineProperty;var g0=Object.getOwnPropertyDescriptor;var b0=Object.getOwnPropertyNames;var y0=Object.getPrototypeOf,v0=Object.prototype.hasOwnProperty;var M=(r,e)=>()=>(r&&(e=r(r=0)),e);var He=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),Mr=(r,e)=>{for(var n in e)Xo(r,n,{get:e[n],enumerable:!0})},hl=(r,e,n,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of b0(e))!v0.call(r,o)&&o!==n&&Xo(r,o,{get:()=>e[o],enumerable:!(t=g0(e,o))||t.enumerable});return r};var On=(r,e,n)=>(n=r!=null?m0(y0(r)):{},hl(e||!r||!r.__esModule?Xo(n,"default",{value:r,enumerable:!0}):n,r)),Ar=r=>hl(Xo({},"__esModule",{value:!0}),r);var Yo,rn,ur,Jo,Zo=M(()=>{Yo=new Map,rn=[],ur=(r,e,n)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){let t=Yo.get(r);if(t===void 0)Yo.set(r,{backend:e,priority:n});else{if(t.priority>n)return;if(t.priority===n&&t.backend!==e)throw new Error(`cannot register backend "${r}" using priority ${n}`)}if(n>=0){let o=rn.indexOf(r);o!==-1&&rn.splice(o,1);for(let i=0;i<rn.length;i++)if(Yo.get(rn[i]).priority<=n){rn.splice(i,0,r);return}rn.push(r)}return}throw new TypeError("not a valid backend")},Jo=async r=>{let e=r.length===0?rn:r,n=[];for(let t of e){let o=Yo.get(t);if(o){if(o.initialized)return o.backend;if(o.aborted)continue;let i=!!o.initPromise;try{return i||(o.initPromise=o.backend.init()),await o.initPromise,o.initialized=!0,o.backend}catch(s){i||n.push({name:t,err:s}),o.aborted=!0}finally{delete o.initPromise}}}throw new Error(`no available backend found. ERR: ${n.map(t=>`[${t.name}] ${t.err}`).join(", ")}`)}});var ml=M(()=>{Zo()});var gl,bl=M(()=>{gl="1.17.0"});var yl,ka,vl=M(()=>{bl();yl="warning",ka={wasm:{},webgl:{},webgpu:{},versions:{common:gl},set logLevel(r){if(r!==void 0){if(typeof r!="string"||["verbose","info","warning","error","fatal"].indexOf(r)===-1)throw new Error(`Unsupported logging level: ${r}`);yl=r}},get logLevel(){return yl}};Object.defineProperty(ka,"logLevel",{enumerable:!0})});var we,xl=M(()=>{vl();we=ka});var wl,Tl,$l=M(()=>{wl=(r,e)=>{let n=document.createElement("canvas");n.width=r.dims[3],n.height=r.dims[2];let t=n.getContext("2d");if(t!=null){let o,i;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(o=r.dims[2],i=r.dims[3]):(o=r.dims[3],i=r.dims[2]);let s=e?.format!==void 0?e.format:"RGB",a=e?.norm,u,l;a===void 0||a.mean===void 0?u=[255,255,255,255]:typeof a.mean=="number"?u=[a.mean,a.mean,a.mean,a.mean]:(u=[a.mean[0],a.mean[1],a.mean[2],0],a.mean[3]!==void 0&&(u[3]=a.mean[3])),a===void 0||a.bias===void 0?l=[0,0,0,0]:typeof a.bias=="number"?l=[a.bias,a.bias,a.bias,a.bias]:(l=[a.bias[0],a.bias[1],a.bias[2],0],a.bias[3]!==void 0&&(l[3]=a.bias[3]));let c=i*o,h=0,m=c,b=c*2,x=-1;s==="RGBA"?(h=0,m=c,b=c*2,x=c*3):s==="RGB"?(h=0,m=c,b=c*2):s==="RBG"&&(h=0,b=c,m=c*2);for(let y=0;y<i;y++)for(let T=0;T<o;T++){let E=(r.data[h++]-l[0])*u[0],_=(r.data[m++]-l[1])*u[1],C=(r.data[b++]-l[2])*u[2],D=x===-1?255:(r.data[x++]-l[3])*u[3];t.fillStyle="rgba("+E+","+_+","+C+","+D+")",t.fillRect(T,y,1,1)}return n.toDataURL()}else throw new Error("Can not access image data")},Tl=(r,e)=>{let n=document.createElement("canvas").getContext("2d"),t;if(n!=null){let o,i,s;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(o=r.dims[2],i=r.dims[1],s=r.dims[3]):(o=r.dims[3],i=r.dims[2],s=r.dims[1]);let a=e!==void 0&&e.format!==void 0?e.format:"RGB",u=e?.norm,l,c;u===void 0||u.mean===void 0?l=[255,255,255,255]:typeof u.mean=="number"?l=[u.mean,u.mean,u.mean,u.mean]:(l=[u.mean[0],u.mean[1],u.mean[2],255],u.mean[3]!==void 0&&(l[3]=u.mean[3])),u===void 0||u.bias===void 0?c=[0,0,0,0]:typeof u.bias=="number"?c=[u.bias,u.bias,u.bias,u.bias]:(c=[u.bias[0],u.bias[1],u.bias[2],0],u.bias[3]!==void 0&&(c[3]=u.bias[3]));let h=i*o;if(e!==void 0&&(e.format!==void 0&&s===4&&e.format!=="RGBA"||s===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let m=4,b=0,x=1,y=2,T=3,E=0,_=h,C=h*2,D=-1;a==="RGBA"?(E=0,_=h,C=h*2,D=h*3):a==="RGB"?(E=0,_=h,C=h*2):a==="RBG"&&(E=0,C=h,_=h*2),t=n.createImageData(o,i);for(let z=0;z<i*o;b+=m,x+=m,y+=m,T+=m,z++)t.data[b]=(r.data[E++]-c[0])*l[0],t.data[x]=(r.data[_++]-c[1])*l[1],t.data[y]=(r.data[C++]-c[2])*l[2],t.data[T]=D===-1?255:(r.data[D++]-c[3])*l[3]}else throw new Error("Can not access image data");return t}});var Ba,Sl,Il,Al,_l,Ol=M(()=>{Qo();Ba=(r,e)=>{if(r===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:n,width:t}=e,o=e.norm??{mean:255,bias:0},i,s;typeof o.mean=="number"?i=[o.mean,o.mean,o.mean,o.mean]:i=[o.mean[0],o.mean[1],o.mean[2],o.mean[3]??255],typeof o.bias=="number"?s=[o.bias,o.bias,o.bias,o.bias]:s=[o.bias[0],o.bias[1],o.bias[2],o.bias[3]??0];let a=e.format!==void 0?e.format:"RGBA",u=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",l=n*t,c=u==="RGBA"?new Float32Array(l*4):new Float32Array(l*3),h=4,m=0,b=1,x=2,y=3,T=0,E=l,_=l*2,C=-1;a==="RGB"&&(h=3,m=0,b=1,x=2,y=-1),u==="RGBA"?C=l*3:u==="RBG"?(T=0,_=l,E=l*2):u==="BGR"&&(_=0,E=l,T=l*2);for(let z=0;z<l;z++,m+=h,x+=h,b+=h,y+=h)c[T++]=(r[m]+s[0])/i[0],c[E++]=(r[b]+s[1])/i[1],c[_++]=(r[x]+s[2])/i[2],C!==-1&&y!==-1&&(c[C++]=(r[y]+s[3])/i[3]);return u==="RGBA"?new Tt("float32",c,[1,4,n,t]):new Tt("float32",c,[1,3,n,t])},Sl=async(r,e)=>{let n=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,t=typeof ImageData<"u"&&r instanceof ImageData,o=typeof ImageBitmap<"u"&&r instanceof ImageBitmap,i=typeof r=="string",s,a=e??{};if(n){let u=document.createElement("canvas");u.width=r.width,u.height=r.height;let l=u.getContext("2d");if(l!=null){let c=r.height,h=r.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(c=e.resizedHeight,h=e.resizedWidth),e!==void 0){if(a=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");a.tensorFormat="RGBA",a.height=c,a.width=h}else a.tensorFormat="RGBA",a.height=c,a.width=h;l.drawImage(r,0,0),s=l.getImageData(0,0,h,c).data}else throw new Error("Can not access image data")}else if(t){let u,l;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(u=e.resizedHeight,l=e.resizedWidth):(u=r.height,l=r.width),e!==void 0&&(a=e),a.format="RGBA",a.height=u,a.width=l,e!==void 0){let c=document.createElement("canvas");c.width=l,c.height=u;let h=c.getContext("2d");if(h!=null)h.putImageData(r,0,0),s=h.getImageData(0,0,l,u).data;else throw new Error("Can not access image data")}else s=r.data}else if(o){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");let u=document.createElement("canvas");u.width=r.width,u.height=r.height;let l=u.getContext("2d");if(l!=null){let c=r.height,h=r.width;return l.drawImage(r,0,0,h,c),s=l.getImageData(0,0,h,c).data,a.height=c,a.width=h,Ba(s,a)}else throw new Error("Can not access image data")}else{if(i)return new Promise((u,l)=>{let c=document.createElement("canvas"),h=c.getContext("2d");if(!r||!h)return l();let m=new Image;m.crossOrigin="Anonymous",m.src=r,m.onload=()=>{c.width=m.width,c.height=m.height,h.drawImage(m,0,0,c.width,c.height);let b=h.getImageData(0,0,c.width,c.height);a.height=c.height,a.width=c.width,u(Ba(b.data,a))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(s!==void 0)return Ba(s,a);throw new Error("Input data provided is not supported - aborted tensor creation")},Il=(r,e)=>{let{width:n,height:t,download:o,dispose:i}=e,s=[1,t,n,4];return new Tt({location:"texture",type:"float32",texture:r,dims:s,download:o,dispose:i})},Al=(r,e)=>{let{dataType:n,dims:t,download:o,dispose:i}=e;return new Tt({location:"gpu-buffer",type:n??"float32",gpuBuffer:r,dims:t,download:o,dispose:i})},_l=(r,e,n)=>new Tt({location:"cpu-pinned",type:r,data:e,dims:n??[e.length]})});var io,ei,Cl,El,Pl=M(()=>{io=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),ei=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),Cl=!1,El=()=>{if(!Cl){Cl=!0;let r=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",e=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function";r&&(io.set("int64",BigInt64Array),ei.set(BigInt64Array,"int64")),e&&(io.set("uint64",BigUint64Array),ei.set(BigUint64Array,"uint64"))}}});var Dl,kl,Bl=M(()=>{Qo();Dl=r=>{let e=1;for(let n=0;n<r.length;n++){let t=r[n];if(typeof t!="number"||!Number.isSafeInteger(t))throw new TypeError(`dims[${n}] must be an integer, got: ${t}`);if(t<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${t}`);e*=t}return e},kl=(r,e)=>{switch(r.location){case"cpu":return new Tt(r.type,r.data,e);case"cpu-pinned":return new Tt({location:"cpu-pinned",data:r.data,type:r.type,dims:e});case"texture":return new Tt({location:"texture",texture:r.texture,type:r.type,dims:e});case"gpu-buffer":return new Tt({location:"gpu-buffer",gpuBuffer:r.gpuBuffer,type:r.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${r.location} is not supported`)}}});var Tt,Qo=M(()=>{$l();Ol();Pl();Bl();Tt=class{constructor(e,n,t){El();let o,i;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,o=e.type,i=e.dims,e.location){case"cpu-pinned":{let a=io.get(o);if(!a)throw new TypeError(`unsupported type "${o}" to create tensor from pinned buffer`);if(!(e.data instanceof a))throw new TypeError(`buffer should be of type ${a.name}`);this.cpuData=e.data;break}case"texture":{if(o!=="float32")throw new TypeError(`unsupported type "${o}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(o!=="float32"&&o!=="float16"&&o!=="int32"&&o!=="int64"&&o!=="uint32"&&o!=="bool")throw new TypeError(`unsupported type "${o}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let a,u;if(typeof e=="string")if(o=e,u=t,e==="string"){if(!Array.isArray(n))throw new TypeError("A string tensor's data must be a string array.");a=n}else{let l=io.get(e);if(l===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(n)){if(e==="float16")throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");e==="uint64"||e==="int64"?a=l.from(n,BigInt):a=l.from(n)}else if(n instanceof l)a=n;else throw new TypeError(`A ${o} tensor's data must be type of ${l}`)}else if(u=n,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let l=typeof e[0];if(l==="string")o="string",a=e;else if(l==="boolean")o="bool",a=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${l}.`)}else{let l=ei.get(e.constructor);if(l===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);o=l,a=e}if(u===void 0)u=[a.length];else if(!Array.isArray(u))throw new TypeError("A tensor's dims must be a number array");i=u,this.cpuData=a,this.dataLocation="cpu"}let s=Dl(i);if(this.cpuData&&s!==this.cpuData.length)throw new Error(`Tensor's size(${s}) does not match data length(${this.cpuData.length}).`);this.type=o,this.dims=i,this.size=s}static async fromImage(e,n){return Sl(e,n)}static fromTexture(e,n){return Il(e,n)}static fromGpuBuffer(e,n){return Al(e,n)}static fromPinnedBuffer(e,n,t){return _l(e,n,t)}toDataURL(e){return wl(this,e)}toImageData(e){return Tl(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let n=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=n,e&&this.disposer&&(this.disposer(),this.disposer=void 0),n}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return kl(this,e)}}});var ft,ti=M(()=>{Qo();ft=Tt});var ri,Rl=M(()=>{Zo();ti();ri=class r{constructor(e){this.handler=e}async run(e,n,t){let o={},i={};if(typeof e!="object"||e===null||e instanceof ft||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let s=!0;if(typeof n=="object"){if(n===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof ft)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(n.length===0)throw new TypeError("'fetches' cannot be an empty array.");s=!1;for(let l of n){if(typeof l!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(l)===-1)throw new RangeError(`'fetches' contains invalid output name: ${l}.`);o[l]=null}if(typeof t=="object"&&t!==null)i=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else{let l=!1,c=Object.getOwnPropertyNames(n);for(let h of this.outputNames)if(c.indexOf(h)!==-1){let m=n[h];(m===null||m instanceof ft)&&(l=!0,s=!1,o[h]=m)}if(l){if(typeof t=="object"&&t!==null)i=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else i=n}}else if(typeof n<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let l of this.inputNames)if(typeof e[l]>"u")throw new Error(`input '${l}' is missing in 'feeds'.`);if(s)for(let l of this.outputNames)o[l]=null;let a=await this.handler.run(e,o,i),u={};for(let l in a)if(Object.hasOwnProperty.call(a,l)){let c=a[l];c instanceof ft?u[l]=c:u[l]=new ft(c.type,c.data,c.dims)}return u}async release(){return this.handler.dispose()}static async create(e,n,t,o){let i,s={};if(typeof e=="string"){if(i=e,typeof n=="object"&&n!==null)s=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(i=e,typeof n=="object"&&n!==null)s=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){let h=e,m=0,b=e.byteLength;if(typeof n=="object"&&n!==null)s=n;else if(typeof n=="number"){if(m=n,!Number.isSafeInteger(m))throw new RangeError("'byteOffset' must be an integer.");if(m<0||m>=h.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${h.byteLength}).`);if(b=e.byteLength-m,typeof t=="number"){if(b=t,!Number.isSafeInteger(b))throw new RangeError("'byteLength' must be an integer.");if(b<=0||m+b>h.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${h.byteLength-m}].`);if(typeof o=="object"&&o!==null)s=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else if(typeof t<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");i=new Uint8Array(h,m,b)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let u=(s.executionProviders||[]).map(h=>typeof h=="string"?h:h.name),c=await(await Jo(u)).createInferenceSessionHandler(i,s);return new r(c)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var Ml,Ll=M(()=>{Rl();Ml=ri});var Nl=M(()=>{});var x0,ni,Fl=M(()=>{Zo();ti();x0="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",ni=class r{constructor(e){this.handler=e}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}static async create(e,n){let t=e.evalModel||"",o=e.optimizerModel||"",i=n||{},a=(i.executionProviders||[]).map(l=>typeof l=="string"?l:l.name),u=await Jo(a);if(u.createTrainingSessionHandler){let l=await u.createTrainingSessionHandler(e.checkpointState,e.trainModel,t,o,i);return new r(l)}else throw new Error(x0)}typeNarrowingForRunStep(e,n,t){let o={},i={};if(typeof e!="object"||e===null||e instanceof ft||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let s=!0;if(typeof n=="object"){if(n===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof ft)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(n.length===0)throw new TypeError("'fetches' cannot be an empty array.");s=!1;for(let a of n){if(typeof a!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(a)===-1)throw new RangeError(`'fetches' contains invalid output name: ${a}.`);o[a]=null}if(typeof t=="object"&&t!==null)i=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else{let a=!1,u=Object.getOwnPropertyNames(n);for(let l of this.outputNames)if(u.indexOf(l)!==-1){let c=n[l];(c===null||c instanceof ft)&&(a=!0,s=!1,o[l]=c)}if(a){if(typeof t=="object"&&t!==null)i=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else i=n}}else if(typeof n<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let a of this.inputNames)if(typeof e[a]>"u")throw new Error(`input '${a}' is missing in 'feeds'.`);if(s)for(let a of this.outputNames)o[a]=null;return[o,i]}convertHandlerReturnTypeToMapOfTensors(e){let n={};for(let t in e)if(Object.hasOwnProperty.call(e,t)){let o=e[t];o instanceof ft?n[t]=o:n[t]=new ft(o.type,o.data,o.dims)}return n}async runTrainStep(e,n,t){let[o,i]=this.typeNarrowingForRunStep(e,n,t),s=await this.handler.runTrainStep(e,o,i);return this.convertHandlerReturnTypeToMapOfTensors(s)}async loadParametersBuffer(e,n){throw new Error("Method not implemented.")}async getContiguousParameters(e){throw new Error("Method not implemented.")}async release(){return this.handler.dispose()}}});var zl,Gl=M(()=>{Fl();zl=ni});var Ra={};Mr(Ra,{InferenceSession:()=>Ml,Tensor:()=>ft,TrainingSession:()=>zl,env:()=>we,registerBackend:()=>ur});var Lt=M(()=>{ml();xl();Ll();ti();Nl();Gl()});function Lr(r,e,n,t){if(e===void 0)return T0(r);if(n===void 0)oi(r,e,1);else if(typeof n=="number"&&t===void 0)oi(r,e,n);else if(typeof n=="string"&&t===void 0)oi(r,n,1,e);else if(typeof n=="string"&&typeof t=="number")oi(r,n,t,e);else throw new TypeError("input is valid")}function T0(r){return{verbose:Lr.verbose.bind(null,r),info:Lr.info.bind(null,r),warning:Lr.warning.bind(null,r),error:Lr.error.bind(null,r),fatal:Lr.fatal.bind(null,r)}}function oi(r,e,n,t){let o=ao[t||""]||ao[""];Wl[r]<Wl[o.minimalSeverity]||(o.logDateTime&&(e=`${new Date().toISOString()}|${e}`),o.logSourceLocation,w0[o.provider].log(r,e,t))}var Ma,La,Wl,w0,Ul,ao,ze,ai,si,ui,ii,Nt=M(()=>{"use strict";Ma=class{log(e,n,t){}},La=class{log(e,n,t){console.log(`${this.color(e)} ${t?"\x1B[35m"+t+"\x1B[0m ":""}${n}`)}color(e){switch(e){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${e}`)}}},Wl={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},w0={none:new Ma,console:new La},Ul={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1},ao={"":Ul};(u=>{function r(l,c){u("verbose",l,c)}u.verbose=r;function e(l,c){u("info",l,c)}u.info=e;function n(l,c){u("warning",l,c)}u.warning=n;function t(l,c){u("error",l,c)}u.error=t;function o(l,c){u("fatal",l,c)}u.fatal=o;function i(l){ao={},s("",l||{})}u.reset=i;function s(l,c){if(l==="*")i(c);else{let h=ao[l]||Ul;ao[l]={provider:c.provider||h.provider,minimalSeverity:c.minimalSeverity||h.minimalSeverity,logDateTime:c.logDateTime===void 0?h.logDateTime:c.logDateTime,logSourceLocation:c.logSourceLocation===void 0?h.logSourceLocation:c.logSourceLocation}}}u.set=s;function a(l){let c={};l.logLevel&&(c.minimalSeverity=l.logLevel),s("",c)}u.setWithEnv=a})(Lr||={});ze=Lr,ai=class{constructor(e,n,t,o,i,s){this.category=e;this.name=n;this.startTime=t;this.endCallback=o;this.timer=i;this.ctx=s}async end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}},si=class{constructor(e,n,t,o){this.category=e;this.name=n;this.startTime=t;this.endTime=o}},ui=class{constructor(e,n,t){this._started=!1;this._flushPointer=0;this._started=!1,this._maxNumberEvents=e===void 0?1e4:e,this._flushBatchSize=n===void 0?10:n,this._flushIntervalInMilliseconds=t===void 0?5e3:t}static create(e){return e===void 0?new this:new this(e.maxNumberEvents,e.flushBatchSize,e.flushIntervalInMilliseconds)}start(){this._started=!0,this._timingEvents=[],this._flushTime=ii(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(e,n,t,o){let i=this._started?this.begin(e,n,o):void 0,s=!1,a=t();if(a&&typeof a.then=="function")return s=!0,new Promise((u,l)=>{a.then(async c=>{i&&await i.end(),u(c)},async c=>{i&&await i.end(),l(c)})});if(!s&&i){let u=i.end();if(u&&typeof u.then=="function")return new Promise((l,c)=>{u.then(()=>{l(a)},h=>{c(h)})})}return a}begin(e,n,t){if(!this._started)throw new Error("profiler is not started yet");if(t===void 0){let o=ii();return this.flush(o),new ai(e,n,o,i=>this.endSync(i))}else{let o=t.beginTimer();return new ai(e,n,0,async i=>this.end(i),o,t)}}async end(e){let n=await e.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new si(e.category,e.name,e.startTime,n)),this.flush(n))}endSync(e){let n=ii();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new si(e.category,e.name,e.startTime,n)),this.flush(n))}logOneEvent(e){ze.verbose(`Profiler.${e.category}`,`${(e.endTime-e.startTime).toFixed(2)}ms on event '${e.name}' at ${e.endTime.toFixed(2)}`)}flush(e){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||e-this._flushTime>=this._flushIntervalInMilliseconds){for(let n=this._flushPointer;this._flushPointer<n+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=ii()}}get started(){return this._started}},ii=typeof performance<"u"&&performance.now?()=>performance.now():Date.now});function Hl(r,e,n){for(let t of n){let o=t[0],i=t[1],s=t[2],a=t[3],u=t[4];if(r.opType===o){for(let l of e)if((l.domain===i||l.domain==="ai.onnx"&&i==="")&&$0(l.version,s))return{opImpl:a,opInit:u}}}throw new TypeError(`cannot resolve operator '${r.opType}' with opsets: ${e.map(t=>`${t.domain||"ai.onnx"} v${t.version}`).join(", ")}`)}function $0(r,e){if(e.endsWith("+")){let n=Number.parseInt(e.substring(0,e.length-1),10);return!isNaN(n)&&n<=r}else if(e.split("-").length===2){let n=e.split("-"),t=Number.parseInt(n[0],10),o=Number.parseInt(n[1],10);return!isNaN(t)&&!isNaN(o)&&t<=r&&r<=o}else return Number.parseInt(e,10)===r}var jl=M(()=>{"use strict"});var ql=He(Na=>{"use strict";Na.__esModule=!0;var S0=function(){function r(e){if(!e)throw new TypeError("Invalid argument; `value` has no value.");this.value=r.EMPTY,e&&r.isGuid(e)&&(this.value=e)}return r.isGuid=function(e){var n=e.toString();return e&&(e instanceof r||r.validator.test(n))},r.create=function(){return new r([r.gen(2),r.gen(1),r.gen(1),r.gen(1),r.gen(3)].join("-"))},r.createEmpty=function(){return new r("emptyguid")},r.parse=function(e){return new r(e)},r.raw=function(){return[r.gen(2),r.gen(1),r.gen(1),r.gen(1),r.gen(3)].join("-")},r.gen=function(e){for(var n="",t=0;t<e;t++)n+=((1+Math.random())*65536|0).toString(16).substring(1);return n},r.prototype.equals=function(e){return r.isGuid(e)&&this.value===e.toString()},r.prototype.isEmpty=function(){return this.value===r.EMPTY},r.prototype.toString=function(){return this.value},r.prototype.toJSON=function(){return{value:this.value}},r.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),r.EMPTY="00000000-0000-0000-0000-000000000000",r}();Na.Guid=S0});function je(r,e,n){this.low=r|0,this.high=e|0,this.unsigned=!!n}function xt(r){return(r&&r.__isLong__)===!0}function Kl(r){var e=Math.clz32(r&-r);return r?31-e:e}function nn(r,e){var n,t,o;return e?(r>>>=0,(o=0<=r&&r<256)&&(t=Yl[r],t)?t:(n=Ne(r,0,!0),o&&(Yl[r]=n),n)):(r|=0,(o=-128<=r&&r<128)&&(t=Xl[r],t)?t:(n=Ne(r,r<0?-1:0,!1),o&&(Xl[r]=n),n))}function zt(r,e){if(isNaN(r))return e?_r:Jt;if(e){if(r<0)return _r;if(r>=ec)return nc}else{if(r<=-Zl)return Ot;if(r+1>=Zl)return rc}return r<0?zt(-r,e).neg():Ne(r%En|0,r/En|0,e)}function Ne(r,e,n){return new je(r,e,n)}function za(r,e,n){if(r.length===0)throw Error("empty string");if(typeof e=="number"?(n=e,e=!1):e=!!e,r==="NaN"||r==="Infinity"||r==="+Infinity"||r==="-Infinity")return e?_r:Jt;if(n=n||10,n<2||36<n)throw RangeError("radix");var t;if((t=r.indexOf("-"))>0)throw Error("interior hyphen");if(t===0)return za(r.substring(1),e,n).neg();for(var o=zt(li(n,8)),i=Jt,s=0;s<r.length;s+=8){var a=Math.min(8,r.length-s),u=parseInt(r.substring(s,s+a),n);if(a<8){var l=zt(li(n,a));i=i.mul(l).add(zt(u))}else i=i.mul(o),i=i.add(zt(u))}return i.unsigned=e,i}function Zt(r,e){return typeof r=="number"?zt(r,e):typeof r=="string"?za(r,e):Ne(r.low,r.high,typeof e=="boolean"?e:r.unsigned)}var Ft,Xl,Yl,li,Jl,I0,En,ec,Zl,Ql,Jt,_r,Cn,tc,Fa,rc,nc,Ot,j,Or,Ga=M(()=>{Ft=null;try{Ft=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}je.prototype.__isLong__;Object.defineProperty(je.prototype,"__isLong__",{value:!0});je.isLong=xt;Xl={},Yl={};je.fromInt=nn;je.fromNumber=zt;je.fromBits=Ne;li=Math.pow;je.fromString=za;je.fromValue=Zt;Jl=65536,I0=1<<24,En=Jl*Jl,ec=En*En,Zl=ec/2,Ql=nn(I0),Jt=nn(0);je.ZERO=Jt;_r=nn(0,!0);je.UZERO=_r;Cn=nn(1);je.ONE=Cn;tc=nn(1,!0);je.UONE=tc;Fa=nn(-1);je.NEG_ONE=Fa;rc=Ne(-1,2147483647,!1);je.MAX_VALUE=rc;nc=Ne(-1,-1,!0);je.MAX_UNSIGNED_VALUE=nc;Ot=Ne(0,-2147483648,!1);je.MIN_VALUE=Ot;j=je.prototype;j.toInt=function(){return this.unsigned?this.low>>>0:this.low};j.toNumber=function(){return this.unsigned?(this.high>>>0)*En+(this.low>>>0):this.high*En+(this.low>>>0)};j.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Ot)){var n=zt(e),t=this.div(n),o=t.mul(n).sub(this);return t.toString(e)+o.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var i=zt(li(e,6),this.unsigned),s=this,a="";;){var u=s.div(i),l=s.sub(u.mul(i)).toInt()>>>0,c=l.toString(e);if(s=u,s.isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}};j.getHighBits=function(){return this.high};j.getHighBitsUnsigned=function(){return this.high>>>0};j.getLowBits=function(){return this.low};j.getLowBitsUnsigned=function(){return this.low>>>0};j.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Ot)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,n=31;n>0&&!(e&1<<n);n--);return this.high!=0?n+33:n+1};j.isZero=function(){return this.high===0&&this.low===0};j.eqz=j.isZero;j.isNegative=function(){return!this.unsigned&&this.high<0};j.isPositive=function(){return this.unsigned||this.high>=0};j.isOdd=function(){return(this.low&1)===1};j.isEven=function(){return(this.low&1)===0};j.equals=function(e){return xt(e)||(e=Zt(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};j.eq=j.equals;j.notEquals=function(e){return!this.eq(e)};j.neq=j.notEquals;j.ne=j.notEquals;j.lessThan=function(e){return this.comp(e)<0};j.lt=j.lessThan;j.lessThanOrEqual=function(e){return this.comp(e)<=0};j.lte=j.lessThanOrEqual;j.le=j.lessThanOrEqual;j.greaterThan=function(e){return this.comp(e)>0};j.gt=j.greaterThan;j.greaterThanOrEqual=function(e){return this.comp(e)>=0};j.gte=j.greaterThanOrEqual;j.ge=j.greaterThanOrEqual;j.compare=function(e){if(xt(e)||(e=Zt(e)),this.eq(e))return 0;var n=this.isNegative(),t=e.isNegative();return n&&!t?-1:!n&&t?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};j.comp=j.compare;j.negate=function(){return!this.unsigned&&this.eq(Ot)?Ot:this.not().add(Cn)};j.neg=j.negate;j.add=function(e){xt(e)||(e=Zt(e));var n=this.high>>>16,t=this.high&65535,o=this.low>>>16,i=this.low&65535,s=e.high>>>16,a=e.high&65535,u=e.low>>>16,l=e.low&65535,c=0,h=0,m=0,b=0;return b+=i+l,m+=b>>>16,b&=65535,m+=o+u,h+=m>>>16,m&=65535,h+=t+a,c+=h>>>16,h&=65535,c+=n+s,c&=65535,Ne(m<<16|b,c<<16|h,this.unsigned)};j.subtract=function(e){return xt(e)||(e=Zt(e)),this.add(e.neg())};j.sub=j.subtract;j.multiply=function(e){if(this.isZero())return this;if(xt(e)||(e=Zt(e)),Ft){var n=Ft.mul(this.low,this.high,e.low,e.high);return Ne(n,Ft.get_high(),this.unsigned)}if(e.isZero())return this.unsigned?_r:Jt;if(this.eq(Ot))return e.isOdd()?Ot:Jt;if(e.eq(Ot))return this.isOdd()?Ot:Jt;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(Ql)&&e.lt(Ql))return zt(this.toNumber()*e.toNumber(),this.unsigned);var t=this.high>>>16,o=this.high&65535,i=this.low>>>16,s=this.low&65535,a=e.high>>>16,u=e.high&65535,l=e.low>>>16,c=e.low&65535,h=0,m=0,b=0,x=0;return x+=s*c,b+=x>>>16,x&=65535,b+=i*c,m+=b>>>16,b&=65535,b+=s*l,m+=b>>>16,b&=65535,m+=o*c,h+=m>>>16,m&=65535,m+=i*l,h+=m>>>16,m&=65535,m+=s*u,h+=m>>>16,m&=65535,h+=t*c+o*l+i*u+s*a,h&=65535,Ne(b<<16|x,h<<16|m,this.unsigned)};j.mul=j.multiply;j.divide=function(e){if(xt(e)||(e=Zt(e)),e.isZero())throw Error("division by zero");if(Ft){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var n=(this.unsigned?Ft.div_u:Ft.div_s)(this.low,this.high,e.low,e.high);return Ne(n,Ft.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?_r:Jt;var t,o,i;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return _r;if(e.gt(this.shru(1)))return tc;i=_r}else{if(this.eq(Ot)){if(e.eq(Cn)||e.eq(Fa))return Ot;if(e.eq(Ot))return Cn;var s=this.shr(1);return t=s.div(e).shl(1),t.eq(Jt)?e.isNegative()?Cn:Fa:(o=this.sub(e.mul(t)),i=t.add(o.div(e)),i)}else if(e.eq(Ot))return this.unsigned?_r:Jt;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();i=Jt}for(o=this;o.gte(e);){t=Math.max(1,Math.floor(o.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(t)/Math.LN2),u=a<=48?1:li(2,a-48),l=zt(t),c=l.mul(e);c.isNegative()||c.gt(o);)t-=u,l=zt(t,this.unsigned),c=l.mul(e);l.isZero()&&(l=Cn),i=i.add(l),o=o.sub(c)}return i};j.div=j.divide;j.modulo=function(e){if(xt(e)||(e=Zt(e)),Ft){var n=(this.unsigned?Ft.rem_u:Ft.rem_s)(this.low,this.high,e.low,e.high);return Ne(n,Ft.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};j.mod=j.modulo;j.rem=j.modulo;j.not=function(){return Ne(~this.low,~this.high,this.unsigned)};j.countLeadingZeros=function(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32};j.clz=j.countLeadingZeros;j.countTrailingZeros=function(){return this.low?Kl(this.low):Kl(this.high)+32};j.ctz=j.countTrailingZeros;j.and=function(e){return xt(e)||(e=Zt(e)),Ne(this.low&e.low,this.high&e.high,this.unsigned)};j.or=function(e){return xt(e)||(e=Zt(e)),Ne(this.low|e.low,this.high|e.high,this.unsigned)};j.xor=function(e){return xt(e)||(e=Zt(e)),Ne(this.low^e.low,this.high^e.high,this.unsigned)};j.shiftLeft=function(e){return xt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Ne(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):Ne(0,this.low<<e-32,this.unsigned)};j.shl=j.shiftLeft;j.shiftRight=function(e){return xt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Ne(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):Ne(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};j.shr=j.shiftRight;j.shiftRightUnsigned=function(e){return xt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Ne(this.low>>>e|this.high<<32-e,this.high>>>e,this.unsigned):e===32?Ne(this.high,0,this.unsigned):Ne(this.high>>>e-32,0,this.unsigned)};j.shru=j.shiftRightUnsigned;j.shr_u=j.shiftRightUnsigned;j.rotateLeft=function(e){var n;return xt(e)&&(e=e.toInt()),(e&=63)===0?this:e===32?Ne(this.high,this.low,this.unsigned):e<32?(n=32-e,Ne(this.low<<e|this.high>>>n,this.high<<e|this.low>>>n,this.unsigned)):(e-=32,n=32-e,Ne(this.high<<e|this.low>>>n,this.low<<e|this.high>>>n,this.unsigned))};j.rotl=j.rotateLeft;j.rotateRight=function(e){var n;return xt(e)&&(e=e.toInt()),(e&=63)===0?this:e===32?Ne(this.high,this.low,this.unsigned):e<32?(n=32-e,Ne(this.high<<n|this.low>>>e,this.low<<n|this.high>>>e,this.unsigned)):(e-=32,n=32-e,Ne(this.low<<n|this.high>>>e,this.high<<n|this.low>>>e,this.unsigned))};j.rotr=j.rotateRight;j.toSigned=function(){return this.unsigned?Ne(this.low,this.high,!1):this};j.toUnsigned=function(){return this.unsigned?this:Ne(this.low,this.high,!0)};j.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};j.toBytesLE=function(){var e=this.high,n=this.low;return[n&255,n>>>8&255,n>>>16&255,n>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};j.toBytesBE=function(){var e=this.high,n=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,n>>>24,n>>>16&255,n>>>8&255,n&255]};je.fromBytes=function(e,n,t){return t?je.fromBytesLE(e,n):je.fromBytesBE(e,n)};je.fromBytesLE=function(e,n){return new je(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,n)};je.fromBytesBE=function(e,n){return new je(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],n)};Or=je});var B,ci=M(()=>{B={};B.Offset;B.Table;B.SIZEOF_SHORT=2;B.SIZEOF_INT=4;B.FILE_IDENTIFIER_LENGTH=4;B.SIZE_PREFIX_LENGTH=4;B.Encoding={UTF8_BYTES:1,UTF16_STRING:2};B.int32=new Int32Array(2);B.float32=new Float32Array(B.int32.buffer);B.float64=new Float64Array(B.int32.buffer);B.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1;B.Long=function(r,e){this.low=r|0,this.high=e|0};B.Long.create=function(r,e){return r==0&&e==0?B.Long.ZERO:new B.Long(r,e)};B.Long.prototype.toFloat64=function(){return(this.low>>>0)+this.high*4294967296};B.Long.prototype.equals=function(r){return this.low==r.low&&this.high==r.high};B.Long.ZERO=new B.Long(0,0);B.Builder=function(r){if(r)var e=r;else var e=1024;this.bb=B.ByteBuffer.allocate(e),this.space=e,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1};B.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1};B.Builder.prototype.forceDefaults=function(r){this.force_defaults=r};B.Builder.prototype.dataBuffer=function(){return this.bb};B.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())};B.Builder.prototype.prep=function(r,e){r>this.minalign&&(this.minalign=r);for(var n=~(this.bb.capacity()-this.space+e)+1&r-1;this.space<n+r+e;){var t=this.bb.capacity();this.bb=B.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-t}this.pad(n)};B.Builder.prototype.pad=function(r){for(var e=0;e<r;e++)this.bb.writeInt8(--this.space,0)};B.Builder.prototype.writeInt8=function(r){this.bb.writeInt8(this.space-=1,r)};B.Builder.prototype.writeInt16=function(r){this.bb.writeInt16(this.space-=2,r)};B.Builder.prototype.writeInt32=function(r){this.bb.writeInt32(this.space-=4,r)};B.Builder.prototype.writeInt64=function(r){this.bb.writeInt64(this.space-=8,r)};B.Builder.prototype.writeFloat32=function(r){this.bb.writeFloat32(this.space-=4,r)};B.Builder.prototype.writeFloat64=function(r){this.bb.writeFloat64(this.space-=8,r)};B.Builder.prototype.addInt8=function(r){this.prep(1,0),this.writeInt8(r)};B.Builder.prototype.addInt16=function(r){this.prep(2,0),this.writeInt16(r)};B.Builder.prototype.addInt32=function(r){this.prep(4,0),this.writeInt32(r)};B.Builder.prototype.addInt64=function(r){this.prep(8,0),this.writeInt64(r)};B.Builder.prototype.addFloat32=function(r){this.prep(4,0),this.writeFloat32(r)};B.Builder.prototype.addFloat64=function(r){this.prep(8,0),this.writeFloat64(r)};B.Builder.prototype.addFieldInt8=function(r,e,n){(this.force_defaults||e!=n)&&(this.addInt8(e),this.slot(r))};B.Builder.prototype.addFieldInt16=function(r,e,n){(this.force_defaults||e!=n)&&(this.addInt16(e),this.slot(r))};B.Builder.prototype.addFieldInt32=function(r,e,n){(this.force_defaults||e!=n)&&(this.addInt32(e),this.slot(r))};B.Builder.prototype.addFieldInt64=function(r,e,n){(this.force_defaults||!e.equals(n))&&(this.addInt64(e),this.slot(r))};B.Builder.prototype.addFieldFloat32=function(r,e,n){(this.force_defaults||e!=n)&&(this.addFloat32(e),this.slot(r))};B.Builder.prototype.addFieldFloat64=function(r,e,n){(this.force_defaults||e!=n)&&(this.addFloat64(e),this.slot(r))};B.Builder.prototype.addFieldOffset=function(r,e,n){(this.force_defaults||e!=n)&&(this.addOffset(e),this.slot(r))};B.Builder.prototype.addFieldStruct=function(r,e,n){e!=n&&(this.nested(e),this.slot(r))};B.Builder.prototype.nested=function(r){if(r!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")};B.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")};B.Builder.prototype.slot=function(r){this.vtable[r]=this.offset()};B.Builder.prototype.offset=function(){return this.bb.capacity()-this.space};B.Builder.growByteBuffer=function(r){var e=r.capacity();if(e&3221225472)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var n=e<<1,t=B.ByteBuffer.allocate(n);return t.setPosition(n-e),t.bytes().set(r.bytes(),n-e),t};B.Builder.prototype.addOffset=function(r){this.prep(B.SIZEOF_INT,0),this.writeInt32(this.offset()-r+B.SIZEOF_INT)};B.Builder.prototype.startObject=function(r){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=r;for(var e=0;e<r;e++)this.vtable[e]=0;this.isNested=!0,this.object_start=this.offset()};B.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var r=this.offset(),e=this.vtable_in_use-1;e>=0&&this.vtable[e]==0;e--);for(var n=e+1;e>=0;e--)this.addInt16(this.vtable[e]!=0?r-this.vtable[e]:0);var t=2;this.addInt16(r-this.object_start);var o=(n+t)*B.SIZEOF_SHORT;this.addInt16(o);var i=0,s=this.space;e:for(e=0;e<this.vtables.length;e++){var a=this.bb.capacity()-this.vtables[e];if(o==this.bb.readInt16(a)){for(var u=B.SIZEOF_SHORT;u<o;u+=B.SIZEOF_SHORT)if(this.bb.readInt16(s+u)!=this.bb.readInt16(a+u))continue e;i=this.vtables[e];break}}return i?(this.space=this.bb.capacity()-r,this.bb.writeInt32(this.space,i-r)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-r,this.offset()-r)),this.isNested=!1,r};B.Builder.prototype.finish=function(r,e,n){var t=n?B.SIZE_PREFIX_LENGTH:0;if(e){var o=e;if(this.prep(this.minalign,B.SIZEOF_INT+B.FILE_IDENTIFIER_LENGTH+t),o.length!=B.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+B.FILE_IDENTIFIER_LENGTH);for(var i=B.FILE_IDENTIFIER_LENGTH-1;i>=0;i--)this.writeInt8(o.charCodeAt(i))}this.prep(this.minalign,B.SIZEOF_INT+t),this.addOffset(r),t&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)};B.Builder.prototype.finishSizePrefixed=function(r,e){this.finish(r,e,!0)};B.Builder.prototype.requiredField=function(r,e){var n=this.bb.capacity()-r,t=n-this.bb.readInt32(n),o=this.bb.readInt16(t+e)!=0;if(!o)throw new Error("FlatBuffers: field "+e+" must be set")};B.Builder.prototype.startVector=function(r,e,n){this.notNested(),this.vector_num_elems=e,this.prep(B.SIZEOF_INT,r*e),this.prep(n,r*e)};B.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()};B.Builder.prototype.createString=function(r){if(r instanceof Uint8Array)var e=r;else for(var e=[],n=0;n<r.length;){var t,o=r.charCodeAt(n++);if(o<55296||o>=56320)t=o;else{var i=r.charCodeAt(n++);t=(o<<10)+i+(65536-56623104-56320)}t<128?e.push(t):(t<2048?e.push(t>>6&31|192):(t<65536?e.push(t>>12&15|224):e.push(t>>18&7|240,t>>12&63|128),e.push(t>>6&63|128)),e.push(t&63|128))}this.addInt8(0),this.startVector(1,e.length,1),this.bb.setPosition(this.space-=e.length);for(var n=0,s=this.space,a=this.bb.bytes();n<e.length;n++)a[s++]=e[n];return this.endVector()};B.Builder.prototype.createLong=function(r,e){return B.Long.create(r,e)};B.ByteBuffer=function(r){this.bytes_=r,this.position_=0};B.ByteBuffer.allocate=function(r){return new B.ByteBuffer(new Uint8Array(r))};B.ByteBuffer.prototype.clear=function(){this.position_=0};B.ByteBuffer.prototype.bytes=function(){return this.bytes_};B.ByteBuffer.prototype.position=function(){return this.position_};B.ByteBuffer.prototype.setPosition=function(r){this.position_=r};B.ByteBuffer.prototype.capacity=function(){return this.bytes_.length};B.ByteBuffer.prototype.readInt8=function(r){return this.readUint8(r)<<24>>24};B.ByteBuffer.prototype.readUint8=function(r){return this.bytes_[r]};B.ByteBuffer.prototype.readInt16=function(r){return this.readUint16(r)<<16>>16};B.ByteBuffer.prototype.readUint16=function(r){return this.bytes_[r]|this.bytes_[r+1]<<8};B.ByteBuffer.prototype.readInt32=function(r){return this.bytes_[r]|this.bytes_[r+1]<<8|this.bytes_[r+2]<<16|this.bytes_[r+3]<<24};B.ByteBuffer.prototype.readUint32=function(r){return this.readInt32(r)>>>0};B.ByteBuffer.prototype.readInt64=function(r){return new B.Long(this.readInt32(r),this.readInt32(r+4))};B.ByteBuffer.prototype.readUint64=function(r){return new B.Long(this.readUint32(r),this.readUint32(r+4))};B.ByteBuffer.prototype.readFloat32=function(r){return B.int32[0]=this.readInt32(r),B.float32[0]};B.ByteBuffer.prototype.readFloat64=function(r){return B.int32[B.isLittleEndian?0:1]=this.readInt32(r),B.int32[B.isLittleEndian?1:0]=this.readInt32(r+4),B.float64[0]};B.ByteBuffer.prototype.writeInt8=function(r,e){this.bytes_[r]=e};B.ByteBuffer.prototype.writeUint8=function(r,e){this.bytes_[r]=e};B.ByteBuffer.prototype.writeInt16=function(r,e){this.bytes_[r]=e,this.bytes_[r+1]=e>>8};B.ByteBuffer.prototype.writeUint16=function(r,e){this.bytes_[r]=e,this.bytes_[r+1]=e>>8};B.ByteBuffer.prototype.writeInt32=function(r,e){this.bytes_[r]=e,this.bytes_[r+1]=e>>8,this.bytes_[r+2]=e>>16,this.bytes_[r+3]=e>>24};B.ByteBuffer.prototype.writeUint32=function(r,e){this.bytes_[r]=e,this.bytes_[r+1]=e>>8,this.bytes_[r+2]=e>>16,this.bytes_[r+3]=e>>24};B.ByteBuffer.prototype.writeInt64=function(r,e){this.writeInt32(r,e.low),this.writeInt32(r+4,e.high)};B.ByteBuffer.prototype.writeUint64=function(r,e){this.writeUint32(r,e.low),this.writeUint32(r+4,e.high)};B.ByteBuffer.prototype.writeFloat32=function(r,e){B.float32[0]=e,this.writeInt32(r,B.int32[0])};B.ByteBuffer.prototype.writeFloat64=function(r,e){B.float64[0]=e,this.writeInt32(r,B.int32[B.isLittleEndian?0:1]),this.writeInt32(r+4,B.int32[B.isLittleEndian?1:0])};B.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+B.SIZEOF_INT+B.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var r="",e=0;e<B.FILE_IDENTIFIER_LENGTH;e++)r+=String.fromCharCode(this.readInt8(this.position_+B.SIZEOF_INT+e));return r};B.ByteBuffer.prototype.__offset=function(r,e){var n=r-this.readInt32(r);return e<this.readInt16(n)?this.readInt16(n+e):0};B.ByteBuffer.prototype.__union=function(r,e){return r.bb_pos=e+this.readInt32(e),r.bb=this,r};B.ByteBuffer.prototype.__string=function(r,e){r+=this.readInt32(r);var n=this.readInt32(r),t="",o=0;if(r+=B.SIZEOF_INT,e===B.Encoding.UTF8_BYTES)return this.bytes_.subarray(r,r+n);for(;o<n;){var i,s=this.readUint8(r+o++);if(s<192)i=s;else{var a=this.readUint8(r+o++);if(s<224)i=(s&31)<<6|a&63;else{var u=this.readUint8(r+o++);if(s<240)i=(s&15)<<12|(a&63)<<6|u&63;else{var l=this.readUint8(r+o++);i=(s&7)<<18|(a&63)<<12|(u&63)<<6|l&63}}}i<65536?t+=String.fromCharCode(i):(i-=65536,t+=String.fromCharCode((i>>10)+55296,(i&1024-1)+56320))}return t};B.ByteBuffer.prototype.__indirect=function(r){return r+this.readInt32(r)};B.ByteBuffer.prototype.__vector=function(r){return r+this.readInt32(r)+B.SIZEOF_INT};B.ByteBuffer.prototype.__vector_len=function(r){return this.readInt32(r+this.readInt32(r))};B.ByteBuffer.prototype.__has_identifier=function(r){if(r.length!=B.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+B.FILE_IDENTIFIER_LENGTH);for(var e=0;e<B.FILE_IDENTIFIER_LENGTH;e++)if(r.charCodeAt(e)!=this.readInt8(this.position_+B.SIZEOF_INT+e))return!1;return!0};B.ByteBuffer.prototype.createLong=function(r,e){return B.Long.create(r,e)}});var ie,so=M(()=>{"use strict";ci();(e=>{let r;(t=>{let n;(i=>{let o;(C=>(C[C.UNDEFINED=0]="UNDEFINED",C[C.FLOAT=1]="FLOAT",C[C.INT=2]="INT",C[C.STRING=3]="STRING",C[C.TENSOR=4]="TENSOR",C[C.GRAPH=5]="GRAPH",C[C.FLOATS=6]="FLOATS",C[C.INTS=7]="INTS",C[C.STRINGS=8]="STRINGS",C[C.TENSORS=9]="TENSORS",C[C.GRAPHS=10]="GRAPHS",C[C.SPARSE_TENSOR=11]="SPARSE_TENSOR",C[C.SPARSE_TENSORS=12]="SPARSE_TENSORS"))(o=i.AttributeType||={})})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{let o;(l=>(l[l.UNKNOWN=0]="UNKNOWN",l[l.VALUE=1]="VALUE",l[l.PARAM=2]="PARAM"))(o=i.DimensionValueType||={})})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{let o;(R=>(R[R.UNDEFINED=0]="UNDEFINED",R[R.FLOAT=1]="FLOAT",R[R.UINT8=2]="UINT8",R[R.INT8=3]="INT8",R[R.UINT16=4]="UINT16",R[R.INT16=5]="INT16",R[R.INT32=6]="INT32",R[R.INT64=7]="INT64",R[R.STRING=8]="STRING",R[R.BOOL=9]="BOOL",R[R.FLOAT16=10]="FLOAT16",R[R.DOUBLE=11]="DOUBLE",R[R.UINT32=12]="UINT32",R[R.UINT64=13]="UINT64",R[R.COMPLEX64=14]="COMPLEX64",R[R.COMPLEX128=15]="COMPLEX128",R[R.BFLOAT16=16]="BFLOAT16",R[R.FLOAT8E4M3FN=17]="FLOAT8E4M3FN",R[R.FLOAT8E4M3FNUZ=18]="FLOAT8E4M3FNUZ",R[R.FLOAT8E5M2=19]="FLOAT8E5M2",R[R.FLOAT8E5M2FNUZ=20]="FLOAT8E5M2FNUZ"))(o=i.TensorDataType||={})})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{let o;(u=>(u[u.Primitive=0]="Primitive",u[u.Fused=1]="Fused"))(o=i.NodeType||={})})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{let o;(c=>(c[c.NONE=0]="NONE",c[c.tensor_type=1]="tensor_type",c[c.sequence_type=2]="sequence_type",c[c.map_type=3]="map_type"))(o=i.TypeInfoValue||={})})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsShape(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsShape(a,u){return a.setPosition(a.position()+B.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}dim(a,u){let l=this.bb.__offset(this.bb_pos,4);return l?(u||new e.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}dimLength(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__vector_len(this.bb_pos+a):0}static startShape(a){a.startObject(1)}static addDim(a,u){a.addFieldOffset(0,u,0)}static createDimVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startDimVector(a,u){a.startVector(4,u,4)}static endShape(a){return a.endObject()}static createShape(a,u){return o.startShape(a),o.addDim(a,u),o.endShape(a)}}i.Shape=o})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsDimension(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsDimension(a,u){return a.setPosition(a.position()+B.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}value(a){let u=this.bb.__offset(this.bb_pos,4);return u?(a||new e.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}denotation(a){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,a):null}static startDimension(a){a.startObject(2)}static addValue(a,u){a.addFieldOffset(0,u,0)}static addDenotation(a,u){a.addFieldOffset(1,u,0)}static endDimension(a){return a.endObject()}static createDimension(a,u,l){return o.startDimension(a),o.addValue(a,u),o.addDenotation(a,l),o.endDimension(a)}}i.Dimension=o})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsDimensionValue(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsDimensionValue(a,u){return a.setPosition(a.position()+B.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}dimType(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readInt8(this.bb_pos+a):0}dimValue(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}dimParam(a){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.__string(this.bb_pos+u,a):null}static startDimensionValue(a){a.startObject(3)}static addDimType(a,u){a.addFieldInt8(0,u,0)}static addDimValue(a,u){a.addFieldInt64(1,u,a.createLong(0,0))}static addDimParam(a,u){a.addFieldOffset(2,u,0)}static endDimensionValue(a){return a.endObject()}static createDimensionValue(a,u,l,c){return o.startDimensionValue(a),o.addDimType(a,u),o.addDimValue(a,l),o.addDimParam(a,c),o.endDimensionValue(a)}}i.DimensionValue=o})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsTensorTypeAndShape(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsTensorTypeAndShape(a,u){return a.setPosition(a.position()+B.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}elemType(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readInt32(this.bb_pos+a):0}shape(a){let u=this.bb.__offset(this.bb_pos,6);return u?(a||new e.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startTensorTypeAndShape(a){a.startObject(2)}static addElemType(a,u){a.addFieldInt32(0,u,0)}static addShape(a,u){a.addFieldOffset(1,u,0)}static endTensorTypeAndShape(a){return a.endObject()}static createTensorTypeAndShape(a,u,l){return o.startTensorTypeAndShape(a),o.addElemType(a,u),o.addShape(a,l),o.endTensorTypeAndShape(a)}}i.TensorTypeAndShape=o})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsMapType(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsMapType(a,u){return a.setPosition(a.position()+B.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}keyType(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readInt32(this.bb_pos+a):0}valueType(a){let u=this.bb.__offset(this.bb_pos,6);return u?(a||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startMapType(a){a.startObject(2)}static addKeyType(a,u){a.addFieldInt32(0,u,0)}static addValueType(a,u){a.addFieldOffset(1,u,0)}static endMapType(a){return a.endObject()}static createMapType(a,u,l){return o.startMapType(a),o.addKeyType(a,u),o.addValueType(a,l),o.endMapType(a)}}i.MapType=o})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsSequenceType(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsSequenceType(a,u){return a.setPosition(a.position()+B.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}elemType(a){let u=this.bb.__offset(this.bb_pos,4);return u?(a||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startSequenceType(a){a.startObject(1)}static addElemType(a,u){a.addFieldOffset(0,u,0)}static endSequenceType(a){return a.endObject()}static createSequenceType(a,u){return o.startSequenceType(a),o.addElemType(a,u),o.endSequenceType(a)}}i.SequenceType=o})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(a,u,l,c){return a.prep(4,12),a.writeInt32(c),a.writeInt32(l),a.writeInt32(u),a.offset()}}i.EdgeEnd=o})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsNodeEdge(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsNodeEdge(a,u){return a.setPosition(a.position()+B.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}nodeIndex(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readUint32(this.bb_pos+a):0}inputEdges(a,u){let l=this.bb.__offset(this.bb_pos,6);return l?(u||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+l)+a*12,this.bb):null}inputEdgesLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}outputEdges(a,u){let l=this.bb.__offset(this.bb_pos,8);return l?(u||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+l)+a*12,this.bb):null}outputEdgesLength(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__vector_len(this.bb_pos+a):0}static startNodeEdge(a){a.startObject(3)}static addNodeIndex(a,u){a.addFieldInt32(0,u,0)}static addInputEdges(a,u){a.addFieldOffset(1,u,0)}static startInputEdgesVector(a,u){a.startVector(12,u,4)}static addOutputEdges(a,u){a.addFieldOffset(2,u,0)}static startOutputEdgesVector(a,u){a.startVector(12,u,4)}static endNodeEdge(a){return a.endObject()}static createNodeEdge(a,u,l,c){return o.startNodeEdge(a),o.addNodeIndex(a,u),o.addInputEdges(a,l),o.addOutputEdges(a,c),o.endNodeEdge(a)}}i.NodeEdge=o})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsNode(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsNode(a,u){return a.setPosition(a.position()+B.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}name(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,a):null}docString(a){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,a):null}domain(a){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.__string(this.bb_pos+u,a):null}sinceVersion(){let a=this.bb.__offset(this.bb_pos,10);return a?this.bb.readInt32(this.bb_pos+a):0}index(){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.readUint32(this.bb_pos+a):0}opType(a){let u=this.bb.__offset(this.bb_pos,14);return u?this.bb.__string(this.bb_pos+u,a):null}type(){let a=this.bb.__offset(this.bb_pos,16);return a?this.bb.readInt32(this.bb_pos+a):0}executionProviderType(a){let u=this.bb.__offset(this.bb_pos,18);return u?this.bb.__string(this.bb_pos+u,a):null}inputs(a,u){let l=this.bb.__offset(this.bb_pos,20);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+a*4,u):null}inputsLength(){let a=this.bb.__offset(this.bb_pos,20);return a?this.bb.__vector_len(this.bb_pos+a):0}outputs(a,u){let l=this.bb.__offset(this.bb_pos,22);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+a*4,u):null}outputsLength(){let a=this.bb.__offset(this.bb_pos,22);return a?this.bb.__vector_len(this.bb_pos+a):0}attributes(a,u){let l=this.bb.__offset(this.bb_pos,24);return l?(u||new e.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}attributesLength(){let a=this.bb.__offset(this.bb_pos,24);return a?this.bb.__vector_len(this.bb_pos+a):0}inputArgCounts(a){let u=this.bb.__offset(this.bb_pos,26);return u?this.bb.readInt32(this.bb.__vector(this.bb_pos+u)+a*4):0}inputArgCountsLength(){let a=this.bb.__offset(this.bb_pos,26);return a?this.bb.__vector_len(this.bb_pos+a):0}inputArgCountsArray(){let a=this.bb.__offset(this.bb_pos,26);return a?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+a),this.bb.__vector_len(this.bb_pos+a)):null}implicitInputs(a,u){let l=this.bb.__offset(this.bb_pos,28);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+a*4,u):null}implicitInputsLength(){let a=this.bb.__offset(this.bb_pos,28);return a?this.bb.__vector_len(this.bb_pos+a):0}static startNode(a){a.startObject(13)}static addName(a,u){a.addFieldOffset(0,u,0)}static addDocString(a,u){a.addFieldOffset(1,u,0)}static addDomain(a,u){a.addFieldOffset(2,u,0)}static addSinceVersion(a,u){a.addFieldInt32(3,u,0)}static addIndex(a,u){a.addFieldInt32(4,u,0)}static addOpType(a,u){a.addFieldOffset(5,u,0)}static addType(a,u){a.addFieldInt32(6,u,0)}static addExecutionProviderType(a,u){a.addFieldOffset(7,u,0)}static addInputs(a,u){a.addFieldOffset(8,u,0)}static createInputsVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startInputsVector(a,u){a.startVector(4,u,4)}static addOutputs(a,u){a.addFieldOffset(9,u,0)}static createOutputsVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startOutputsVector(a,u){a.startVector(4,u,4)}static addAttributes(a,u){a.addFieldOffset(10,u,0)}static createAttributesVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startAttributesVector(a,u){a.startVector(4,u,4)}static addInputArgCounts(a,u){a.addFieldOffset(11,u,0)}static createInputArgCountsVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addInt32(u[l]);return a.endVector()}static startInputArgCountsVector(a,u){a.startVector(4,u,4)}static addImplicitInputs(a,u){a.addFieldOffset(12,u,0)}static createImplicitInputsVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startImplicitInputsVector(a,u){a.startVector(4,u,4)}static endNode(a){return a.endObject()}static createNode(a,u,l,c,h,m,b,x,y,T,E,_,C,D){return o.startNode(a),o.addName(a,u),o.addDocString(a,l),o.addDomain(a,c),o.addSinceVersion(a,h),o.addIndex(a,m),o.addOpType(a,b),o.addType(a,x),o.addExecutionProviderType(a,y),o.addInputs(a,T),o.addOutputs(a,E),o.addAttributes(a,_),o.addInputArgCounts(a,C),o.addImplicitInputs(a,D),o.endNode(a)}}i.Node=o})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsValueInfo(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsValueInfo(a,u){return a.setPosition(a.position()+B.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}name(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,a):null}docString(a){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,a):null}type(a){let u=this.bb.__offset(this.bb_pos,8);return u?(a||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startValueInfo(a){a.startObject(3)}static addName(a,u){a.addFieldOffset(0,u,0)}static addDocString(a,u){a.addFieldOffset(1,u,0)}static addType(a,u){a.addFieldOffset(2,u,0)}static endValueInfo(a){return a.endObject()}static createValueInfo(a,u,l,c){return o.startValueInfo(a),o.addName(a,u),o.addDocString(a,l),o.addType(a,c),o.endValueInfo(a)}}i.ValueInfo=o})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsTypeInfo(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsTypeInfo(a,u){return a.setPosition(a.position()+B.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}denotation(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,a):null}valueType(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.readUint8(this.bb_pos+a):0}value(a){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.__union(a,this.bb_pos+u):null}static startTypeInfo(a){a.startObject(3)}static addDenotation(a,u){a.addFieldOffset(0,u,0)}static addValueType(a,u){a.addFieldInt8(1,u,0)}static addValue(a,u){a.addFieldOffset(2,u,0)}static endTypeInfo(a){return a.endObject()}static createTypeInfo(a,u,l,c){return o.startTypeInfo(a),o.addDenotation(a,u),o.addValueType(a,l),o.addValue(a,c),o.endTypeInfo(a)}}i.TypeInfo=o})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsOperatorSetId(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsOperatorSetId(a,u){return a.setPosition(a.position()+B.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}domain(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,a):null}version(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}static startOperatorSetId(a){a.startObject(2)}static addDomain(a,u){a.addFieldOffset(0,u,0)}static addVersion(a,u){a.addFieldInt64(1,u,a.createLong(0,0))}static endOperatorSetId(a){return a.endObject()}static createOperatorSetId(a,u,l){return o.startOperatorSetId(a),o.addDomain(a,u),o.addVersion(a,l),o.endOperatorSetId(a)}}i.OperatorSetId=o})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsTensor(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsTensor(a,u){return a.setPosition(a.position()+B.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}name(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,a):null}docString(a){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,a):null}dims(a){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.readInt64(this.bb.__vector(this.bb_pos+u)+a*8):this.bb.createLong(0,0)}dimsLength(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__vector_len(this.bb_pos+a):0}dataType(){let a=this.bb.__offset(this.bb_pos,10);return a?this.bb.readInt32(this.bb_pos+a):0}rawData(a){let u=this.bb.__offset(this.bb_pos,12);return u?this.bb.readUint8(this.bb.__vector(this.bb_pos+u)+a):0}rawDataLength(){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.__vector_len(this.bb_pos+a):0}rawDataArray(){let a=this.bb.__offset(this.bb_pos,12);return a?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+a),this.bb.__vector_len(this.bb_pos+a)):null}stringData(a,u){let l=this.bb.__offset(this.bb_pos,14);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+a*4,u):null}stringDataLength(){let a=this.bb.__offset(this.bb_pos,14);return a?this.bb.__vector_len(this.bb_pos+a):0}static startTensor(a){a.startObject(6)}static addName(a,u){a.addFieldOffset(0,u,0)}static addDocString(a,u){a.addFieldOffset(1,u,0)}static addDims(a,u){a.addFieldOffset(2,u,0)}static createDimsVector(a,u){a.startVector(8,u.length,8);for(let l=u.length-1;l>=0;l--)a.addInt64(u[l]);return a.endVector()}static startDimsVector(a,u){a.startVector(8,u,8)}static addDataType(a,u){a.addFieldInt32(3,u,0)}static addRawData(a,u){a.addFieldOffset(4,u,0)}static createRawDataVector(a,u){a.startVector(1,u.length,1);for(let l=u.length-1;l>=0;l--)a.addInt8(u[l]);return a.endVector()}static startRawDataVector(a,u){a.startVector(1,u,1)}static addStringData(a,u){a.addFieldOffset(5,u,0)}static createStringDataVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startStringDataVector(a,u){a.startVector(4,u,4)}static endTensor(a){return a.endObject()}static createTensor(a,u,l,c,h,m,b){return o.startTensor(a),o.addName(a,u),o.addDocString(a,l),o.addDims(a,c),o.addDataType(a,h),o.addRawData(a,m),o.addStringData(a,b),o.endTensor(a)}}i.Tensor=o})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsSparseTensor(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsSparseTensor(a,u){return a.setPosition(a.position()+B.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}values(a){let u=this.bb.__offset(this.bb_pos,4);return u?(a||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}indices(a){let u=this.bb.__offset(this.bb_pos,6);return u?(a||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}dims(a){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.readInt64(this.bb.__vector(this.bb_pos+u)+a*8):this.bb.createLong(0,0)}dimsLength(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__vector_len(this.bb_pos+a):0}static startSparseTensor(a){a.startObject(3)}static addValues(a,u){a.addFieldOffset(0,u,0)}static addIndices(a,u){a.addFieldOffset(1,u,0)}static addDims(a,u){a.addFieldOffset(2,u,0)}static createDimsVector(a,u){a.startVector(8,u.length,8);for(let l=u.length-1;l>=0;l--)a.addInt64(u[l]);return a.endVector()}static startDimsVector(a,u){a.startVector(8,u,8)}static endSparseTensor(a){return a.endObject()}static createSparseTensor(a,u,l,c){return o.startSparseTensor(a),o.addValues(a,u),o.addIndices(a,l),o.addDims(a,c),o.endSparseTensor(a)}}i.SparseTensor=o})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsAttribute(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsAttribute(a,u){return a.setPosition(a.position()+B.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}name(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,a):null}docString(a){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,a):null}type(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.readInt32(this.bb_pos+a):0}f(){let a=this.bb.__offset(this.bb_pos,10);return a?this.bb.readFloat32(this.bb_pos+a):0}i(){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}s(a){let u=this.bb.__offset(this.bb_pos,14);return u?this.bb.__string(this.bb_pos+u,a):null}t(a){let u=this.bb.__offset(this.bb_pos,16);return u?(a||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}g(a){let u=this.bb.__offset(this.bb_pos,18);return u?(a||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}floats(a){let u=this.bb.__offset(this.bb_pos,20);return u?this.bb.readFloat32(this.bb.__vector(this.bb_pos+u)+a*4):0}floatsLength(){let a=this.bb.__offset(this.bb_pos,20);return a?this.bb.__vector_len(this.bb_pos+a):0}floatsArray(){let a=this.bb.__offset(this.bb_pos,20);return a?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+a),this.bb.__vector_len(this.bb_pos+a)):null}ints(a){let u=this.bb.__offset(this.bb_pos,22);return u?this.bb.readInt64(this.bb.__vector(this.bb_pos+u)+a*8):this.bb.createLong(0,0)}intsLength(){let a=this.bb.__offset(this.bb_pos,22);return a?this.bb.__vector_len(this.bb_pos+a):0}strings(a,u){let l=this.bb.__offset(this.bb_pos,24);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+a*4,u):null}stringsLength(){let a=this.bb.__offset(this.bb_pos,24);return a?this.bb.__vector_len(this.bb_pos+a):0}tensors(a,u){let l=this.bb.__offset(this.bb_pos,26);return l?(u||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}tensorsLength(){let a=this.bb.__offset(this.bb_pos,26);return a?this.bb.__vector_len(this.bb_pos+a):0}graphs(a,u){let l=this.bb.__offset(this.bb_pos,28);return l?(u||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}graphsLength(){let a=this.bb.__offset(this.bb_pos,28);return a?this.bb.__vector_len(this.bb_pos+a):0}static startAttribute(a){a.startObject(13)}static addName(a,u){a.addFieldOffset(0,u,0)}static addDocString(a,u){a.addFieldOffset(1,u,0)}static addType(a,u){a.addFieldInt32(2,u,0)}static addF(a,u){a.addFieldFloat32(3,u,0)}static addI(a,u){a.addFieldInt64(4,u,a.createLong(0,0))}static addS(a,u){a.addFieldOffset(5,u,0)}static addT(a,u){a.addFieldOffset(6,u,0)}static addG(a,u){a.addFieldOffset(7,u,0)}static addFloats(a,u){a.addFieldOffset(8,u,0)}static createFloatsVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addFloat32(u[l]);return a.endVector()}static startFloatsVector(a,u){a.startVector(4,u,4)}static addInts(a,u){a.addFieldOffset(9,u,0)}static createIntsVector(a,u){a.startVector(8,u.length,8);for(let l=u.length-1;l>=0;l--)a.addInt64(u[l]);return a.endVector()}static startIntsVector(a,u){a.startVector(8,u,8)}static addStrings(a,u){a.addFieldOffset(10,u,0)}static createStringsVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startStringsVector(a,u){a.startVector(4,u,4)}static addTensors(a,u){a.addFieldOffset(11,u,0)}static createTensorsVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startTensorsVector(a,u){a.startVector(4,u,4)}static addGraphs(a,u){a.addFieldOffset(12,u,0)}static createGraphsVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startGraphsVector(a,u){a.startVector(4,u,4)}static endAttribute(a){return a.endObject()}static createAttribute(a,u,l,c,h,m,b,x,y,T,E,_,C,D){return o.startAttribute(a),o.addName(a,u),o.addDocString(a,l),o.addType(a,c),o.addF(a,h),o.addI(a,m),o.addS(a,b),o.addT(a,x),o.addG(a,y),o.addFloats(a,T),o.addInts(a,E),o.addStrings(a,_),o.addTensors(a,C),o.addGraphs(a,D),o.endAttribute(a)}}i.Attribute=o})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsGraph(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsGraph(a,u){return a.setPosition(a.position()+B.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}initializers(a,u){let l=this.bb.__offset(this.bb_pos,4);return l?(u||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}initializersLength(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__vector_len(this.bb_pos+a):0}nodeArgs(a,u){let l=this.bb.__offset(this.bb_pos,6);return l?(u||new e.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}nodeArgsLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}nodes(a,u){let l=this.bb.__offset(this.bb_pos,8);return l?(u||new e.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}nodesLength(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__vector_len(this.bb_pos+a):0}maxNodeIndex(){let a=this.bb.__offset(this.bb_pos,10);return a?this.bb.readUint32(this.bb_pos+a):0}nodeEdges(a,u){let l=this.bb.__offset(this.bb_pos,12);return l?(u||new e.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}nodeEdgesLength(){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.__vector_len(this.bb_pos+a):0}inputs(a,u){let l=this.bb.__offset(this.bb_pos,14);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+a*4,u):null}inputsLength(){let a=this.bb.__offset(this.bb_pos,14);return a?this.bb.__vector_len(this.bb_pos+a):0}outputs(a,u){let l=this.bb.__offset(this.bb_pos,16);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+a*4,u):null}outputsLength(){let a=this.bb.__offset(this.bb_pos,16);return a?this.bb.__vector_len(this.bb_pos+a):0}sparseInitializers(a,u){let l=this.bb.__offset(this.bb_pos,18);return l?(u||new e.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}sparseInitializersLength(){let a=this.bb.__offset(this.bb_pos,18);return a?this.bb.__vector_len(this.bb_pos+a):0}static startGraph(a){a.startObject(8)}static addInitializers(a,u){a.addFieldOffset(0,u,0)}static createInitializersVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startInitializersVector(a,u){a.startVector(4,u,4)}static addNodeArgs(a,u){a.addFieldOffset(1,u,0)}static createNodeArgsVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startNodeArgsVector(a,u){a.startVector(4,u,4)}static addNodes(a,u){a.addFieldOffset(2,u,0)}static createNodesVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startNodesVector(a,u){a.startVector(4,u,4)}static addMaxNodeIndex(a,u){a.addFieldInt32(3,u,0)}static addNodeEdges(a,u){a.addFieldOffset(4,u,0)}static createNodeEdgesVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startNodeEdgesVector(a,u){a.startVector(4,u,4)}static addInputs(a,u){a.addFieldOffset(5,u,0)}static createInputsVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startInputsVector(a,u){a.startVector(4,u,4)}static addOutputs(a,u){a.addFieldOffset(6,u,0)}static createOutputsVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startOutputsVector(a,u){a.startVector(4,u,4)}static addSparseInitializers(a,u){a.addFieldOffset(7,u,0)}static createSparseInitializersVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startSparseInitializersVector(a,u){a.startVector(4,u,4)}static endGraph(a){return a.endObject()}static createGraph(a,u,l,c,h,m,b,x,y){return o.startGraph(a),o.addInitializers(a,u),o.addNodeArgs(a,l),o.addNodes(a,c),o.addMaxNodeIndex(a,h),o.addNodeEdges(a,m),o.addInputs(a,b),o.addOutputs(a,x),o.addSparseInitializers(a,y),o.endGraph(a)}}i.Graph=o})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsModel(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsModel(a,u){return a.setPosition(a.position()+B.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}irVersion(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}opsetImport(a,u){let l=this.bb.__offset(this.bb_pos,6);return l?(u||new e.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}opsetImportLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}producerName(a){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.__string(this.bb_pos+u,a):null}producerVersion(a){let u=this.bb.__offset(this.bb_pos,10);return u?this.bb.__string(this.bb_pos+u,a):null}domain(a){let u=this.bb.__offset(this.bb_pos,12);return u?this.bb.__string(this.bb_pos+u,a):null}modelVersion(){let a=this.bb.__offset(this.bb_pos,14);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}docString(a){let u=this.bb.__offset(this.bb_pos,16);return u?this.bb.__string(this.bb_pos+u,a):null}graph(a){let u=this.bb.__offset(this.bb_pos,18);return u?(a||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}graphDocString(a){let u=this.bb.__offset(this.bb_pos,20);return u?this.bb.__string(this.bb_pos+u,a):null}static startModel(a){a.startObject(9)}static addIrVersion(a,u){a.addFieldInt64(0,u,a.createLong(0,0))}static addOpsetImport(a,u){a.addFieldOffset(1,u,0)}static createOpsetImportVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startOpsetImportVector(a,u){a.startVector(4,u,4)}static addProducerName(a,u){a.addFieldOffset(2,u,0)}static addProducerVersion(a,u){a.addFieldOffset(3,u,0)}static addDomain(a,u){a.addFieldOffset(4,u,0)}static addModelVersion(a,u){a.addFieldInt64(5,u,a.createLong(0,0))}static addDocString(a,u){a.addFieldOffset(6,u,0)}static addGraph(a,u){a.addFieldOffset(7,u,0)}static addGraphDocString(a,u){a.addFieldOffset(8,u,0)}static endModel(a){return a.endObject()}static createModel(a,u,l,c,h,m,b,x,y,T){return o.startModel(a),o.addIrVersion(a,u),o.addOpsetImport(a,l),o.addProducerName(a,c),o.addProducerVersion(a,h),o.addDomain(a,m),o.addModelVersion(a,b),o.addDocString(a,x),o.addGraph(a,y),o.addGraphDocString(a,T),o.endModel(a)}}i.Model=o})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsKernelCreateInfos(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsKernelCreateInfos(a,u){return a.setPosition(a.position()+B.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}nodeIndices(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.readUint32(this.bb.__vector(this.bb_pos+u)+a*4):0}nodeIndicesLength(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__vector_len(this.bb_pos+a):0}nodeIndicesArray(){let a=this.bb.__offset(this.bb_pos,4);return a?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+a),this.bb.__vector_len(this.bb_pos+a)):null}kernelDefHashes(a){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.readUint64(this.bb.__vector(this.bb_pos+u)+a*8):this.bb.createLong(0,0)}kernelDefHashesLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}static startKernelCreateInfos(a){a.startObject(2)}static addNodeIndices(a,u){a.addFieldOffset(0,u,0)}static createNodeIndicesVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addInt32(u[l]);return a.endVector()}static startNodeIndicesVector(a,u){a.startVector(4,u,4)}static addKernelDefHashes(a,u){a.addFieldOffset(1,u,0)}static createKernelDefHashesVector(a,u){a.startVector(8,u.length,8);for(let l=u.length-1;l>=0;l--)a.addInt64(u[l]);return a.endVector()}static startKernelDefHashesVector(a,u){a.startVector(8,u,8)}static endKernelCreateInfos(a){return a.endObject()}static createKernelCreateInfos(a,u,l){return o.startKernelCreateInfos(a),o.addNodeIndices(a,u),o.addKernelDefHashes(a,l),o.endKernelCreateInfos(a)}}i.KernelCreateInfos=o})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsSubGraphSessionState(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsSubGraphSessionState(a,u){return a.setPosition(a.position()+B.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}graphId(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,a):null}sessionState(a){let u=this.bb.__offset(this.bb_pos,6);return u?(a||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startSubGraphSessionState(a){a.startObject(2)}static addGraphId(a,u){a.addFieldOffset(0,u,0)}static addSessionState(a,u){a.addFieldOffset(1,u,0)}static endSubGraphSessionState(a){let u=a.endObject();return a.requiredField(u,4),u}static createSubGraphSessionState(a,u,l){return o.startSubGraphSessionState(a),o.addGraphId(a,u),o.addSessionState(a,l),o.endSubGraphSessionState(a)}}i.SubGraphSessionState=o})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsSessionState(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsSessionState(a,u){return a.setPosition(a.position()+B.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}kernels(a){let u=this.bb.__offset(this.bb_pos,4);return u?(a||new e.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}subGraphSessionStates(a,u){let l=this.bb.__offset(this.bb_pos,6);return l?(u||new e.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}subGraphSessionStatesLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}static startSessionState(a){a.startObject(2)}static addKernels(a,u){a.addFieldOffset(0,u,0)}static addSubGraphSessionStates(a,u){a.addFieldOffset(1,u,0)}static createSubGraphSessionStatesVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startSubGraphSessionStatesVector(a,u){a.startVector(4,u,4)}static endSessionState(a){return a.endObject()}static createSessionState(a,u,l){return o.startSessionState(a),o.addKernels(a,u),o.addSubGraphSessionStates(a,l),o.endSessionState(a)}}i.SessionState=o})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsInferenceSession(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsInferenceSession(a,u){return a.setPosition(a.position()+B.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static bufferHasIdentifier(a){return a.__has_identifier("ORTM")}ortVersion(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,a):null}model(a){let u=this.bb.__offset(this.bb_pos,6);return u?(a||new e.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}sessionState(a){let u=this.bb.__offset(this.bb_pos,8);return u?(a||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startInferenceSession(a){a.startObject(3)}static addOrtVersion(a,u){a.addFieldOffset(0,u,0)}static addModel(a,u){a.addFieldOffset(1,u,0)}static addSessionState(a,u){a.addFieldOffset(2,u,0)}static endInferenceSession(a){return a.endObject()}static finishInferenceSessionBuffer(a,u){a.finish(u,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(a,u){a.finish(u,"ORTM",!0)}static createInferenceSession(a,u,l,c){return o.startInferenceSession(a),o.addOrtVersion(a,u),o.addModel(a,l),o.addSessionState(a,c),o.endInferenceSession(a)}}i.InferenceSession=o})(n=t.fbs||={})})(r=e.experimental||={})})(ie||={})});var ic=He((A$,oc)=>{"use strict";oc.exports=A0;function A0(r,e){for(var n=new Array(arguments.length-1),t=0,o=2,i=!0;o<arguments.length;)n[t++]=arguments[o++];return new Promise(function(a,u){n[t]=function(c){if(i)if(i=!1,c)u(c);else{for(var h=new Array(arguments.length-1),m=0;m<h.length;)h[m++]=arguments[m];a.apply(null,h)}};try{r.apply(e||null,n)}catch(l){i&&(i=!1,u(l))}})}});var lc=He(uc=>{"use strict";var di=uc;di.length=function(e){var n=e.length;if(!n)return 0;for(var t=0;--n%4>1&&e.charAt(n)==="=";)++t;return Math.ceil(e.length*3)/4-t};var Pn=new Array(64),sc=new Array(123);for(Qt=0;Qt<64;)sc[Pn[Qt]=Qt<26?Qt+65:Qt<52?Qt+71:Qt<62?Qt-4:Qt-59|43]=Qt++;var Qt;di.encode=function(e,n,t){for(var o=null,i=[],s=0,a=0,u;n<t;){var l=e[n++];switch(a){case 0:i[s++]=Pn[l>>2],u=(l&3)<<4,a=1;break;case 1:i[s++]=Pn[u|l>>4],u=(l&15)<<2,a=2;break;case 2:i[s++]=Pn[u|l>>6],i[s++]=Pn[l&63],a=0;break}s>8191&&((o||(o=[])).push(String.fromCharCode.apply(String,i)),s=0)}return a&&(i[s++]=Pn[u],i[s++]=61,a===1&&(i[s++]=61)),o?(s&&o.push(String.fromCharCode.apply(String,i.slice(0,s))),o.join("")):String.fromCharCode.apply(String,i.slice(0,s))};var ac="invalid encoding";di.decode=function(e,n,t){for(var o=t,i=0,s,a=0;a<e.length;){var u=e.charCodeAt(a++);if(u===61&&i>1)break;if((u=sc[u])===void 0)throw Error(ac);switch(i){case 0:s=u,i=1;break;case 1:n[t++]=s<<2|(u&48)>>4,s=u,i=2;break;case 2:n[t++]=(s&15)<<4|(u&60)>>2,s=u,i=3;break;case 3:n[t++]=(s&3)<<6|u,i=0;break}}if(i===1)throw Error(ac);return t-o};di.test=function(e){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e)}});var dc=He((O$,cc)=>{"use strict";cc.exports=fi;function fi(){this._listeners={}}fi.prototype.on=function(e,n,t){return(this._listeners[e]||(this._listeners[e]=[])).push({fn:n,ctx:t||this}),this};fi.prototype.off=function(e,n){if(e===void 0)this._listeners={};else if(n===void 0)this._listeners[e]=[];else for(var t=this._listeners[e],o=0;o<t.length;)t[o].fn===n?t.splice(o,1):++o;return this};fi.prototype.emit=function(e){var n=this._listeners[e];if(n){for(var t=[],o=1;o<arguments.length;)t.push(arguments[o++]);for(o=0;o<n.length;)n[o].fn.apply(n[o++].ctx,t)}return this}});var yc=He((C$,bc)=>{"use strict";bc.exports=fc(fc);function fc(r){return typeof Float32Array<"u"?function(){var e=new Float32Array([-0]),n=new Uint8Array(e.buffer),t=n[3]===128;function o(u,l,c){e[0]=u,l[c]=n[0],l[c+1]=n[1],l[c+2]=n[2],l[c+3]=n[3]}function i(u,l,c){e[0]=u,l[c]=n[3],l[c+1]=n[2],l[c+2]=n[1],l[c+3]=n[0]}r.writeFloatLE=t?o:i,r.writeFloatBE=t?i:o;function s(u,l){return n[0]=u[l],n[1]=u[l+1],n[2]=u[l+2],n[3]=u[l+3],e[0]}function a(u,l){return n[3]=u[l],n[2]=u[l+1],n[1]=u[l+2],n[0]=u[l+3],e[0]}r.readFloatLE=t?s:a,r.readFloatBE=t?a:s}():function(){function e(t,o,i,s){var a=o<0?1:0;if(a&&(o=-o),o===0)t(1/o>0?0:2147483648,i,s);else if(isNaN(o))t(2143289344,i,s);else if(o>34028234663852886e22)t((a<<31|2139095040)>>>0,i,s);else if(o<11754943508222875e-54)t((a<<31|Math.round(o/1401298464324817e-60))>>>0,i,s);else{var u=Math.floor(Math.log(o)/Math.LN2),l=Math.round(o*Math.pow(2,-u)*8388608)&8388607;t((a<<31|u+127<<23|l)>>>0,i,s)}}r.writeFloatLE=e.bind(null,pc),r.writeFloatBE=e.bind(null,hc);function n(t,o,i){var s=t(o,i),a=(s>>31)*2+1,u=s>>>23&255,l=s&8388607;return u===255?l?NaN:a*(1/0):u===0?a*1401298464324817e-60*l:a*Math.pow(2,u-150)*(l+8388608)}r.readFloatLE=n.bind(null,mc),r.readFloatBE=n.bind(null,gc)}(),typeof Float64Array<"u"?function(){var e=new Float64Array([-0]),n=new Uint8Array(e.buffer),t=n[7]===128;function o(u,l,c){e[0]=u,l[c]=n[0],l[c+1]=n[1],l[c+2]=n[2],l[c+3]=n[3],l[c+4]=n[4],l[c+5]=n[5],l[c+6]=n[6],l[c+7]=n[7]}function i(u,l,c){e[0]=u,l[c]=n[7],l[c+1]=n[6],l[c+2]=n[5],l[c+3]=n[4],l[c+4]=n[3],l[c+5]=n[2],l[c+6]=n[1],l[c+7]=n[0]}r.writeDoubleLE=t?o:i,r.writeDoubleBE=t?i:o;function s(u,l){return n[0]=u[l],n[1]=u[l+1],n[2]=u[l+2],n[3]=u[l+3],n[4]=u[l+4],n[5]=u[l+5],n[6]=u[l+6],n[7]=u[l+7],e[0]}function a(u,l){return n[7]=u[l],n[6]=u[l+1],n[5]=u[l+2],n[4]=u[l+3],n[3]=u[l+4],n[2]=u[l+5],n[1]=u[l+6],n[0]=u[l+7],e[0]}r.readDoubleLE=t?s:a,r.readDoubleBE=t?a:s}():function(){function e(t,o,i,s,a,u){var l=s<0?1:0;if(l&&(s=-s),s===0)t(0,a,u+o),t(1/s>0?0:2147483648,a,u+i);else if(isNaN(s))t(0,a,u+o),t(2146959360,a,u+i);else if(s>17976931348623157e292)t(0,a,u+o),t((l<<31|2146435072)>>>0,a,u+i);else{var c;if(s<22250738585072014e-324)c=s/5e-324,t(c>>>0,a,u+o),t((l<<31|c/4294967296)>>>0,a,u+i);else{var h=Math.floor(Math.log(s)/Math.LN2);h===1024&&(h=1023),c=s*Math.pow(2,-h),t(c*4503599627370496>>>0,a,u+o),t((l<<31|h+1023<<20|c*1048576&1048575)>>>0,a,u+i)}}}r.writeDoubleLE=e.bind(null,pc,0,4),r.writeDoubleBE=e.bind(null,hc,4,0);function n(t,o,i,s,a){var u=t(s,a+o),l=t(s,a+i),c=(l>>31)*2+1,h=l>>>20&2047,m=4294967296*(l&1048575)+u;return h===2047?m?NaN:c*(1/0):h===0?c*5e-324*m:c*Math.pow(2,h-1075)*(m+4503599627370496)}r.readDoubleLE=n.bind(null,mc,0,4),r.readDoubleBE=n.bind(null,gc,4,0)}(),r}function pc(r,e,n){e[n]=r&255,e[n+1]=r>>>8&255,e[n+2]=r>>>16&255,e[n+3]=r>>>24}function hc(r,e,n){e[n]=r>>>24,e[n+1]=r>>>16&255,e[n+2]=r>>>8&255,e[n+3]=r&255}function mc(r,e){return(r[e]|r[e+1]<<8|r[e+2]<<16|r[e+3]<<24)>>>0}function gc(r,e){return(r[e]<<24|r[e+1]<<16|r[e+2]<<8|r[e+3])>>>0}});var vc=He((exports,module)=>{"use strict";module.exports=inquire;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(r){}return null}});var wc=He(xc=>{"use strict";var Va=xc;Va.length=function(e){for(var n=0,t=0,o=0;o<e.length;++o)t=e.charCodeAt(o),t<128?n+=1:t<2048?n+=2:(t&64512)===55296&&(e.charCodeAt(o+1)&64512)===56320?(++o,n+=4):n+=3;return n};Va.read=function(e,n,t){var o=t-n;if(o<1)return"";for(var i=null,s=[],a=0,u;n<t;)u=e[n++],u<128?s[a++]=u:u>191&&u<224?s[a++]=(u&31)<<6|e[n++]&63:u>239&&u<365?(u=((u&7)<<18|(e[n++]&63)<<12|(e[n++]&63)<<6|e[n++]&63)-65536,s[a++]=55296+(u>>10),s[a++]=56320+(u&1023)):s[a++]=(u&15)<<12|(e[n++]&63)<<6|e[n++]&63,a>8191&&((i||(i=[])).push(String.fromCharCode.apply(String,s)),a=0);return i?(a&&i.push(String.fromCharCode.apply(String,s.slice(0,a))),i.join("")):String.fromCharCode.apply(String,s.slice(0,a))};Va.write=function(e,n,t){for(var o=t,i,s,a=0;a<e.length;++a)i=e.charCodeAt(a),i<128?n[t++]=i:i<2048?(n[t++]=i>>6|192,n[t++]=i&63|128):(i&64512)===55296&&((s=e.charCodeAt(a+1))&64512)===56320?(i=65536+((i&1023)<<10)+(s&1023),++a,n[t++]=i>>18|240,n[t++]=i>>12&63|128,n[t++]=i>>6&63|128,n[t++]=i&63|128):(n[t++]=i>>12|224,n[t++]=i>>6&63|128,n[t++]=i&63|128);return t-o}});var $c=He((P$,Tc)=>{"use strict";Tc.exports=_0;function _0(r,e,n){var t=n||8192,o=t>>>1,i=null,s=t;return function(u){if(u<1||u>o)return r(u);s+u>t&&(i=r(t),s=0);var l=e.call(i,s,s+=u);return s&7&&(s=(s|7)+1),l}}});var Ic=He((D$,Sc)=>{"use strict";Sc.exports=ht;var uo=Fr();function ht(r,e){this.lo=r>>>0,this.hi=e>>>0}var on=ht.zero=new ht(0,0);on.toNumber=function(){return 0};on.zzEncode=on.zzDecode=function(){return this};on.length=function(){return 1};var O0=ht.zeroHash="\0\0\0\0\0\0\0\0";ht.fromNumber=function(e){if(e===0)return on;var n=e<0;n&&(e=-e);var t=e>>>0,o=(e-t)/4294967296>>>0;return n&&(o=~o>>>0,t=~t>>>0,++t>4294967295&&(t=0,++o>4294967295&&(o=0))),new ht(t,o)};ht.from=function(e){if(typeof e=="number")return ht.fromNumber(e);if(uo.isString(e))if(uo.Long)e=uo.Long.fromString(e);else return ht.fromNumber(parseInt(e,10));return e.low||e.high?new ht(e.low>>>0,e.high>>>0):on};ht.prototype.toNumber=function(e){if(!e&&this.hi>>>31){var n=~this.lo+1>>>0,t=~this.hi>>>0;return n||(t=t+1>>>0),-(n+t*4294967296)}return this.lo+this.hi*4294967296};ht.prototype.toLong=function(e){return uo.Long?new uo.Long(this.lo|0,this.hi|0,!!e):{low:this.lo|0,high:this.hi|0,unsigned:!!e}};var Nr=String.prototype.charCodeAt;ht.fromHash=function(e){return e===O0?on:new ht((Nr.call(e,0)|Nr.call(e,1)<<8|Nr.call(e,2)<<16|Nr.call(e,3)<<24)>>>0,(Nr.call(e,4)|Nr.call(e,5)<<8|Nr.call(e,6)<<16|Nr.call(e,7)<<24)>>>0)};ht.prototype.toHash=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)};ht.prototype.zzEncode=function(){var e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this};ht.prototype.zzDecode=function(){var e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this};ht.prototype.length=function(){var e=this.lo,n=(this.lo>>>28|this.hi<<4)>>>0,t=this.hi>>>24;return t===0?n===0?e<16384?e<128?1:2:e<2097152?3:4:n<16384?n<128?5:6:n<2097152?7:8:t<128?9:10}});var Fr=He(Wa=>{"use strict";var ue=Wa;ue.asPromise=ic();ue.base64=lc();ue.EventEmitter=dc();ue.float=yc();ue.inquire=vc();ue.utf8=wc();ue.pool=$c();ue.LongBits=Ic();ue.isNode=!!(typeof global<"u"&&global&&global.process&&global.process.versions&&global.process.versions.node);ue.global=ue.isNode&&global||typeof window<"u"&&window||typeof self<"u"&&self||Wa;ue.emptyArray=Object.freeze?Object.freeze([]):[];ue.emptyObject=Object.freeze?Object.freeze({}):{};ue.isInteger=Number.isInteger||function(e){return typeof e=="number"&&isFinite(e)&&Math.floor(e)===e};ue.isString=function(e){return typeof e=="string"||e instanceof String};ue.isObject=function(e){return e&&typeof e=="object"};ue.isset=ue.isSet=function(e,n){var t=e[n];return t!=null&&e.hasOwnProperty(n)?typeof t!="object"||(Array.isArray(t)?t.length:Object.keys(t).length)>0:!1};ue.Buffer=function(){try{var r=ue.inquire("buffer").Buffer;return r.prototype.utf8Write?r:null}catch{return null}}();ue._Buffer_from=null;ue._Buffer_allocUnsafe=null;ue.newBuffer=function(e){return typeof e=="number"?ue.Buffer?ue._Buffer_allocUnsafe(e):new ue.Array(e):ue.Buffer?ue._Buffer_from(e):typeof Uint8Array>"u"?e:new Uint8Array(e)};ue.Array=typeof Uint8Array<"u"?Uint8Array:Array;ue.Long=ue.global.dcodeIO&&ue.global.dcodeIO.Long||ue.global.Long||ue.inquire("long");ue.key2Re=/^true|false|0|1$/;ue.key32Re=/^-?(?:0|[1-9][0-9]*)$/;ue.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;ue.longToHash=function(e){return e?ue.LongBits.from(e).toHash():ue.LongBits.zeroHash};ue.longFromHash=function(e,n){var t=ue.LongBits.fromHash(e);return ue.Long?ue.Long.fromBits(t.lo,t.hi,n):t.toNumber(!!n)};function Ac(r,e,n){for(var t=Object.keys(e),o=0;o<t.length;++o)(r[t[o]]===void 0||!n)&&(r[t[o]]=e[t[o]]);return r}ue.merge=Ac;ue.lcFirst=function(e){return e.charAt(0).toLowerCase()+e.substring(1)};function _c(r){function e(n,t){if(!(this instanceof e))return new e(n,t);Object.defineProperty(this,"message",{get:function(){return n}}),Error.captureStackTrace?Error.captureStackTrace(this,e):Object.defineProperty(this,"stack",{value:new Error().stack||""}),t&&Ac(this,t)}return e.prototype=Object.create(Error.prototype,{constructor:{value:e,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return r},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),e}ue.newError=_c;ue.ProtocolError=_c("ProtocolError");ue.oneOfGetter=function(e){for(var n={},t=0;t<e.length;++t)n[e[t]]=1;return function(){for(var o=Object.keys(this),i=o.length-1;i>-1;--i)if(n[o[i]]===1&&this[o[i]]!==void 0&&this[o[i]]!==null)return o[i]}};ue.oneOfSetter=function(e){return function(n){for(var t=0;t<e.length;++t)e[t]!==n&&delete this[e[t]]}};ue.toJSONOptions={longs:String,enums:String,bytes:String,json:!0};ue._configure=function(){var r=ue.Buffer;if(!r){ue._Buffer_from=ue._Buffer_allocUnsafe=null;return}ue._Buffer_from=r.from!==Uint8Array.from&&r.from||function(n,t){return new r(n,t)},ue._Buffer_allocUnsafe=r.allocUnsafe||function(n){return new r(n)}}});var Ya=He((B$,Pc)=>{"use strict";Pc.exports=Re;var Gt=Fr(),Ua,pi=Gt.LongBits,Oc=Gt.base64,Cc=Gt.utf8;function lo(r,e,n){this.fn=r,this.len=e,this.next=void 0,this.val=n}function ja(){}function C0(r){this.head=r.head,this.tail=r.tail,this.len=r.len,this.next=r.states}function Re(){this.len=0,this.head=new lo(ja,0,0),this.tail=this.head,this.states=null}var Ec=function(){return Gt.Buffer?function(){return(Re.create=function(){return new Ua})()}:function(){return new Re}};Re.create=Ec();Re.alloc=function(e){return new Gt.Array(e)};Gt.Array!==Array&&(Re.alloc=Gt.pool(Re.alloc,Gt.Array.prototype.subarray));Re.prototype._push=function(e,n,t){return this.tail=this.tail.next=new lo(e,n,t),this.len+=n,this};function qa(r,e,n){e[n]=r&255}function E0(r,e,n){for(;r>127;)e[n++]=r&127|128,r>>>=7;e[n]=r}function Ka(r,e){this.len=r,this.next=void 0,this.val=e}Ka.prototype=Object.create(lo.prototype);Ka.prototype.fn=E0;Re.prototype.uint32=function(e){return this.len+=(this.tail=this.tail.next=new Ka((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this};Re.prototype.int32=function(e){return e<0?this._push(Xa,10,pi.fromNumber(e)):this.uint32(e)};Re.prototype.sint32=function(e){return this.uint32((e<<1^e>>31)>>>0)};function Xa(r,e,n){for(;r.hi;)e[n++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)e[n++]=r.lo&127|128,r.lo=r.lo>>>7;e[n++]=r.lo}Re.prototype.uint64=function(e){var n=pi.from(e);return this._push(Xa,n.length(),n)};Re.prototype.int64=Re.prototype.uint64;Re.prototype.sint64=function(e){var n=pi.from(e).zzEncode();return this._push(Xa,n.length(),n)};Re.prototype.bool=function(e){return this._push(qa,1,e?1:0)};function Ha(r,e,n){e[n]=r&255,e[n+1]=r>>>8&255,e[n+2]=r>>>16&255,e[n+3]=r>>>24}Re.prototype.fixed32=function(e){return this._push(Ha,4,e>>>0)};Re.prototype.sfixed32=Re.prototype.fixed32;Re.prototype.fixed64=function(e){var n=pi.from(e);return this._push(Ha,4,n.lo)._push(Ha,4,n.hi)};Re.prototype.sfixed64=Re.prototype.fixed64;Re.prototype.float=function(e){return this._push(Gt.float.writeFloatLE,4,e)};Re.prototype.double=function(e){return this._push(Gt.float.writeDoubleLE,8,e)};var P0=Gt.Array.prototype.set?function(e,n,t){n.set(e,t)}:function(e,n,t){for(var o=0;o<e.length;++o)n[t+o]=e[o]};Re.prototype.bytes=function(e){var n=e.length>>>0;if(!n)return this._push(qa,1,0);if(Gt.isString(e)){var t=Re.alloc(n=Oc.length(e));Oc.decode(e,t,0),e=t}return this.uint32(n)._push(P0,n,e)};Re.prototype.string=function(e){var n=Cc.length(e);return n?this.uint32(n)._push(Cc.write,n,e):this._push(qa,1,0)};Re.prototype.fork=function(){return this.states=new C0(this),this.head=this.tail=new lo(ja,0,0),this.len=0,this};Re.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new lo(ja,0,0),this.len=0),this};Re.prototype.ldelim=function(){var e=this.head,n=this.tail,t=this.len;return this.reset().uint32(t),t&&(this.tail.next=e.next,this.tail=n,this.len+=t),this};Re.prototype.finish=function(){for(var e=this.head.next,n=this.constructor.alloc(this.len),t=0;e;)e.fn(e.val,n,t),t+=e.len,e=e.next;return n};Re._configure=function(r){Ua=r,Re.create=Ec(),Ua._configure()}});var Bc=He((R$,kc)=>{"use strict";kc.exports=lr;var Dc=Ya();(lr.prototype=Object.create(Dc.prototype)).constructor=lr;var zr=Fr();function lr(){Dc.call(this)}lr._configure=function(){lr.alloc=zr._Buffer_allocUnsafe,lr.writeBytesBuffer=zr.Buffer&&zr.Buffer.prototype instanceof Uint8Array&&zr.Buffer.prototype.set.name==="set"?function(e,n,t){n.set(e,t)}:function(e,n,t){if(e.copy)e.copy(n,t,0,e.length);else for(var o=0;o<e.length;)n[t++]=e[o++]}};lr.prototype.bytes=function(e){zr.isString(e)&&(e=zr._Buffer_from(e,"base64"));var n=e.length>>>0;return this.uint32(n),n&&this._push(lr.writeBytesBuffer,n,e),this};function D0(r,e,n){r.length<40?zr.utf8.write(r,e,n):e.utf8Write?e.utf8Write(r,n):e.write(r,n)}lr.prototype.string=function(e){var n=zr.Buffer.byteLength(e);return this.uint32(n),n&&this._push(D0,n,e),this};lr._configure()});var Qa=He((M$,Fc)=>{"use strict";Fc.exports=nt;var cr=Fr(),Za,Lc=cr.LongBits,k0=cr.utf8;function er(r,e){return RangeError("index out of range: "+r.pos+" + "+(e||1)+" > "+r.len)}function nt(r){this.buf=r,this.pos=0,this.len=r.length}var Rc=typeof Uint8Array<"u"?function(e){if(e instanceof Uint8Array||Array.isArray(e))return new nt(e);throw Error("illegal buffer")}:function(e){if(Array.isArray(e))return new nt(e);throw Error("illegal buffer")},Nc=function(){return cr.Buffer?function(n){return(nt.create=function(o){return cr.Buffer.isBuffer(o)?new Za(o):Rc(o)})(n)}:Rc};nt.create=Nc();nt.prototype._slice=cr.Array.prototype.subarray||cr.Array.prototype.slice;nt.prototype.uint32=function(){var e=4294967295;return function(){if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,er(this,10);return e}}();nt.prototype.int32=function(){return this.uint32()|0};nt.prototype.sint32=function(){var e=this.uint32();return e>>>1^-(e&1)|0};function Ja(){var r=new Lc(0,0),e=0;if(this.len-this.pos>4){for(;e<4;++e)if(r.lo=(r.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return r;if(r.lo=(r.lo|(this.buf[this.pos]&127)<<28)>>>0,r.hi=(r.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return r;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw er(this);if(r.lo=(r.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return r}return r.lo=(r.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,r}if(this.len-this.pos>4){for(;e<5;++e)if(r.hi=(r.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return r}else for(;e<5;++e){if(this.pos>=this.len)throw er(this);if(r.hi=(r.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return r}throw Error("invalid varint encoding")}nt.prototype.bool=function(){return this.uint32()!==0};function hi(r,e){return(r[e-4]|r[e-3]<<8|r[e-2]<<16|r[e-1]<<24)>>>0}nt.prototype.fixed32=function(){if(this.pos+4>this.len)throw er(this,4);return hi(this.buf,this.pos+=4)};nt.prototype.sfixed32=function(){if(this.pos+4>this.len)throw er(this,4);return hi(this.buf,this.pos+=4)|0};function Mc(){if(this.pos+8>this.len)throw er(this,8);return new Lc(hi(this.buf,this.pos+=4),hi(this.buf,this.pos+=4))}nt.prototype.float=function(){if(this.pos+4>this.len)throw er(this,4);var e=cr.float.readFloatLE(this.buf,this.pos);return this.pos+=4,e};nt.prototype.double=function(){if(this.pos+8>this.len)throw er(this,4);var e=cr.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,e};nt.prototype.bytes=function(){var e=this.uint32(),n=this.pos,t=this.pos+e;if(t>this.len)throw er(this,e);return this.pos+=e,Array.isArray(this.buf)?this.buf.slice(n,t):n===t?new this.buf.constructor(0):this._slice.call(this.buf,n,t)};nt.prototype.string=function(){var e=this.bytes();return k0.read(e,0,e.length)};nt.prototype.skip=function(e){if(typeof e=="number"){if(this.pos+e>this.len)throw er(this,e);this.pos+=e}else do if(this.pos>=this.len)throw er(this);while(this.buf[this.pos++]&128);return this};nt.prototype.skipType=function(r){switch(r){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(r=this.uint32()&7)!==4;)this.skipType(r);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+r+" at offset "+this.pos)}return this};nt._configure=function(r){Za=r,nt.create=Nc(),Za._configure();var e=cr.Long?"toLong":"toNumber";cr.merge(nt.prototype,{int64:function(){return Ja.call(this)[e](!1)},uint64:function(){return Ja.call(this)[e](!0)},sint64:function(){return Ja.call(this).zzDecode()[e](!1)},fixed64:function(){return Mc.call(this)[e](!0)},sfixed64:function(){return Mc.call(this)[e](!1)}})}});var Wc=He((L$,Vc)=>{"use strict";Vc.exports=an;var Gc=Qa();(an.prototype=Object.create(Gc.prototype)).constructor=an;var zc=Fr();function an(r){Gc.call(this,r)}an._configure=function(){zc.Buffer&&(an.prototype._slice=zc.Buffer.prototype.slice)};an.prototype.string=function(){var e=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+e,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+e,this.len))};an._configure()});var Hc=He((N$,Uc)=>{"use strict";Uc.exports=co;var es=Fr();(co.prototype=Object.create(es.EventEmitter.prototype)).constructor=co;function co(r,e,n){if(typeof r!="function")throw TypeError("rpcImpl must be a function");es.EventEmitter.call(this),this.rpcImpl=r,this.requestDelimited=!!e,this.responseDelimited=!!n}co.prototype.rpcCall=function r(e,n,t,o,i){if(!o)throw TypeError("request must be specified");var s=this;if(!i)return es.asPromise(r,s,e,n,t,o);if(!s.rpcImpl){setTimeout(function(){i(Error("already ended"))},0);return}try{return s.rpcImpl(e,n[s.requestDelimited?"encodeDelimited":"encode"](o).finish(),function(u,l){if(u)return s.emit("error",u,e),i(u);if(l===null){s.end(!0);return}if(!(l instanceof t))try{l=t[s.responseDelimited?"decodeDelimited":"decode"](l)}catch(c){return s.emit("error",c,e),i(c)}return s.emit("data",l,e),i(null,l)})}catch(a){s.emit("error",a,e),setTimeout(function(){i(a)},0);return}};co.prototype.end=function(e){return this.rpcImpl&&(e||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}});var qc=He(jc=>{"use strict";var B0=jc;B0.Service=Hc()});var Xc=He((z$,Kc)=>{"use strict";Kc.exports={}});var Zc=He(Jc=>{"use strict";var Ct=Jc;Ct.build="minimal";Ct.Writer=Ya();Ct.BufferWriter=Bc();Ct.Reader=Qa();Ct.BufferReader=Wc();Ct.util=Fr();Ct.rpc=qc();Ct.roots=Xc();Ct.configure=Yc;function Yc(){Ct.util._configure(),Ct.Writer._configure(Ct.BufferWriter),Ct.Reader._configure(Ct.BufferReader)}Yc()});var ed=He((V$,Qc)=>{"use strict";Qc.exports=Zc()});var Dn=He((W$,td)=>{"use strict";var qe=ed(),X=qe.Reader,ot=qe.Writer,O=qe.util,$=qe.roots.default||(qe.roots.default={});$.onnx=function(){var r={};return r.Version=function(){var e={},n=Object.create(e);return n[e[0]="_START_VERSION"]=0,n[e[1]="IR_VERSION_2017_10_10"]=1,n[e[2]="IR_VERSION_2017_10_30"]=2,n[e[3]="IR_VERSION_2017_11_3"]=3,n[e[4]="IR_VERSION_2019_1_22"]=4,n[e[5]="IR_VERSION_2019_3_18"]=5,n[e[6]="IR_VERSION_2019_9_19"]=6,n[e[7]="IR_VERSION_2020_5_8"]=7,n[e[8]="IR_VERSION_2021_7_30"]=8,n[e[9]="IR_VERSION"]=9,n}(),r.AttributeProto=function(){function e(n){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],this.sparseTensors=[],this.typeProtos=[],n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.name="",e.prototype.refAttrName="",e.prototype.docString="",e.prototype.type=0,e.prototype.f=0,e.prototype.i=O.Long?O.Long.fromBits(0,0,!1):0,e.prototype.s=O.newBuffer([]),e.prototype.t=null,e.prototype.g=null,e.prototype.sparseTensor=null,e.prototype.tp=null,e.prototype.floats=O.emptyArray,e.prototype.ints=O.emptyArray,e.prototype.strings=O.emptyArray,e.prototype.tensors=O.emptyArray,e.prototype.graphs=O.emptyArray,e.prototype.sparseTensors=O.emptyArray,e.prototype.typeProtos=O.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=ot.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&o.uint32(10).string(t.name),t.f!=null&&Object.hasOwnProperty.call(t,"f")&&o.uint32(21).float(t.f),t.i!=null&&Object.hasOwnProperty.call(t,"i")&&o.uint32(24).int64(t.i),t.s!=null&&Object.hasOwnProperty.call(t,"s")&&o.uint32(34).bytes(t.s),t.t!=null&&Object.hasOwnProperty.call(t,"t")&&$.onnx.TensorProto.encode(t.t,o.uint32(42).fork()).ldelim(),t.g!=null&&Object.hasOwnProperty.call(t,"g")&&$.onnx.GraphProto.encode(t.g,o.uint32(50).fork()).ldelim(),t.floats!=null&&t.floats.length){o.uint32(58).fork();for(var i=0;i<t.floats.length;++i)o.float(t.floats[i]);o.ldelim()}if(t.ints!=null&&t.ints.length){o.uint32(66).fork();for(var i=0;i<t.ints.length;++i)o.int64(t.ints[i]);o.ldelim()}if(t.strings!=null&&t.strings.length)for(var i=0;i<t.strings.length;++i)o.uint32(74).bytes(t.strings[i]);if(t.tensors!=null&&t.tensors.length)for(var i=0;i<t.tensors.length;++i)$.onnx.TensorProto.encode(t.tensors[i],o.uint32(82).fork()).ldelim();if(t.graphs!=null&&t.graphs.length)for(var i=0;i<t.graphs.length;++i)$.onnx.GraphProto.encode(t.graphs[i],o.uint32(90).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&o.uint32(106).string(t.docString),t.tp!=null&&Object.hasOwnProperty.call(t,"tp")&&$.onnx.TypeProto.encode(t.tp,o.uint32(114).fork()).ldelim(),t.typeProtos!=null&&t.typeProtos.length)for(var i=0;i<t.typeProtos.length;++i)$.onnx.TypeProto.encode(t.typeProtos[i],o.uint32(122).fork()).ldelim();if(t.type!=null&&Object.hasOwnProperty.call(t,"type")&&o.uint32(160).int32(t.type),t.refAttrName!=null&&Object.hasOwnProperty.call(t,"refAttrName")&&o.uint32(170).string(t.refAttrName),t.sparseTensor!=null&&Object.hasOwnProperty.call(t,"sparseTensor")&&$.onnx.SparseTensorProto.encode(t.sparseTensor,o.uint32(178).fork()).ldelim(),t.sparseTensors!=null&&t.sparseTensors.length)for(var i=0;i<t.sparseTensors.length;++i)$.onnx.SparseTensorProto.encode(t.sparseTensors[i],o.uint32(186).fork()).ldelim();return o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof X||(t=X.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new $.onnx.AttributeProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{s.name=t.string();break}case 21:{s.refAttrName=t.string();break}case 13:{s.docString=t.string();break}case 20:{s.type=t.int32();break}case 2:{s.f=t.float();break}case 3:{s.i=t.int64();break}case 4:{s.s=t.bytes();break}case 5:{s.t=$.onnx.TensorProto.decode(t,t.uint32());break}case 6:{s.g=$.onnx.GraphProto.decode(t,t.uint32());break}case 22:{s.sparseTensor=$.onnx.SparseTensorProto.decode(t,t.uint32());break}case 14:{s.tp=$.onnx.TypeProto.decode(t,t.uint32());break}case 7:{if(s.floats&&s.floats.length||(s.floats=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.floats.push(t.float());else s.floats.push(t.float());break}case 8:{if(s.ints&&s.ints.length||(s.ints=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.ints.push(t.int64());else s.ints.push(t.int64());break}case 9:{s.strings&&s.strings.length||(s.strings=[]),s.strings.push(t.bytes());break}case 10:{s.tensors&&s.tensors.length||(s.tensors=[]),s.tensors.push($.onnx.TensorProto.decode(t,t.uint32()));break}case 11:{s.graphs&&s.graphs.length||(s.graphs=[]),s.graphs.push($.onnx.GraphProto.decode(t,t.uint32()));break}case 23:{s.sparseTensors&&s.sparseTensors.length||(s.sparseTensors=[]),s.sparseTensors.push($.onnx.SparseTensorProto.decode(t,t.uint32()));break}case 15:{s.typeProtos&&s.typeProtos.length||(s.typeProtos=[]),s.typeProtos.push($.onnx.TypeProto.decode(t,t.uint32()));break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof X||(t=new X(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!O.isString(t.name))return"name: string expected";if(t.refAttrName!=null&&t.hasOwnProperty("refAttrName")&&!O.isString(t.refAttrName))return"refAttrName: string expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!O.isString(t.docString))return"docString: string expected";if(t.type!=null&&t.hasOwnProperty("type"))switch(t.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 11:case 13:case 6:case 7:case 8:case 9:case 10:case 12:case 14:break}if(t.f!=null&&t.hasOwnProperty("f")&&typeof t.f!="number")return"f: number expected";if(t.i!=null&&t.hasOwnProperty("i")&&!O.isInteger(t.i)&&!(t.i&&O.isInteger(t.i.low)&&O.isInteger(t.i.high)))return"i: integer|Long expected";if(t.s!=null&&t.hasOwnProperty("s")&&!(t.s&&typeof t.s.length=="number"||O.isString(t.s)))return"s: buffer expected";if(t.t!=null&&t.hasOwnProperty("t")){var o=$.onnx.TensorProto.verify(t.t);if(o)return"t."+o}if(t.g!=null&&t.hasOwnProperty("g")){var o=$.onnx.GraphProto.verify(t.g);if(o)return"g."+o}if(t.sparseTensor!=null&&t.hasOwnProperty("sparseTensor")){var o=$.onnx.SparseTensorProto.verify(t.sparseTensor);if(o)return"sparseTensor."+o}if(t.tp!=null&&t.hasOwnProperty("tp")){var o=$.onnx.TypeProto.verify(t.tp);if(o)return"tp."+o}if(t.floats!=null&&t.hasOwnProperty("floats")){if(!Array.isArray(t.floats))return"floats: array expected";for(var i=0;i<t.floats.length;++i)if(typeof t.floats[i]!="number")return"floats: number[] expected"}if(t.ints!=null&&t.hasOwnProperty("ints")){if(!Array.isArray(t.ints))return"ints: array expected";for(var i=0;i<t.ints.length;++i)if(!O.isInteger(t.ints[i])&&!(t.ints[i]&&O.isInteger(t.ints[i].low)&&O.isInteger(t.ints[i].high)))return"ints: integer|Long[] expected"}if(t.strings!=null&&t.hasOwnProperty("strings")){if(!Array.isArray(t.strings))return"strings: array expected";for(var i=0;i<t.strings.length;++i)if(!(t.strings[i]&&typeof t.strings[i].length=="number"||O.isString(t.strings[i])))return"strings: buffer[] expected"}if(t.tensors!=null&&t.hasOwnProperty("tensors")){if(!Array.isArray(t.tensors))return"tensors: array expected";for(var i=0;i<t.tensors.length;++i){var o=$.onnx.TensorProto.verify(t.tensors[i]);if(o)return"tensors."+o}}if(t.graphs!=null&&t.hasOwnProperty("graphs")){if(!Array.isArray(t.graphs))return"graphs: array expected";for(var i=0;i<t.graphs.length;++i){var o=$.onnx.GraphProto.verify(t.graphs[i]);if(o)return"graphs."+o}}if(t.sparseTensors!=null&&t.hasOwnProperty("sparseTensors")){if(!Array.isArray(t.sparseTensors))return"sparseTensors: array expected";for(var i=0;i<t.sparseTensors.length;++i){var o=$.onnx.SparseTensorProto.verify(t.sparseTensors[i]);if(o)return"sparseTensors."+o}}if(t.typeProtos!=null&&t.hasOwnProperty("typeProtos")){if(!Array.isArray(t.typeProtos))return"typeProtos: array expected";for(var i=0;i<t.typeProtos.length;++i){var o=$.onnx.TypeProto.verify(t.typeProtos[i]);if(o)return"typeProtos."+o}}return null},e.fromObject=function(t){if(t instanceof $.onnx.AttributeProto)return t;var o=new $.onnx.AttributeProto;switch(t.name!=null&&(o.name=String(t.name)),t.refAttrName!=null&&(o.refAttrName=String(t.refAttrName)),t.docString!=null&&(o.docString=String(t.docString)),t.type){default:if(typeof t.type=="number"){o.type=t.type;break}break;case"UNDEFINED":case 0:o.type=0;break;case"FLOAT":case 1:o.type=1;break;case"INT":case 2:o.type=2;break;case"STRING":case 3:o.type=3;break;case"TENSOR":case 4:o.type=4;break;case"GRAPH":case 5:o.type=5;break;case"SPARSE_TENSOR":case 11:o.type=11;break;case"TYPE_PROTO":case 13:o.type=13;break;case"FLOATS":case 6:o.type=6;break;case"INTS":case 7:o.type=7;break;case"STRINGS":case 8:o.type=8;break;case"TENSORS":case 9:o.type=9;break;case"GRAPHS":case 10:o.type=10;break;case"SPARSE_TENSORS":case 12:o.type=12;break;case"TYPE_PROTOS":case 14:o.type=14;break}if(t.f!=null&&(o.f=Number(t.f)),t.i!=null&&(O.Long?(o.i=O.Long.fromValue(t.i)).unsigned=!1:typeof t.i=="string"?o.i=parseInt(t.i,10):typeof t.i=="number"?o.i=t.i:typeof t.i=="object"&&(o.i=new O.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber())),t.s!=null&&(typeof t.s=="string"?O.base64.decode(t.s,o.s=O.newBuffer(O.base64.length(t.s)),0):t.s.length>=0&&(o.s=t.s)),t.t!=null){if(typeof t.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");o.t=$.onnx.TensorProto.fromObject(t.t)}if(t.g!=null){if(typeof t.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");o.g=$.onnx.GraphProto.fromObject(t.g)}if(t.sparseTensor!=null){if(typeof t.sparseTensor!="object")throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");o.sparseTensor=$.onnx.SparseTensorProto.fromObject(t.sparseTensor)}if(t.tp!=null){if(typeof t.tp!="object")throw TypeError(".onnx.AttributeProto.tp: object expected");o.tp=$.onnx.TypeProto.fromObject(t.tp)}if(t.floats){if(!Array.isArray(t.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");o.floats=[];for(var i=0;i<t.floats.length;++i)o.floats[i]=Number(t.floats[i])}if(t.ints){if(!Array.isArray(t.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");o.ints=[];for(var i=0;i<t.ints.length;++i)O.Long?(o.ints[i]=O.Long.fromValue(t.ints[i])).unsigned=!1:typeof t.ints[i]=="string"?o.ints[i]=parseInt(t.ints[i],10):typeof t.ints[i]=="number"?o.ints[i]=t.ints[i]:typeof t.ints[i]=="object"&&(o.ints[i]=new O.LongBits(t.ints[i].low>>>0,t.ints[i].high>>>0).toNumber())}if(t.strings){if(!Array.isArray(t.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");o.strings=[];for(var i=0;i<t.strings.length;++i)typeof t.strings[i]=="string"?O.base64.decode(t.strings[i],o.strings[i]=O.newBuffer(O.base64.length(t.strings[i])),0):t.strings[i].length>=0&&(o.strings[i]=t.strings[i])}if(t.tensors){if(!Array.isArray(t.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");o.tensors=[];for(var i=0;i<t.tensors.length;++i){if(typeof t.tensors[i]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");o.tensors[i]=$.onnx.TensorProto.fromObject(t.tensors[i])}}if(t.graphs){if(!Array.isArray(t.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");o.graphs=[];for(var i=0;i<t.graphs.length;++i){if(typeof t.graphs[i]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");o.graphs[i]=$.onnx.GraphProto.fromObject(t.graphs[i])}}if(t.sparseTensors){if(!Array.isArray(t.sparseTensors))throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");o.sparseTensors=[];for(var i=0;i<t.sparseTensors.length;++i){if(typeof t.sparseTensors[i]!="object")throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");o.sparseTensors[i]=$.onnx.SparseTensorProto.fromObject(t.sparseTensors[i])}}if(t.typeProtos){if(!Array.isArray(t.typeProtos))throw TypeError(".onnx.AttributeProto.typeProtos: array expected");o.typeProtos=[];for(var i=0;i<t.typeProtos.length;++i){if(typeof t.typeProtos[i]!="object")throw TypeError(".onnx.AttributeProto.typeProtos: object expected");o.typeProtos[i]=$.onnx.TypeProto.fromObject(t.typeProtos[i])}}return o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.floats=[],i.ints=[],i.strings=[],i.tensors=[],i.graphs=[],i.typeProtos=[],i.sparseTensors=[]),o.defaults){if(i.name="",i.f=0,O.Long){var s=new O.Long(0,0,!1);i.i=o.longs===String?s.toString():o.longs===Number?s.toNumber():s}else i.i=o.longs===String?"0":0;o.bytes===String?i.s="":(i.s=[],o.bytes!==Array&&(i.s=O.newBuffer(i.s))),i.t=null,i.g=null,i.docString="",i.tp=null,i.type=o.enums===String?"UNDEFINED":0,i.refAttrName="",i.sparseTensor=null}if(t.name!=null&&t.hasOwnProperty("name")&&(i.name=t.name),t.f!=null&&t.hasOwnProperty("f")&&(i.f=o.json&&!isFinite(t.f)?String(t.f):t.f),t.i!=null&&t.hasOwnProperty("i")&&(typeof t.i=="number"?i.i=o.longs===String?String(t.i):t.i:i.i=o.longs===String?O.Long.prototype.toString.call(t.i):o.longs===Number?new O.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber():t.i),t.s!=null&&t.hasOwnProperty("s")&&(i.s=o.bytes===String?O.base64.encode(t.s,0,t.s.length):o.bytes===Array?Array.prototype.slice.call(t.s):t.s),t.t!=null&&t.hasOwnProperty("t")&&(i.t=$.onnx.TensorProto.toObject(t.t,o)),t.g!=null&&t.hasOwnProperty("g")&&(i.g=$.onnx.GraphProto.toObject(t.g,o)),t.floats&&t.floats.length){i.floats=[];for(var a=0;a<t.floats.length;++a)i.floats[a]=o.json&&!isFinite(t.floats[a])?String(t.floats[a]):t.floats[a]}if(t.ints&&t.ints.length){i.ints=[];for(var a=0;a<t.ints.length;++a)typeof t.ints[a]=="number"?i.ints[a]=o.longs===String?String(t.ints[a]):t.ints[a]:i.ints[a]=o.longs===String?O.Long.prototype.toString.call(t.ints[a]):o.longs===Number?new O.LongBits(t.ints[a].low>>>0,t.ints[a].high>>>0).toNumber():t.ints[a]}if(t.strings&&t.strings.length){i.strings=[];for(var a=0;a<t.strings.length;++a)i.strings[a]=o.bytes===String?O.base64.encode(t.strings[a],0,t.strings[a].length):o.bytes===Array?Array.prototype.slice.call(t.strings[a]):t.strings[a]}if(t.tensors&&t.tensors.length){i.tensors=[];for(var a=0;a<t.tensors.length;++a)i.tensors[a]=$.onnx.TensorProto.toObject(t.tensors[a],o)}if(t.graphs&&t.graphs.length){i.graphs=[];for(var a=0;a<t.graphs.length;++a)i.graphs[a]=$.onnx.GraphProto.toObject(t.graphs[a],o)}if(t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),t.tp!=null&&t.hasOwnProperty("tp")&&(i.tp=$.onnx.TypeProto.toObject(t.tp,o)),t.typeProtos&&t.typeProtos.length){i.typeProtos=[];for(var a=0;a<t.typeProtos.length;++a)i.typeProtos[a]=$.onnx.TypeProto.toObject(t.typeProtos[a],o)}if(t.type!=null&&t.hasOwnProperty("type")&&(i.type=o.enums===String?$.onnx.AttributeProto.AttributeType[t.type]===void 0?t.type:$.onnx.AttributeProto.AttributeType[t.type]:t.type),t.refAttrName!=null&&t.hasOwnProperty("refAttrName")&&(i.refAttrName=t.refAttrName),t.sparseTensor!=null&&t.hasOwnProperty("sparseTensor")&&(i.sparseTensor=$.onnx.SparseTensorProto.toObject(t.sparseTensor,o)),t.sparseTensors&&t.sparseTensors.length){i.sparseTensors=[];for(var a=0;a<t.sparseTensors.length;++a)i.sparseTensors[a]=$.onnx.SparseTensorProto.toObject(t.sparseTensors[a],o)}return i},e.prototype.toJSON=function(){return this.constructor.toObject(this,qe.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.AttributeProto"},e.AttributeType=function(){var n={},t=Object.create(n);return t[n[0]="UNDEFINED"]=0,t[n[1]="FLOAT"]=1,t[n[2]="INT"]=2,t[n[3]="STRING"]=3,t[n[4]="TENSOR"]=4,t[n[5]="GRAPH"]=5,t[n[11]="SPARSE_TENSOR"]=11,t[n[13]="TYPE_PROTO"]=13,t[n[6]="FLOATS"]=6,t[n[7]="INTS"]=7,t[n[8]="STRINGS"]=8,t[n[9]="TENSORS"]=9,t[n[10]="GRAPHS"]=10,t[n[12]="SPARSE_TENSORS"]=12,t[n[14]="TYPE_PROTOS"]=14,t}(),e}(),r.ValueInfoProto=function(){function e(n){if(n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.name="",e.prototype.type=null,e.prototype.docString="",e.create=function(t){return new e(t)},e.encode=function(t,o){return o||(o=ot.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&o.uint32(10).string(t.name),t.type!=null&&Object.hasOwnProperty.call(t,"type")&&$.onnx.TypeProto.encode(t.type,o.uint32(18).fork()).ldelim(),t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&o.uint32(26).string(t.docString),o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof X||(t=X.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new $.onnx.ValueInfoProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{s.name=t.string();break}case 2:{s.type=$.onnx.TypeProto.decode(t,t.uint32());break}case 3:{s.docString=t.string();break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof X||(t=new X(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!O.isString(t.name))return"name: string expected";if(t.type!=null&&t.hasOwnProperty("type")){var o=$.onnx.TypeProto.verify(t.type);if(o)return"type."+o}return t.docString!=null&&t.hasOwnProperty("docString")&&!O.isString(t.docString)?"docString: string expected":null},e.fromObject=function(t){if(t instanceof $.onnx.ValueInfoProto)return t;var o=new $.onnx.ValueInfoProto;if(t.name!=null&&(o.name=String(t.name)),t.type!=null){if(typeof t.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");o.type=$.onnx.TypeProto.fromObject(t.type)}return t.docString!=null&&(o.docString=String(t.docString)),o},e.toObject=function(t,o){o||(o={});var i={};return o.defaults&&(i.name="",i.type=null,i.docString=""),t.name!=null&&t.hasOwnProperty("name")&&(i.name=t.name),t.type!=null&&t.hasOwnProperty("type")&&(i.type=$.onnx.TypeProto.toObject(t.type,o)),t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,qe.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.ValueInfoProto"},e}(),r.NodeProto=function(){function e(n){if(this.input=[],this.output=[],this.attribute=[],n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.input=O.emptyArray,e.prototype.output=O.emptyArray,e.prototype.name="",e.prototype.opType="",e.prototype.domain="",e.prototype.attribute=O.emptyArray,e.prototype.docString="",e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=ot.create()),t.input!=null&&t.input.length)for(var i=0;i<t.input.length;++i)o.uint32(10).string(t.input[i]);if(t.output!=null&&t.output.length)for(var i=0;i<t.output.length;++i)o.uint32(18).string(t.output[i]);if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&o.uint32(26).string(t.name),t.opType!=null&&Object.hasOwnProperty.call(t,"opType")&&o.uint32(34).string(t.opType),t.attribute!=null&&t.attribute.length)for(var i=0;i<t.attribute.length;++i)$.onnx.AttributeProto.encode(t.attribute[i],o.uint32(42).fork()).ldelim();return t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&o.uint32(50).string(t.docString),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&o.uint32(58).string(t.domain),o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof X||(t=X.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new $.onnx.NodeProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{s.input&&s.input.length||(s.input=[]),s.input.push(t.string());break}case 2:{s.output&&s.output.length||(s.output=[]),s.output.push(t.string());break}case 3:{s.name=t.string();break}case 4:{s.opType=t.string();break}case 7:{s.domain=t.string();break}case 5:{s.attribute&&s.attribute.length||(s.attribute=[]),s.attribute.push($.onnx.AttributeProto.decode(t,t.uint32()));break}case 6:{s.docString=t.string();break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof X||(t=new X(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var o=0;o<t.input.length;++o)if(!O.isString(t.input[o]))return"input: string[] expected"}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(var o=0;o<t.output.length;++o)if(!O.isString(t.output[o]))return"output: string[] expected"}if(t.name!=null&&t.hasOwnProperty("name")&&!O.isString(t.name))return"name: string expected";if(t.opType!=null&&t.hasOwnProperty("opType")&&!O.isString(t.opType))return"opType: string expected";if(t.domain!=null&&t.hasOwnProperty("domain")&&!O.isString(t.domain))return"domain: string expected";if(t.attribute!=null&&t.hasOwnProperty("attribute")){if(!Array.isArray(t.attribute))return"attribute: array expected";for(var o=0;o<t.attribute.length;++o){var i=$.onnx.AttributeProto.verify(t.attribute[o]);if(i)return"attribute."+i}}return t.docString!=null&&t.hasOwnProperty("docString")&&!O.isString(t.docString)?"docString: string expected":null},e.fromObject=function(t){if(t instanceof $.onnx.NodeProto)return t;var o=new $.onnx.NodeProto;if(t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.NodeProto.input: array expected");o.input=[];for(var i=0;i<t.input.length;++i)o.input[i]=String(t.input[i])}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.NodeProto.output: array expected");o.output=[];for(var i=0;i<t.output.length;++i)o.output[i]=String(t.output[i])}if(t.name!=null&&(o.name=String(t.name)),t.opType!=null&&(o.opType=String(t.opType)),t.domain!=null&&(o.domain=String(t.domain)),t.attribute){if(!Array.isArray(t.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");o.attribute=[];for(var i=0;i<t.attribute.length;++i){if(typeof t.attribute[i]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");o.attribute[i]=$.onnx.AttributeProto.fromObject(t.attribute[i])}}return t.docString!=null&&(o.docString=String(t.docString)),o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.input=[],i.output=[],i.attribute=[]),o.defaults&&(i.name="",i.opType="",i.docString="",i.domain=""),t.input&&t.input.length){i.input=[];for(var s=0;s<t.input.length;++s)i.input[s]=t.input[s]}if(t.output&&t.output.length){i.output=[];for(var s=0;s<t.output.length;++s)i.output[s]=t.output[s]}if(t.name!=null&&t.hasOwnProperty("name")&&(i.name=t.name),t.opType!=null&&t.hasOwnProperty("opType")&&(i.opType=t.opType),t.attribute&&t.attribute.length){i.attribute=[];for(var s=0;s<t.attribute.length;++s)i.attribute[s]=$.onnx.AttributeProto.toObject(t.attribute[s],o)}return t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),t.domain!=null&&t.hasOwnProperty("domain")&&(i.domain=t.domain),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,qe.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.NodeProto"},e}(),r.TrainingInfoProto=function(){function e(n){if(this.initializationBinding=[],this.updateBinding=[],n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.initialization=null,e.prototype.algorithm=null,e.prototype.initializationBinding=O.emptyArray,e.prototype.updateBinding=O.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=ot.create()),t.initialization!=null&&Object.hasOwnProperty.call(t,"initialization")&&$.onnx.GraphProto.encode(t.initialization,o.uint32(10).fork()).ldelim(),t.algorithm!=null&&Object.hasOwnProperty.call(t,"algorithm")&&$.onnx.GraphProto.encode(t.algorithm,o.uint32(18).fork()).ldelim(),t.initializationBinding!=null&&t.initializationBinding.length)for(var i=0;i<t.initializationBinding.length;++i)$.onnx.StringStringEntryProto.encode(t.initializationBinding[i],o.uint32(26).fork()).ldelim();if(t.updateBinding!=null&&t.updateBinding.length)for(var i=0;i<t.updateBinding.length;++i)$.onnx.StringStringEntryProto.encode(t.updateBinding[i],o.uint32(34).fork()).ldelim();return o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof X||(t=X.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new $.onnx.TrainingInfoProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{s.initialization=$.onnx.GraphProto.decode(t,t.uint32());break}case 2:{s.algorithm=$.onnx.GraphProto.decode(t,t.uint32());break}case 3:{s.initializationBinding&&s.initializationBinding.length||(s.initializationBinding=[]),s.initializationBinding.push($.onnx.StringStringEntryProto.decode(t,t.uint32()));break}case 4:{s.updateBinding&&s.updateBinding.length||(s.updateBinding=[]),s.updateBinding.push($.onnx.StringStringEntryProto.decode(t,t.uint32()));break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof X||(t=new X(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.initialization!=null&&t.hasOwnProperty("initialization")){var o=$.onnx.GraphProto.verify(t.initialization);if(o)return"initialization."+o}if(t.algorithm!=null&&t.hasOwnProperty("algorithm")){var o=$.onnx.GraphProto.verify(t.algorithm);if(o)return"algorithm."+o}if(t.initializationBinding!=null&&t.hasOwnProperty("initializationBinding")){if(!Array.isArray(t.initializationBinding))return"initializationBinding: array expected";for(var i=0;i<t.initializationBinding.length;++i){var o=$.onnx.StringStringEntryProto.verify(t.initializationBinding[i]);if(o)return"initializationBinding."+o}}if(t.updateBinding!=null&&t.hasOwnProperty("updateBinding")){if(!Array.isArray(t.updateBinding))return"updateBinding: array expected";for(var i=0;i<t.updateBinding.length;++i){var o=$.onnx.StringStringEntryProto.verify(t.updateBinding[i]);if(o)return"updateBinding."+o}}return null},e.fromObject=function(t){if(t instanceof $.onnx.TrainingInfoProto)return t;var o=new $.onnx.TrainingInfoProto;if(t.initialization!=null){if(typeof t.initialization!="object")throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");o.initialization=$.onnx.GraphProto.fromObject(t.initialization)}if(t.algorithm!=null){if(typeof t.algorithm!="object")throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");o.algorithm=$.onnx.GraphProto.fromObject(t.algorithm)}if(t.initializationBinding){if(!Array.isArray(t.initializationBinding))throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");o.initializationBinding=[];for(var i=0;i<t.initializationBinding.length;++i){if(typeof t.initializationBinding[i]!="object")throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");o.initializationBinding[i]=$.onnx.StringStringEntryProto.fromObject(t.initializationBinding[i])}}if(t.updateBinding){if(!Array.isArray(t.updateBinding))throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");o.updateBinding=[];for(var i=0;i<t.updateBinding.length;++i){if(typeof t.updateBinding[i]!="object")throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");o.updateBinding[i]=$.onnx.StringStringEntryProto.fromObject(t.updateBinding[i])}}return o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.initializationBinding=[],i.updateBinding=[]),o.defaults&&(i.initialization=null,i.algorithm=null),t.initialization!=null&&t.hasOwnProperty("initialization")&&(i.initialization=$.onnx.GraphProto.toObject(t.initialization,o)),t.algorithm!=null&&t.hasOwnProperty("algorithm")&&(i.algorithm=$.onnx.GraphProto.toObject(t.algorithm,o)),t.initializationBinding&&t.initializationBinding.length){i.initializationBinding=[];for(var s=0;s<t.initializationBinding.length;++s)i.initializationBinding[s]=$.onnx.StringStringEntryProto.toObject(t.initializationBinding[s],o)}if(t.updateBinding&&t.updateBinding.length){i.updateBinding=[];for(var s=0;s<t.updateBinding.length;++s)i.updateBinding[s]=$.onnx.StringStringEntryProto.toObject(t.updateBinding[s],o)}return i},e.prototype.toJSON=function(){return this.constructor.toObject(this,qe.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TrainingInfoProto"},e}(),r.ModelProto=function(){function e(n){if(this.opsetImport=[],this.metadataProps=[],this.trainingInfo=[],this.functions=[],n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.irVersion=O.Long?O.Long.fromBits(0,0,!1):0,e.prototype.opsetImport=O.emptyArray,e.prototype.producerName="",e.prototype.producerVersion="",e.prototype.domain="",e.prototype.modelVersion=O.Long?O.Long.fromBits(0,0,!1):0,e.prototype.docString="",e.prototype.graph=null,e.prototype.metadataProps=O.emptyArray,e.prototype.trainingInfo=O.emptyArray,e.prototype.functions=O.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=ot.create()),t.irVersion!=null&&Object.hasOwnProperty.call(t,"irVersion")&&o.uint32(8).int64(t.irVersion),t.producerName!=null&&Object.hasOwnProperty.call(t,"producerName")&&o.uint32(18).string(t.producerName),t.producerVersion!=null&&Object.hasOwnProperty.call(t,"producerVersion")&&o.uint32(26).string(t.producerVersion),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&o.uint32(34).string(t.domain),t.modelVersion!=null&&Object.hasOwnProperty.call(t,"modelVersion")&&o.uint32(40).int64(t.modelVersion),t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&o.uint32(50).string(t.docString),t.graph!=null&&Object.hasOwnProperty.call(t,"graph")&&$.onnx.GraphProto.encode(t.graph,o.uint32(58).fork()).ldelim(),t.opsetImport!=null&&t.opsetImport.length)for(var i=0;i<t.opsetImport.length;++i)$.onnx.OperatorSetIdProto.encode(t.opsetImport[i],o.uint32(66).fork()).ldelim();if(t.metadataProps!=null&&t.metadataProps.length)for(var i=0;i<t.metadataProps.length;++i)$.onnx.StringStringEntryProto.encode(t.metadataProps[i],o.uint32(114).fork()).ldelim();if(t.trainingInfo!=null&&t.trainingInfo.length)for(var i=0;i<t.trainingInfo.length;++i)$.onnx.TrainingInfoProto.encode(t.trainingInfo[i],o.uint32(162).fork()).ldelim();if(t.functions!=null&&t.functions.length)for(var i=0;i<t.functions.length;++i)$.onnx.FunctionProto.encode(t.functions[i],o.uint32(202).fork()).ldelim();return o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof X||(t=X.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new $.onnx.ModelProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{s.irVersion=t.int64();break}case 8:{s.opsetImport&&s.opsetImport.length||(s.opsetImport=[]),s.opsetImport.push($.onnx.OperatorSetIdProto.decode(t,t.uint32()));break}case 2:{s.producerName=t.string();break}case 3:{s.producerVersion=t.string();break}case 4:{s.domain=t.string();break}case 5:{s.modelVersion=t.int64();break}case 6:{s.docString=t.string();break}case 7:{s.graph=$.onnx.GraphProto.decode(t,t.uint32());break}case 14:{s.metadataProps&&s.metadataProps.length||(s.metadataProps=[]),s.metadataProps.push($.onnx.StringStringEntryProto.decode(t,t.uint32()));break}case 20:{s.trainingInfo&&s.trainingInfo.length||(s.trainingInfo=[]),s.trainingInfo.push($.onnx.TrainingInfoProto.decode(t,t.uint32()));break}case 25:{s.functions&&s.functions.length||(s.functions=[]),s.functions.push($.onnx.FunctionProto.decode(t,t.uint32()));break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof X||(t=new X(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.irVersion!=null&&t.hasOwnProperty("irVersion")&&!O.isInteger(t.irVersion)&&!(t.irVersion&&O.isInteger(t.irVersion.low)&&O.isInteger(t.irVersion.high)))return"irVersion: integer|Long expected";if(t.opsetImport!=null&&t.hasOwnProperty("opsetImport")){if(!Array.isArray(t.opsetImport))return"opsetImport: array expected";for(var o=0;o<t.opsetImport.length;++o){var i=$.onnx.OperatorSetIdProto.verify(t.opsetImport[o]);if(i)return"opsetImport."+i}}if(t.producerName!=null&&t.hasOwnProperty("producerName")&&!O.isString(t.producerName))return"producerName: string expected";if(t.producerVersion!=null&&t.hasOwnProperty("producerVersion")&&!O.isString(t.producerVersion))return"producerVersion: string expected";if(t.domain!=null&&t.hasOwnProperty("domain")&&!O.isString(t.domain))return"domain: string expected";if(t.modelVersion!=null&&t.hasOwnProperty("modelVersion")&&!O.isInteger(t.modelVersion)&&!(t.modelVersion&&O.isInteger(t.modelVersion.low)&&O.isInteger(t.modelVersion.high)))return"modelVersion: integer|Long expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!O.isString(t.docString))return"docString: string expected";if(t.graph!=null&&t.hasOwnProperty("graph")){var i=$.onnx.GraphProto.verify(t.graph);if(i)return"graph."+i}if(t.metadataProps!=null&&t.hasOwnProperty("metadataProps")){if(!Array.isArray(t.metadataProps))return"metadataProps: array expected";for(var o=0;o<t.metadataProps.length;++o){var i=$.onnx.StringStringEntryProto.verify(t.metadataProps[o]);if(i)return"metadataProps."+i}}if(t.trainingInfo!=null&&t.hasOwnProperty("trainingInfo")){if(!Array.isArray(t.trainingInfo))return"trainingInfo: array expected";for(var o=0;o<t.trainingInfo.length;++o){var i=$.onnx.TrainingInfoProto.verify(t.trainingInfo[o]);if(i)return"trainingInfo."+i}}if(t.functions!=null&&t.hasOwnProperty("functions")){if(!Array.isArray(t.functions))return"functions: array expected";for(var o=0;o<t.functions.length;++o){var i=$.onnx.FunctionProto.verify(t.functions[o]);if(i)return"functions."+i}}return null},e.fromObject=function(t){if(t instanceof $.onnx.ModelProto)return t;var o=new $.onnx.ModelProto;if(t.irVersion!=null&&(O.Long?(o.irVersion=O.Long.fromValue(t.irVersion)).unsigned=!1:typeof t.irVersion=="string"?o.irVersion=parseInt(t.irVersion,10):typeof t.irVersion=="number"?o.irVersion=t.irVersion:typeof t.irVersion=="object"&&(o.irVersion=new O.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber())),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");o.opsetImport=[];for(var i=0;i<t.opsetImport.length;++i){if(typeof t.opsetImport[i]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");o.opsetImport[i]=$.onnx.OperatorSetIdProto.fromObject(t.opsetImport[i])}}if(t.producerName!=null&&(o.producerName=String(t.producerName)),t.producerVersion!=null&&(o.producerVersion=String(t.producerVersion)),t.domain!=null&&(o.domain=String(t.domain)),t.modelVersion!=null&&(O.Long?(o.modelVersion=O.Long.fromValue(t.modelVersion)).unsigned=!1:typeof t.modelVersion=="string"?o.modelVersion=parseInt(t.modelVersion,10):typeof t.modelVersion=="number"?o.modelVersion=t.modelVersion:typeof t.modelVersion=="object"&&(o.modelVersion=new O.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber())),t.docString!=null&&(o.docString=String(t.docString)),t.graph!=null){if(typeof t.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");o.graph=$.onnx.GraphProto.fromObject(t.graph)}if(t.metadataProps){if(!Array.isArray(t.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");o.metadataProps=[];for(var i=0;i<t.metadataProps.length;++i){if(typeof t.metadataProps[i]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");o.metadataProps[i]=$.onnx.StringStringEntryProto.fromObject(t.metadataProps[i])}}if(t.trainingInfo){if(!Array.isArray(t.trainingInfo))throw TypeError(".onnx.ModelProto.trainingInfo: array expected");o.trainingInfo=[];for(var i=0;i<t.trainingInfo.length;++i){if(typeof t.trainingInfo[i]!="object")throw TypeError(".onnx.ModelProto.trainingInfo: object expected");o.trainingInfo[i]=$.onnx.TrainingInfoProto.fromObject(t.trainingInfo[i])}}if(t.functions){if(!Array.isArray(t.functions))throw TypeError(".onnx.ModelProto.functions: array expected");o.functions=[];for(var i=0;i<t.functions.length;++i){if(typeof t.functions[i]!="object")throw TypeError(".onnx.ModelProto.functions: object expected");o.functions[i]=$.onnx.FunctionProto.fromObject(t.functions[i])}}return o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.opsetImport=[],i.metadataProps=[],i.trainingInfo=[],i.functions=[]),o.defaults){if(O.Long){var s=new O.Long(0,0,!1);i.irVersion=o.longs===String?s.toString():o.longs===Number?s.toNumber():s}else i.irVersion=o.longs===String?"0":0;if(i.producerName="",i.producerVersion="",i.domain="",O.Long){var s=new O.Long(0,0,!1);i.modelVersion=o.longs===String?s.toString():o.longs===Number?s.toNumber():s}else i.modelVersion=o.longs===String?"0":0;i.docString="",i.graph=null}if(t.irVersion!=null&&t.hasOwnProperty("irVersion")&&(typeof t.irVersion=="number"?i.irVersion=o.longs===String?String(t.irVersion):t.irVersion:i.irVersion=o.longs===String?O.Long.prototype.toString.call(t.irVersion):o.longs===Number?new O.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber():t.irVersion),t.producerName!=null&&t.hasOwnProperty("producerName")&&(i.producerName=t.producerName),t.producerVersion!=null&&t.hasOwnProperty("producerVersion")&&(i.producerVersion=t.producerVersion),t.domain!=null&&t.hasOwnProperty("domain")&&(i.domain=t.domain),t.modelVersion!=null&&t.hasOwnProperty("modelVersion")&&(typeof t.modelVersion=="number"?i.modelVersion=o.longs===String?String(t.modelVersion):t.modelVersion:i.modelVersion=o.longs===String?O.Long.prototype.toString.call(t.modelVersion):o.longs===Number?new O.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber():t.modelVersion),t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),t.graph!=null&&t.hasOwnProperty("graph")&&(i.graph=$.onnx.GraphProto.toObject(t.graph,o)),t.opsetImport&&t.opsetImport.length){i.opsetImport=[];for(var a=0;a<t.opsetImport.length;++a)i.opsetImport[a]=$.onnx.OperatorSetIdProto.toObject(t.opsetImport[a],o)}if(t.metadataProps&&t.metadataProps.length){i.metadataProps=[];for(var a=0;a<t.metadataProps.length;++a)i.metadataProps[a]=$.onnx.StringStringEntryProto.toObject(t.metadataProps[a],o)}if(t.trainingInfo&&t.trainingInfo.length){i.trainingInfo=[];for(var a=0;a<t.trainingInfo.length;++a)i.trainingInfo[a]=$.onnx.TrainingInfoProto.toObject(t.trainingInfo[a],o)}if(t.functions&&t.functions.length){i.functions=[];for(var a=0;a<t.functions.length;++a)i.functions[a]=$.onnx.FunctionProto.toObject(t.functions[a],o)}return i},e.prototype.toJSON=function(){return this.constructor.toObject(this,qe.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.ModelProto"},e}(),r.StringStringEntryProto=function(){function e(n){if(n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.key="",e.prototype.value="",e.create=function(t){return new e(t)},e.encode=function(t,o){return o||(o=ot.create()),t.key!=null&&Object.hasOwnProperty.call(t,"key")&&o.uint32(10).string(t.key),t.value!=null&&Object.hasOwnProperty.call(t,"value")&&o.uint32(18).string(t.value),o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof X||(t=X.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new $.onnx.StringStringEntryProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{s.key=t.string();break}case 2:{s.value=t.string();break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof X||(t=new X(t)),this.decode(t,t.uint32())},e.verify=function(t){return typeof t!="object"||t===null?"object expected":t.key!=null&&t.hasOwnProperty("key")&&!O.isString(t.key)?"key: string expected":t.value!=null&&t.hasOwnProperty("value")&&!O.isString(t.value)?"value: string expected":null},e.fromObject=function(t){if(t instanceof $.onnx.StringStringEntryProto)return t;var o=new $.onnx.StringStringEntryProto;return t.key!=null&&(o.key=String(t.key)),t.value!=null&&(o.value=String(t.value)),o},e.toObject=function(t,o){o||(o={});var i={};return o.defaults&&(i.key="",i.value=""),t.key!=null&&t.hasOwnProperty("key")&&(i.key=t.key),t.value!=null&&t.hasOwnProperty("value")&&(i.value=t.value),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,qe.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.StringStringEntryProto"},e}(),r.TensorAnnotation=function(){function e(n){if(this.quantParameterTensorNames=[],n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.tensorName="",e.prototype.quantParameterTensorNames=O.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=ot.create()),t.tensorName!=null&&Object.hasOwnProperty.call(t,"tensorName")&&o.uint32(10).string(t.tensorName),t.quantParameterTensorNames!=null&&t.quantParameterTensorNames.length)for(var i=0;i<t.quantParameterTensorNames.length;++i)$.onnx.StringStringEntryProto.encode(t.quantParameterTensorNames[i],o.uint32(18).fork()).ldelim();return o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof X||(t=X.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new $.onnx.TensorAnnotation;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{s.tensorName=t.string();break}case 2:{s.quantParameterTensorNames&&s.quantParameterTensorNames.length||(s.quantParameterTensorNames=[]),s.quantParameterTensorNames.push($.onnx.StringStringEntryProto.decode(t,t.uint32()));break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof X||(t=new X(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.tensorName!=null&&t.hasOwnProperty("tensorName")&&!O.isString(t.tensorName))return"tensorName: string expected";if(t.quantParameterTensorNames!=null&&t.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(t.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var o=0;o<t.quantParameterTensorNames.length;++o){var i=$.onnx.StringStringEntryProto.verify(t.quantParameterTensorNames[o]);if(i)return"quantParameterTensorNames."+i}}return null},e.fromObject=function(t){if(t instanceof $.onnx.TensorAnnotation)return t;var o=new $.onnx.TensorAnnotation;if(t.tensorName!=null&&(o.tensorName=String(t.tensorName)),t.quantParameterTensorNames){if(!Array.isArray(t.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");o.quantParameterTensorNames=[];for(var i=0;i<t.quantParameterTensorNames.length;++i){if(typeof t.quantParameterTensorNames[i]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");o.quantParameterTensorNames[i]=$.onnx.StringStringEntryProto.fromObject(t.quantParameterTensorNames[i])}}return o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.quantParameterTensorNames=[]),o.defaults&&(i.tensorName=""),t.tensorName!=null&&t.hasOwnProperty("tensorName")&&(i.tensorName=t.tensorName),t.quantParameterTensorNames&&t.quantParameterTensorNames.length){i.quantParameterTensorNames=[];for(var s=0;s<t.quantParameterTensorNames.length;++s)i.quantParameterTensorNames[s]=$.onnx.StringStringEntryProto.toObject(t.quantParameterTensorNames[s],o)}return i},e.prototype.toJSON=function(){return this.constructor.toObject(this,qe.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorAnnotation"},e}(),r.GraphProto=function(){function e(n){if(this.node=[],this.initializer=[],this.sparseInitializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.node=O.emptyArray,e.prototype.name="",e.prototype.initializer=O.emptyArray,e.prototype.sparseInitializer=O.emptyArray,e.prototype.docString="",e.prototype.input=O.emptyArray,e.prototype.output=O.emptyArray,e.prototype.valueInfo=O.emptyArray,e.prototype.quantizationAnnotation=O.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=ot.create()),t.node!=null&&t.node.length)for(var i=0;i<t.node.length;++i)$.onnx.NodeProto.encode(t.node[i],o.uint32(10).fork()).ldelim();if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&o.uint32(18).string(t.name),t.initializer!=null&&t.initializer.length)for(var i=0;i<t.initializer.length;++i)$.onnx.TensorProto.encode(t.initializer[i],o.uint32(42).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&o.uint32(82).string(t.docString),t.input!=null&&t.input.length)for(var i=0;i<t.input.length;++i)$.onnx.ValueInfoProto.encode(t.input[i],o.uint32(90).fork()).ldelim();if(t.output!=null&&t.output.length)for(var i=0;i<t.output.length;++i)$.onnx.ValueInfoProto.encode(t.output[i],o.uint32(98).fork()).ldelim();if(t.valueInfo!=null&&t.valueInfo.length)for(var i=0;i<t.valueInfo.length;++i)$.onnx.ValueInfoProto.encode(t.valueInfo[i],o.uint32(106).fork()).ldelim();if(t.quantizationAnnotation!=null&&t.quantizationAnnotation.length)for(var i=0;i<t.quantizationAnnotation.length;++i)$.onnx.TensorAnnotation.encode(t.quantizationAnnotation[i],o.uint32(114).fork()).ldelim();if(t.sparseInitializer!=null&&t.sparseInitializer.length)for(var i=0;i<t.sparseInitializer.length;++i)$.onnx.SparseTensorProto.encode(t.sparseInitializer[i],o.uint32(122).fork()).ldelim();return o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof X||(t=X.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new $.onnx.GraphProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{s.node&&s.node.length||(s.node=[]),s.node.push($.onnx.NodeProto.decode(t,t.uint32()));break}case 2:{s.name=t.string();break}case 5:{s.initializer&&s.initializer.length||(s.initializer=[]),s.initializer.push($.onnx.TensorProto.decode(t,t.uint32()));break}case 15:{s.sparseInitializer&&s.sparseInitializer.length||(s.sparseInitializer=[]),s.sparseInitializer.push($.onnx.SparseTensorProto.decode(t,t.uint32()));break}case 10:{s.docString=t.string();break}case 11:{s.input&&s.input.length||(s.input=[]),s.input.push($.onnx.ValueInfoProto.decode(t,t.uint32()));break}case 12:{s.output&&s.output.length||(s.output=[]),s.output.push($.onnx.ValueInfoProto.decode(t,t.uint32()));break}case 13:{s.valueInfo&&s.valueInfo.length||(s.valueInfo=[]),s.valueInfo.push($.onnx.ValueInfoProto.decode(t,t.uint32()));break}case 14:{s.quantizationAnnotation&&s.quantizationAnnotation.length||(s.quantizationAnnotation=[]),s.quantizationAnnotation.push($.onnx.TensorAnnotation.decode(t,t.uint32()));break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof X||(t=new X(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.node!=null&&t.hasOwnProperty("node")){if(!Array.isArray(t.node))return"node: array expected";for(var o=0;o<t.node.length;++o){var i=$.onnx.NodeProto.verify(t.node[o]);if(i)return"node."+i}}if(t.name!=null&&t.hasOwnProperty("name")&&!O.isString(t.name))return"name: string expected";if(t.initializer!=null&&t.hasOwnProperty("initializer")){if(!Array.isArray(t.initializer))return"initializer: array expected";for(var o=0;o<t.initializer.length;++o){var i=$.onnx.TensorProto.verify(t.initializer[o]);if(i)return"initializer."+i}}if(t.sparseInitializer!=null&&t.hasOwnProperty("sparseInitializer")){if(!Array.isArray(t.sparseInitializer))return"sparseInitializer: array expected";for(var o=0;o<t.sparseInitializer.length;++o){var i=$.onnx.SparseTensorProto.verify(t.sparseInitializer[o]);if(i)return"sparseInitializer."+i}}if(t.docString!=null&&t.hasOwnProperty("docString")&&!O.isString(t.docString))return"docString: string expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var o=0;o<t.input.length;++o){var i=$.onnx.ValueInfoProto.verify(t.input[o]);if(i)return"input."+i}}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(var o=0;o<t.output.length;++o){var i=$.onnx.ValueInfoProto.verify(t.output[o]);if(i)return"output."+i}}if(t.valueInfo!=null&&t.hasOwnProperty("valueInfo")){if(!Array.isArray(t.valueInfo))return"valueInfo: array expected";for(var o=0;o<t.valueInfo.length;++o){var i=$.onnx.ValueInfoProto.verify(t.valueInfo[o]);if(i)return"valueInfo."+i}}if(t.quantizationAnnotation!=null&&t.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(t.quantizationAnnotation))return"quantizationAnnotation: array expected";for(var o=0;o<t.quantizationAnnotation.length;++o){var i=$.onnx.TensorAnnotation.verify(t.quantizationAnnotation[o]);if(i)return"quantizationAnnotation."+i}}return null},e.fromObject=function(t){if(t instanceof $.onnx.GraphProto)return t;var o=new $.onnx.GraphProto;if(t.node){if(!Array.isArray(t.node))throw TypeError(".onnx.GraphProto.node: array expected");o.node=[];for(var i=0;i<t.node.length;++i){if(typeof t.node[i]!="object")throw TypeError(".onnx.GraphProto.node: object expected");o.node[i]=$.onnx.NodeProto.fromObject(t.node[i])}}if(t.name!=null&&(o.name=String(t.name)),t.initializer){if(!Array.isArray(t.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");o.initializer=[];for(var i=0;i<t.initializer.length;++i){if(typeof t.initializer[i]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");o.initializer[i]=$.onnx.TensorProto.fromObject(t.initializer[i])}}if(t.sparseInitializer){if(!Array.isArray(t.sparseInitializer))throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");o.sparseInitializer=[];for(var i=0;i<t.sparseInitializer.length;++i){if(typeof t.sparseInitializer[i]!="object")throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");o.sparseInitializer[i]=$.onnx.SparseTensorProto.fromObject(t.sparseInitializer[i])}}if(t.docString!=null&&(o.docString=String(t.docString)),t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.GraphProto.input: array expected");o.input=[];for(var i=0;i<t.input.length;++i){if(typeof t.input[i]!="object")throw TypeError(".onnx.GraphProto.input: object expected");o.input[i]=$.onnx.ValueInfoProto.fromObject(t.input[i])}}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.GraphProto.output: array expected");o.output=[];for(var i=0;i<t.output.length;++i){if(typeof t.output[i]!="object")throw TypeError(".onnx.GraphProto.output: object expected");o.output[i]=$.onnx.ValueInfoProto.fromObject(t.output[i])}}if(t.valueInfo){if(!Array.isArray(t.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");o.valueInfo=[];for(var i=0;i<t.valueInfo.length;++i){if(typeof t.valueInfo[i]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");o.valueInfo[i]=$.onnx.ValueInfoProto.fromObject(t.valueInfo[i])}}if(t.quantizationAnnotation){if(!Array.isArray(t.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");o.quantizationAnnotation=[];for(var i=0;i<t.quantizationAnnotation.length;++i){if(typeof t.quantizationAnnotation[i]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");o.quantizationAnnotation[i]=$.onnx.TensorAnnotation.fromObject(t.quantizationAnnotation[i])}}return o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.node=[],i.initializer=[],i.input=[],i.output=[],i.valueInfo=[],i.quantizationAnnotation=[],i.sparseInitializer=[]),o.defaults&&(i.name="",i.docString=""),t.node&&t.node.length){i.node=[];for(var s=0;s<t.node.length;++s)i.node[s]=$.onnx.NodeProto.toObject(t.node[s],o)}if(t.name!=null&&t.hasOwnProperty("name")&&(i.name=t.name),t.initializer&&t.initializer.length){i.initializer=[];for(var s=0;s<t.initializer.length;++s)i.initializer[s]=$.onnx.TensorProto.toObject(t.initializer[s],o)}if(t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),t.input&&t.input.length){i.input=[];for(var s=0;s<t.input.length;++s)i.input[s]=$.onnx.ValueInfoProto.toObject(t.input[s],o)}if(t.output&&t.output.length){i.output=[];for(var s=0;s<t.output.length;++s)i.output[s]=$.onnx.ValueInfoProto.toObject(t.output[s],o)}if(t.valueInfo&&t.valueInfo.length){i.valueInfo=[];for(var s=0;s<t.valueInfo.length;++s)i.valueInfo[s]=$.onnx.ValueInfoProto.toObject(t.valueInfo[s],o)}if(t.quantizationAnnotation&&t.quantizationAnnotation.length){i.quantizationAnnotation=[];for(var s=0;s<t.quantizationAnnotation.length;++s)i.quantizationAnnotation[s]=$.onnx.TensorAnnotation.toObject(t.quantizationAnnotation[s],o)}if(t.sparseInitializer&&t.sparseInitializer.length){i.sparseInitializer=[];for(var s=0;s<t.sparseInitializer.length;++s)i.sparseInitializer[s]=$.onnx.SparseTensorProto.toObject(t.sparseInitializer[s],o)}return i},e.prototype.toJSON=function(){return this.constructor.toObject(this,qe.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.GraphProto"},e}(),r.TensorProto=function(){function e(n){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.dims=O.emptyArray,e.prototype.dataType=0,e.prototype.segment=null,e.prototype.floatData=O.emptyArray,e.prototype.int32Data=O.emptyArray,e.prototype.stringData=O.emptyArray,e.prototype.int64Data=O.emptyArray,e.prototype.name="",e.prototype.docString="",e.prototype.rawData=O.newBuffer([]),e.prototype.externalData=O.emptyArray,e.prototype.dataLocation=0,e.prototype.doubleData=O.emptyArray,e.prototype.uint64Data=O.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=ot.create()),t.dims!=null&&t.dims.length){o.uint32(10).fork();for(var i=0;i<t.dims.length;++i)o.int64(t.dims[i]);o.ldelim()}if(t.dataType!=null&&Object.hasOwnProperty.call(t,"dataType")&&o.uint32(16).int32(t.dataType),t.segment!=null&&Object.hasOwnProperty.call(t,"segment")&&$.onnx.TensorProto.Segment.encode(t.segment,o.uint32(26).fork()).ldelim(),t.floatData!=null&&t.floatData.length){o.uint32(34).fork();for(var i=0;i<t.floatData.length;++i)o.float(t.floatData[i]);o.ldelim()}if(t.int32Data!=null&&t.int32Data.length){o.uint32(42).fork();for(var i=0;i<t.int32Data.length;++i)o.int32(t.int32Data[i]);o.ldelim()}if(t.stringData!=null&&t.stringData.length)for(var i=0;i<t.stringData.length;++i)o.uint32(50).bytes(t.stringData[i]);if(t.int64Data!=null&&t.int64Data.length){o.uint32(58).fork();for(var i=0;i<t.int64Data.length;++i)o.int64(t.int64Data[i]);o.ldelim()}if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&o.uint32(66).string(t.name),t.rawData!=null&&Object.hasOwnProperty.call(t,"rawData")&&o.uint32(74).bytes(t.rawData),t.doubleData!=null&&t.doubleData.length){o.uint32(82).fork();for(var i=0;i<t.doubleData.length;++i)o.double(t.doubleData[i]);o.ldelim()}if(t.uint64Data!=null&&t.uint64Data.length){o.uint32(90).fork();for(var i=0;i<t.uint64Data.length;++i)o.uint64(t.uint64Data[i]);o.ldelim()}if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&o.uint32(98).string(t.docString),t.externalData!=null&&t.externalData.length)for(var i=0;i<t.externalData.length;++i)$.onnx.StringStringEntryProto.encode(t.externalData[i],o.uint32(106).fork()).ldelim();return t.dataLocation!=null&&Object.hasOwnProperty.call(t,"dataLocation")&&o.uint32(112).int32(t.dataLocation),o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof X||(t=X.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new $.onnx.TensorProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{if(s.dims&&s.dims.length||(s.dims=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.dims.push(t.int64());else s.dims.push(t.int64());break}case 2:{s.dataType=t.int32();break}case 3:{s.segment=$.onnx.TensorProto.Segment.decode(t,t.uint32());break}case 4:{if(s.floatData&&s.floatData.length||(s.floatData=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.floatData.push(t.float());else s.floatData.push(t.float());break}case 5:{if(s.int32Data&&s.int32Data.length||(s.int32Data=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.int32Data.push(t.int32());else s.int32Data.push(t.int32());break}case 6:{s.stringData&&s.stringData.length||(s.stringData=[]),s.stringData.push(t.bytes());break}case 7:{if(s.int64Data&&s.int64Data.length||(s.int64Data=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.int64Data.push(t.int64());else s.int64Data.push(t.int64());break}case 8:{s.name=t.string();break}case 12:{s.docString=t.string();break}case 9:{s.rawData=t.bytes();break}case 13:{s.externalData&&s.externalData.length||(s.externalData=[]),s.externalData.push($.onnx.StringStringEntryProto.decode(t,t.uint32()));break}case 14:{s.dataLocation=t.int32();break}case 10:{if(s.doubleData&&s.doubleData.length||(s.doubleData=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.doubleData.push(t.double());else s.doubleData.push(t.double());break}case 11:{if(s.uint64Data&&s.uint64Data.length||(s.uint64Data=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.uint64Data.push(t.uint64());else s.uint64Data.push(t.uint64());break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof X||(t=new X(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.dims!=null&&t.hasOwnProperty("dims")){if(!Array.isArray(t.dims))return"dims: array expected";for(var o=0;o<t.dims.length;++o)if(!O.isInteger(t.dims[o])&&!(t.dims[o]&&O.isInteger(t.dims[o].low)&&O.isInteger(t.dims[o].high)))return"dims: integer|Long[] expected"}if(t.dataType!=null&&t.hasOwnProperty("dataType")&&!O.isInteger(t.dataType))return"dataType: integer expected";if(t.segment!=null&&t.hasOwnProperty("segment")){var i=$.onnx.TensorProto.Segment.verify(t.segment);if(i)return"segment."+i}if(t.floatData!=null&&t.hasOwnProperty("floatData")){if(!Array.isArray(t.floatData))return"floatData: array expected";for(var o=0;o<t.floatData.length;++o)if(typeof t.floatData[o]!="number")return"floatData: number[] expected"}if(t.int32Data!=null&&t.hasOwnProperty("int32Data")){if(!Array.isArray(t.int32Data))return"int32Data: array expected";for(var o=0;o<t.int32Data.length;++o)if(!O.isInteger(t.int32Data[o]))return"int32Data: integer[] expected"}if(t.stringData!=null&&t.hasOwnProperty("stringData")){if(!Array.isArray(t.stringData))return"stringData: array expected";for(var o=0;o<t.stringData.length;++o)if(!(t.stringData[o]&&typeof t.stringData[o].length=="number"||O.isString(t.stringData[o])))return"stringData: buffer[] expected"}if(t.int64Data!=null&&t.hasOwnProperty("int64Data")){if(!Array.isArray(t.int64Data))return"int64Data: array expected";for(var o=0;o<t.int64Data.length;++o)if(!O.isInteger(t.int64Data[o])&&!(t.int64Data[o]&&O.isInteger(t.int64Data[o].low)&&O.isInteger(t.int64Data[o].high)))return"int64Data: integer|Long[] expected"}if(t.name!=null&&t.hasOwnProperty("name")&&!O.isString(t.name))return"name: string expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!O.isString(t.docString))return"docString: string expected";if(t.rawData!=null&&t.hasOwnProperty("rawData")&&!(t.rawData&&typeof t.rawData.length=="number"||O.isString(t.rawData)))return"rawData: buffer expected";if(t.externalData!=null&&t.hasOwnProperty("externalData")){if(!Array.isArray(t.externalData))return"externalData: array expected";for(var o=0;o<t.externalData.length;++o){var i=$.onnx.StringStringEntryProto.verify(t.externalData[o]);if(i)return"externalData."+i}}if(t.dataLocation!=null&&t.hasOwnProperty("dataLocation"))switch(t.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:break}if(t.doubleData!=null&&t.hasOwnProperty("doubleData")){if(!Array.isArray(t.doubleData))return"doubleData: array expected";for(var o=0;o<t.doubleData.length;++o)if(typeof t.doubleData[o]!="number")return"doubleData: number[] expected"}if(t.uint64Data!=null&&t.hasOwnProperty("uint64Data")){if(!Array.isArray(t.uint64Data))return"uint64Data: array expected";for(var o=0;o<t.uint64Data.length;++o)if(!O.isInteger(t.uint64Data[o])&&!(t.uint64Data[o]&&O.isInteger(t.uint64Data[o].low)&&O.isInteger(t.uint64Data[o].high)))return"uint64Data: integer|Long[] expected"}return null},e.fromObject=function(t){if(t instanceof $.onnx.TensorProto)return t;var o=new $.onnx.TensorProto;if(t.dims){if(!Array.isArray(t.dims))throw TypeError(".onnx.TensorProto.dims: array expected");o.dims=[];for(var i=0;i<t.dims.length;++i)O.Long?(o.dims[i]=O.Long.fromValue(t.dims[i])).unsigned=!1:typeof t.dims[i]=="string"?o.dims[i]=parseInt(t.dims[i],10):typeof t.dims[i]=="number"?o.dims[i]=t.dims[i]:typeof t.dims[i]=="object"&&(o.dims[i]=new O.LongBits(t.dims[i].low>>>0,t.dims[i].high>>>0).toNumber())}if(t.dataType!=null&&(o.dataType=t.dataType|0),t.segment!=null){if(typeof t.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");o.segment=$.onnx.TensorProto.Segment.fromObject(t.segment)}if(t.floatData){if(!Array.isArray(t.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");o.floatData=[];for(var i=0;i<t.floatData.length;++i)o.floatData[i]=Number(t.floatData[i])}if(t.int32Data){if(!Array.isArray(t.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");o.int32Data=[];for(var i=0;i<t.int32Data.length;++i)o.int32Data[i]=t.int32Data[i]|0}if(t.stringData){if(!Array.isArray(t.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");o.stringData=[];for(var i=0;i<t.stringData.length;++i)typeof t.stringData[i]=="string"?O.base64.decode(t.stringData[i],o.stringData[i]=O.newBuffer(O.base64.length(t.stringData[i])),0):t.stringData[i].length>=0&&(o.stringData[i]=t.stringData[i])}if(t.int64Data){if(!Array.isArray(t.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");o.int64Data=[];for(var i=0;i<t.int64Data.length;++i)O.Long?(o.int64Data[i]=O.Long.fromValue(t.int64Data[i])).unsigned=!1:typeof t.int64Data[i]=="string"?o.int64Data[i]=parseInt(t.int64Data[i],10):typeof t.int64Data[i]=="number"?o.int64Data[i]=t.int64Data[i]:typeof t.int64Data[i]=="object"&&(o.int64Data[i]=new O.LongBits(t.int64Data[i].low>>>0,t.int64Data[i].high>>>0).toNumber())}if(t.name!=null&&(o.name=String(t.name)),t.docString!=null&&(o.docString=String(t.docString)),t.rawData!=null&&(typeof t.rawData=="string"?O.base64.decode(t.rawData,o.rawData=O.newBuffer(O.base64.length(t.rawData)),0):t.rawData.length>=0&&(o.rawData=t.rawData)),t.externalData){if(!Array.isArray(t.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");o.externalData=[];for(var i=0;i<t.externalData.length;++i){if(typeof t.externalData[i]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");o.externalData[i]=$.onnx.StringStringEntryProto.fromObject(t.externalData[i])}}switch(t.dataLocation){default:if(typeof t.dataLocation=="number"){o.dataLocation=t.dataLocation;break}break;case"DEFAULT":case 0:o.dataLocation=0;break;case"EXTERNAL":case 1:o.dataLocation=1;break}if(t.doubleData){if(!Array.isArray(t.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");o.doubleData=[];for(var i=0;i<t.doubleData.length;++i)o.doubleData[i]=Number(t.doubleData[i])}if(t.uint64Data){if(!Array.isArray(t.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");o.uint64Data=[];for(var i=0;i<t.uint64Data.length;++i)O.Long?(o.uint64Data[i]=O.Long.fromValue(t.uint64Data[i])).unsigned=!0:typeof t.uint64Data[i]=="string"?o.uint64Data[i]=parseInt(t.uint64Data[i],10):typeof t.uint64Data[i]=="number"?o.uint64Data[i]=t.uint64Data[i]:typeof t.uint64Data[i]=="object"&&(o.uint64Data[i]=new O.LongBits(t.uint64Data[i].low>>>0,t.uint64Data[i].high>>>0).toNumber(!0))}return o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.dims=[],i.floatData=[],i.int32Data=[],i.stringData=[],i.int64Data=[],i.doubleData=[],i.uint64Data=[],i.externalData=[]),o.defaults&&(i.dataType=0,i.segment=null,i.name="",o.bytes===String?i.rawData="":(i.rawData=[],o.bytes!==Array&&(i.rawData=O.newBuffer(i.rawData))),i.docString="",i.dataLocation=o.enums===String?"DEFAULT":0),t.dims&&t.dims.length){i.dims=[];for(var s=0;s<t.dims.length;++s)typeof t.dims[s]=="number"?i.dims[s]=o.longs===String?String(t.dims[s]):t.dims[s]:i.dims[s]=o.longs===String?O.Long.prototype.toString.call(t.dims[s]):o.longs===Number?new O.LongBits(t.dims[s].low>>>0,t.dims[s].high>>>0).toNumber():t.dims[s]}if(t.dataType!=null&&t.hasOwnProperty("dataType")&&(i.dataType=t.dataType),t.segment!=null&&t.hasOwnProperty("segment")&&(i.segment=$.onnx.TensorProto.Segment.toObject(t.segment,o)),t.floatData&&t.floatData.length){i.floatData=[];for(var s=0;s<t.floatData.length;++s)i.floatData[s]=o.json&&!isFinite(t.floatData[s])?String(t.floatData[s]):t.floatData[s]}if(t.int32Data&&t.int32Data.length){i.int32Data=[];for(var s=0;s<t.int32Data.length;++s)i.int32Data[s]=t.int32Data[s]}if(t.stringData&&t.stringData.length){i.stringData=[];for(var s=0;s<t.stringData.length;++s)i.stringData[s]=o.bytes===String?O.base64.encode(t.stringData[s],0,t.stringData[s].length):o.bytes===Array?Array.prototype.slice.call(t.stringData[s]):t.stringData[s]}if(t.int64Data&&t.int64Data.length){i.int64Data=[];for(var s=0;s<t.int64Data.length;++s)typeof t.int64Data[s]=="number"?i.int64Data[s]=o.longs===String?String(t.int64Data[s]):t.int64Data[s]:i.int64Data[s]=o.longs===String?O.Long.prototype.toString.call(t.int64Data[s]):o.longs===Number?new O.LongBits(t.int64Data[s].low>>>0,t.int64Data[s].high>>>0).toNumber():t.int64Data[s]}if(t.name!=null&&t.hasOwnProperty("name")&&(i.name=t.name),t.rawData!=null&&t.hasOwnProperty("rawData")&&(i.rawData=o.bytes===String?O.base64.encode(t.rawData,0,t.rawData.length):o.bytes===Array?Array.prototype.slice.call(t.rawData):t.rawData),t.doubleData&&t.doubleData.length){i.doubleData=[];for(var s=0;s<t.doubleData.length;++s)i.doubleData[s]=o.json&&!isFinite(t.doubleData[s])?String(t.doubleData[s]):t.doubleData[s]}if(t.uint64Data&&t.uint64Data.length){i.uint64Data=[];for(var s=0;s<t.uint64Data.length;++s)typeof t.uint64Data[s]=="number"?i.uint64Data[s]=o.longs===String?String(t.uint64Data[s]):t.uint64Data[s]:i.uint64Data[s]=o.longs===String?O.Long.prototype.toString.call(t.uint64Data[s]):o.longs===Number?new O.LongBits(t.uint64Data[s].low>>>0,t.uint64Data[s].high>>>0).toNumber(!0):t.uint64Data[s]}if(t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),t.externalData&&t.externalData.length){i.externalData=[];for(var s=0;s<t.externalData.length;++s)i.externalData[s]=$.onnx.StringStringEntryProto.toObject(t.externalData[s],o)}return t.dataLocation!=null&&t.hasOwnProperty("dataLocation")&&(i.dataLocation=o.enums===String?$.onnx.TensorProto.DataLocation[t.dataLocation]===void 0?t.dataLocation:$.onnx.TensorProto.DataLocation[t.dataLocation]:t.dataLocation),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,qe.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorProto"},e.DataType=function(){var n={},t=Object.create(n);return t[n[0]="UNDEFINED"]=0,t[n[1]="FLOAT"]=1,t[n[2]="UINT8"]=2,t[n[3]="INT8"]=3,t[n[4]="UINT16"]=4,t[n[5]="INT16"]=5,t[n[6]="INT32"]=6,t[n[7]="INT64"]=7,t[n[8]="STRING"]=8,t[n[9]="BOOL"]=9,t[n[10]="FLOAT16"]=10,t[n[11]="DOUBLE"]=11,t[n[12]="UINT32"]=12,t[n[13]="UINT64"]=13,t[n[14]="COMPLEX64"]=14,t[n[15]="COMPLEX128"]=15,t[n[16]="BFLOAT16"]=16,t[n[17]="FLOAT8E4M3FN"]=17,t[n[18]="FLOAT8E4M3FNUZ"]=18,t[n[19]="FLOAT8E5M2"]=19,t[n[20]="FLOAT8E5M2FNUZ"]=20,t}(),e.Segment=function(){function n(t){if(t)for(var o=Object.keys(t),i=0;i<o.length;++i)t[o[i]]!=null&&(this[o[i]]=t[o[i]])}return n.prototype.begin=O.Long?O.Long.fromBits(0,0,!1):0,n.prototype.end=O.Long?O.Long.fromBits(0,0,!1):0,n.create=function(o){return new n(o)},n.encode=function(o,i){return i||(i=ot.create()),o.begin!=null&&Object.hasOwnProperty.call(o,"begin")&&i.uint32(8).int64(o.begin),o.end!=null&&Object.hasOwnProperty.call(o,"end")&&i.uint32(16).int64(o.end),i},n.encodeDelimited=function(o,i){return this.encode(o,i).ldelim()},n.decode=function(o,i){o instanceof X||(o=X.create(o));for(var s=i===void 0?o.len:o.pos+i,a=new $.onnx.TensorProto.Segment;o.pos<s;){var u=o.uint32();switch(u>>>3){case 1:{a.begin=o.int64();break}case 2:{a.end=o.int64();break}default:o.skipType(u&7);break}}return a},n.decodeDelimited=function(o){return o instanceof X||(o=new X(o)),this.decode(o,o.uint32())},n.verify=function(o){return typeof o!="object"||o===null?"object expected":o.begin!=null&&o.hasOwnProperty("begin")&&!O.isInteger(o.begin)&&!(o.begin&&O.isInteger(o.begin.low)&&O.isInteger(o.begin.high))?"begin: integer|Long expected":o.end!=null&&o.hasOwnProperty("end")&&!O.isInteger(o.end)&&!(o.end&&O.isInteger(o.end.low)&&O.isInteger(o.end.high))?"end: integer|Long expected":null},n.fromObject=function(o){if(o instanceof $.onnx.TensorProto.Segment)return o;var i=new $.onnx.TensorProto.Segment;return o.begin!=null&&(O.Long?(i.begin=O.Long.fromValue(o.begin)).unsigned=!1:typeof o.begin=="string"?i.begin=parseInt(o.begin,10):typeof o.begin=="number"?i.begin=o.begin:typeof o.begin=="object"&&(i.begin=new O.LongBits(o.begin.low>>>0,o.begin.high>>>0).toNumber())),o.end!=null&&(O.Long?(i.end=O.Long.fromValue(o.end)).unsigned=!1:typeof o.end=="string"?i.end=parseInt(o.end,10):typeof o.end=="number"?i.end=o.end:typeof o.end=="object"&&(i.end=new O.LongBits(o.end.low>>>0,o.end.high>>>0).toNumber())),i},n.toObject=function(o,i){i||(i={});var s={};if(i.defaults){if(O.Long){var a=new O.Long(0,0,!1);s.begin=i.longs===String?a.toString():i.longs===Number?a.toNumber():a}else s.begin=i.longs===String?"0":0;if(O.Long){var a=new O.Long(0,0,!1);s.end=i.longs===String?a.toString():i.longs===Number?a.toNumber():a}else s.end=i.longs===String?"0":0}return o.begin!=null&&o.hasOwnProperty("begin")&&(typeof o.begin=="number"?s.begin=i.longs===String?String(o.begin):o.begin:s.begin=i.longs===String?O.Long.prototype.toString.call(o.begin):i.longs===Number?new O.LongBits(o.begin.low>>>0,o.begin.high>>>0).toNumber():o.begin),o.end!=null&&o.hasOwnProperty("end")&&(typeof o.end=="number"?s.end=i.longs===String?String(o.end):o.end:s.end=i.longs===String?O.Long.prototype.toString.call(o.end):i.longs===Number?new O.LongBits(o.end.low>>>0,o.end.high>>>0).toNumber():o.end),s},n.prototype.toJSON=function(){return this.constructor.toObject(this,qe.util.toJSONOptions)},n.getTypeUrl=function(o){return o===void 0&&(o="type.googleapis.com"),o+"/onnx.TensorProto.Segment"},n}(),e.DataLocation=function(){var n={},t=Object.create(n);return t[n[0]="DEFAULT"]=0,t[n[1]="EXTERNAL"]=1,t}(),e}(),r.SparseTensorProto=function(){function e(n){if(this.dims=[],n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.values=null,e.prototype.indices=null,e.prototype.dims=O.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=ot.create()),t.values!=null&&Object.hasOwnProperty.call(t,"values")&&$.onnx.TensorProto.encode(t.values,o.uint32(10).fork()).ldelim(),t.indices!=null&&Object.hasOwnProperty.call(t,"indices")&&$.onnx.TensorProto.encode(t.indices,o.uint32(18).fork()).ldelim(),t.dims!=null&&t.dims.length){o.uint32(26).fork();for(var i=0;i<t.dims.length;++i)o.int64(t.dims[i]);o.ldelim()}return o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof X||(t=X.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new $.onnx.SparseTensorProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{s.values=$.onnx.TensorProto.decode(t,t.uint32());break}case 2:{s.indices=$.onnx.TensorProto.decode(t,t.uint32());break}case 3:{if(s.dims&&s.dims.length||(s.dims=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.dims.push(t.int64());else s.dims.push(t.int64());break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof X||(t=new X(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.values!=null&&t.hasOwnProperty("values")){var o=$.onnx.TensorProto.verify(t.values);if(o)return"values."+o}if(t.indices!=null&&t.hasOwnProperty("indices")){var o=$.onnx.TensorProto.verify(t.indices);if(o)return"indices."+o}if(t.dims!=null&&t.hasOwnProperty("dims")){if(!Array.isArray(t.dims))return"dims: array expected";for(var i=0;i<t.dims.length;++i)if(!O.isInteger(t.dims[i])&&!(t.dims[i]&&O.isInteger(t.dims[i].low)&&O.isInteger(t.dims[i].high)))return"dims: integer|Long[] expected"}return null},e.fromObject=function(t){if(t instanceof $.onnx.SparseTensorProto)return t;var o=new $.onnx.SparseTensorProto;if(t.values!=null){if(typeof t.values!="object")throw TypeError(".onnx.SparseTensorProto.values: object expected");o.values=$.onnx.TensorProto.fromObject(t.values)}if(t.indices!=null){if(typeof t.indices!="object")throw TypeError(".onnx.SparseTensorProto.indices: object expected");o.indices=$.onnx.TensorProto.fromObject(t.indices)}if(t.dims){if(!Array.isArray(t.dims))throw TypeError(".onnx.SparseTensorProto.dims: array expected");o.dims=[];for(var i=0;i<t.dims.length;++i)O.Long?(o.dims[i]=O.Long.fromValue(t.dims[i])).unsigned=!1:typeof t.dims[i]=="string"?o.dims[i]=parseInt(t.dims[i],10):typeof t.dims[i]=="number"?o.dims[i]=t.dims[i]:typeof t.dims[i]=="object"&&(o.dims[i]=new O.LongBits(t.dims[i].low>>>0,t.dims[i].high>>>0).toNumber())}return o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.dims=[]),o.defaults&&(i.values=null,i.indices=null),t.values!=null&&t.hasOwnProperty("values")&&(i.values=$.onnx.TensorProto.toObject(t.values,o)),t.indices!=null&&t.hasOwnProperty("indices")&&(i.indices=$.onnx.TensorProto.toObject(t.indices,o)),t.dims&&t.dims.length){i.dims=[];for(var s=0;s<t.dims.length;++s)typeof t.dims[s]=="number"?i.dims[s]=o.longs===String?String(t.dims[s]):t.dims[s]:i.dims[s]=o.longs===String?O.Long.prototype.toString.call(t.dims[s]):o.longs===Number?new O.LongBits(t.dims[s].low>>>0,t.dims[s].high>>>0).toNumber():t.dims[s]}return i},e.prototype.toJSON=function(){return this.constructor.toObject(this,qe.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.SparseTensorProto"},e}(),r.TensorShapeProto=function(){function e(n){if(this.dim=[],n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.dim=O.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=ot.create()),t.dim!=null&&t.dim.length)for(var i=0;i<t.dim.length;++i)$.onnx.TensorShapeProto.Dimension.encode(t.dim[i],o.uint32(10).fork()).ldelim();return o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof X||(t=X.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new $.onnx.TensorShapeProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{s.dim&&s.dim.length||(s.dim=[]),s.dim.push($.onnx.TensorShapeProto.Dimension.decode(t,t.uint32()));break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof X||(t=new X(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.dim!=null&&t.hasOwnProperty("dim")){if(!Array.isArray(t.dim))return"dim: array expected";for(var o=0;o<t.dim.length;++o){var i=$.onnx.TensorShapeProto.Dimension.verify(t.dim[o]);if(i)return"dim."+i}}return null},e.fromObject=function(t){if(t instanceof $.onnx.TensorShapeProto)return t;var o=new $.onnx.TensorShapeProto;if(t.dim){if(!Array.isArray(t.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");o.dim=[];for(var i=0;i<t.dim.length;++i){if(typeof t.dim[i]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");o.dim[i]=$.onnx.TensorShapeProto.Dimension.fromObject(t.dim[i])}}return o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.dim=[]),t.dim&&t.dim.length){i.dim=[];for(var s=0;s<t.dim.length;++s)i.dim[s]=$.onnx.TensorShapeProto.Dimension.toObject(t.dim[s],o)}return i},e.prototype.toJSON=function(){return this.constructor.toObject(this,qe.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorShapeProto"},e.Dimension=function(){function n(o){if(o)for(var i=Object.keys(o),s=0;s<i.length;++s)o[i[s]]!=null&&(this[i[s]]=o[i[s]])}n.prototype.dimValue=null,n.prototype.dimParam=null,n.prototype.denotation="";var t;return Object.defineProperty(n.prototype,"value",{get:O.oneOfGetter(t=["dimValue","dimParam"]),set:O.oneOfSetter(t)}),n.create=function(i){return new n(i)},n.encode=function(i,s){return s||(s=ot.create()),i.dimValue!=null&&Object.hasOwnProperty.call(i,"dimValue")&&s.uint32(8).int64(i.dimValue),i.dimParam!=null&&Object.hasOwnProperty.call(i,"dimParam")&&s.uint32(18).string(i.dimParam),i.denotation!=null&&Object.hasOwnProperty.call(i,"denotation")&&s.uint32(26).string(i.denotation),s},n.encodeDelimited=function(i,s){return this.encode(i,s).ldelim()},n.decode=function(i,s){i instanceof X||(i=X.create(i));for(var a=s===void 0?i.len:i.pos+s,u=new $.onnx.TensorShapeProto.Dimension;i.pos<a;){var l=i.uint32();switch(l>>>3){case 1:{u.dimValue=i.int64();break}case 2:{u.dimParam=i.string();break}case 3:{u.denotation=i.string();break}default:i.skipType(l&7);break}}return u},n.decodeDelimited=function(i){return i instanceof X||(i=new X(i)),this.decode(i,i.uint32())},n.verify=function(i){if(typeof i!="object"||i===null)return"object expected";var s={};if(i.dimValue!=null&&i.hasOwnProperty("dimValue")&&(s.value=1,!O.isInteger(i.dimValue)&&!(i.dimValue&&O.isInteger(i.dimValue.low)&&O.isInteger(i.dimValue.high))))return"dimValue: integer|Long expected";if(i.dimParam!=null&&i.hasOwnProperty("dimParam")){if(s.value===1)return"value: multiple values";if(s.value=1,!O.isString(i.dimParam))return"dimParam: string expected"}return i.denotation!=null&&i.hasOwnProperty("denotation")&&!O.isString(i.denotation)?"denotation: string expected":null},n.fromObject=function(i){if(i instanceof $.onnx.TensorShapeProto.Dimension)return i;var s=new $.onnx.TensorShapeProto.Dimension;return i.dimValue!=null&&(O.Long?(s.dimValue=O.Long.fromValue(i.dimValue)).unsigned=!1:typeof i.dimValue=="string"?s.dimValue=parseInt(i.dimValue,10):typeof i.dimValue=="number"?s.dimValue=i.dimValue:typeof i.dimValue=="object"&&(s.dimValue=new O.LongBits(i.dimValue.low>>>0,i.dimValue.high>>>0).toNumber())),i.dimParam!=null&&(s.dimParam=String(i.dimParam)),i.denotation!=null&&(s.denotation=String(i.denotation)),s},n.toObject=function(i,s){s||(s={});var a={};return s.defaults&&(a.denotation=""),i.dimValue!=null&&i.hasOwnProperty("dimValue")&&(typeof i.dimValue=="number"?a.dimValue=s.longs===String?String(i.dimValue):i.dimValue:a.dimValue=s.longs===String?O.Long.prototype.toString.call(i.dimValue):s.longs===Number?new O.LongBits(i.dimValue.low>>>0,i.dimValue.high>>>0).toNumber():i.dimValue,s.oneofs&&(a.value="dimValue")),i.dimParam!=null&&i.hasOwnProperty("dimParam")&&(a.dimParam=i.dimParam,s.oneofs&&(a.value="dimParam")),i.denotation!=null&&i.hasOwnProperty("denotation")&&(a.denotation=i.denotation),a},n.prototype.toJSON=function(){return this.constructor.toObject(this,qe.util.toJSONOptions)},n.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TensorShapeProto.Dimension"},n}(),e}(),r.TypeProto=function(){function e(t){if(t)for(var o=Object.keys(t),i=0;i<o.length;++i)t[o[i]]!=null&&(this[o[i]]=t[o[i]])}e.prototype.tensorType=null,e.prototype.sequenceType=null,e.prototype.mapType=null,e.prototype.optionalType=null,e.prototype.sparseTensorType=null,e.prototype.denotation="";var n;return Object.defineProperty(e.prototype,"value",{get:O.oneOfGetter(n=["tensorType","sequenceType","mapType","optionalType","sparseTensorType"]),set:O.oneOfSetter(n)}),e.create=function(o){return new e(o)},e.encode=function(o,i){return i||(i=ot.create()),o.tensorType!=null&&Object.hasOwnProperty.call(o,"tensorType")&&$.onnx.TypeProto.Tensor.encode(o.tensorType,i.uint32(10).fork()).ldelim(),o.sequenceType!=null&&Object.hasOwnProperty.call(o,"sequenceType")&&$.onnx.TypeProto.Sequence.encode(o.sequenceType,i.uint32(34).fork()).ldelim(),o.mapType!=null&&Object.hasOwnProperty.call(o,"mapType")&&$.onnx.TypeProto.Map.encode(o.mapType,i.uint32(42).fork()).ldelim(),o.denotation!=null&&Object.hasOwnProperty.call(o,"denotation")&&i.uint32(50).string(o.denotation),o.sparseTensorType!=null&&Object.hasOwnProperty.call(o,"sparseTensorType")&&$.onnx.TypeProto.SparseTensor.encode(o.sparseTensorType,i.uint32(66).fork()).ldelim(),o.optionalType!=null&&Object.hasOwnProperty.call(o,"optionalType")&&$.onnx.TypeProto.Optional.encode(o.optionalType,i.uint32(74).fork()).ldelim(),i},e.encodeDelimited=function(o,i){return this.encode(o,i).ldelim()},e.decode=function(o,i){o instanceof X||(o=X.create(o));for(var s=i===void 0?o.len:o.pos+i,a=new $.onnx.TypeProto;o.pos<s;){var u=o.uint32();switch(u>>>3){case 1:{a.tensorType=$.onnx.TypeProto.Tensor.decode(o,o.uint32());break}case 4:{a.sequenceType=$.onnx.TypeProto.Sequence.decode(o,o.uint32());break}case 5:{a.mapType=$.onnx.TypeProto.Map.decode(o,o.uint32());break}case 9:{a.optionalType=$.onnx.TypeProto.Optional.decode(o,o.uint32());break}case 8:{a.sparseTensorType=$.onnx.TypeProto.SparseTensor.decode(o,o.uint32());break}case 6:{a.denotation=o.string();break}default:o.skipType(u&7);break}}return a},e.decodeDelimited=function(o){return o instanceof X||(o=new X(o)),this.decode(o,o.uint32())},e.verify=function(o){if(typeof o!="object"||o===null)return"object expected";var i={};if(o.tensorType!=null&&o.hasOwnProperty("tensorType")){i.value=1;{var s=$.onnx.TypeProto.Tensor.verify(o.tensorType);if(s)return"tensorType."+s}}if(o.sequenceType!=null&&o.hasOwnProperty("sequenceType")){if(i.value===1)return"value: multiple values";i.value=1;{var s=$.onnx.TypeProto.Sequence.verify(o.sequenceType);if(s)return"sequenceType."+s}}if(o.mapType!=null&&o.hasOwnProperty("mapType")){if(i.value===1)return"value: multiple values";i.value=1;{var s=$.onnx.TypeProto.Map.verify(o.mapType);if(s)return"mapType."+s}}if(o.optionalType!=null&&o.hasOwnProperty("optionalType")){if(i.value===1)return"value: multiple values";i.value=1;{var s=$.onnx.TypeProto.Optional.verify(o.optionalType);if(s)return"optionalType."+s}}if(o.sparseTensorType!=null&&o.hasOwnProperty("sparseTensorType")){if(i.value===1)return"value: multiple values";i.value=1;{var s=$.onnx.TypeProto.SparseTensor.verify(o.sparseTensorType);if(s)return"sparseTensorType."+s}}return o.denotation!=null&&o.hasOwnProperty("denotation")&&!O.isString(o.denotation)?"denotation: string expected":null},e.fromObject=function(o){if(o instanceof $.onnx.TypeProto)return o;var i=new $.onnx.TypeProto;if(o.tensorType!=null){if(typeof o.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");i.tensorType=$.onnx.TypeProto.Tensor.fromObject(o.tensorType)}if(o.sequenceType!=null){if(typeof o.sequenceType!="object")throw TypeError(".onnx.TypeProto.sequenceType: object expected");i.sequenceType=$.onnx.TypeProto.Sequence.fromObject(o.sequenceType)}if(o.mapType!=null){if(typeof o.mapType!="object")throw TypeError(".onnx.TypeProto.mapType: object expected");i.mapType=$.onnx.TypeProto.Map.fromObject(o.mapType)}if(o.optionalType!=null){if(typeof o.optionalType!="object")throw TypeError(".onnx.TypeProto.optionalType: object expected");i.optionalType=$.onnx.TypeProto.Optional.fromObject(o.optionalType)}if(o.sparseTensorType!=null){if(typeof o.sparseTensorType!="object")throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");i.sparseTensorType=$.onnx.TypeProto.SparseTensor.fromObject(o.sparseTensorType)}return o.denotation!=null&&(i.denotation=String(o.denotation)),i},e.toObject=function(o,i){i||(i={});var s={};return i.defaults&&(s.denotation=""),o.tensorType!=null&&o.hasOwnProperty("tensorType")&&(s.tensorType=$.onnx.TypeProto.Tensor.toObject(o.tensorType,i),i.oneofs&&(s.value="tensorType")),o.sequenceType!=null&&o.hasOwnProperty("sequenceType")&&(s.sequenceType=$.onnx.TypeProto.Sequence.toObject(o.sequenceType,i),i.oneofs&&(s.value="sequenceType")),o.mapType!=null&&o.hasOwnProperty("mapType")&&(s.mapType=$.onnx.TypeProto.Map.toObject(o.mapType,i),i.oneofs&&(s.value="mapType")),o.denotation!=null&&o.hasOwnProperty("denotation")&&(s.denotation=o.denotation),o.sparseTensorType!=null&&o.hasOwnProperty("sparseTensorType")&&(s.sparseTensorType=$.onnx.TypeProto.SparseTensor.toObject(o.sparseTensorType,i),i.oneofs&&(s.value="sparseTensorType")),o.optionalType!=null&&o.hasOwnProperty("optionalType")&&(s.optionalType=$.onnx.TypeProto.Optional.toObject(o.optionalType,i),i.oneofs&&(s.value="optionalType")),s},e.prototype.toJSON=function(){return this.constructor.toObject(this,qe.util.toJSONOptions)},e.getTypeUrl=function(o){return o===void 0&&(o="type.googleapis.com"),o+"/onnx.TypeProto"},e.Tensor=function(){function t(o){if(o)for(var i=Object.keys(o),s=0;s<i.length;++s)o[i[s]]!=null&&(this[i[s]]=o[i[s]])}return t.prototype.elemType=0,t.prototype.shape=null,t.create=function(i){return new t(i)},t.encode=function(i,s){return s||(s=ot.create()),i.elemType!=null&&Object.hasOwnProperty.call(i,"elemType")&&s.uint32(8).int32(i.elemType),i.shape!=null&&Object.hasOwnProperty.call(i,"shape")&&$.onnx.TensorShapeProto.encode(i.shape,s.uint32(18).fork()).ldelim(),s},t.encodeDelimited=function(i,s){return this.encode(i,s).ldelim()},t.decode=function(i,s){i instanceof X||(i=X.create(i));for(var a=s===void 0?i.len:i.pos+s,u=new $.onnx.TypeProto.Tensor;i.pos<a;){var l=i.uint32();switch(l>>>3){case 1:{u.elemType=i.int32();break}case 2:{u.shape=$.onnx.TensorShapeProto.decode(i,i.uint32());break}default:i.skipType(l&7);break}}return u},t.decodeDelimited=function(i){return i instanceof X||(i=new X(i)),this.decode(i,i.uint32())},t.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.elemType!=null&&i.hasOwnProperty("elemType")&&!O.isInteger(i.elemType))return"elemType: integer expected";if(i.shape!=null&&i.hasOwnProperty("shape")){var s=$.onnx.TensorShapeProto.verify(i.shape);if(s)return"shape."+s}return null},t.fromObject=function(i){if(i instanceof $.onnx.TypeProto.Tensor)return i;var s=new $.onnx.TypeProto.Tensor;if(i.elemType!=null&&(s.elemType=i.elemType|0),i.shape!=null){if(typeof i.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");s.shape=$.onnx.TensorShapeProto.fromObject(i.shape)}return s},t.toObject=function(i,s){s||(s={});var a={};return s.defaults&&(a.elemType=0,a.shape=null),i.elemType!=null&&i.hasOwnProperty("elemType")&&(a.elemType=i.elemType),i.shape!=null&&i.hasOwnProperty("shape")&&(a.shape=$.onnx.TensorShapeProto.toObject(i.shape,s)),a},t.prototype.toJSON=function(){return this.constructor.toObject(this,qe.util.toJSONOptions)},t.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.Tensor"},t}(),e.Sequence=function(){function t(o){if(o)for(var i=Object.keys(o),s=0;s<i.length;++s)o[i[s]]!=null&&(this[i[s]]=o[i[s]])}return t.prototype.elemType=null,t.create=function(i){return new t(i)},t.encode=function(i,s){return s||(s=ot.create()),i.elemType!=null&&Object.hasOwnProperty.call(i,"elemType")&&$.onnx.TypeProto.encode(i.elemType,s.uint32(10).fork()).ldelim(),s},t.encodeDelimited=function(i,s){return this.encode(i,s).ldelim()},t.decode=function(i,s){i instanceof X||(i=X.create(i));for(var a=s===void 0?i.len:i.pos+s,u=new $.onnx.TypeProto.Sequence;i.pos<a;){var l=i.uint32();switch(l>>>3){case 1:{u.elemType=$.onnx.TypeProto.decode(i,i.uint32());break}default:i.skipType(l&7);break}}return u},t.decodeDelimited=function(i){return i instanceof X||(i=new X(i)),this.decode(i,i.uint32())},t.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.elemType!=null&&i.hasOwnProperty("elemType")){var s=$.onnx.TypeProto.verify(i.elemType);if(s)return"elemType."+s}return null},t.fromObject=function(i){if(i instanceof $.onnx.TypeProto.Sequence)return i;var s=new $.onnx.TypeProto.Sequence;if(i.elemType!=null){if(typeof i.elemType!="object")throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");s.elemType=$.onnx.TypeProto.fromObject(i.elemType)}return s},t.toObject=function(i,s){s||(s={});var a={};return s.defaults&&(a.elemType=null),i.elemType!=null&&i.hasOwnProperty("elemType")&&(a.elemType=$.onnx.TypeProto.toObject(i.elemType,s)),a},t.prototype.toJSON=function(){return this.constructor.toObject(this,qe.util.toJSONOptions)},t.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.Sequence"},t}(),e.Map=function(){function t(o){if(o)for(var i=Object.keys(o),s=0;s<i.length;++s)o[i[s]]!=null&&(this[i[s]]=o[i[s]])}return t.prototype.keyType=0,t.prototype.valueType=null,t.create=function(i){return new t(i)},t.encode=function(i,s){return s||(s=ot.create()),i.keyType!=null&&Object.hasOwnProperty.call(i,"keyType")&&s.uint32(8).int32(i.keyType),i.valueType!=null&&Object.hasOwnProperty.call(i,"valueType")&&$.onnx.TypeProto.encode(i.valueType,s.uint32(18).fork()).ldelim(),s},t.encodeDelimited=function(i,s){return this.encode(i,s).ldelim()},t.decode=function(i,s){i instanceof X||(i=X.create(i));for(var a=s===void 0?i.len:i.pos+s,u=new $.onnx.TypeProto.Map;i.pos<a;){var l=i.uint32();switch(l>>>3){case 1:{u.keyType=i.int32();break}case 2:{u.valueType=$.onnx.TypeProto.decode(i,i.uint32());break}default:i.skipType(l&7);break}}return u},t.decodeDelimited=function(i){return i instanceof X||(i=new X(i)),this.decode(i,i.uint32())},t.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.keyType!=null&&i.hasOwnProperty("keyType")&&!O.isInteger(i.keyType))return"keyType: integer expected";if(i.valueType!=null&&i.hasOwnProperty("valueType")){var s=$.onnx.TypeProto.verify(i.valueType);if(s)return"valueType."+s}return null},t.fromObject=function(i){if(i instanceof $.onnx.TypeProto.Map)return i;var s=new $.onnx.TypeProto.Map;if(i.keyType!=null&&(s.keyType=i.keyType|0),i.valueType!=null){if(typeof i.valueType!="object")throw TypeError(".onnx.TypeProto.Map.valueType: object expected");s.valueType=$.onnx.TypeProto.fromObject(i.valueType)}return s},t.toObject=function(i,s){s||(s={});var a={};return s.defaults&&(a.keyType=0,a.valueType=null),i.keyType!=null&&i.hasOwnProperty("keyType")&&(a.keyType=i.keyType),i.valueType!=null&&i.hasOwnProperty("valueType")&&(a.valueType=$.onnx.TypeProto.toObject(i.valueType,s)),a},t.prototype.toJSON=function(){return this.constructor.toObject(this,qe.util.toJSONOptions)},t.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.Map"},t}(),e.Optional=function(){function t(o){if(o)for(var i=Object.keys(o),s=0;s<i.length;++s)o[i[s]]!=null&&(this[i[s]]=o[i[s]])}return t.prototype.elemType=null,t.create=function(i){return new t(i)},t.encode=function(i,s){return s||(s=ot.create()),i.elemType!=null&&Object.hasOwnProperty.call(i,"elemType")&&$.onnx.TypeProto.encode(i.elemType,s.uint32(10).fork()).ldelim(),s},t.encodeDelimited=function(i,s){return this.encode(i,s).ldelim()},t.decode=function(i,s){i instanceof X||(i=X.create(i));for(var a=s===void 0?i.len:i.pos+s,u=new $.onnx.TypeProto.Optional;i.pos<a;){var l=i.uint32();switch(l>>>3){case 1:{u.elemType=$.onnx.TypeProto.decode(i,i.uint32());break}default:i.skipType(l&7);break}}return u},t.decodeDelimited=function(i){return i instanceof X||(i=new X(i)),this.decode(i,i.uint32())},t.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.elemType!=null&&i.hasOwnProperty("elemType")){var s=$.onnx.TypeProto.verify(i.elemType);if(s)return"elemType."+s}return null},t.fromObject=function(i){if(i instanceof $.onnx.TypeProto.Optional)return i;var s=new $.onnx.TypeProto.Optional;if(i.elemType!=null){if(typeof i.elemType!="object")throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");s.elemType=$.onnx.TypeProto.fromObject(i.elemType)}return s},t.toObject=function(i,s){s||(s={});var a={};return s.defaults&&(a.elemType=null),i.elemType!=null&&i.hasOwnProperty("elemType")&&(a.elemType=$.onnx.TypeProto.toObject(i.elemType,s)),a},t.prototype.toJSON=function(){return this.constructor.toObject(this,qe.util.toJSONOptions)},t.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.Optional"},t}(),e.SparseTensor=function(){function t(o){if(o)for(var i=Object.keys(o),s=0;s<i.length;++s)o[i[s]]!=null&&(this[i[s]]=o[i[s]])}return t.prototype.elemType=0,t.prototype.shape=null,t.create=function(i){return new t(i)},t.encode=function(i,s){return s||(s=ot.create()),i.elemType!=null&&Object.hasOwnProperty.call(i,"elemType")&&s.uint32(8).int32(i.elemType),i.shape!=null&&Object.hasOwnProperty.call(i,"shape")&&$.onnx.TensorShapeProto.encode(i.shape,s.uint32(18).fork()).ldelim(),s},t.encodeDelimited=function(i,s){return this.encode(i,s).ldelim()},t.decode=function(i,s){i instanceof X||(i=X.create(i));for(var a=s===void 0?i.len:i.pos+s,u=new $.onnx.TypeProto.SparseTensor;i.pos<a;){var l=i.uint32();switch(l>>>3){case 1:{u.elemType=i.int32();break}case 2:{u.shape=$.onnx.TensorShapeProto.decode(i,i.uint32());break}default:i.skipType(l&7);break}}return u},t.decodeDelimited=function(i){return i instanceof X||(i=new X(i)),this.decode(i,i.uint32())},t.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.elemType!=null&&i.hasOwnProperty("elemType")&&!O.isInteger(i.elemType))return"elemType: integer expected";if(i.shape!=null&&i.hasOwnProperty("shape")){var s=$.onnx.TensorShapeProto.verify(i.shape);if(s)return"shape."+s}return null},t.fromObject=function(i){if(i instanceof $.onnx.TypeProto.SparseTensor)return i;var s=new $.onnx.TypeProto.SparseTensor;if(i.elemType!=null&&(s.elemType=i.elemType|0),i.shape!=null){if(typeof i.shape!="object")throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");s.shape=$.onnx.TensorShapeProto.fromObject(i.shape)}return s},t.toObject=function(i,s){s||(s={});var a={};return s.defaults&&(a.elemType=0,a.shape=null),i.elemType!=null&&i.hasOwnProperty("elemType")&&(a.elemType=i.elemType),i.shape!=null&&i.hasOwnProperty("shape")&&(a.shape=$.onnx.TensorShapeProto.toObject(i.shape,s)),a},t.prototype.toJSON=function(){return this.constructor.toObject(this,qe.util.toJSONOptions)},t.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.SparseTensor"},t}(),e}(),r.OperatorSetIdProto=function(){function e(n){if(n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.domain="",e.prototype.version=O.Long?O.Long.fromBits(0,0,!1):0,e.create=function(t){return new e(t)},e.encode=function(t,o){return o||(o=ot.create()),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&o.uint32(10).string(t.domain),t.version!=null&&Object.hasOwnProperty.call(t,"version")&&o.uint32(16).int64(t.version),o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof X||(t=X.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new $.onnx.OperatorSetIdProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{s.domain=t.string();break}case 2:{s.version=t.int64();break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof X||(t=new X(t)),this.decode(t,t.uint32())},e.verify=function(t){return typeof t!="object"||t===null?"object expected":t.domain!=null&&t.hasOwnProperty("domain")&&!O.isString(t.domain)?"domain: string expected":t.version!=null&&t.hasOwnProperty("version")&&!O.isInteger(t.version)&&!(t.version&&O.isInteger(t.version.low)&&O.isInteger(t.version.high))?"version: integer|Long expected":null},e.fromObject=function(t){if(t instanceof $.onnx.OperatorSetIdProto)return t;var o=new $.onnx.OperatorSetIdProto;return t.domain!=null&&(o.domain=String(t.domain)),t.version!=null&&(O.Long?(o.version=O.Long.fromValue(t.version)).unsigned=!1:typeof t.version=="string"?o.version=parseInt(t.version,10):typeof t.version=="number"?o.version=t.version:typeof t.version=="object"&&(o.version=new O.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber())),o},e.toObject=function(t,o){o||(o={});var i={};if(o.defaults)if(i.domain="",O.Long){var s=new O.Long(0,0,!1);i.version=o.longs===String?s.toString():o.longs===Number?s.toNumber():s}else i.version=o.longs===String?"0":0;return t.domain!=null&&t.hasOwnProperty("domain")&&(i.domain=t.domain),t.version!=null&&t.hasOwnProperty("version")&&(typeof t.version=="number"?i.version=o.longs===String?String(t.version):t.version:i.version=o.longs===String?O.Long.prototype.toString.call(t.version):o.longs===Number?new O.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber():t.version),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,qe.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.OperatorSetIdProto"},e}(),r.OperatorStatus=function(){var e={},n=Object.create(e);return n[e[0]="EXPERIMENTAL"]=0,n[e[1]="STABLE"]=1,n}(),r.FunctionProto=function(){function e(n){if(this.input=[],this.output=[],this.attribute=[],this.attributeProto=[],this.node=[],this.opsetImport=[],n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.name="",e.prototype.input=O.emptyArray,e.prototype.output=O.emptyArray,e.prototype.attribute=O.emptyArray,e.prototype.attributeProto=O.emptyArray,e.prototype.node=O.emptyArray,e.prototype.docString="",e.prototype.opsetImport=O.emptyArray,e.prototype.domain="",e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=ot.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&o.uint32(10).string(t.name),t.input!=null&&t.input.length)for(var i=0;i<t.input.length;++i)o.uint32(34).string(t.input[i]);if(t.output!=null&&t.output.length)for(var i=0;i<t.output.length;++i)o.uint32(42).string(t.output[i]);if(t.attribute!=null&&t.attribute.length)for(var i=0;i<t.attribute.length;++i)o.uint32(50).string(t.attribute[i]);if(t.node!=null&&t.node.length)for(var i=0;i<t.node.length;++i)$.onnx.NodeProto.encode(t.node[i],o.uint32(58).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&o.uint32(66).string(t.docString),t.opsetImport!=null&&t.opsetImport.length)for(var i=0;i<t.opsetImport.length;++i)$.onnx.OperatorSetIdProto.encode(t.opsetImport[i],o.uint32(74).fork()).ldelim();if(t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&o.uint32(82).string(t.domain),t.attributeProto!=null&&t.attributeProto.length)for(var i=0;i<t.attributeProto.length;++i)$.onnx.AttributeProto.encode(t.attributeProto[i],o.uint32(90).fork()).ldelim();return o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof X||(t=X.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new $.onnx.FunctionProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{s.name=t.string();break}case 4:{s.input&&s.input.length||(s.input=[]),s.input.push(t.string());break}case 5:{s.output&&s.output.length||(s.output=[]),s.output.push(t.string());break}case 6:{s.attribute&&s.attribute.length||(s.attribute=[]),s.attribute.push(t.string());break}case 11:{s.attributeProto&&s.attributeProto.length||(s.attributeProto=[]),s.attributeProto.push($.onnx.AttributeProto.decode(t,t.uint32()));break}case 7:{s.node&&s.node.length||(s.node=[]),s.node.push($.onnx.NodeProto.decode(t,t.uint32()));break}case 8:{s.docString=t.string();break}case 9:{s.opsetImport&&s.opsetImport.length||(s.opsetImport=[]),s.opsetImport.push($.onnx.OperatorSetIdProto.decode(t,t.uint32()));break}case 10:{s.domain=t.string();break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof X||(t=new X(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!O.isString(t.name))return"name: string expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var o=0;o<t.input.length;++o)if(!O.isString(t.input[o]))return"input: string[] expected"}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(var o=0;o<t.output.length;++o)if(!O.isString(t.output[o]))return"output: string[] expected"}if(t.attribute!=null&&t.hasOwnProperty("attribute")){if(!Array.isArray(t.attribute))return"attribute: array expected";for(var o=0;o<t.attribute.length;++o)if(!O.isString(t.attribute[o]))return"attribute: string[] expected"}if(t.attributeProto!=null&&t.hasOwnProperty("attributeProto")){if(!Array.isArray(t.attributeProto))return"attributeProto: array expected";for(var o=0;o<t.attributeProto.length;++o){var i=$.onnx.AttributeProto.verify(t.attributeProto[o]);if(i)return"attributeProto."+i}}if(t.node!=null&&t.hasOwnProperty("node")){if(!Array.isArray(t.node))return"node: array expected";for(var o=0;o<t.node.length;++o){var i=$.onnx.NodeProto.verify(t.node[o]);if(i)return"node."+i}}if(t.docString!=null&&t.hasOwnProperty("docString")&&!O.isString(t.docString))return"docString: string expected";if(t.opsetImport!=null&&t.hasOwnProperty("opsetImport")){if(!Array.isArray(t.opsetImport))return"opsetImport: array expected";for(var o=0;o<t.opsetImport.length;++o){var i=$.onnx.OperatorSetIdProto.verify(t.opsetImport[o]);if(i)return"opsetImport."+i}}return t.domain!=null&&t.hasOwnProperty("domain")&&!O.isString(t.domain)?"domain: string expected":null},e.fromObject=function(t){if(t instanceof $.onnx.FunctionProto)return t;var o=new $.onnx.FunctionProto;if(t.name!=null&&(o.name=String(t.name)),t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.FunctionProto.input: array expected");o.input=[];for(var i=0;i<t.input.length;++i)o.input[i]=String(t.input[i])}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.FunctionProto.output: array expected");o.output=[];for(var i=0;i<t.output.length;++i)o.output[i]=String(t.output[i])}if(t.attribute){if(!Array.isArray(t.attribute))throw TypeError(".onnx.FunctionProto.attribute: array expected");o.attribute=[];for(var i=0;i<t.attribute.length;++i)o.attribute[i]=String(t.attribute[i])}if(t.attributeProto){if(!Array.isArray(t.attributeProto))throw TypeError(".onnx.FunctionProto.attributeProto: array expected");o.attributeProto=[];for(var i=0;i<t.attributeProto.length;++i){if(typeof t.attributeProto[i]!="object")throw TypeError(".onnx.FunctionProto.attributeProto: object expected");o.attributeProto[i]=$.onnx.AttributeProto.fromObject(t.attributeProto[i])}}if(t.node){if(!Array.isArray(t.node))throw TypeError(".onnx.FunctionProto.node: array expected");o.node=[];for(var i=0;i<t.node.length;++i){if(typeof t.node[i]!="object")throw TypeError(".onnx.FunctionProto.node: object expected");o.node[i]=$.onnx.NodeProto.fromObject(t.node[i])}}if(t.docString!=null&&(o.docString=String(t.docString)),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(".onnx.FunctionProto.opsetImport: array expected");o.opsetImport=[];for(var i=0;i<t.opsetImport.length;++i){if(typeof t.opsetImport[i]!="object")throw TypeError(".onnx.FunctionProto.opsetImport: object expected");o.opsetImport[i]=$.onnx.OperatorSetIdProto.fromObject(t.opsetImport[i])}}return t.domain!=null&&(o.domain=String(t.domain)),o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.input=[],i.output=[],i.attribute=[],i.node=[],i.opsetImport=[],i.attributeProto=[]),o.defaults&&(i.name="",i.docString="",i.domain=""),t.name!=null&&t.hasOwnProperty("name")&&(i.name=t.name),t.input&&t.input.length){i.input=[];for(var s=0;s<t.input.length;++s)i.input[s]=t.input[s]}if(t.output&&t.output.length){i.output=[];for(var s=0;s<t.output.length;++s)i.output[s]=t.output[s]}if(t.attribute&&t.attribute.length){i.attribute=[];for(var s=0;s<t.attribute.length;++s)i.attribute[s]=t.attribute[s]}if(t.node&&t.node.length){i.node=[];for(var s=0;s<t.node.length;++s)i.node[s]=$.onnx.NodeProto.toObject(t.node[s],o)}if(t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),t.opsetImport&&t.opsetImport.length){i.opsetImport=[];for(var s=0;s<t.opsetImport.length;++s)i.opsetImport[s]=$.onnx.OperatorSetIdProto.toObject(t.opsetImport[s],o)}if(t.domain!=null&&t.hasOwnProperty("domain")&&(i.domain=t.domain),t.attributeProto&&t.attributeProto.length){i.attributeProto=[];for(var s=0;s<t.attributeProto.length;++s)i.attributeProto[s]=$.onnx.AttributeProto.toObject(t.attributeProto[s],o)}return i},e.prototype.toJSON=function(){return this.constructor.toObject(this,qe.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.FunctionProto"},e}(),r}();td.exports=$});function kn(r,e){if(!r)throw new Error(typeof e=="string"?e:e())}function po(r){return new TextDecoder().decode(r)}var Ke,sn,ts,$t,mi,yt,Et,te,fo,un,ln,cn,Fe=M(()=>{"use strict";ci();Ga();Ke=On(Dn());dn();sn=class{static arraysEqual(e,n){if(e.length!==n.length)return!1;for(let t=0;t<e.length;t++)if(e[t]!==n[t])return!1;return!0}},ts=class{static preprocessInputShapes(e,n){let t=e.length===1?[1,e[0]]:e,o=n.length===1?[n[0],1]:n;return[t,o]}static postprocessOutputShape(e,n,t){n===1&&e.splice(e.length-2,1),t===1&&e.pop()}static calcMatMulShape(e,n){return e[1]!==n[0]?void 0:[e[0],n[1]]}},$t=class r{static calcShape(e,n,t=!1){let o=e.length,i=n.length;if(o===0)return n;if(i===0)return e;let s=Math.max(e.length,n.length),a=new Array(s);if(t){if(o<2||i<2)return;let u=ts.calcMatMulShape([e[o-2],e[o-1]],[n[i-2],n[i-1]]);if(u===void 0)return;[a[s-2],a[s-1]]=u}for(let u=t?3:1;u<=s;u++){let l=o-u<0?1:e[o-u],c=i-u<0?1:n[i-u];if(l!==c&&l>1&&c>1)return;a[s-u]=Math.max(l,c)}return a}static index(e,n){let t=new Array(n.length);return r.fillIndex(e,n,t),t}static fillIndex(e,n,t){let o=e.length-n.length;for(let i=0;i<n.length;i++)t[i]=e[o+i]%n[i]}static calc(e,n,t,o,i){let s=r.calcShape(e.dims,n.dims);if(s){if(o&&!te.areEqual(s,e.dims))return;let a=te.size(s),u=o?e:new dt(s,i||e.type);if(s.length===0)u.set([],t(e.get([]),n.get([])));else{let l=new Array(s.length),c=new Array(e.dims.length),h=new Array(n.dims.length),m=0,b=0,x=!1,y=!1;e.dims.length===0&&(m=e.get([]),x=!0),n.dims.length===0&&(b=n.get([]),y=!0);let T;for(let E=0;E<a;E++){T=E;for(let _=s.length-1;_>=0;_--)l[_]=T%s[_],T=Math.floor(T/s[_]);x||(r.fillIndex(l,e.dims,c),m=e.get(c)),y||(r.fillIndex(l,n.dims,h),b=n.get(h)),u.set(l,t(m,b))}}return u}}static isValidBroadcast(e,n){let t=e.length,o=n.length;if(t>o)return!1;for(let i=1;i<=t;i++)if(e[t-i]!==1&&e[t-i]!==n[o-i])return!1;return!0}static getBroadcastDims(e,n){let t=e.length,o=[];for(let i=0;i<t;i++){let s=t-1-i,a=e[s]||1;(n[n.length-1-i]||1)>1&&a===1&&o.unshift(s)}return o}},mi=class{static getShapeOfGemmResult(e,n,t,o,i){if(e.length!==2||t.length!==2)throw new Error("shape need to be of size 2");let s,a,u;n?(s=e[1],a=e[0]):(s=e[0],a=e[1]);let l=-1;if(o?(u=t[0],l=1):(u=t[1],l=0),t[l]!==a)throw new Error("dimension mismatch");if(s<=0||u<=0||a<=0)throw new Error("invalid shape specified");if(i&&!$t.isValidBroadcast(i,[s,u]))throw new Error("gemm: invalid bias shape for broadcast");return[s,u,a]}},yt=class r{static tensorDataTypeFromProto(e){switch(e){case Ke.onnx.TensorProto.DataType.INT8:return"int8";case Ke.onnx.TensorProto.DataType.UINT8:return"uint8";case Ke.onnx.TensorProto.DataType.BOOL:return"bool";case Ke.onnx.TensorProto.DataType.INT16:return"int16";case Ke.onnx.TensorProto.DataType.UINT16:return"uint16";case Ke.onnx.TensorProto.DataType.INT32:return"int32";case Ke.onnx.TensorProto.DataType.UINT32:return"uint32";case Ke.onnx.TensorProto.DataType.FLOAT:return"float32";case Ke.onnx.TensorProto.DataType.DOUBLE:return"float64";case Ke.onnx.TensorProto.DataType.STRING:return"string";case Ke.onnx.TensorProto.DataType.INT64:return"int32";case Ke.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${Ke.onnx.TensorProto.DataType[e]}`)}}static tensorDataTypeStringToEnum(e){switch(e){case"int8":return Ke.onnx.TensorProto.DataType.INT8;case"uint8":return Ke.onnx.TensorProto.DataType.UINT8;case"bool":return Ke.onnx.TensorProto.DataType.BOOL;case"int16":return Ke.onnx.TensorProto.DataType.INT16;case"uint16":return Ke.onnx.TensorProto.DataType.UINT16;case"int32":return Ke.onnx.TensorProto.DataType.INT32;case"uint32":return Ke.onnx.TensorProto.DataType.UINT32;case"float32":return Ke.onnx.TensorProto.DataType.FLOAT;case"float64":return Ke.onnx.TensorProto.DataType.DOUBLE;case"string":return Ke.onnx.TensorProto.DataType.STRING;case"int64":return Ke.onnx.TensorProto.DataType.INT64;case"uint64":return Ke.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${e}`)}}static tensorDimsFromProto(e){return e.map(n=>Or.isLong(n)?n.toNumber():n)}static tensorValueTypeFromProto(e){return{tensorType:r.tensorDataTypeFromProto(e.elemType),shape:{dims:r.tensorDimsFromProto(e.shape.dim.map(n=>n.dimValue))}}}static tensorDimsFromORTFormat(e){let n=[];for(let t=0;t<e.dimsLength();t++)n.push(Et.longToNumber(e.dims(t)));return n}static tensorAttributesFromORTFormat(e){let n=[];for(let t=0;t<e.attributesLength();t++)n.push(e.attributes(t));return n}},Et=class{static longToNumber(e,n){return Or.isLong(e)?e.toNumber():e instanceof B.Long?Or.fromValue({low:e.low,high:e.high,unsigned:n??!1}).toNumber():e}static isLong(e){return Or.isLong(e)||e instanceof B.Long}},te=class r{static size(e){return r.getSizeFromDimensionRange(e,0,e.length)}static sizeFromDimension(e,n){if(n<0||n>e.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return r.getSizeFromDimensionRange(e,n,e.length)}static sizeToDimension(e,n){if(n<0||n>e.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${e.length} dimensions.`);return r.getSizeFromDimensionRange(e,0,n)}static getSizeFromDimensionRange(e,n,t){let o=1;for(let i=n;i<t;i++){if(e[i]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");o*=e[i]}return o}static computeStrides(e){let n=e.length;if(n===0)return[];if(n===1)return[1];let t=new Array(n);t[n-1]=1,t[n-2]=e[n-1];for(let o=n-3;o>=0;--o)t[o]=t[o+1]*e[o+1];return t}static transpose(e){return e.slice().reverse()}static indicesToOffset(e,n,t){t===void 0&&(t=e.length);let o=0;for(let i=0;i<t;++i)o+=n[i]*e[i];return o}static offsetToIndices(e,n){let t=n.length;if(t===0)return[];if(t===1)return[e*n[0]];let o=new Array(n.length);for(let i=0;i<o.length-1;++i)o[i]=Math.floor(e/n[i]),e-=o[i]*n[i];return o[o.length-1]=e,o}static normalizeAxis(e,n){if(e<-n&&e>=n)throw new Error("unsupported axis for this operation.");return e<0?e+n:e}static normalizeAxes(e,n){return e.map(t=>this.normalizeAxis(t,n))}static incrementIndex(e,n,t){if(n.length===0||e.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(t===void 0)t=n.length;else if(t<=0||t>n.length)throw new Error("Incorrect axis to increment on");for(let o=t-1;o>=0&&(e[o]++,!(e[o]<n[o]));--o)e[o]=0}static calculateReshapedDims(e,n){if(n.length===0){if(e.length===0||r.size(e)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}let t=n.length,o=new Array(t),i=-1,s=1;for(let u=0;u<t;u++){if(n[u]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(n[u]===-1){if(i!==-1)throw new Error("at most one dimension in shape hints can be -1");i=u}else{if(n[u]===0){if(u>=e.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");o[u]=e[u]}else o[u]=n[u];s*=o[u]}}let a=r.size(e);if(i!==-1){if(a%s!==0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${e}] Output shape: [${n}]`);o[i]=a/s}else if(s!==a)throw new Error("reshapedDims and originalDims don't have matching sizes");return o}static sortBasedOnPerm(e,n){return n?n.map(t=>e[t]):e.slice().reverse()}static padShape(e,n){let t=e.length;return e.map((o,i)=>o+n[i]+n[i+t])}static areEqual(e,n){return e.length!==n.length?!1:e.every((t,o)=>t===n[o])}static validateDimsAndCalcSize(e){if(e.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let n=1;for(let t of e){if(!Number.isInteger(t))throw new TypeError(`Invalid shape: ${t} is not an integer`);if(t<0||t>2147483647)throw new TypeError(`Invalid shape: length ${t} is not allowed`);n*=t}return n}static flattenShape(e,n){n<0&&(n+=e.length);let t=e.reduce((s,a)=>s*a,1),o=e.slice(n).reduce((s,a)=>s*a,1);return[t/o,o]}static squeezeShape(e,n){let t=new Array;n=r.normalizeAxes(n,e.length);for(let o=0;o<e.length;o++){let i=n.indexOf(o)>=0;if(i&&e[o]!==1)throw new Error("squeeze an axis of size different than 1");(n.length===0&&e[o]>1||n.length>0&&!i)&&t.push(e[o])}return t}static unsqueezeShape(e,n){let t=new Array(e.length+n.length);t.fill(0);for(let i=0;i<n.length;i++){let s=r.normalizeAxis(n[i],t.length);if(s>=t.length)throw new Error("'axes' has an out of range axis");if(t[s]!==0)throw new Error("'axes' has a duplicate axis");t[s]=1}let o=0;for(let i=0;i<t.length;i++)t[i]===0&&(t[i]=e[o++]);if(o!==e.length)throw new Error("the unsqueezed dimension could not be established");return t}},fo=class r{static splitShape(e,n,t,o){if(t.length===0){if(!o)throw new Error("need to know number of outputs when the 'split' attribute is not specified");r.determineSplit(e[n],o,t)}let i=[],s=[0];for(let a=0;a<t.length;++a){a!==0&&s.push(s[a-1]+t[a-1]);let u=e.slice();u[n]=t[a],i.push(u)}return[i,s]}static determineSplit(e,n,t){if(e%n!==0)throw new Error("cannot split tensor to equal sized parts");for(let o=0;o<n;++o)t.push(e/n)}},un=class r{static adjustPoolAttributes(e,n,t,o,i,s){if(!e&&t.length!==n.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let a=0;a<n.length-2;a++)a>=t.length?t.push(n[a+2]):t[a]=n[a+2];for(let a=0;a<t.length;a++)if(a<o.length){if(o[a]<0)throw new Error("strides should be greater than or equal to 1")}else o.push(1);for(let a=0;a<t.length;a++)if(a<i.length){if(i[a]<0)throw new Error("dilations should be greater than or equal to 1")}else i.push(1);for(let a=0;a<t.length*2;a++)if(a<s.length){if(s[a]<0)throw new Error("pad should be greater than or equal to 1")}else s.push(0);for(let a=0;a<t.length;a++){if(t[a]<=0)throw new Error("kernel shapes need to be greater than 0");if(s[a]>=t[a]||s[a+t.length]>=t[a])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,n,t,o,i,s){if(s){if(i.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(o.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let a=0;a<e.length-2;a++)r.adjustPadAndReturnShape(e[a+2],n[a],t[a],o[a],i,a,a+e.length-2,s)}}static computePoolOutputShape(e,n,t,o,i,s,a){if(n.length<=0)throw new Error("input shape must be of size greater than 0");let u=[n[0],n[1]];return r.computeShapeHelper(e,n,u,t,o,i,s,a),u}static computeConvOutputShape(e,n,t,o,i,s,a){if(e.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let u=[e[0],n[0]];return r.computeShapeHelper(!1,e,u,t,o,i,s,a),u}static computeShapeHelper(e,n,t,o,i,s,a,u){if(e)for(let l=0;l<n.length-2;l++)t.push(1);else for(let l=0;l<n.length-2;l++)t.push(r.adjustPadAndReturnShape(n[l+2],o[l],i[l],s[l],a,l,l+n.length-2,u))}static adjustPadAndReturnShape(e,n,t,o,i,s,a,u){let l=t*(o-1)+1;if(u&&u!=="NOTSET")switch(u){case"VALID":return i[s]=0,i[a]=0,Math.floor((e-l)/n+1);case"SAME_LOWER":case"SAME_UPPER":if(t!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let h=((e+n-1)/n-1)*n+o-e;return i[s]=Math.floor(u==="SAME_LOWER"?(h+1)/2:h/2),i[a]=h-i[s],Math.floor((e+h-o)/n+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((e+i[s]+i[a]-l)/n+1)}},ln=-34028234663852886e22,cn=34028234663852886e22});function R0(r){switch(r){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${r}`)}}function rd(r){switch(r){case Se.onnx.TensorProto.DataType.UINT8:case Se.onnx.TensorProto.DataType.INT8:case Se.onnx.TensorProto.DataType.BOOL:return 1;case Se.onnx.TensorProto.DataType.UINT16:case Se.onnx.TensorProto.DataType.INT16:return 2;case Se.onnx.TensorProto.DataType.FLOAT:case Se.onnx.TensorProto.DataType.INT32:case Se.onnx.TensorProto.DataType.UINT32:return 4;case Se.onnx.TensorProto.DataType.INT64:case Se.onnx.TensorProto.DataType.DOUBLE:case Se.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${Se.onnx.TensorProto.DataType[r]}`)}}function M0(r,e){return new(id(e))(r)}function id(r){switch(r){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function ns(r,e){if(e===Se.onnx.TensorProto.DataType.INT64||e===rs.TensorDataType.INT64){if(r.greaterThanOrEqual(2147483648)||r.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else if(e===Se.onnx.TensorProto.DataType.UINT32||e===rs.TensorDataType.UINT32||e===Se.onnx.TensorProto.DataType.UINT64||e===rs.TensorDataType.UINT64){if(r.greaterThanOrEqual(4294967296)||r.lessThan(0))throw new TypeError("uint64 is not supported")}else throw new TypeError(`not a LONG type: ${Se.onnx.TensorProto.DataType[e]}`);return r.toNumber()}function nd(r,e,n){switch(e){case Se.onnx.TensorProto.DataType.BOOL:case Se.onnx.TensorProto.DataType.UINT8:return r.getUint8(n);case Se.onnx.TensorProto.DataType.INT8:return r.getInt8(n);case Se.onnx.TensorProto.DataType.UINT16:return r.getUint16(n,!0);case Se.onnx.TensorProto.DataType.INT16:return r.getInt16(n,!0);case Se.onnx.TensorProto.DataType.FLOAT:return r.getFloat32(n,!0);case Se.onnx.TensorProto.DataType.INT32:return r.getInt32(n,!0);case Se.onnx.TensorProto.DataType.UINT32:return r.getUint32(n,!0);case Se.onnx.TensorProto.DataType.INT64:return ns(Or.fromBits(r.getUint32(n,!0),r.getUint32(n+4,!0),!1),e);case Se.onnx.TensorProto.DataType.DOUBLE:return r.getFloat64(n,!0);case Se.onnx.TensorProto.DataType.UINT64:return ns(Or.fromBits(r.getUint32(n,!0),r.getUint32(n+4,!0),!0),e);default:throw new Error(`cannot read from DataView for type ${Se.onnx.TensorProto.DataType[e]}`)}}var od,Se,rs,dt,dn=M(()=>{"use strict";od=On(ql());Ga();so();Se=On(Dn());Fe();rs=ie.experimental.fbs,dt=class r{constructor(e,n,t,o,i,s=od.Guid.create()){this.dims=e;this.type=n;this.dataProvider=t;this.asyncDataProvider=o;this.cache=i;this.dataId=s;this.size=te.validateDimsAndCalcSize(e);let a=this.size,u=t===void 0&&o===void 0&&i===void 0;if(i!==void 0&&i.length!==a)throw new RangeError("Input dims doesn't match data length.");if(n==="string"){if(i!==void 0&&(!Array.isArray(i)||!i.every(l=>typeof l=="string")))throw new TypeError("cache should be a string array");u&&(this.cache=new Array(a))}else{if(i!==void 0){let l=id(n);if(!(i instanceof l))throw new TypeError(`cache should be type ${l.name}`)}if(u){let l=new ArrayBuffer(a*R0(n));this.cache=M0(l,n)}}}get data(){if(this.cache===void 0){let e=this.dataProvider(this.dataId);if(e.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=e}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(e){return this.data[te.indicesToOffset(e,this.strides)]}set(e,n){this.data[te.indicesToOffset(e,this.strides)]=n}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=te.computeStrides(this.dims)),this._strides}static fromProto(e){if(!e)throw new Error("cannot construct Value from an empty tensor");let n=yt.tensorDataTypeFromProto(e.dataType),t=yt.tensorDimsFromProto(e.dims),o=new r(t,n);if(n==="string")e.stringData.forEach((i,s)=>{o.data[s]=po(i)});else if(e.rawData&&typeof e.rawData.byteLength=="number"&&e.rawData.byteLength>0){let i=o.data,s=new DataView(e.rawData.buffer,e.rawData.byteOffset,e.rawData.byteLength),a=rd(e.dataType),u=e.rawData.byteLength/a;if(e.rawData.byteLength%a!==0)throw new Error("invalid buffer length");if(i.length!==u)throw new Error("buffer length mismatch");for(let l=0;l<u;l++){let c=nd(s,e.dataType,l*a);i[l]=c}}else{let i;switch(e.dataType){case Se.onnx.TensorProto.DataType.FLOAT:i=e.floatData;break;case Se.onnx.TensorProto.DataType.INT32:case Se.onnx.TensorProto.DataType.INT16:case Se.onnx.TensorProto.DataType.UINT16:case Se.onnx.TensorProto.DataType.INT8:case Se.onnx.TensorProto.DataType.UINT8:case Se.onnx.TensorProto.DataType.BOOL:i=e.int32Data;break;case Se.onnx.TensorProto.DataType.INT64:i=e.int64Data;break;case Se.onnx.TensorProto.DataType.DOUBLE:i=e.doubleData;break;case Se.onnx.TensorProto.DataType.UINT32:case Se.onnx.TensorProto.DataType.UINT64:i=e.uint64Data;break;default:throw new Error("unspecific error")}if(i==null)throw new Error("failed to populate data from a tensorproto value");let s=o.data;if(s.length!==i.length)throw new Error("array length mismatch");for(let a=0;a<i.length;a++){let u=i[a];Or.isLong(u)?s[a]=ns(u,e.dataType):s[a]=u}}return o}static fromData(e,n,t){return new r(n,t,void 0,void 0,e)}static fromOrtTensor(e){if(!e)throw new Error("cannot construct Value from an empty tensor");let n=yt.tensorDimsFromORTFormat(e),t=yt.tensorDataTypeFromProto(e.dataType()),o=new r(n,t);if(t==="string")for(let i=0;i<e.stringDataLength();i++)o.data[i]=e.stringData(i);else if(e.rawDataArray()&&typeof e.rawDataLength()=="number"&&e.rawDataLength()>0){let i=o.data,s=new DataView(e.rawDataArray().buffer,e.rawDataArray().byteOffset,e.rawDataLength()),a=rd(e.dataType()),u=e.rawDataLength()/a;if(e.rawDataLength()%a!==0)throw new Error("invalid buffer length");if(i.length!==u)throw new Error("buffer length mismatch");for(let l=0;l<u;l++){let c=nd(s,e.dataType(),l*a);i[l]=c}}return o}}});function de(r){return r===1?L0:N0}function ad(r){let e=de(r);return`${e.version}
      precision highp float;
      ${e.attribute} vec3 position;
      ${e.attribute} vec2 textureCoord;

      ${e.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`}function sd(r){let e=de(r);return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFrag} vec2 TexCoords;
    ${e.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `}function ud(r,e){let n=de(r);return`
  void main() {
    int indices[${e}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${n.output} = result;
  }
  `}var L0,N0,Qe=M(()=>{"use strict";L0={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},N0={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"}});var Ee=M(()=>{"use strict"});async function os(r,e=t=>0,n){return new Promise((t,o)=>{let i=0,s=()=>{if(r()){t();return}i++;let a=e(i);if(n!=null&&i>=n){o();return}setTimeout(s,a)};s()})}function gi(r){return kn(typeof r<"u"&&r.length!==0,()=>"empty string found for sampler name"),"get"+r.charAt(0).toUpperCase()+r.slice(1)}function ld(r){return kn(typeof r<"u"&&r.length!==0,()=>"empty string found for sampler name"),"get"+r.charAt(0).toUpperCase()+r.slice(1)+"AtOutCoords"}function Bn(r,e){let n=JSON.parse(JSON.stringify(r));return n=e,n}function Rn(r,e){return e.map(n=>r[n]).join(", ")}function St(r){if(r<=1)return"int";if(r===2)return"ivec2";if(r===3)return"ivec3";if(r===4)return"ivec4";if(r===5)return"ivec5";if(r===6)return"ivec6";throw Error(`GPU for rank ${r} is not yet supported`)}function tr(r=6){return["x","y","z","w","u","v"].slice(0,r)}var dr=M(()=>{"use strict";Fe()});function F0(r,e){return tr(e).map(n=>`${r}.${n}`)}function Mn(r,e){return e===1?[r]:F0(r,e)}function fr(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}var fn=M(()=>{"use strict";dr()});function G0(r,e,n){if(r===0)return"false";if(r===1)return`rc > ${e[0]}`;let t="";for(let o=r-2;o<r;o++)t+=`${n[o]} >= ${e[o-r+2]}`,o<r-1&&(t+="||");return t}function V0(r,e){let n=r.length;if(n===0)return"getA(), 0, 0, 0";if(n===1)return`getA(rc),
            rc + 1 >= ${r[0]} ? 0. : getA(rc + 1),
            0, 0`;let t="r, c",o="r, cp1",i="rp1, c",s="rp1, cp1",a="";if(n>2)for(let u=0;u<n-2;++u)a=a+`${e[u]},`;return`getA(${a}${t}),
          rEdge ? 0. : getA(${a}${i}),
          cEdge ? 0. : getA(${a}${o}),
          rEdge || cEdge ? 0. : getA(${a}${s})`}function W0(r,e,n,t){return r===0||r===1?"":`
    int r = ${e[r-2]};
    int c = ${e[r-1]};
    int rp1 = ${e[r-2]} + 1;
    int cp1 = ${e[r-1]} + 1;
    bool rEdge = rp1 >= ${t};
    bool cEdge = cp1 >= ${n};
    `}var cd,z0,dd,fd=M(()=>{"use strict";Qe();Ee();dr();fn();cd={name:"pack",inputNames:["A"],inputTypes:[1]},z0=(r,e)=>{let n=de(r.session.backend.glContext.version),t=e.dims,o=t.length,i=e.dims.length,s=St(i),a=Mn("rc",i),u=W0(i,a,t[t.length-2],t[t.length-1]),l;o===0?l=[1,1]:o===1?l=[t[0],1]:l=[t[i-1],t[i-2]];let c=G0(i,l,a),h=V0(t,a),m=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${c}) {
            ${n.output} = vec4(0);
          } else {
            ${u}

            ${n.output} = vec4(${h});
          }
        }
      `;return{...cd,hasMain:!0,output:{dims:e.dims,type:e.type,textureType:2},shaderSource:m}},dd=(r,e)=>({...cd,get:()=>z0(r,e)})});function is(r){if(r.length===0)return[1,1,1];let e=1;for(let n=0;n<r.length-2;++n)e*=r[n];return[e,r.length>1?r[r.length-2]:1,r[r.length-1]]}function hd(r,e){let n=!1;return r.length===0||e.length===0?n=!0:r.length<2||e.length<2?n=r[r.length-1]===e[e.length-1]:n=r[r.length-1]===e[e.length-1]&&r[r.length-2]===e[e.length-2],n}function j0(r){let e=te.computeStrides(r),n=["b","r","c"],t="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e.map((i,s)=>{let a=`int ${n[s]} = ${t} / ${i}`,u=s===e.length-1?`int ${n[s+1]} = ${t} - ${n[s]} * ${i}`:`index -= ${n[s]} * ${i}`;return`${a}; ${u};`}).join("")}
      return ivec3(b, r, c);
    }
  `}function q0(r){let e=te.computeStrides(r);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${e[0]} + coords.z * ${e[1]} + coords.y;
  }
`}var U0,H0,pd,md=M(()=>{"use strict";Fe();Qe();Ee();fn();U0=r=>({name:"Reshape (packed)",inputTypes:[2],inputNames:["A"],cacheHint:`${r}`}),H0=(r,e,n,t)=>{let o=e.dims,i=t,s="";for(let l=0;l<4;l++){let c="";switch(l){case 0:c="outputCoords = rc;";break;case 1:c="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:c="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:c="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}s+=`
        ${c}
        ${l>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${l}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${l>0?"}":""}
      `}let a=de(r.session.backend.glContext.version),u=`
      ${j0(o)}
      ${q0(i)}
      ${fr()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${i[2]};
        int cols = ${i[1]};

        ${s}
        ${a.output} = result;
      }
    `;return{...n,output:{dims:i,type:e.type,textureType:2},shaderSource:u,hasMain:!0}},pd=(r,e,n)=>{let t=U0(n);return{...t,get:()=>H0(r,e,t,n)}}});var as,gd=M(()=>{"use strict";Qe();Ee();as=(r,e)=>{let n=e.shape,t=de(r.session.backend.glContext.version),o=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${t.texture2D}(X,TexCoords).r;
      ${t.output} = encodeAsUint8(value);
    }`,i={name:"Uint8Encode",inputTypes:[0],inputNames:["X"],output:{dims:n,type:e.tensor.type,textureType:3},shaderSource:o,hasMain:!0};return r.executeProgram(i,[e.tensor])}});function X0(r,e){if(r===1)return"rc";let n="";for(let t=0;t<r;t++)n+=e[t],t<r-1&&(n+=",");return n}var bd,K0,yd,vd=M(()=>{"use strict";Qe();Ee();dr();fn();bd={name:"unpack",inputNames:["A"],inputTypes:[2]},K0=(r,e)=>{let n=e.dims.length,t=Mn("rc",n),o=t.slice(-2),i=St(n),s=fr(),u=e.dims.length===0?"":X0(n,t),l=n<=1?"rc":`vec2(${o.join(",")})`,c=de(r.session.backend.glContext.version),h=`
    ${s}
    void main() {
      ${i} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${u});

       ${c.output} = vec4(getChannel(packedInput, ${l}), 0, 0, 0);
     }
   `;return{...bd,hasMain:!0,output:{dims:e.dims,type:e.type,textureType:0},shaderSource:h}},yd=(r,e)=>({...bd,get:()=>K0(r,e)})});var bi,ho,yi,mo=M(()=>{"use strict";Nt();bi=class{constructor(e,n=1){if(n===1)this.internalFormat=e.R32F,this.format=e.RED,this.textureType=e.FLOAT,this.channelSize=n;else if(n===4)this.internalFormat=e.RGBA32F,this.format=e.RGBA,this.textureType=e.FLOAT,this.channelSize=n;else throw new Error(`Invalid number of channels: ${n}`)}encode(e,n){let t,o;return e.constructor!==Float32Array&&(ze.warning("Encoder","data was not of type Float32; creating new Float32Array"),o=new Float32Array(e)),n*this.channelSize>e.length?(ze.warning("Encoder","Source data too small. Allocating larger array"),o=e,t=this.allocate(n*this.channelSize),o.forEach((i,s)=>t[s]=i)):(o=e,t=o),t}allocate(e){return new Float32Array(e*4)}decode(e,n){return this.channelSize===1?e.filter((o,i)=>i%4===0).subarray(0,n):e.subarray(0,n)}},ho=class{constructor(e,n=1,t){if(n!==1&&n!==4)throw new Error(`Invalid number of channels: ${n}`);this.internalFormat=e.RGBA,this.format=e.RGBA,this.channelSize=n,this.textureType=t||e.FLOAT}encode(e,n){let t=e;return this.channelSize===1&&(ze.verbose("Encoder","Exploding into a larger array"),t=this.allocate(n),e.forEach((o,i)=>t[i*4]=o)),t}allocate(e){return new Float32Array(e*4)}decode(e,n){return this.channelSize===1?e.filter((o,i)=>i%4===0).subarray(0,n):e.subarray(0,n)}},yi=class{constructor(e,n=1){this.channelSize=4;if(n===1)this.internalFormat=e.ALPHA,this.format=e.ALPHA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=n;else if(n===4)this.internalFormat=e.RGBA,this.format=e.RGBA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=n;else throw new Error(`Invalid number of channels: ${n}`)}encode(e,n){return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}allocate(e){return new Uint8Array(e*this.channelSize)}decode(e,n){if(e instanceof Uint8Array)return e.subarray(0,n);throw new Error(`Invalid array type: ${e.constructor}`)}}});var go,xd,ss,wd=M(()=>{"use strict";Fe();Ee();go=(r,e,n)=>{let t=n===0||n===1?1:4,o=n===2,i=n===1||n===2,s=n===4?e.length-1:void 0,a=n===4?e.map((u,l)=>l===e.length-1?u*4:u):void 0;return ss(r,e,t,a,{isPacked:o,reverseWH:i,breakAxis:s})},xd=(r,e,n)=>{let t=go(r,e,n);return[t.width,t.height]},ss=(r,e,n=1,t,o)=>{let i=!!(o&&o.isPacked),[s,a]=r.computeTextureWH(i&&t||e,o),u=e.length,l=e.slice(0);if(u===0&&(l=[1]),n===1)t=e;else if(i){if(n!==4)throw new Error("a packed texture must be 4-channel");t=e,u>0&&(l[u-1]=Math.ceil(l[u-1]/2)),u>1&&(l[u-2]=Math.ceil(l[u-2]/2))}else if(!t)throw new Error("Unpacked shape is needed when using channels > 1");return{width:s,height:a,channels:n,isPacked:i,shape:l,strides:te.computeStrides(l),unpackedShape:t,reversedWH:o&&o.reverseWH}}});var J0,vi,$d=M(()=>{"use strict";Nt();dn();Fe();fd();md();gd();vd();mo();wd();Ee();J0=(r,e)=>{let n=e.map(o=>`${o.unpackedShape.join(",")};${o.width}x${o.height}`).join("_"),t=r.name;return r.cacheHint&&(t+="["+r.cacheHint+"]"),t+=":"+n,t},vi=class{constructor(e){this.session=e;this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(e,n){return xd(this.session.layoutStrategy,e,n)}executeProgram(e,n){if(n.length<e.inputNames.length)throw new Error(`Input size mustn't be less than ${e.inputNames.length}.`);if(e.inputNames.length!==e.inputTypes.length)throw new Error("input names size does not match input types");let t=[];for(let l=0;l<e.inputNames.length;++l)t[l]=this.getOrCreateTextureData(n[l],e.inputTypes[l]);let o=J0(e,t),i=this.session.programManager.getArtifact(o),s=i?i.programInfo:typeof e.get=="function"?e.get():e,a=go(this.session.layoutStrategy,s.output.dims,s.output.textureType),u=this.createTextureData(a,s.output.type);return i||(i=this.session.programManager.build(s,t,u),this.session.programManager.setArtifact(o,i)),this.runProgram(i,t,u),u}run(e,n){return this.executeProgram(e,n).tensor}runProgram(e,n,t){for(let o=0;o<n.length;++o)if(!!n[o].isPacked!=(e.programInfo.inputTypes[o]===2))throw new Error(`input[${o}] property packed inconsistent`);if(!!t.isPacked!=(e.programInfo.output.textureType===2))throw new Error("output property packed inconsistent");this.session.programManager.run(e,n,t)}getOrCreateTextureData(e,n){let t=this.getTextureData(e.dataId,n===2);if(!t&&(t=this.getTextureData(e.dataId,n!==2),t))return n===2?this.pack(t):this.unpack(t);if(!t){let o=go(this.session.layoutStrategy,e.dims,n);if(n===4){let a=e.dims;if(a.length===4){let u=[a[0],Math.ceil(a[1]*a[2]*a[3]/4)],l=go(this.session.layoutStrategy,u,n),c=e.numberData;if(a[1]*a[2]*a[3]%4!==0){let h=a[0],m=a[1]*a[2]*a[3],b=Math.ceil(m*1/4)*4,x=h*b;c=new Float32Array(x);for(let y=0;y<h;++y){let T=y*m,E=y*b+y%1*m;c.set(e.numberData.subarray(T,T+m),E)}}return this.createTextureData(l,e.type,c,e,1)}}if(n===2){let i=ss(this.session.layoutStrategy,e.dims,1,[],{reverseWH:!0}),s=this.createTextureData(i,e.type,e.numberData,e,1);t=this.pack(s)}else t=this.createTextureData(o,e.type,e.numberData,e,1)}return t}createTextureDataFromLayoutBindTensor(e,n,t,o){return this.createTextureData(e,n,t,o,1)}createTextureData(e,n,t,o,i){ze.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(e)}]`);let s=this.session.textureManager.createTextureFromLayout(n,e,t,i);return this.createTextureDataFromTexture(e,n,s,o)}reshapeUnpacked(e,n){let t=this.getOrCreateTextureData(e,0),o={channels:t.channels,height:t.height,width:t.width,shape:n.length!==0?n:[1],strides:te.computeStrides(n),unpackedShape:n};return this.createTextureDataFromTexture(o,e.type,t.texture).tensor}reshapePacked(e,n){let t=this.getOrCreateTextureData(e,2);if(hd(e.dims,n)){let l={channels:t.channels,height:t.height,width:t.width,shape:n.length!==0?n:[1],strides:te.computeStrides(n),unpackedShape:n,isPacked:!0};return this.createTextureDataFromTexture(l,e.type,t.texture).tensor}let o=is(e.dims),i=is(n),s=this.reshapePacked(e,o),a=this.run(pd(this,s,i),[s]);return this.reshapePacked(a,n)}cast(e,n){let t=this.getOrCreateTextureData(e,0);return this.createTextureDataFromTexture(t,n,t.texture).tensor}createTextureDataFromTexture(e,n,t,o,i){let s={...e,tensor:o||new dt(e.unpackedShape,n,a=>this.readTexture(s),async a=>this.readTextureAsync(s),void 0,i),texture:t};return this.setTextureData(s.tensor.dataId,s,e.isPacked),s}getTextureData(e,n=!1){return this.session.isInitializer(e)?this.session.getTextureData(e,n):n?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,n,t=!1){this.session.isInitializer(e)?this.session.setTextureData(e,n,t):(t?this.packedTextureDataCache:this.unpackedTextureDataCache).set(e,n)}isTextureLayoutCached(e,n=!1){return!!this.getTextureData(e.dataId,n)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.unpackedTextureDataCache=new Map}readTexture(e){return e.isPacked?this.readTexture(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat(as(this,e))}async readTextureAsync(e){return e.isPacked?this.readTextureAsync(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat(as(this,e))}pack(e){return this.executeProgram(dd(this,e.tensor),[e.tensor])}unpack(e){return this.executeProgram(yd(this,e.tensor),[e.tensor])}}});var us,Te,mt=M(()=>{"use strict";us=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this._cacheKey}},Te=r=>new us(r)});var Sd,Id,Ad,Z0,Q0,_d=M(()=>{"use strict";mt();Qe();Ee();Sd={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[0,0,0,0,0]},Id=(r,e,n)=>(Q0(e),[r.run({...Sd,cacheHint:n.cacheKey,get:()=>Z0(r,e,n)},e)]),Ad=r=>{let e=r.attributes.getFloat("epsilon",1e-5),n=r.attributes.getFloat("momentum",.9),t=r.attributes.getInt("spatial",1);return Te({epsilon:e,momentum:n,spatial:t})},Z0=(r,e,n)=>{let t=de(r.session.backend.glContext.version),o=e[0].dims.length,[i,s]=r.calculateTextureWidthAndHeight(e[1].dims,0),a=`
  float process(int[${o}] indices) {
    vec2 position = offsetToCoords(indices[1], ${i}, ${s});
    float scale = getColorAsFloat(${t.texture2D}(Scale, position));
    float mean = getColorAsFloat(${t.texture2D}(Mean, position));
    float variance = getColorAsFloat(${t.texture2D}(Variance, position));
    float b = getColorAsFloat(${t.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n.epsilon})) ) + b;
  }`;return{...Sd,output:{dims:e[0].dims,type:e[0].type,textureType:0},shaderSource:a}},Q0=r=>{if(!r||r.length!==5)throw new Error("BatchNormalization requires 5 inputs.");let e=r[0],n=r[1],t=r[2],o=r[3],i=r[4];if(e.dims.length<3||n.dims.length!==1||t.dims.length!==1||o.dims.length!==1||i.dims.length!==1)throw new Error("invalid input shape.");if(n.dims[0]!==e.dims[1]||t.dims[0]!==e.dims[1]||o.dims[0]!==e.dims[1]||i.dims[0]!==e.dims[1])throw new Error("invalid input shape.");if(e.type!=="float32"&&e.type!=="float64"||n.type!=="float32"&&n.type!=="float64"||t.type!=="float32"&&t.type!=="float64"||o.type!=="float32"&&o.type!=="float64"||i.type!=="float32"&&i.type!=="float64")throw new Error("invalid input tensor types.")}});var xi,Vt,Z,bo,wi,Cr=M(()=>{"use strict";xi=class{constructor(e,n,t,o){this.glContext=e;this.programInfo=n;this.inputTextureLayouts=t;this.outputTextureLayout=o}},Vt=class{constructor(e){this.context=e}},Z=class{constructor(e,n){this.routineBody=e;this.dependencies=n}},bo=class{constructor(e,n,t){this.name=e;t?this.dependencies=t:this.dependencies=[],n&&(this.routineBody=n)}addDependency(e){e&&this.dependencies.push(e)}},wi=class{static returnOrderedNodes(e){if(!e||e.length===0)return[];if(e.length===1)return e;let n=new Set,t=new Set,o=new Array;return this.createOrderedNodes(e,n,t,o),o}static createOrderedNodes(e,n,t,o){for(let i=0;i<e.length;++i)this.dfsTraverse(e[i],n,t,o)}static dfsTraverse(e,n,t,o){if(!e||t.has(e.name))return;if(n.has(e.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");n.add(e.name);let i=e.dependencies;if(i&&i.length>0)for(let s=0;s<i.length;++s)this.dfsTraverse(i[s],n,t,o);o.push(e),t.add(e.name),n.delete(e.name)}}});function tv(){let r="add_";return{body:`
  float ${r}(float a, float b) {
    return a + b;
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:r,type:0}}function rv(){let r="div_";return{body:`
  float ${r}(float a, float b) {
    return a / b;
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:r,type:0}}function nv(){let r="mul_";return{body:`
  float ${r}(float a, float b) {
    return a * b;
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:r,type:0}}function ov(){let r="sub_";return{body:`
  float ${r}(float a, float b) {
    return a - b;
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:r,type:0}}function iv(){let r="equal_";return{body:`
  float ${r}(float a, float b) {
    return float(a == b);
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:r,type:0}}function av(){let r="greater_";return{body:`
  float ${r}(float a, float b) {
    return float(a > b);
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:r,type:0}}function sv(){let r="less_";return{body:`
  float ${r}(float a, float b) {
    return float(a < b);
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:r,type:0}}function uv(){let r="and_";return{body:`
  float ${r}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:r,type:0}}function lv(){let r="or_";return{body:`
  float ${r}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:r,type:0}}function cv(){let r="xor_";return{body:`
  float ${r}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:r,type:0}}function dv(){return pv("pow")}function fv(){let r="prelu_";return{body:`
  float ${r}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:r,type:0}}function pv(r){let e=`${r}_`;return{body:`
  float ${e}(float a, float b) {
    return ${r}(a, b);
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return ${r}(v1, v2);
  }
  `,name:e,type:0}}var Wt,hv,Od,Cd,Ed,Pd,Dd,kd,Bd,Rd,Md,Ld,Nd,Fd,zd=M(()=>{"use strict";Fe();Cr();Qe();Ee();Wt=(r,e,n,t=e[0].type,o)=>{let i=r.session.pack?2:0;return{name:n.name,inputNames:["A","B"],inputTypes:[i,i],cacheHint:o,get:()=>hv(r,e,n,t)}},hv=(r,e,n,t=e[0].type)=>{let o=r.session.pack?2:0,i=!te.areEqual(e[0].dims,e[1].dims),s=e[0].dims,a=r.session.pack;if(i){let c=$t.calcShape(e[0].dims,e[1].dims,!1);if(!c)throw new Error("Can't perform binary op on the given tensors");s=c;let h=s.length,m=e[0].dims.length!==0?e[0].dims.length:1,b=e[1].dims.length!==0?e[1].dims.length:1,x=e[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",y=e[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",T=de(r.session.backend.glContext.version),E=a?`
      ${n.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${n.name}(a, b);
        ${T.output} = result;
      }`:`
      ${n.body}
      float process(int indices[${h}]) {
        int aindices[${m}];
        int bindices[${b}];
        ${x}
        ${y}
        return ${n.name}(_A(aindices), _B(bindices));
      }`;return{name:n.name,inputNames:["A","B"],inputTypes:[o,o],output:{dims:s,type:t,textureType:o},shaderSource:E,hasMain:a}}let u=de(r.session.backend.glContext.version),l=`
    ${n.body}
    void main() {
      vec4 v1 = ${u.texture2D}(A, TexCoords);
      vec4 v2 = ${u.texture2D}(B, TexCoords);
      vec4 result = ${n.name}(v1, v2);
      ${u.output} = result;
    }
    `;return{name:n.name,inputNames:["A","B"],inputTypes:[o,o],output:{dims:e[0].dims,type:t,textureType:o},shaderSource:l,hasMain:!0}},Od=(r,e)=>[r.run(Wt(r,e,tv()),e)],Cd=(r,e)=>[r.run(Wt(r,e,uv(),"bool"),e)],Ed=(r,e)=>[r.run(Wt(r,e,rv()),e)],Pd=(r,e)=>[r.run(Wt(r,e,iv(),"bool"),e)],Dd=(r,e)=>[r.run(Wt(r,e,av(),"bool"),e)],kd=(r,e)=>[r.run(Wt(r,e,sv(),"bool"),e)],Bd=(r,e)=>[r.run(Wt(r,e,nv()),e)],Rd=(r,e)=>[r.run(Wt(r,e,lv(),"bool"),e)],Md=(r,e)=>[r.run(Wt(r,e,dv()),e)],Ld=(r,e)=>[r.run(Wt(r,e,fv()),e)],Nd=(r,e)=>[r.run(Wt(r,e,ov()),e)],Fd=(r,e)=>[r.run(Wt(r,e,cv(),"bool"),e)]});var Gd,Vd,gv,Wd=M(()=>{"use strict";Fe();Gd=(r,e,n)=>(gv(e),[r.cast(e[0],n)]),Vd=r=>yt.tensorDataTypeFromProto(r.attributes.getInt("to")),gv=r=>{if(!r||r.length!==1)throw new Error("Cast requires 1 input.");if(r[0].type==="string")throw new Error("Invalid input type.")}});var bv,yv,Ud,Ti,Hd=M(()=>{"use strict";Qe();Ee();dr();fn();bv=(r,e)=>({name:"Concat (packed)",inputNames:Array.from({length:r},(n,t)=>`X${t}`),inputTypes:Array(r).fill(2),cacheHint:e}),yv=(r,e,n,t)=>{let o=n[0].dims.slice();if(t>=o.length||t<-1*o.length)throw new Error("axis specified for concat doesn't match input dimensionality");t<0&&(t=o.length+t);let i=o.slice(0);for(let z=1;z<n.length;z++){let F=n[z].dims.slice();for(let V=0;V<o.length;V++)if(V===t)i[t]+=F[V];else if(o[V]!==F[V])throw new Error("non concat dimensions must match")}let s=i.length,a=Mn("coords",s),u=St(s),l=fr(),c=n.map(z=>z.dims),h=tr(s),m=new Array(c.length-1);m[0]=c[0][t];for(let z=1;z<m.length;z++)m[z]=m[z-1]+c[z][t];let b=h[t],x=h.slice(-2),y=h.join(),T=`if (${b} < ${m[0]}) {
        return getChannel(
            getX0(${y}), vec2(${x.join()}));
        }`;for(let z=1;z<m.length;z++){let F=m[z-1];T+=`
            if (${b} < ${m[z]}  && ${b} >= ${m[z-1]}) {
              return getChannel(
                getX${z}(${Ti(h,b,F)}),
                vec2(${Ti(x,b,F)}));
            }`}let E=m.length,_=m[m.length-1];T+=`
            return getChannel(
              getX${E}(${Ti(h,b,_)}),
              vec2(${Ti(x,b,_)}));`;let C=de(r.session.backend.glContext.version),D=`
          ${l}
          float getValue(${h.map(z=>"int "+z)}) {
            ${T}
          }

          void main() {
            ${u} coords = getOutputCoords();
            int lastDim = coords.${h[s-1]};
            coords.${h[s-1]} = coords.${h[s-2]};
            coords.${h[s-2]} = lastDim;

            vec4 result = vec4(getValue(${a}), 0., 0., 0.);

            ${a[s-1]} = ${a[s-1]} + 1;
            if (${a[s-1]} < ${i[s-1]}) {
              result.g = getValue(${a});
            }

            ${a[s-2]} = ${a[s-2]} + 1;
            if (${a[s-2]} < ${i[s-2]}) {
              result.a = getValue(${a});
            }

            ${a[s-1]} = ${a[s-1]} - 1;
            if (${a[s-2]} < ${i[s-2]} &&
                ${a[s-1]} < ${i[s-1]}) {
              result.b = getValue(${a});
            }
            ${C.output} = result;
          }
        `;return{...e,output:{dims:i,type:n[0].type,textureType:2},shaderSource:D,hasMain:!0}},Ud=(r,e,n)=>{let t=bv(e.length,n.cacheKey);return{...t,get:()=>yv(r,t,e,n.axis)}},Ti=(r,e,n)=>{let t=r.indexOf(e);return r.map((i,s)=>s===t?`${i} - ${n}`:i).join()}});var jd,vv,xv,wv,qd,Tv,$v,Sv,Kd,Iv,Xd=M(()=>{"use strict";mt();Ee();Hd();jd=(r,e,n)=>(Iv(e),r.session.pack&&e[0].dims.length>1?[r.run(Ud(r,e,n),e)]:[r.run(wv(r,e,n),e)]),vv=(r,e)=>({name:"Concat",inputNames:Array.from({length:r},(n,t)=>`X${t}`),inputTypes:Array(r).fill(0),cacheHint:e}),xv=(r,e,n,t)=>{let o=n[0].dims.slice();if(t>=o.length||t<-1*o.length)throw new Error("axis specified for concat doesn't match input dimensionality");t<0&&(t=o.length+t);let i=o.slice(0);for(let b=1;b<n.length;b++){let x=n[b].dims.slice();for(let y=0;y<o.length;y++)if(y===t)i[t]+=x[y];else if(o[y]!==x[y])throw new Error("non concat dimensions must match")}let s=i.length,a=new Array(n.length),u=0;for(let b=0;b<a.length;++b)u+=n[b].dims[t],a[b]=u;let l="";n.length<5?l=qd(a):l=Tv(a);let c=$v(n.length,s),h=Sv(a),m=`
        ${c}
        ${h}
        ${l}
        float process(int indices[${s}]) {
          int textureIndex = getTextureWhereDataResides (indices[${t}]);

          if(textureIndex != 0) {
            indices[${t}] = indices[${t}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return{...e,output:{dims:i,type:n[0].type,textureType:0},shaderSource:m}},wv=(r,e,n)=>{let t=vv(e.length,n.cacheKey);return{...t,get:()=>xv(r,t,e,n.axis)}},qd=r=>`int getTextureWhereDataResides(int index) {
      ${r.map((n,t)=>`if(index<${n}) {return ${t};}
`).join("")}
    }`,Tv=r=>qd(r),$v=(r,e)=>{let n=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${e}]) {`];for(let t=0;t<r;++t)t===0?n.push(`	if (textureIndex == ${t}) { return _X${t}(indices); }`):t===r-1?n.push(`	else { return _X${t}(indices); }`):n.push(`	else if (textureIndex == ${t}) { return _X${t}(indices); }`);return n.push("	}"),n.join(`
`)},Sv=r=>{let e=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let n=0;n<r.length;++n)n===0?e.push(`	if (index == ${n}) { return ${r[n]}; }`):n===r.length-1?e.push(`	else { return ${r[n]}; }`):e.push(`	else if (index == ${n}) { return ${r[n]}; }`);return e.push("	}"),e.join(`
`)},Kd=r=>Te({axis:r.attributes.getInt("axis")}),Iv=r=>{if(!r||r.length<1)throw new Error("too few inputs");let e=r[0].type,n=r[0].dims.length;if(e==="string")throw new Error("string tensor is not supported yet");for(let t of r){if(t.type!==e)throw new Error("input tensors should be one type");if(t.dims.length!==n)throw new Error("input tensors should have the same shape")}}});function Av(){return Ut("abs")}function _v(){return Ut("acos")}function Ov(){return Ut("asin")}function Cv(){return Ut("atan")}function Ev(){return Ut("ceil")}function Pv(){return Ut("cos")}function Dv(r){let e="elu";return{body:`
  const float alpha = float(${r});

  float ${e}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${e}_(vec4 v) {
    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));
  }
  `,name:e,type:0}}function kv(){return Ut("exp")}function Bv(){return Ut("floor")}function ls(r,e){let n="clip";return{body:`
  const float min = float(${r});
  const float max = float(${e});

  float ${n}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${n}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:n,type:0}}function Rv(){let r="indentity";return{body:`
  float ${r}_(float a) {
    return a;
  }
  vec4 ${r}_(vec4 v) {
    return v;
  }
  `,name:r,type:0}}function Mv(r){let e="leakyRelu";return{body:`
  const float alpha = float(${r});

  float ${e}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${e}_(vec4 v) {
    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));
  }
  `,name:e,type:0}}function Lv(){return Ut("log")}function Nv(){let r="neg";return{body:`
  float ${r}_(float a) {
    return -a;
  }
  vec4 ${r}_(vec4 v) {
    return -v;
  }
  `,name:r,type:0}}function Fv(){let r="not";return{body:`
  float ${r}_(float a) {
    return float( ! bool(a) );
  }
  bool ${r}_(bool a) {
    return !a;
  }
  vec4 ${r}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${r}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:r,type:0}}function zv(){return Ut("sin")}function cs(){let r="relu";return{body:`
  float ${r}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${r}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:r,type:0}}function ds(){let r="sigmoid";return{body:`
  float ${r}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${r}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:r,type:0}}function Gv(){return Ut("sqrt")}function Vv(){return Ut("tan")}function Wv(){let r="tanh";return{body:`
  float ${r}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${r}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:r,type:0}}function Ut(r){return{body:`
  float ${r}_(float a) {
    return ${r}(a);
  }
  vec4 ${r}_(vec4 v) {
    return ${r}(v);
  }
  `,name:r,type:0}}var Uv,it,Yd,Jd,Zd,Qd,fs,ef,tf,Hv,rf,nf,of,af,sf,uf,ps,lf,cf,df,ff,pf,hf,mf,gf,bf,yf,vf,hs=M(()=>{"use strict";mt();Fe();Cr();Qe();Ee();Uv=(r,e,n,t)=>{let o=r.session.pack?2:0,i=de(r.session.backend.glContext.version);return{...e,output:{dims:n.dims,type:n.type,textureType:o},shaderSource:`
     ${t.body}
     void main() {
       vec4 v = ${i.texture2D}(A, TexCoords);
       v = ${t.name}_(v);
       ${i.output} = v;
     }
     `,hasMain:!0}},it=(r,e,n,t)=>{let o=r.session.pack?2:0,i={name:n.name,inputTypes:[o],inputNames:["A"],cacheHint:t};return{...i,get:()=>Uv(r,i,e,n)}},Yd=(r,e)=>[r.run(it(r,e[0],Av()),e)],Jd=(r,e)=>[r.run(it(r,e[0],_v()),e)],Zd=(r,e)=>[r.run(it(r,e[0],Ov()),e)],Qd=(r,e)=>[r.run(it(r,e[0],Cv()),e)],fs=(r,e,n)=>[r.run(it(r,e[0],ls(n.min,n.max),n.cacheKey),e)],ef=r=>Te({min:r.attributes.getFloat("min",ln),max:r.attributes.getFloat("max",cn)}),tf=(r,e)=>{let n=Hv(r,e);return fs(r,[e[0]],n)},Hv=(r,e)=>{if(e.length>=3&&(!r.session.isInitializer(e[1].dataId)||!r.session.isInitializer(e[2].dataId)))throw new Error("dynamic clip attributes are not allowed");let n=e.length>=3?e[1].numberData[0]:ln,t=e.length>=3?e[2].numberData[0]:cn;return Te({min:n,max:t})},rf=(r,e)=>[r.run(it(r,e[0],Ev()),e)],nf=(r,e)=>[r.run(it(r,e[0],Pv()),e)],of=(r,e,n)=>[r.run(it(r,e[0],Dv(n.alpha),n.cacheKey),e)],af=r=>Te({alpha:r.attributes.getFloat("alpha",1)}),sf=(r,e)=>[r.run(it(r,e[0],kv()),e)],uf=(r,e)=>[r.run(it(r,e[0],Bv()),e)],ps=(r,e)=>[r.run(it(r,e[0],Rv()),e)],lf=(r,e,n)=>[r.run(it(r,e[0],Mv(n.alpha),n.cacheKey),e)],cf=r=>Te({alpha:r.attributes.getFloat("alpha",.01)}),df=(r,e)=>[r.run(it(r,e[0],Lv()),e)],ff=(r,e)=>[r.run(it(r,e[0],Nv()),e)],pf=(r,e)=>[r.run(it(r,e[0],Fv()),e)],hf=(r,e)=>[r.run(it(r,e[0],cs()),e)],mf=(r,e)=>[r.run(it(r,e[0],ds()),e)],gf=(r,e)=>[r.run(it(r,e[0],zv()),e)],bf=(r,e)=>[r.run(it(r,e[0],Gv()),e)],yf=(r,e)=>[r.run(it(r,e[0],Vv()),e)],vf=(r,e)=>[r.run(it(r,e[0],Wv()),e)]});function pr(r){let e;switch(r.activation){case"Relu":e=cs();break;case"Sigmoid":e=ds();break;case"Clip":e=ls(r.clipMin,r.clipMax);break;default:return{activationFunction:"",applyActivation:""}}let n=e.name,t=e.body,o=`value = ${n}_(value);`;return{activationFunction:t,applyActivation:o}}var Ln,pn=M(()=>{"use strict";Fe();hs();Ln=r=>{let e=r.getString("activation","");if(e==="Clip"){let[n,t]=r.getFloats("activation_params",[ln,cn]);return{activation:e,clipMax:t,clipMin:n,activationCacheKey:`${e}:${n},${t}`}}return{activation:e,activationCacheKey:e}}});var qv,Kv,xf,wf=M(()=>{"use strict";Nt();Qe();Ee();$i();pn();qv=(r,e)=>({name:"GroupedConv",inputNames:r?["X","W","Bias"]:["X","W"],inputTypes:r?[0,0,0]:[0,0],cacheHint:e}),Kv=(r,e,n,t)=>{let i=e.length>2?"value += getBias(output_channel);":"",s=e[0].dims.slice(),a=e[1].dims.slice(),u=a[0]/t.group;ze.verbose("GroupedConv",`autpPad:${t.autoPad}, dilations:${t.dilations}, group:${t.group}, kernelShape:${t.kernelShape}, pads:${t.pads}, strides:${t.strides}`);let l=Nn(s,a,t.dilations,t.pads,t.strides),c=de(r.session.backend.glContext.version),{activationFunction:h,applyActivation:m}=pr(t),b=`
  const ivec2 strides = ivec2(${t.strides[0]}, ${t.strides[1]});
  const ivec2 pads = ivec2(${t.pads[0]}, ${t.pads[1]});
  ${h}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${u};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${a[1]}; wInChannel++) {
      int input_channel = group_id * ${a[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${a[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${t.dilations[0]};

        if (xHeight < 0 || xHeight >= ${s[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${a[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${t.dilations[1]};
          if (xWidth < 0 || xWidth >= ${s[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${i}
    ${m}
    ${c.output} = vec4(value, .0, .0, .0);
  }
`;return{...n,output:{dims:l,type:e[0].type,textureType:0},shaderSource:b,hasMain:!0}},xf=(r,e,n)=>{let t=qv(e.length>2,n.cacheKey);return{...t,get:()=>Kv(r,e,t,n)}}});var Xv,Yv,Tf,$f=M(()=>{"use strict";Qe();Ee();fn();Xv=r=>({name:"Im2Col (packed)",inputNames:["A"],inputTypes:[2],cacheHint:r}),Yv=(r,e,n,t,o,i)=>{let s=n.dims,a=t.dims,u=2,l=3,c=o.length,h=[a[1]*a[2]*a[3],o[2]*o[3]],m=a[2]*a[3],b=fr(),x=de(r.session.backend.glContext.version),y="";for(let E=0;E<=1;E++)for(let _=0;_<=1;_++)y+=`
            blockIndex = rc.x + ${_};
            pos = rc.y + ${E};

            if(blockIndex < ${h[1]} && pos < ${h[0]}) {
              offsetY = int(blockIndex / (${o[c-1]})) * ${i.strides[0]} -
                ${i.pads[0]};
              d0 = offsetY + ${i.dilations[0]} * (imod(pos, ${m}) / ${a[2]});

              if(d0 < ${s[u]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${o[c-1]}) * ${i.strides[1]} -
                  ${i.pads[1]};
                d1 = offsetX + ${i.dilations[1]} * imod(imod(pos, ${m}), ${a[2]});

                if(d1 < ${s[l]} && d1 >= 0) {

                  ch = int(float(pos)/ ${m}.);
                    innerDims = vec2(d0, d1);
                    result[${E*2+_}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;let T=`
      ${b}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${y}
          ${x.output} = result;
      }
            `;return{...e,output:{dims:h,type:n.type,textureType:2},shaderSource:T,hasMain:!0}},Tf=(r,e,n,t,o)=>{let i=Xv(o.cacheKey);return{...i,get:()=>Yv(r,i,e,n,t,o)}}});function Zv(r,e,n){let t=e[0].dims,o=e[1].dims,i=$t.calcShape(t,o,!0);if(!i)throw new Error("Can't use matmul on the given tensors");let s=St(i.length),a=tr(),{activationFunction:u,applyActivation:l}=pr(n),c=e.length>2,h=c?"value += getBiasForMatmul();":"",m=c?`${gs(s,a,e[2].dims,i,!1)}`:"",b=i.length,x=t.length,y=o.length,T=t[t.length-1],E=`
    ${u}
    ${m}
    float process(int indices[${b}]) {
        int a[${x}];
        int b[${y}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${T}; ++k) {
            a[${x-1}] = k;
            b[${y-2}] = k;
            value += _A(a) * _B(b);
        }
        ${h}
        ${l}
        return value;
    }`;return{...r,output:{dims:i,type:e[0].type,textureType:0},shaderSource:E}}function ms(r,e){let n=Jv(r.length>2,e.activationCacheKey);return{...n,get:()=>Zv(n,r,e)}}function gs(r,e,n,t,o){let i="",s=n.length,a=t.length,u=a-s;a<2&&s>0?i="coords":i=n.map((y,T)=>`coords.${e[T+u]}`).join(", ");let c=$t.getBroadcastDims(n,t).map(y=>`coords.${e[y+u]} = 0;`).join(`
`),m=te.size(n)===1,b="vec4(outputValue.xx, outputValue.yy)";return m&&(b="vec4(outputValue.x)"),o?`
vec4 getBiasForMatmul() {
  ${r} coords = getOutputCoords();
  ${c}
  vec4 outputValue = getBias(${i});
  return ${b};
}`:`
float getBiasForMatmul() {
  ${r} coords = getOutputCoords();
  ${c}
  return getBias(coords.x);
}`}var Sf,If,Jv,Qv,Si=M(()=>{"use strict";Fe();Ee();dr();pn();bs();Sf=(r,e,n)=>(Qv(e),r.session.pack?[r.run(Ii(r,e,n),e)]:[r.run(ms(e,n),e)]),If=r=>Ln(r.attributes),Jv=(r,e)=>({name:"MatMul",inputNames:r?["A","B","Bias"]:["A","B"],inputTypes:r?[0,0,0]:[0,0],cacheHint:e});Qv=r=>{if(!r||r.length!==2)throw new Error("MatMul requires 2 inputs.");if(r[0].dims[r[0].dims.length-1]!==r[1].dims[r[1].dims.length-2])throw new Error("shared dimension does not match.");if(r[0].type!=="float32"&&r[0].type!=="float64"||r[1].type!=="float32"&&r[1].type!=="float64")throw new Error("inputs should be float type");if(r[0].type!==r[1].type)throw new Error("inputs types should match")}});function rx(r,e,n,t){let o=[],i=[],s=n[0].dims,a=n[1].dims,u=s.length,l=a.length,c=t.length,h=c-u,m=c-l;o=s.map((C,D)=>`coords.${e[D+h]}`),o[u-1]="i*2",o.join(", "),i=a.map((C,D)=>`coords.${e[D+m]}`),i[l-2]="i*2",i.join(", ");let b=$t.getBroadcastDims(s,t),x=$t.getBroadcastDims(a,t),y=b.map(C=>`coords.${e[C+h]} = 0;`).join(`
`),T=x.map(C=>`coords.${e[C+m]} = 0;`).join(`
`),E=`int lastDim = coords.${e[c-1]};
  coords.${e[c-1]} = coords.${e[c-2]};
  coords.${e[c-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${r} coords = getOutputCoords();
  ${E}
  ${y}
  vec4 outputValue = getA(${o});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${r} coords = getOutputCoords();
  ${E}
  ${T}
  vec4 outputValue = getB(${i});
  return outputValue;
}`}function nx(r,e){let n="";for(let t=0;t<e-2;t++)n+=`rc.${r[t]}, `;return n+=`rc.${r[e-2]}, i*2`,n}function ox(r,e){let n="";for(let t=0;t<e-2;t++)n+=`rc.${r[t]}, `;return n+=`i*2, rc.${r[e-1]}`,n}var ex,tx,Ii,bs=M(()=>{"use strict";Fe();Qe();Ee();dr();pn();Si();ex=(r,e)=>({name:"MatMul (packed)",inputNames:r?["A","B","Bias"]:["A","B"],inputTypes:r?[2,2,2]:[2,2],cacheHint:e}),tx=(r,e,n,t)=>{let o=n.length>2,i=o?"value += getBiasForMatmul();":"",s=n[0].dims,a=n[1].dims,u=$t.calcShape(s,a,!0),l=!te.areEqual(n[0].dims,n[1].dims);if(!u)throw new Error("Can't use matmul on the given tensors");let c=s[s.length-1],h=Math.ceil(c/2),m=s.length,b=a.length,x=de(r.session.backend.glContext.version),y=St(u.length),T=u.length,E=tr(),{activationFunction:_,applyActivation:C}=pr(t),D=o?`${gs(y,E,n[2].dims,u,!0)}`:"",z=l?`${rx(y,E,n,u)}`:"",F=l?"getAAtOutCoordsMatmul(i)":`getA(${nx(E,m)})`,V=l?"getBAtOutCoordsMatmul(i)":`getB(${ox(E,b)})`,ee=l?"":`${y} rc =
          getOutputCoords(); int lastDim = rc.${E[T-1]}; rc.${E[T-1]} =
          rc.${E[T-2]}; rc.${E[T-2]} = lastDim;
      `,re=`
            ${z}
            ${D}
            ${_}
            void main() {
              ${ee}

              vec4 value = vec4(0);
              for (int i = 0; i < ${h}; i++) {
                vec4 a = ${F};
                vec4 b = ${V};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${i}
              ${C}
              ${x.output} = value;
            }`;return{...e,output:{dims:u,type:n[0].type,textureType:2},shaderSource:re,hasMain:!0}},Ii=(r,e,n)=>{let t=ex(e.length>2,n.activationCacheKey);return{...t,get:()=>tx(r,t,e,n)}}});var Af,_f=M(()=>{"use strict";$i();$f();bs();Af=(r,e,n)=>{let t=e[0].dims,o=e[1].dims,i=Nn(t,o,n.dilations,n.pads,n.strides),s=r.run(Tf(r,e[0],e[1],i,n),[e[0]]),a=r.reshapePacked(e[1],[o[0],o[1]*o[2]*o[3]]),u=e.length===3?[a,s,e[2]]:[a,s],l=r.run(Ii(r,u,n),u);return r.reshapePacked(l,i)}});var ix,ax,Of,ys,vs=M(()=>{"use strict";Ee();ix=r=>({name:"Im2Col",inputNames:["X"],inputTypes:[0],cacheHint:r}),ax=(r,e,n,t,o,i)=>{let s=n.dims,a=t.dims,u=o.length,l=ys(s,a,o,4),c=`
        const int XC = ${s[1]};
        const int XH = ${s[2]};
        const int XW = ${s[3]};
        const int KH = ${i.kernelShape[0]};
        const int KW = ${i.kernelShape[1]};
        const int dilationH = ${i.dilations[0]};
        const int dilationW = ${i.dilations[1]};
        const int strideH = ${i.strides[0]};
        const int strideW = ${i.strides[1]};
        const int padH = ${i.pads[0]};
        const int padW = ${i.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${u}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${s.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return{...e,output:{dims:l,type:n.type,textureType:4},shaderSource:c}},Of=(r,e,n,t,o)=>{let i=ix(o.cacheKey);return{...i,get:()=>ax(r,i,e,n,t,o)}},ys=(r,e,n,t=4)=>[n[0],n[2],n[3],Math.ceil(r[1]*e[2]*e[3]/t)]});var sx,ux,Cf,Ef=M(()=>{"use strict";Fe();Qe();Ee();pn();vs();sx=(r,e)=>({name:"ConvDotProduct",inputNames:r?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:r?[0,4,0]:[0,4],cacheKey:e.activationCacheKey}),ux=(r,e,n,t,o)=>{let i=n[0].dims,s=n[1].dims,a=[s[0],Math.ceil(i[1]*s[2]*s[3]/4)],u=ys(i,s,t),[l,c]=r.calculateTextureWidthAndHeight(a,4),h=te.computeStrides(u),[m,b]=r.calculateTextureWidthAndHeight(u,4),x=t.length,y=n.length<3?"0.0":"_B(b)",T=Math.ceil(i[1]*s[2]*s[3]/4),{activationFunction:E,applyActivation:_}=pr(o),C=de(r.session.backend.glContext.version),D=`
${E}
float process(int indices[${x}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${h[0]} + im2col[1] * ${h[1]} + im2col[2] * ${h[2]};
  int kernelOffset = indices[1] * ${a[1]};
  float value = ${y};
  for (int i = 0; i < ${T}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${m}, ${b});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${l}, ${c});
    value += dot(${C.texture2D}(Im2Col, im2colCoords), ${C.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${_}
  return value;
}`;return{...e,output:{dims:t,type:n[0].type,textureType:0},shaderSource:D}},Cf=(r,e,n,t)=>{let o=sx(e.length>2,t);return{...o,get:()=>ux(r,o,e,n,t)}}});var Nn,xs,lx,cx,dx,fx,ws,px,$i=M(()=>{"use strict";mt();Fe();wf();_f();Ef();pn();vs();Si();Nn=(r,e,n,t,o)=>{let i=r[0],s=r.slice(2),a=s.length,u=e[0],c=e.slice(2).map((x,y)=>x+(x-1)*(n[y]-1)),m=s.map((x,y)=>x+t[y]+t[y+a]).map((x,y)=>Math.floor((x-c[y]+o[y])/o[y]));return[i,u].concat(...m)},xs=(r,e,n)=>(px(e,n),lx(r,e,n)),lx=(r,e,n)=>{let t=fx(n,e),o=r.session.pack,i=t.kernelShape[0]===1&&t.kernelShape[1]===1;return t.group>1?[r.run(xf(r,e,t),e)]:i&&o?[cx(r,e,t)]:o&&e[0].dims.length===4&&e[0].dims[0]===1&&!i?[Af(r,e,t)]:[dx(r,e,t)]},cx=(r,e,n)=>{let t=e[0].dims,o=e[1].dims,i=Nn(t,o,n.dilations,n.pads,n.strides),s=r.reshapeUnpacked(e[0],[t[1],t[2]*t[3]]),a=r.reshapeUnpacked(e[1],[o[0],o[1]]),u=e.length>2?[a,s,e[2]]:[a,s],l=r.run(ms(u,n),u);return r.reshapeUnpacked(l,i)},dx=(r,e,n)=>{let t=e[0].dims,o=e[1].dims,i=Nn(t,o,n.dilations,n.pads,n.strides),s=r.run(Of(r,e[0],e[1],i,n),[e[0]]),a=e.length===3?[s,e[1],e[2]]:[s,e[1]];return r.run(Cf(r,e,i,n),a)},fx=(r,e)=>{let n=r.kernelShape.slice();if(r.kernelShape.length===0)for(let i=2;i<e[1].dims.length;++i)n.push(e[1].dims[i]);let t=r.pads.slice();un.adjustPadsBasedOnAutoPad(e[0].dims,r.strides,r.dilations,n,t,r.autoPad);let o=Object.assign({},r);return Object.assign(o,{kernelShape:n,pads:t,cacheKey:r.cacheKey}),o},ws=r=>{let e=r.attributes,n=Ln(e),t=e.getString("auto_pad","NOTSET"),o=e.getInts("dilations",[1,1]),i=e.getInt("group",1),s=e.getInts("kernel_shape",[]),a=e.getInts("pads",[0,0,0,0]),u=e.getInts("strides",[1,1]);return Te({autoPad:t,dilations:o,group:i,kernelShape:s,pads:a,strides:u,...n})},px=(r,e)=>{if(!r||r.length!==2&&r.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(r[0].dims.length!==4||r[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let n=r[0].dims[1],t=r[1].dims[1]*e.group;if(n!==t)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(r.length===3&&(r[2].dims.length!==1||r[1].dims[0]!==r[2].dims[0]))throw new Error("invalid bias");let o=r[0].dims.length-2;if(e.dilations.length!==o)throw new Error(`dilations should be ${o}D`);if(e.strides.length!==o)throw new Error(`strides should be ${o}D`);if(e.pads.length!==o*2)throw new Error(`pads should be ${o*2}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==r[1].dims.length-2)throw new Error("invalid kernel shape");if(r[0].type!=="float32"||r[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(r.length===3&&r[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}});var hx,mx,gx,Pf,bx,yx,vx,xx,wx,Tx,Df,$x,kf=M(()=>{"use strict";mt();Qe();Ee();pn();hx=(r,e,n,t,o,i)=>(r-1)*e+n+(t-1)*o+1-i,mx=(r,e,n,t,o)=>{let i=Math.floor(r/2);e==="SAME_UPPER"?(n[t]=i,n[o]=r-i):e==="SAME_LOWER"&&(n[t]=r-i,n[o]=i)},gx=(r,e,n,t,o,i,s,a)=>{let u=r.length-2,l=a.length===0;for(let c=0;c<u;++c){let h=l?r[c+2]*i[c]:a[c],m=hx(r[c+2],i[c],o[c],e[c],n[c],h);mx(m,t,o,c,c+u),l&&a.push(i[c]*(r[c+2]-1)+s[c]+(e[c]-1)*n[c]+1-o[c]-o[c+u])}},Pf=(r,e,n)=>($x(e,n),bx(r,e,n)),bx=(r,e,n)=>{let t=Tx(n,e);return[wx(r,e,t)]},yx=(r,e)=>({name:"ConvTranspose",inputNames:r?["X","W","B"]:["X","W"],inputTypes:r?[0,0,0]:[0,0],cacheHint:e}),vx=(r,e,n,t)=>{let i=e.length>2?"getB(output_channel)":"0.0",s=e[0].dims,a=e[1].dims,u=a[1],l=a[0]/t.group,c=[e[0].dims[0],e[1].dims[1]*t.group,...t.outputShape],h=de(r.session.backend.glContext.version),{activationFunction:m,applyActivation:b}=pr(t),x=`
  const ivec2 strides = ivec2(${t.strides[0]}, ${t.strides[1]});
  const ivec2 pads = ivec2(${t.pads[0]}, ${t.pads[1]});
  ${m}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${u};
    int wOutChannel = output_channel - group_id * ${u};

    float value = ${i};
    for (int inChannelOffset = 0; inChannelOffset < ${l}; inChannelOffset++) {
      int input_channel = group_id * ${l} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${a[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${a[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${t.dilations[0]}, wHOff * ${t.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${s[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${s[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${b}
    ${h.output} = vec4(value, .0, .0, .0);
  }
`;return{...n,output:{dims:c,type:e[0].type,textureType:0},shaderSource:x,hasMain:!0}},xx=(r,e,n)=>{let t=yx(e.length>2,n.cacheKey);return{...t,get:()=>vx(r,e,t,n)}},wx=(r,e,n)=>r.run(xx(r,e,n),e),Tx=(r,e)=>{let n=r.kernelShape.slice();if(r.kernelShape.length===0)for(let a=2;a<e[1].dims.length;++a)n.push(e[1].dims[a]);let t=r.pads.slice(),o=r.outputShape.slice(),i=e[0].dims;gx(i,n,r.dilations,r.autoPad,t,r.strides,r.outputPadding,o);let s=Object.assign({},r);return Object.assign(s,{kernelShape:n,pads:t,outputShape:o,cacheKey:r.cacheKey}),s},Df=r=>{let e=r.attributes,n=Ln(e),t=e.getString("auto_pad","NOTSET"),o=e.getInts("dilations",[1,1]),i=e.getInt("group",1),s=e.getInts("kernel_shape",[]),a=e.getInts("output_padding",[0,0]),u=e.getInts("output_shape",[]),l=e.getInts("pads",[0,0,0,0]),c=e.getInts("strides",[1,1]);return Te({autoPad:t,dilations:o,group:i,kernelShape:s,outputPadding:a,outputShape:u,pads:l,strides:c,...n})},$x=(r,e)=>{if(!r||r.length!==2&&r.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(r[0].dims.length!==4||r[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let n=r[0].dims[1],t=r[1].dims[0];if(n!==t)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let o=r[1].dims[1]*e.group;if(r.length===3&&(r[2].dims.length!==1||r[2].dims[0]!==o))throw new Error("invalid bias");let i=r[0].dims.length-2;if(e.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(e.strides.length!==i)throw new Error(`strides should be ${i}D`);if(e.pads.length!==i*2)throw new Error(`pads should be ${i*2}D`);if(e.outputPadding.length!==i)throw new Error(`output_padding should be ${i}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==r[1].dims.length-2)throw new Error("invalid kernel shape");if(e.outputShape.length!==0&&e.outputShape.length!==r[0].dims.length-2)throw new Error("invalid output shape");if(r[0].type!=="float32"||r[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(r.length===3&&r[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}});var Bf,hn,Rf,Sx,Mf,Ix,Ax,_x,Ai=M(()=>{"use strict";mt();Fe();Ee();Bf={name:"Transpose",inputNames:["A"],inputTypes:[0]},hn=(r,e,n)=>(_x(e),[r.run({...Bf,cacheHint:n.cacheKey,get:()=>Sx(r,e[0],n.perm)},e)]),Rf=r=>Te({perm:r.attributes.getInts("perm",[])}),Sx=(r,e,n)=>{let t=e.dims;n=Mf(t,n);let o=Ix(t,n),i=t.length,s=`
      ${Ax("perm",n,i)}
      float process(int indices[${i}]) {
        int a[${i}];
        perm(a, indices);
        return _A(a);
      }`;return{...Bf,output:{dims:o,type:e.type,textureType:0},shaderSource:s}},Mf=(r,e)=>(e&&e.length!==r.length&&(e=[...r.keys()].reverse()),e),Ix=(r,e)=>(e=Mf(r,e),te.sortBasedOnPerm(r,e)),Ax=(r,e,n)=>{let t=[];t.push(`void ${r}(out int a[${n}], int src[${n}]) {`);for(let o=0;o<n;++o)t.push(`	a[${e[o]}]=src[${o}];`);return t.push("	}"),t.join(`
`)},_x=r=>{if(!r||r.length!==1)throw new Error("Transpose requires 1 input.");if(r[0].type!=="float32"&&r[0].type!=="float64")throw new Error("input should be float tensor")}});var Lf,Nf,Ox,Ff=M(()=>{"use strict";Ai();Lf=(r,e,n)=>{Ox(e);let t=n.blocksize,o=t*t,i=n.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],s=n.mode==="DCR"?[e[0].dims[0],t,t,e[0].dims[1]/o,e[0].dims[2],e[0].dims[3]]:[e[0].dims[0],e[0].dims[1]/o,t,t,e[0].dims[2],e[0].dims[3]],a=r.reshapeUnpacked(e[0],s),u={perm:i,cacheKey:`${i}`},[l]=hn(r,[a],u),c=[e[0].dims[0],e[0].dims[1]/o,e[0].dims[2]*t,e[0].dims[3]*t];return[r.reshapeUnpacked(l,c)]},Nf=r=>{let e=r.attributes.getInt("blocksize");if(e<1)throw new Error(`blocksize must be >= 1, but got : ${e} for DepthToSpace`);let n=r.attributes.getString("mode","DCR");if(n!=="DCR"&&n!=="CRD")throw new Error(`unrecognized mode: ${n} for DepthToSpace`);return{mode:n,blocksize:e}},Ox=r=>{if(r.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${r.length}`);if(r[0].type==="string"||r[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}});var zf,Gf,Cx,Vf=M(()=>{"use strict";Fe();zf=(r,e,n)=>{Cx(e,n);let t=te.flattenShape(e[0].dims,n);return[r.reshapeUnpacked(e[0],t)]},Gf=r=>r.attributes.getInt("axis",1),Cx=(r,e)=>{if(!r||r.length!==1)throw new Error("Flatten requires 1 input.");let n=r[0].dims.length;if(n===0)throw new Error("scalar tensor is not supported.");if(e<-n||e>n)throw new Error("Invalid axis");if(r[0].type==="string")throw new Error("string tensor is not supported.")}});var Gr,yo=M(()=>{"use strict";Gr=["float32","float64","int32","int16","int8","uint16","uint32","uint8"]});var Wf,Uf,Ex,Px,Dx,kx,Hf=M(()=>{"use strict";mt();yo();Fe();Ee();Wf=(r,e,n)=>(kx(e,n.axis),[r.run(Dx(r,e,n),e)]),Uf=r=>Te({axis:r.attributes.getInt("axis",0)}),Ex={name:"Gather",inputNames:["A","B"],inputTypes:[0,0]},Px=(r,e,n,t)=>{let o=n[0].dims.slice(),i=n[1].dims.slice(),s=new Array(o.length+i.length-1);t=te.normalizeAxis(t,o.length);let a=[];for(let m=0;m<s.length;m++)m<t?(s[m]=o[m],a.push(`inputIdx[${m}] = outputIdx[${m}];`)):m<t+i.length?(s[m]=i[m-t],a.push(`indexDataIdx[${m-t}] = outputIdx[${m}];`)):(s[m]=o[m-i.length+1],a.push(`inputIdx[${m-i.length+1}] = outputIdx[${m}];`));let u=s.length||1,l=o.length,c=i.length||1,h=`
      float process(int outputIdx[${u}]) {
        int inputIdx[${l}];
        int indexDataIdx[${c}];
        indexDataIdx[0] = 0;
        ${a.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${t}] = idx < 0 ? idx + ${o[t]} : idx;
        return _A(inputIdx);
      }`;return{...e,output:{dims:s,type:n[0].type,textureType:0},shaderSource:h}},Dx=(r,e,n)=>{let t={...Ex,cacheHint:n.cacheKey};return{...t,get:()=>Px(r,t,e,n.axis)}},kx=(r,e)=>{if(!r||r.length!==2)throw new Error("Gather requires 2 inputs.");let n=r[0].dims.length;if(n<1)throw new Error("Invalid input shape.");if(e<-n||e>n-1)throw new Error("Invalid axis.");if(Gr.indexOf(r[0].type)===-1)throw new Error("Invaid input type.");if(r[1].type!=="int32"&&r[1].type!=="int16")throw new Error("Invaid input type.")}});var Ts,jf,qf,Kf,Bx,Rx,Mx,Xf=M(()=>{"use strict";mt();Fe();Ee();Ts=(r,e,n)=>(Mx(e,n),[r.run(Bx(e,n),e)]),jf=(r,e)=>{let n=r.attributes.getInt("transA",0)!==0,t=r.attributes.getInt("transB",0)!==0,o=r.attributes.getFloat("alpha",1),i=r.attributes.getFloat("beta",1);return Te({transA:n,transB:t,alpha:o,beta:i,isOptionalC:e})},qf=r=>jf(r,!1),Kf=r=>jf(r,!0),Bx=(r,e)=>{let n={name:"Gemm",inputNames:r.length===3?["A","B","C"]:["A","B"],inputTypes:r.length===3?[0,0,0]:[0,0],key:e.cacheKey};return{...n,get:()=>Rx(n,r,e)}},Rx=(r,e,n)=>{let t=e[0].dims.slice(),o=e[1].dims.slice(),[i,s]=mi.getShapeOfGemmResult(t,n.transA,o,n.transB,e.length===3?e[2].dims:void 0),a=[i,s];if(!a)throw new Error("Can't use gemm on the given tensors");let u=t[t.length-1],l="";n.transA&&(u=t[0]),n.transA&&n.transB?l="value += _A_T(a) * _B_T(b);":n.transA&&!n.transB?l="value += _A_T(a) * _B(b);":!n.transA&&n.transB?l="value += _A(a) * _B_T(b);":!n.transA&&!n.transB&&(l="value += _A(a) * _B(b);");let c=a.length,h=e.length===3?`int c[${e[2].dims.length}];`:"",m=e.length===3?"bcastIndices_C(indices, c);":"",b=e.length===3?"value += beta * _C(c);":"",x=`
      float process(int indices[${c}]) {
          int a[${c}];
          int b[${c}];
          ${h}

          copyVec(indices, a);
          copyVec(indices, b);
          ${m}

          float value = 0.0;
          for (int k=0; k<${u}; ++k) {
              a[${c-1}] = k;
              b[${c-2}] = k;
              ${l}
          }

          value = value * alpha;
          ${b}
          return value;
      }`;return{...r,output:{dims:a,type:e[0].type,textureType:0},variables:[{name:"alpha",type:"float",data:n.alpha},{name:"beta",type:"float",data:n.beta}],shaderSource:x}},Mx=(r,e)=>{if(!r)throw new Error("Input is missing");if(e.isOptionalC&&(r.length<2||r.length>3))throw new Error("Invaid input shape.");if(!e.isOptionalC&&r.length!==3)throw new Error("Gemm requires 3 inputs");if(r.length===3&&r[2].dims.length!==1&&r[2].dims.length!==2)throw new Error("Invalid input shape of C");if(r[0].type!=="float32"&&r[0].type!=="float64"||r[1].type!=="float32"&&r[1].type!=="float64"||r.length===3&&r[2].type!=="float32"&&r[2].type!=="float64")throw new Error("Invalid input type.");if(r[0].type!==r[1].type||r.length===3&&r[0].type!==r[2].type)throw new Error("Input types are mismatched")}});var Yf,Jf,Lx,Nx,Fx,zx,Gx,Zf=M(()=>{"use strict";mt();Ee();Yf=(r,e,n)=>(Gx(e),[r.run(Fx(r,e,n),e)]),Jf=r=>{let e=r.attributes.getFloat("scale"),n=r.attributes.getFloats("bias");return Te({scale:e,bias:n})},Lx={name:"ImageScaler",inputNames:["X"],inputTypes:[0]},Nx=(r,e,n,t)=>{let o=n[0].dims.slice(),i=o.length,a=`
      ${zx(t.bias.length)}
      float process(int indices[${i}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return{...e,output:{dims:o,type:n[0].type,textureType:0},variables:[{name:"bias",type:"float",arrayLength:t.bias.length,data:t.bias},{name:"scale",type:"float",data:t.scale}],shaderSource:a}},Fx=(r,e,n)=>{let t={...Lx,cacheHint:n.cacheKey};return{...t,get:()=>Nx(r,t,e,n)}},zx=r=>{let e=[`float getBias(float bias[${r}], int channel) {`];for(let n=0;n<r;++n)n===0?e.push(`	if (channel == ${n}) { return bias[${n}]; }`):n===r-1?e.push(`	else { return bias[${n}]; }`):e.push(`	else if (channel == ${n}) { return bias[${n}]; }`);return e.push("	}"),e.join(`
`)},Gx=r=>{if(!r||r.length!==1)throw new Error("ImageScaler requires 1 input.");if(r[0].dims.length!==4)throw new Error("Invalid input shape.");if(r[0].type!=="float32"&&r[0].type!=="float64")throw new Error("Invalid input type.")}});var ep,tp,Qf,Vx,Wx,Ux,Hx,jx,qx,rp=M(()=>{"use strict";Qe();Ee();ep=(r,e,n)=>{qx(e);let t=r.run(Wx(e[0]),e);return[r.run(jx(r,e[0],n,t.dims),[e[0],t,e[1],e[2]])]},tp=r=>r.attributes.getFloat("epsilon",1e-5),Qf={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[0]},Vx=(r,e)=>{let n=e.dims.slice(),t=n[1],o=n[2]*n[3],i=[n[0],t],s=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${n[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${o});
        temp = 0.0;
        for(int a2=0; a2<${n[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${o});

        return v;
      }`;return{...r,output:{dims:i,type:e.type,textureType:4},shaderSource:s}},Wx=r=>({...Qf,get:()=>Vx(Qf,r)}),Ux={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[0,4,0,0]},Hx=(r,e,n,t,o)=>{let i=de(r.session.backend.glContext.version),[s,a]=r.calculateTextureWidthAndHeight(o,4),[u,l]=[s/4,a],c=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${u}, ${l});
        return ${i.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return{...e,output:{dims:n.dims,type:n.type,textureType:0},variables:[{name:"epsilon",type:"float",data:t}],shaderSource:c}},jx=(r,e,n,t)=>{let o={...Ux,cacheHint:`${n}`};return{...o,get:()=>Hx(r,o,e,n,t)}},qx=r=>{if(!r||r.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");let e=r[0],n=r[1],t=r[2];if(e.dims.length<3||n.dims.length!==1||t.dims.length!==1)throw new Error("Invalid input shape.");if(n.dims[0]!==e.dims[1]||t.dims[0]!==e.dims[1])throw new Error("Input shapes are mismatched.");if(e.type!=="float32"&&e.type!=="float64"||n.type!=="float32"&&n.type!=="float64"||t.type!=="float32"&&t.type!=="float64")throw new Error("Invalid input type.");if(r[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}});function Kx(r,e){let n=r[0].dims[1],t=r[0].dims.length,o=-Math.floor((e.size-1)/2),i=Math.ceil((e.size-1)/2),s=`float(${e.alpha}) / float(${e.size})`,a=`float(${e.bias})`,u=`float(${e.beta})`,l=`
    float process(int indices[${t}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${o}; i <= ${i}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${n}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(${a} + ${s} * square_sum, ${u});
    }`;return{...ip,cacheHint:e.cacheKey,output:{dims:r[0].dims,type:r[0].type,textureType:0},shaderSource:l}}function Xx(r,e){return{...ip,cacheHint:e.cacheKey,get:()=>Kx(r,e)}}var np,op,ip,Yx,ap=M(()=>{"use strict";mt();Ee();np=(r,e,n)=>(Yx(e),[r.run(Xx(e,n),e)]),op=r=>{let e=r.attributes.getFloat("alpha",1e-4),n=r.attributes.getFloat("beta",.75),t=r.attributes.getFloat("bias",1),o=r.attributes.getInt("size");return Te({alpha:e,beta:n,bias:t,size:o})},ip={name:"LRN",inputNames:["X"],inputTypes:[0]};Yx=r=>{if(!r||r.length!==1)throw new Error("LRN requires 1 input.");if(r[0].dims.length!==4)throw new Error('currently only support LRN for input with "NCHW" format');if(r[0].type!=="float32")throw new Error("input should be float type")}});var Jx,$s,sp,up,lp,Zx,Qx,ew,tw,rw,nw,ow,iw,cp=M(()=>{"use strict";mt();Fe();Qe();Ee();Jx={name:"Pad",inputNames:["A"],inputTypes:[0]},$s=(r,e,n)=>(ew(e),[r.run({...Jx,cacheHint:n.cacheKey,get:()=>Qx(r,e[0],n)},e)]),sp=r=>{let e=r.attributes.getString("mode","constant"),n=r.attributes.getFloat("value",0),t=r.attributes.getInts("pads");return Te({mode:e,value:n,pads:t})},up=(r,e,n)=>{tw(e);let t=Zx(r,e,n);return $s(r,[e[0]],t)},lp=r=>r.attributes.getString("mode","constant"),Zx=(r,e,n)=>{if(!r.session.isInitializer(e[1].dataId)||e.length>=3&&!r.session.isInitializer(e[2].dataId))throw new Error("dynamic pad attributes are not allowed");let t=Array.from(e[1].integerData),o=e.length>=3?e[2].floatData[0]:0;return Te({mode:n,pads:t,value:o})},Qx=(r,e,n)=>{let t=te.padShape(e.dims.slice(),n.pads),o=t.length,s=`
      ${rw(r,e,n)}
      float process(int[${o}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[0],output:{dims:t,type:e.type,textureType:0},shaderSource:s}},ew=r=>{if(!r||r.length!==1)throw new Error("Pad requires 1 input");if(r[0].type!=="float32"&&r[0].type!=="float64")throw new Error("Invalid input type.")},tw=r=>{if(!r||r.length!==2&&r.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(r[1].type!=="int32")throw new Error("Invalid input type.");if(r.length>=3&&r[2].type==="string")throw new Error("Invalid input type.")},rw=(r,e,n)=>{let t=de(r.session.backend.glContext.version),[o,i]=r.calculateTextureWidthAndHeight(e.dims,0),s=te.computeStrides(e.dims);switch(n.mode){case"constant":return nw(t,e.dims,s,o,i,n.pads,n.value);case"reflect":return ow(t,e.dims,s,o,i,n.pads);case"edge":return iw(t,e.dims,s,o,i,n.pads);default:throw new Error("Invalid mode")}},nw=(r,e,n,t,o,i,s)=>{let a=e.length,u="";for(let l=a-1;l>=0;--l)u+=`
        k = m[${l}] - ${i[l]};
        if (k < 0)  return constant;
        if (k >= ${e[l]}) return constant;
        offset += k * ${n[l]};
        `;return`
      float padA(int m[${a}]) {
        const float constant = float(${s});
        int offset = 0;
        int k = 0;
        ${u}
        vec2 coords = offsetToCoords(offset, ${t}, ${o});
        float value = getColorAsFloat(${r.texture2D}(A, coords));
        return value;
      }
      `},ow=(r,e,n,t,o,i)=>{let s=e.length,a="";for(let u=s-1;u>=0;--u)a+=`
        k = m[${u}] - ${i[u]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(e[u]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${e[u]}) { k = _2n_1 - k; }
        }
        offset += k * ${n[u]};
        `;return`
      float padA(int m[${s}]) {
        int offset = 0;
        int k = 0;
        ${a}
        vec2 coords = offsetToCoords(offset, ${t}, ${o});
        float value = getColorAsFloat(${r.texture2D}(A, coords));
        return value;
      }
      `},iw=(r,e,n,t,o,i)=>{let s=e.length,a="";for(let u=s-1;u>=0;--u)a+=`
        k = m[${u}] - ${i[u]};
        if (k < 0)  k = 0;
        if (k >= ${e[u]}) k = ${e[u]-1};
        offset += k * ${n[u]};
      `;return`
      float padA(int m[${s}]) {
        int offset = 0;
        int k = 0;
        ${a}
        vec2 coords = offsetToCoords(offset, ${t}, ${o});
        float value = getColorAsFloat(${r.texture2D}(A, coords));
        return value;
      }
      `}});var fp,pp,hp,mp,gp,bp,yp,vp,xp,aw,dp,wp,Oi,Tp,_i,sw,$p=M(()=>{"use strict";mt();Fe();Ee();fp=(r,e,n)=>{Oi(e);let t={name:"AveragePool",inputNames:["X"],inputTypes:[0],cacheHint:n.cacheKey};return[r.run({...t,get:()=>hp(e,t,!1,n)},e)]},pp=r=>{let e=r.attributes.getString("auto_pad","NOTSET"),n=r.attributes.getInt("ceil_mode",0),t=r.attributes.getInt("count_include_pad",0)!==0,o=r.attributes.getInts("kernel_shape"),i=r.attributes.getInts("strides",[]),s=r.attributes.getInts("pads",[]);if(n!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return Te({autoPad:e,ceilMode:n,countIncludePad:t,kernelShape:o,strides:i,pads:s})},hp=(r,e,n,t)=>{let[o,i]=xp(r,t,n),s=te.size(o.kernelShape),a="value += _X(x);",u="";o.countIncludePad?u+=`value /= float(${s});`:u+=`value /= float(${s} - pad);`;let c=`
        ${Tp(r[0].dims,o,a,u,"0.0")}
      `;return{...e,output:{dims:i,type:r[0].type,textureType:0},shaderSource:c}},mp=(r,e,n)=>{Oi(e);let t={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[0],cacheHint:`${n.countIncludePad}`};return[r.run({...t,get:()=>hp(e,t,!0,n)},e)]},gp=r=>{let e=r.attributes.getInt("count_include_pad",0)!==0;return Te({autoPad:"",ceilMode:0,countIncludePad:e,kernelShape:[],strides:[],pads:[]})},bp=(r,e,n)=>{Oi(e);let t={name:"MaxPool",inputNames:["X"],inputTypes:[0],cacheHint:n.cacheKey};return[r.run({...t,get:()=>vp(e,t,!1,n)},e)]},yp=r=>{let e=r.attributes.getString("auto_pad","NOTSET"),n=r.attributes.getInt("ceil_mode",0),t=r.attributes.getInts("kernel_shape"),o=r.attributes.getInts("strides",[]),i=r.attributes.getInts("pads",[]),s=r.attributes.getInt("storage_order",0),a=r.attributes.getInts("dilations",[]);if(s!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(n!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return Te({autoPad:e,ceilMode:n,countIncludePad:!1,kernelShape:t,strides:o,pads:i,storageOrder:s,dilations:a})},vp=(r,e,n,t)=>{let[o,i]=xp(r,t,n),s=`
      value = max(_X(x), value);
    `,a="",l=`
      ${Tp(r[0].dims,o,s,a,"-1e5")}
    `;return{...e,output:{dims:i,type:r[0].type,textureType:0},shaderSource:l}},xp=(r,e,n)=>{let t=r[0].dims.slice(),o=Object.hasOwnProperty.call(e,"dilations"),i=e.kernelShape.slice(),s=e.strides.slice(),a=o?e.dilations.slice():[],u=e.pads.slice();un.adjustPoolAttributes(n,t,i,s,a,u);let l=un.computePoolOutputShape(n,t,s,a,i,u,e.autoPad),c=Object.assign({},e);return o?Object.assign(c,{kernelShape:i,strides:s,pads:u,dilations:a,cacheKey:e.cacheKey}):Object.assign(c,{kernelShape:i,strides:s,pads:u,cacheKey:e.cacheKey}),[c,l]},aw={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},dp={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[0]},wp=(r,e)=>(Oi(e),[r.run({...dp,get:()=>vp(e,dp,!0,aw)},e)]),Oi=r=>{if(!r||r.length!==1)throw new Error("Pool ops requires 1 input.");if(r[0].type!=="float32"&&r[0].type!=="float64")throw new Error("Invalid input type.")},Tp=(r,e,n,t,o)=>{let i=r.length;if(e.kernelShape.length<=2){let s=e.kernelShape[e.kernelShape.length-1],a=e.strides[e.strides.length-1],u=e.pads[e.pads.length/2-1],l=e.pads[e.pads.length-1],c=r[i-1],h="",m="",b="";if(u+l!==0?h=`
          for (int i = 0; i < ${s}; i++) {
            x[${i} - 1] = indices[${i} - 1] * ${a} - ${u} + i;
            if (x[${i} - 1] < 0 || x[${i} - 1] >= ${c}) {
              pad++;
              continue;
            }
            ${n}
          }`:h=`
          for (int i = 0; i < ${s}; i++) {
            x[${i} - 1] = indices[${i} - 1] * ${a} - ${u} + i;
            ${n}
          }`,e.kernelShape.length===2){let y=e.kernelShape[e.kernelShape.length-2],T=e.strides[e.strides.length-2],E=e.pads[e.pads.length/2-2],_=e.pads[e.pads.length-2],C=r[i-2];E+_!==0?m=`
            for (int j = 0; j < ${y}; j++) {
              x[${i} - 2] = indices[${i} - 2] * ${T} - ${E} + j;
              if (x[${i} - 2] < 0 || x[${i} - 2] >= ${C}) {
                pad+= ${s};
                continue;
              }
          `:m=`
            for (int j = 0; j < ${y}; j++) {
              x[${i} - 2] = indices[${i} - 2] * ${T} - ${E} + j;
            `,b=`
          }
        `}return`
        float process(int indices[${i}]) {
          int x[${i}];
          copyVec(indices, x);

          float value = ${o};
          int pad = 0;
          ${m}
          ${h}
          ${b}
          ${t}
          return value;
        }
      `}else{let s=te.size(e.kernelShape),a=te.computeStrides(e.kernelShape),u=a.length,l=e.pads.length,c=sw(u),h=_i(r,"inputDims"),m=_i(e.pads,"pads"),b=_i(a,"kernelStrides"),x=_i(e.strides,"strides"),y=e.pads.reduce((_,C)=>_+C),T="";return y?T=`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${n}
          }`:T=`
          }
          ${n}
        `,`
        ${c}
        float process(int indices[${i}]) {
          int x[${i}];
          copyVec(indices, x);
          int offset[${u}];
          int pads[${l}];
          int inputDims[${i}];
          int kernelStrides[${u}];
          int strides[${u}];
          ${m}
          ${h}
          ${x}
          ${b}

          float value = ${o};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${s}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${i} - ${u}; j < ${i}; j++) {
              x[j] = indices[j] * strides[j - ${i} + ${u}]
                + offset[j - ${i} + ${u}] - pads[j - 2];
              ${T}
          }
          ${t}

          return value;
        }
      `}},_i=(r,e)=>{let n="";for(let t=0;t<r.length;t++)n+=`
      ${e}[${t}] = ${r[t]};
    `;return n},sw=r=>`
  void offsetToIndices(int offset, int[${r}] strides, out int[${r}] indices) {
    if (${r} == 0) {
      return;
    }
    for (int i = 0; i < ${r} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${r} - 1] = offset;
  }`});var mn,Vr,uw,lw,Sp,Ip,Ap,_p,Op,Cp,Ep,Pp=M(()=>{"use strict";mt();yo();Fe();Ee();mn=(r,e,n,t,o)=>{lw(e);let i={name:t,inputNames:["A"],inputTypes:[0]};return[r.run({...i,cacheHint:n.cacheKey,get:()=>uw(r,e,n,t,o,i)},e)]},Vr=r=>{let e=r.attributes.getInts("axes",[]),n=r.attributes.getInt("keepdims",1)===1;return Te({axes:e,keepDims:n})},uw=(r,e,n,t,o,i)=>{let s=[],a=e[0].dims.length||1,u=[],l=te.normalizeAxes(n.axes,e[0].dims.length),c=o(e,l),h=c[1];for(let x=0;x<e[0].dims.length;x++)l.indexOf(x)>=0||l.length===0?(n.keepDims&&s.push(1),h=`
          for(int j${x} = 0; j${x} < ${e[0].dims[x]}; j${x}++) {
            inputIdx[${x}] = j${x};
            ${h}
          }`):(u.push(`inputIdx[${x}] = outputIdx[${s.length}];`),s.push(e[0].dims[x]));let b=`
      float process(int outputIdx[${s.length||1}]) {
        float value;                 // final result
        int inputIdx[${a}];      // addressing input data
        ${u.join(`
`)}
        ${c[0]}       // init ops for reduce max/min
        ${h}
        ${c[2]}       // final computation for reduce mean
        return value;
      }`;return{...i,output:{dims:s,type:e[0].type,textureType:0},shaderSource:b}},lw=r=>{if(!r||r.length!==1)throw new Error("Reduce op requires 1 input.");if(Gr.indexOf(r[0].type)===-1)throw new Error("Invalid input type.")},Sp=(r,e,n)=>mn(r,e,n,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),Ip=(r,e,n)=>mn(r,e,n,"ReduceMean",(o,i)=>{let s=1;for(let a=0;a<o[0].dims.length;a++)(i.indexOf(a)>=0||i.length===0)&&(s*=o[0].dims[a]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${s}.;`]}),Ap=(r,e,n)=>mn(r,e,n,"ReduceMax",(o,i)=>{let s=[];for(let a=0;a<o[0].dims.length;a++)(i.indexOf(a)>=0||i.length===0)&&s.push(`inputIdx[${a}] = 0;`);return[`${s.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),_p=(r,e,n)=>mn(r,e,n,"ReduceMin",(o,i)=>{let s=[];for(let a=0;a<o[0].dims.length;a++)(i.indexOf(a)>=0||i.length===0)&&s.push(`inputIdx[${a}] = 0;`);return[`${s.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),Op=(r,e,n)=>mn(r,e,n,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),Cp=(r,e,n)=>mn(r,e,n,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),Ep=(r,e,n)=>mn(r,e,n,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])});var Dp,kp=M(()=>{"use strict";Fe();Dp=(r,e)=>{let n=te.calculateReshapedDims(e[0].dims,e[1].integerData);return r.session.pack?[r.reshapePacked(e[0],n)]:[r.reshapeUnpacked(e[0],n)]}});var Bp,Ss,Rp,Mp,vo,cw,Is,Ci,As=M(()=>{"use strict";mt();Qe();Ee();Bp={name:"Upsample",inputNames:["X"],inputTypes:[0]},Ss=(r,e,n)=>(Is(e,n),[r.run({...Bp,cacheHint:n.cacheKey,get:()=>cw(r,e,n)},e)]),Rp=r=>vo(r,7),Mp=r=>vo(r,9),vo=(r,e)=>{let n=e>=10,t=r.attributes.getString("mode","nearest");if(t!=="nearest"&&t!=="linear"&&(e<11||t!=="cubic"))throw new Error(`unrecognized mode: ${t}`);let o=[];e<9&&(o=r.attributes.getFloats("scales"),Ci(o,t,n));let i=r.attributes.getFloat("extrapolation_value",0),s=e>10?r.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(s)===-1)throw new Error(`coordinate_transform_mode '${s}' is not supported`);let a=s==="tf_crop_and_resize",u=a,l=t==="nearest"&&e>=11?r.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(l)===-1)throw new Error(`nearest_mode '${l}' is not supported`);let c=r.attributes.getFloat("cubic_coeff_a",-.75),h=r.attributes.getInt("exclude_outside",0)!==0;if(h&&t!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");let m=e<11?!0:t==="nearest"&&s==="asymmetric"&&l==="floor",b=0,x=0,y=0;return e>10?r.inputs.length>2?(b=1,x=2,y=3):(x=1,y=2):e===9&&(x=1),Te({opset:e,isResize:n,mode:t,scales:o,extrapolationValue:i,coordinateTransformMode:s,useExtrapolation:u,needRoiInput:a,nearestMode:l,cubicCoefficientA:c,excludeOutside:h,useNearest2xOptimization:m,roiInputIdx:b,scalesInputIdx:x,sizesInputIdx:y})},cw=(r,e,n)=>{let t=de(r.session.backend.glContext.version),[o,i]=r.calculateTextureWidthAndHeight(e[0].dims,0),s=e[0].dims.map((y,T)=>Math.floor(y*n.scales[T])),[a,u]=r.calculateTextureWidthAndHeight(s,0),l=s.length,c=new Array(l),h=new Array(l),m=`
      int output_pitches[${l}];
      int input_pitches[${l}];
      `;for(let y=l-1;y>=0;y--)c[y]=y===l-1?1:c[y+1]*s[y+1],h[y]=y===l-1?1:h[y+1]*e[0].dims[y+1],m+=`
        output_pitches[${y}] = ${c[y]};
        input_pitches[${y}] = ${h[y]};
        `;let b=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${o}, ${i});
        float value = getColorAsFloat(${t.texture2D}(X, coords));
        return value;
      }
      `,x=n.mode==="nearest"?`
    ${b}
    float process(int indices[${l}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${a}, ${u});

      ${m}

      int d, m;
      for (int dim = 0; dim < ${l}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:l===4?`
    ${b}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${a}, ${u});

      ${m}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${e[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${b}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${a}, ${u});

      ${m}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${e[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return{...Bp,output:{dims:s,type:e[0].type,textureType:0},shaderSource:x,variables:[{name:"scales",type:"int",arrayLength:n.scales.length,data:n.scales.map(y=>Math.ceil(y))}]}},Is=(r,e)=>{if(!r||e.opset<9&&r.length!==1||e.opset>=9&&e.opset<11&&r.length!==2||e.opset>=11&&r.length<2)throw new Error("invalid inputs.");if(e.scales.length>0&&r[0].dims.length!==e.scales.length)throw new Error("Invalid input shape.");if(r[0].type==="string")throw new Error("Invalid input tensor types.")},Ci=(r,e,n)=>{if(n){for(let t of r)if(t<=0)throw new Error("Scale value should be greater than 0.")}else for(let t of r)if(t<1)throw new Error("Scale value should be greater than or equal to 1.");if((e==="linear"||e==="cubic")&&r.length!==2&&(r.length!==4||r[0]!==1||r[1]!==1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n?"Resize":"Upsample"} opeartor.`)}});var _s,Os,Lp,Np,dw,fw,pw,hw,Fp=M(()=>{"use strict";Qe();Ee();dr();fn();As();_s={name:"Resize",inputNames:["A"],inputTypes:[2]},Os=(r,e,n)=>(Is(e,n),[r.run({..._s,cacheHint:n.cacheKey,get:()=>dw(r,e,n)},e)]),Lp=r=>vo(r,10),Np=r=>vo(r,11),dw=(r,e,n)=>{let t=de(r.session.backend.glContext.version),[o,i]=fw(e,n);if(o.every(C=>C===1)&&n.coordinateTransformMode!=="tf_crop_and_resize")return{..._s,output:{dims:i,type:e[0].type,textureType:2},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${t.texture2D}(X, TexCoords);
                    ${t.output} = v;
                }`};let a=i.length;if(a<2)throw new Error(`output dimension should be at least 2, but got ${a}`);let u=i[a-2],l=i[a-1],c=e[0].dims;if(a!==c.length)throw new Error(`output dimension should match input ${c.length}, but got ${a}`);let h=c[a-2],m=c[a-1],b=o[a-2],x=o[a-1],y="";if(n.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${n.mode}'`);switch(n.coordinateTransformMode){case"asymmetric":y=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":y=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":y=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${l}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${u}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${l}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${u}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":y=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${l}.0 - 1.0, ${u}.0 - 1.0, ${l}.0 - 1.0,
                            ${u}.0 - 1.0);
                        vec4 original = vec4(${m}.0 - 1.0, ${h}.0 - 1.0, ${m}.0 - 1.0,
                            ${h}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n.coordinateTransformMode}'`)}let T=St(a),E=fr(),_=`
            const vec2 inputWH = vec2(${h}.0, ${m}.0);
            const vec4 scaleWHWH = vec4(float(${b}), float(${x}), float(${b}), float(${x}));
            ${E}
            ${y}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${T} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${u-1};
                bool hasNextCol = rc.z < ${l-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${t.output} = vec4(newValue);
            }
        `;return{..._s,output:{dims:i,type:e[0].type,textureType:2},hasMain:!0,shaderSource:_}},fw=(r,e)=>{let t=r[0].dims,o=e.scales,i;if(o.length===0){let a=r[e.scalesInputIdx];if(a&&a.size!==0){if(r[e.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");o=pw(a,e.mode,e.isResize)}else{let u=r[e.sizesInputIdx];if(!u||u.size===0)throw new Error("Either scales or sizes MUST be provided as input.");i=Array.from(u.integerData),o=hw(i,t,e.mode,e.isResize)}}else if(r[e.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");let s=i||t.map((a,u)=>Math.floor(a*o[u]));return[o,s]},pw=(r,e,n)=>{let t=Array.from(r.floatData);return Ci(t,e,n),t},hw=(r,e,n,t)=>{let o=e.length,i=new Array(o);for(let s=0,a=o;s<a;s++)if(e[s]===0){if(r[s]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");i[s]=1}else i[s]=r[s]/e[s];return Ci(i,n,t),i}});var zp,mw,Gp=M(()=>{"use strict";dn();zp=(r,e)=>(mw(e),[new dt([e[0].dims.length],"int32",void 0,void 0,new Int32Array(e[0].dims))]),mw=r=>{if(!r||r.length!==1)throw new Error("Shape requires 1 input.")}});var Cs,Vp,Wp,Up,gw,Hp,bw,yw,jp=M(()=>{"use strict";mt();yo();Fe();Ee();Cs={name:"Slice",inputNames:["A"],inputTypes:[0]},Vp=(r,e,n)=>(gw(e),[r.run({...Cs,cacheHint:n.cacheKey,get:()=>Up(r,e[0],n)},e)]),Wp=r=>{let e=r.attributes.getInts("starts"),n=r.attributes.getInts("ends"),t=r.attributes.getInts("axes",[]);return Te({starts:e,ends:n,axes:t})},Up=(r,e,n)=>{let t=n.axes.length===0?e.dims.slice(0).map((h,m)=>m):n.axes,o=te.normalizeAxes(t,e.dims.length),i=n.starts.map((h,m)=>h>e.dims[o[m]]-1?e.dims[o[m]]:te.normalizeAxis(h,e.dims[o[m]])),s=n.ends.map((h,m)=>h>e.dims[o[m]]-1?e.dims[o[m]]:te.normalizeAxis(h,e.dims[o[m]])),a=e.dims.slice(),u=[];for(let h=0;h<o.length;h++)a[o[h]]=s[h]-i[h],i[h]>0&&u.push(`outputIdx[${o[h]}] += ${i[h]};`);let c=`
      float process(int outputIdx[${a.length}]) {
        ${u.join(`
      `)}
        return _A(outputIdx);
      }`;return{...Cs,output:{dims:a,type:e.type,textureType:0},shaderSource:c}},gw=r=>{if(!r||r.length!==1)throw new Error("Slice requires 1 input.");if(Gr.indexOf(r[0].type)===-1)throw new Error("Invalid input type.")},Hp=(r,e)=>{yw(e);let n=bw(r,e);return[r.run({...Cs,cacheHint:n.cacheKey,get:()=>Up(r,e[0],n)},[e[0]])]},bw=(r,e)=>{if(!r.session.isInitializer(e[1].dataId)||!r.session.isInitializer(e[2].dataId)||e.length>=4&&!r.session.isInitializer(e[3].dataId)||e.length>=5&&!r.session.isInitializer(e[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(e.length>=5&&e[4].integerData.some(s=>s!==1))throw new Error("currently non-1 steps is not supported for Slice");let n=Array.from(e[1].integerData),t=Array.from(e[2].integerData),o=e.length>=4?Array.from(e[3].integerData):[],i=`${o};${n};${t}`;return{starts:n,ends:t,axes:o,cacheKey:i}},yw=r=>{if(!r||r.length<3||r.length>5)throw new Error("Invalid input number.");if(r[1].type!=="int32"||r[1].dims.length!==1)throw new Error("Invalid input type.");if(r[2].type!=="int32"||r[2].dims.length!==1)throw new Error("Invalid input type.");if(r.length>=4&&(r[3].type!=="int32"||r[3].dims.length!==1))throw new Error("Invalid input type.");if(r.length>=5&&(r[4].type!=="int32"||r[4].dims.length!==1))throw new Error("Invalid input type.")}});var qp,Kp,Xp,Yp,Jp,Zp,Qp,eh,vw,xw,ww,th,rh=M(()=>{"use strict";mt();Fe();Qe();Ee();Ai();qp={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[0]},Kp={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[0,0]},Xp={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[0,0,0]},Yp=(r,e,n)=>{th(e);let t=e[0].dims.slice(),o=te.normalizeAxis(n.axis,t.length),i=te.sizeToDimension(t,o),s=te.sizeFromDimension(t,o);return eh(r,e,n,i,s)},Jp=r=>Te({axis:r.attributes.getInt("axis",1)}),Zp=r=>Te({axis:r.attributes.getInt("axis",-1)}),Qp=(r,e,n)=>{th(e);let t=e[0].dims.slice(),o=te.normalizeAxis(n.axis,t.length),i=t.length,s=o!==i-1,a=[],u=[],l=[],c;s&&(u=Array.from({length:i}).map((x,y)=>y),u[o]=i-1,u[i-1]=o,u.map(x=>a.push(t[x])),c=Te({perm:u}),l=hn(r,e,c));let h=s?te.sizeToDimension(a,i-1):te.sizeToDimension(t,i-1),m=s?te.sizeFromDimension(a,i-1):te.sizeFromDimension(t,i-1),b=eh(r,s?l:e,n,h,m);return s?hn(r,b,c):b},eh=(r,e,n,t,o)=>{let i=vw(r,e[0],t,o,[t]),s=r.run({...qp,cacheHint:n.cacheKey,get:()=>i},e),a=xw(r,e[0],t,o,i.output.dims,[t]),u=r.run({...Kp,cacheHint:n.cacheKey,get:()=>a},[e[0],s]),l=ww(r,e[0],t,o,i.output.dims,a.output.dims);return[r.run({...Xp,cacheHint:n.cacheKey,get:()=>l},[e[0],s,u])]},vw=(r,e,n,t,o)=>{let[i,s]=r.calculateTextureWidthAndHeight(e.dims,0),a=o.length;if(n<1||t<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(o.length!==1)throw new Error("Dimensionality of the output should be 1");if(o[0]!==n)throw new Error("Shape of the output should be equal to logical row count");let u=de(r.session.backend.glContext.version),l=`
      float process(int[${a}] indices) {
        int logical_row_start_offset = indices[0] * ${t};

        float max = getColorAsFloat(${u.texture2D}(A, offsetToCoords(logical_row_start_offset, ${i},
        ${s} )));
        for(int i=1; i<${t}; ++i)
        {
          float current = getColorAsFloat(${u.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${i}, ${s})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return{...qp,output:{dims:o,type:e.type,textureType:0},shaderSource:l}},xw=(r,e,n,t,o,i)=>{let[s,a]=r.calculateTextureWidthAndHeight(e.dims,0),u=i.length;if(n<1||t<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(i.length!==1)throw new Error("Dimensionality of the output should be 1");if(i[0]!==n)throw new Error("Shape of the output should be equal to logical row count");if(o.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(o[0]!==n)throw new Error("Shape of the intermediate results should be equal to logical row count");let l=de(r.session.backend.glContext.version),c=`
      float process(int[${u}] indices) {
        int logical_row_start_offset = indices[0] * ${t};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${t}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${l.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${s}, ${a}))) - max);
        }

        return norm_factor;
      }`;return{...Kp,output:{dims:i,type:e.type,textureType:0},shaderSource:c}},ww=(r,e,n,t,o,i)=>{let[s,a]=r.calculateTextureWidthAndHeight(e.dims,0),u=e.dims.length;if(n<1||t<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(o.length!==1||i.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(o[0]!==n||i[0]!==n)throw new Error("Shape of the intermediate results should be equal to logical row count");let l=`
      float process(int[${u}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${s}, ${a});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${t};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return{...Xp,output:{dims:e.dims,type:e.type,textureType:0},shaderSource:l}},th=r=>{if(!r||r.length!==1)throw new Error("Softmax requires 1 input.");if(r[0].type!=="float32"&&r[0].type!=="float64")throw new Error("Invalid input type")}});var nh,oh,ih,Tw,$w,Sw,ah=M(()=>{"use strict";mt();Fe();Ee();nh={name:"Split",inputNames:["A"],inputTypes:[0]},oh=(r,e,n)=>{Sw(e);let t=te.normalizeAxis(n.axis,e[0].dims.length),o=Tw(r,e,t,n),i=[];for(let s=0;s<o;++s)i.push(r.run({...nh,cacheHint:`${n.cacheKey};${s}`,get:()=>$w(r,e[0],n,t,s)},e));return i},ih=r=>{let e=r.attributes.getInt("axis",0),n=r.attributes.getInts("split",[]),t=r.outputs.length;return Te({axis:e,split:n,numOutputs:t})},Tw=(r,e,n,t)=>{let[,o]=fo.splitShape(e[0].dims,n,t.split,t.numOutputs);return o.length},$w=(r,e,n,t,o)=>{let[i,s]=fo.splitShape(e.dims,t,n.split,n.numOutputs),a=s[o],u=i[o],c=`
      float process(int indices[${u.length}]) {
        indices[${t}] += ${a};
        return _A(indices);
      }
    `;return{...nh,cacheHint:`${n.cacheKey}:${o}`,output:{dims:u,type:e.type,textureType:0},shaderSource:c}},Sw=r=>{if(!r||r.length!==1)throw new Error("Split requires one input.");if(r[0].type!=="int8"&&r[0].type!=="uint8"&&r[0].type!=="int16"&&r[0].type!=="uint16"&&r[0].type!=="int32"&&r[0].type!=="uint32"&&r[0].type!=="float32"&&r[0].type!=="float64"&&r[0].type!=="bool")throw new Error("Invalid input type.")}});var Es,sh,uh,Iw,Aw,lh=M(()=>{"use strict";Fe();Es=(r,e,n)=>{Iw(e);let t=te.squeezeShape(e[0].dims,n);return[r.reshapeUnpacked(e[0],t)]},sh=(r,e)=>(Aw(e),Es(r,[e[0]],Array.from(e[1].integerData))),uh=r=>r.attributes.getInts("axes"),Iw=r=>{if(!r||r.length!==1)throw new Error("Squeeze requires 1 input.");if(r[0].type==="string")throw new Error("invalid input tensor types.")},Aw=r=>{if(!r||r.length!==2)throw new Error("Squeeze requires 2 inputs.");if(r[1].type!=="int32")throw new Error("Invalid input type.")}});var ch,_w,Ow,dh=M(()=>{"use strict";Qe();Ee();ch=(r,e)=>{Ow(e);let n={name:"Sum",inputNames:e.map((o,i)=>`X${i}`),inputTypes:new Array(e.length).fill(0)};return[r.run({...n,get:()=>_w(r,e,n)},e)]},_w=(r,e,n)=>{let t=de(r.session.backend.glContext.version),o=e[0].dims.slice(),s=`
      void main() {
        vec4 result = ${e.map((a,u)=>`${t.texture2D}(X${u},TexCoords)`).join(" + ")};
        ${t.output} = result;
      }
    `;return{...n,output:{dims:o,type:e[0].type,textureType:0},hasMain:!0,shaderSource:s}},Ow=r=>{if(!r||r.length===0)throw new Error("Sum requires inputs.");let e=r[0].dims.length;for(let n=1;n<r.length;n++){if(e!==r[n].dims.length)throw new Error("Input shapes are mismatched.");for(let t=0;t<e;t++)if(r[0].dims[t]!==r[n].dims[t])throw new Error("Input shapes are not matched.")}if(r[0].type!=="float32"&&r[0].type!=="float64")throw new Error("Invalid input type.");for(let n=1;n<r.length;n++)if(r[0].type!==r[n].type)throw new Error("Input types are not matched.")}});var fh,Cw,Ew,ph=M(()=>{"use strict";yo();Ee();fh=(r,e)=>{Ew(e);let n={name:"Tile",inputNames:["A"],inputTypes:[0]};return[r.run({...n,get:()=>Cw(r,e,n)},e)]},Cw=(r,e,n)=>{let t=e[0].dims.slice(),o=new Array(t.length),i=[];for(let u=0;u<t.length;u++)o[u]=t[u]*e[1].numberData[u],i.push(`inputIdx[${u}] = int(mod(float(outputIdx[${u}]), ${t[u]}.));`);let s=o.length,a=`
      float process(int outputIdx[${s}]) {
        int inputIdx[${s}];
        ${i.join(`
`)}
        return _A(inputIdx);
      }
    `;return{...n,output:{dims:o,type:e[0].type,textureType:0},shaderSource:a}},Ew=r=>{if(!r||r.length!==2)throw new Error("Tile requires 2 input.");if(r[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(r[1].dims[0]!==r[0].dims.length)throw new Error("Invalid input shape.");if(Gr.indexOf(r[0].type)===-1)throw new Error("Invalid input type.");if(r[1].type!=="int32"&&r[1].type!=="int16")throw new Error("Invalid repeat type.")}});var Ps,hh,mh,Pw,Dw,gh=M(()=>{"use strict";Fe();Ps=(r,e,n)=>{Pw(e);let t=te.unsqueezeShape(e[0].dims,n);return[r.reshapeUnpacked(e[0],t)]},hh=(r,e)=>(Dw(e),Ps(r,[e[0]],Array.from(e[1].integerData))),mh=r=>r.attributes.getInts("axes"),Pw=r=>{if(!r||r.length!==1)throw new Error("Unsqueeze requires 1 input.");if(r[0].type==="string")throw new Error("invalid input tensor types.")},Dw=r=>{if(!r||r.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(r[1].type!=="int32")throw new Error("Invalid input type.")}});var bh,yh=M(()=>{"use strict";_d();zd();Wd();Xd();$i();kf();Ff();Vf();Hf();Xf();Zf();rp();ap();Si();cp();$p();Pp();kp();Fp();Gp();jp();rh();ah();lh();dh();ph();Ai();hs();gh();As();bh=[["Abs","","6+",Yd],["Acos","","7+",Jd],["Add","","7+",Od],["And","","7+",Cd],["Asin","","7+",Zd],["Atan","","7+",Qd],["AveragePool","","7+",fp,pp],["BatchNormalization","","7+",Id,Ad],["Cast","","6+",Gd,Vd],["Ceil","","6+",rf],["Clip","","6-10",fs,ef],["Clip","","11+",tf],["Concat","","4+",jd,Kd],["Conv","","1+",xs,ws],["ConvTranspose","","1+",Pf,Df],["Cos","","7+",nf],["Div","","7+",Ed],["Dropout","","7+",ps],["DepthToSpace","","1+",Lf,Nf],["Equal","","7+",Pd],["Elu","","6+",of,af],["Exp","","6+",sf],["Flatten","","1+",zf,Gf],["Floor","","6+",uf],["FusedConv","com.microsoft","1+",xs,ws],["Gather","","1+",Wf,Uf],["Gemm","","7-10",Ts,qf],["Gemm","","11+",Ts,Kf],["GlobalAveragePool","","1+",mp,gp],["GlobalMaxPool","","1+",wp],["Greater","","7+",Dd],["Identity","","1+",ps],["ImageScaler","","1+",Yf,Jf],["InstanceNormalization","","6+",ep,tp],["LeakyRelu","","6+",lf,cf],["Less","","7+",kd],["LRN","","1+",np,op],["Log","","6+",df],["MatMul","","1+",Sf,If],["MaxPool","","1+",bp,yp],["Mul","","7+",Bd],["Neg","","6+",ff],["Not","","1+",pf],["Or","","7+",Rd],["Pad","","2-10",$s,sp],["Pad","","11+",up,lp],["Pow","","7+",Md],["PRelu","","7+",Ld],["ReduceLogSum","","1+",Cp,Vr],["ReduceMax","","1+",Ap,Vr],["ReduceMean","","1+",Ip,Vr],["ReduceMin","","1+",_p,Vr],["ReduceProd","","1+",Op,Vr],["ReduceSum","","1-12",Sp,Vr],["ReduceSumSquare","","1+",Ep,Vr],["Relu","","6+",hf],["Reshape","","5+",Dp],["Resize","","10",Os,Lp],["Resize","","11+",Os,Np],["Shape","","1+",zp],["Sigmoid","","6+",mf],["Sin","","7+",gf],["Slice","","10+",Hp],["Slice","","1-9",Vp,Wp],["Softmax","","1-12",Yp,Jp],["Softmax","","13+",Qp,Zp],["Split","","2-12",oh,ih],["Sqrt","","6+",bf],["Squeeze","","1-12",Es,uh],["Squeeze","","13+",sh],["Sub","","7+",Nd],["Sum","","6+",ch],["Tan","","7+",yf],["Tanh","","6+",vf],["Tile","","6+",fh],["Transpose","","1+",hn,Rf],["Upsample","","7-8",Ss,Rp],["Upsample","","9",Ss,Mp],["Unsqueeze","","1-12",Ps,mh],["Unsqueeze","","13+",hh],["Xor","","7+",Fd]]});function xh(r){let e={},n;for(;(n=vh.exec(r))!==null;){let t=n[3].split(",").map(o=>{let i=o.trim().split(" ");return i&&i.length===2?{type:i[0],name:i[1]}:null}).filter(o=>o!==null);e[n[2]]={params:t,body:n[4]}}for(let t in e){let o=kw.replace("__FUNC__",t),i=new RegExp(o,"gm");for(;(n=i.exec(r))!==null;){let s=n[1],a=n[2],u=n[3].split(","),l=s?`${s} ${a};`:"",c=e[t].body,h="";e[t].params.forEach((b,x)=>{b&&(h+=`${b.type} ${b.name} = ${u[x]};
`)}),c=`${h}
 ${c}`,c=c.replace("return",`${a} = `);let m=`
      ${l}
      {
        ${c}
      }
      `;r=r.replace(n[0],m)}}return r=r.replace(vh,""),r}var vh,kw,wh=M(()=>{"use strict";vh=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm,kw="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;"});function Fn(r,e){let n=[],t=[],o=e!=null&&Array.isArray(e)&&e.length===0,i=e==null||o?null:Bw(e,r).sort(),s=0;for(let a=0;a<r.length;++a){if(i!=null){if(i[s]===a&&r[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${r[a]}' is not 1`);(i[s]==null||i[s]>a)&&r[a]===1&&(n.push(r[a]),t.push(a)),i[s]<=a&&s++}r[a]!==1&&(n.push(r[a]),t.push(a))}return{newShape:n,keptDims:t}}function Bw(r,e){let n=e.length;return r=r==null?e.map((t,o)=>o):[].concat(r),kn(r.every(t=>t>=-n&&t<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${r}`),kn(r.every(Rw),()=>`All values in axis param must be integers but got axis ${r}`),r.map(t=>t<0?n+t:t)}function Rw(r){return r%1===0}function Mw(r){if(r.length===0)return 1;let e=r[0];for(let n=1;n<r.length;n++)e*=r[n];return e}function Th(r){let e=Math.ceil(Math.sqrt(r));return[e,Math.ceil(r/e)]}var Ei,Ds=M(()=>{"use strict";Nt();Fe();Ei=class{constructor(e){this.maxTextureSize=e}computeTextureWH(e,n){let t=this.computeTexture(e,n);return n&&n.isPacked&&(t[0]/=2,t[1]/=2),n&&n.reverseWH?[t[1],t[0]]:t}computeTexture(e,n){let t=n&&n.isPacked;if(e.length===0)return t?[2,2]:[1,1];let o=this.maxTextureSize;if(n&&n.breakAxis!==void 0){let a=n.breakAxis>=e.length?1:e.slice(n.breakAxis).reduce((l,c)=>l*c),u=n.breakAxis<=0?1:e.slice(0,n.breakAxis).reduce((l,c)=>l*c);if(a>o||u>o)ze.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${e}, breakAxis:${n.breakAxis}`);else return[a,u]}let i=e.slice(0);t&&(o=o*2,i=i.map((a,u)=>u>=i.length-2?i[u]%2===0?i[u]:i[u]+1:i[u]),i.length===1&&(i=[2,i[0]])),i.length!==2&&(i=Fn(i).newShape);let s=Mw(i);return i.length<=1&&s<=o?[1,s]:i.length===2&&i[0]<=o&&i[1]<=o?i:i.length===3&&i[0]*i[1]<=o&&i[2]<=o?[i[0]*i[1],i[2]]:i.length===3&&i[0]<=o&&i[1]*i[2]<=o?[i[0],i[1]*i[2]]:i.length===4&&i[0]*i[1]*i[2]<=o&&i[3]<=o?[i[0]*i[1]*i[2],i[3]]:i.length===4&&i[0]<=o&&i[1]*i[2]*i[3]<=o?[i[0],i[1]*i[2]*i[3]]:t?Th(s/4).map(a=>a*2):Th(s)}}});var Pi,$h=M(()=>{"use strict";Fe();Cr();Qe();Ds();dr();Pi=class extends Vt{constructor(n){super(n)}getFunctions(){return{...this.offsetToCoords(),...this.coordsToOffset(),...this.toVec(),...this.valueFrom(),...this.getCommonUtilFuncs(),...this.getInputsSamplingSnippets(),...this.getOutputSamplingSnippet()}}getCustomTypes(){return{}}offsetToCoords(){let n="offsetToCoords";return{offsetToCoords:new Z(`
      vec2 ${n}(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){let n="coordsToOffset";return{coordsToOffset:new Z(`
      int ${n}(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){let n=this.context.outputTextureLayout;return n.isPacked?this.getPackedOutputSamplingSnippet(n):this.getUnpackedOutputSamplingSnippet(n)}getPackedOutputSamplingSnippet(n){let t=n.unpackedShape,o=[n.width,n.height],i={},s="getOutputCoords";switch(t.length){case 0:i[s]=this.getOutputScalarCoords();break;case 1:i[s]=this.getOutputPacked1DCoords(t,o);break;case 2:i[s]=this.getOutputPacked2DCoords(t,o);break;case 3:i[s]=this.getOutputPacked3DCoords(t,o);break;default:i[s]=this.getOutputPackedNDCoords(t,o)}let u=`
      void setOutput(vec4 val) {
        ${de(this.context.glContext.version).output} = val;
      }
    `,l="floatTextureSetRGBA";return i[l]=new Z(u),i}getUnpackedOutputSamplingSnippet(n){let t=n.unpackedShape,o=[n.width,n.height],i={},s="getOutputCoords";switch(t.length){case 0:i[s]=this.getOutputScalarCoords();break;case 1:i[s]=this.getOutputUnpacked1DCoords(t,o);break;case 2:i[s]=this.getOutputUnpacked2DCoords(t,o);break;case 3:i[s]=this.getOutputUnpacked3DCoords(t,o);break;case 4:i[s]=this.getOutputUnpacked4DCoords(t,o);break;case 5:i[s]=this.getOutputUnpacked5DCoords(t,o);break;case 6:i[s]=this.getOutputUnpacked6DCoords(t,o);break;default:throw new Error(`Unsupported output dimensionality: ${t.length}`)}let u=`
        void setOutput(float val) {
          ${de(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `,l="floatTextureSetR";return i[l]=new Z(u),i}getOutputScalarCoords(){return new Z(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(n,t){let o=t,i="";return o[0]===1?(i=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${o[1]}.0);
          }
        `,new Z(i)):o[1]===1?(i=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${o[0]}.0);
          }
        `,new Z(i)):(i=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${o[0]}, ${o[1]}));
          return 2 * (resTexRC.y * ${o[0]} + resTexRC.x);
        }
      `,new Z(i))}getOutputPacked2DCoords(n,t){let o="";if(sn.arraysEqual(n,t))return o=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${t[0]}, ${t[1]}));
        }
      `,new Z(o);let i=t,s=Math.ceil(n[1]/2);return o=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${i[0]}, ${i[1]}));

          int index = resTexRC.y * ${i[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${s}) * 2;
          int c = 2 * (index / ${s});

          return ivec2(r, c);
        }
      `,new Z(o)}getOutputPacked3DCoords(n,t){let o=[t[0],t[1]],i=Math.ceil(n[2]/2),s=i*Math.ceil(n[1]/2),a=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${o[0]}, ${o[1]}));
          int index = resTexRC.y * ${o[0]} + resTexRC.x;

          int b = index / ${s};
          index -= b * ${s};

          // reverse r and c order for packed texture
          int r = imod(index, ${i}) * 2;
          int c = 2 * (index / ${i});

          return ivec3(b, r, c);
        }
      `;return new Z(a)}getOutputPackedNDCoords(n,t){let o=[t[0],t[1]],i=Math.ceil(n[n.length-1]/2),s=i*Math.ceil(n[n.length-2]/2),a=s,u="",l="b, r, c";for(let h=2;h<n.length-1;h++)a*=n[n.length-h-1],u=`
      int b${h} = index / ${a};
      index -= b${h} * ${a};
    `+u,l=`b${h}, `+l;let c=`
      ivec${n.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${o[0]}, ${o[1]}));
        int index = resTexRC.y * ${o[0]} + resTexRC.x;

        ${u}

        int b = index / ${s};
        index -= b * ${s};

        // reverse r and c order for packed texture
        int r = imod(index, ${i}) * 2;
        int c = 2 * (index / ${i});

        return ivec${n.length}(${l});
      }
    `;return new Z(c)}getOutputUnpacked1DCoords(n,t){let o=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          return resTexRC.y * ${t[0]} + resTexRC.x;
        }
      `;return new Z(o)}getOutputUnpacked2DCoords(n,t){let o=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;
          int r = index / ${n[1]};
          int c = index - r * ${n[1]};
          return ivec2(r, c);
        }
      `;return new Z(o)}getOutputUnpacked3DCoords(n,t){let o="",i=n.length,s=null;i<2&&(s=[]),s=new Array(i-1),s[i-2]=n[i-1];for(let l=i-3;l>=0;--l)s[l]=s[l+1]*n[l+1];let a=["r","c","d"],u=s.map((l,c)=>{let h=`int ${a[c]} = index / ${l}`,m=c===s.length-1?`int ${a[c+1]} = index - ${a[c]} * ${l}`:`index -= ${a[c]} * ${l}`;return`${h}; ${m};`}).join("");return o=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;
          ${u}
          return ivec3(r, c, d);
        }
      `,new Z(o)}getOutputUnpacked4DCoords(n,t){let o="",i=n.length,s=null;i<2&&(s=[]),s=new Array(i-1),s[i-2]=n[i-1];for(let l=i-3;l>=0;--l)s[l]=s[l+1]*n[l+1];let a=["r","c","d","d2"],u=s.map((l,c)=>{let h=`int ${a[c]} = index / ${l}`,m=c===s.length-1?`int ${a[c+1]} = index - ${a[c]} * ${l}`:`index -= ${a[c]} * ${l}`;return`${h}; ${m};`}).join("");return o=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;
          ${u}
          return ivec4(r, c, d, d2);
        }
      `,new Z(o)}getOutputUnpacked5DCoords(n,t){let o="",i=n.length,s=null;i<2&&(s=[]),s=new Array(i-1),s[i-2]=n[i-1];for(let l=i-3;l>=0;--l)s[l]=s[l+1]*n[l+1];let a=["r","c","d","d2","d3"],u=s.map((l,c)=>{let h=`int ${a[c]} = index / ${l}`,m=c===s.length-1?`int ${a[c+1]} = index - ${a[c]} * ${l}`:`index -= ${a[c]} * ${l}`;return`${h}; ${m};`}).join("");return o=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;
          ${u}
          return ivec5(r, c, d, d2, d3);
        }
      `,new Z(o)}getOutputUnpacked6DCoords(n,t){let o="",i=n.length,s=null;i<2&&(s=[]),s=new Array(i-1),s[i-2]=n[i-1];for(let l=i-3;l>=0;--l)s[l]=s[l+1]*n[l+1];let a=["r","c","d","d2","d3","d4"],u=s.map((l,c)=>{let h=`int ${a[c]} = index / ${l}`,m=c===s.length-1?`int ${a[c+1]} = index - ${a[c]} * ${l}`:`index -= ${a[c]} * ${l}`;return`${h}; ${m};`}).join("");return o=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${t[0]}, ${t[1]}));
         int index = resTexRC.y * ${t[0]} + resTexRC.x;
         ${u}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new Z(o)}getCommonUtilFuncs(){let n={},t="uvFromFlat";n[t]=new Z(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),t="packedUVfrom1D",n[t]=new Z(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),t="packedUVfrom2D",n[t]=new Z(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),t="packedUVfrom3D",n[t]=new Z(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),t="sampleTexture";let o=de(this.context.glContext.version);return n[t]=new Z(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${o.texture2D}(textureSampler, uv).r;
        }`),n}getInputsSamplingSnippets(){let n={},t=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((o,i)=>{let s=this.context.inputTextureLayouts[i],a=gi(o);s.isPacked?n[a]=this.getPackedSamplerFromInput(a,o,s):n[a]=this.getUnpackedSamplerFromInput(a,o,s);let u=ld(o);s.unpackedShape.length<=t.unpackedShape.length&&(s.isPacked?n[u]=this.getPackedSamplerAtOutputCoords(u,s,t,o):n[u]=this.getUnpackedSamplerAtOutputCoords(u,s,t,o))}),n}getPackedSamplerAtOutputCoords(n,t,o,i){let s=t.unpackedShape,a=o.unpackedShape,l=gi(i),c=s.length,h=a.length,m=$t.getBroadcastDims(s,a),b=St(h),x=h-c,y,T=tr();c===0?y="":h<2&&m.length>=1?y="coords = 0;":y=m.map(re=>`coords.${T[re+x]} = 0;`).join(`
`);let E="";h<2&&c>0?E="coords":E=s.map((re,le)=>`coords.${T[le+x]}`).join(", ");let _="return outputValue;",D=te.size(s)===1,F=te.size(a)===1;if(c===1&&!D&&!F)_=`
        return vec4(outputValue.xy, outputValue.xy);
      `;else if(D&&!F)h===1?_=`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:_=`
          return vec4(outputValue.x);
        `;else if(m.length){let re=c-2,le=c-1;m.indexOf(re)>-1&&m.indexOf(le)>-1?_="return vec4(outputValue.x);":m.indexOf(re)>-1?_="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":m.indexOf(le)>-1&&(_="return vec4(outputValue.xx, outputValue.zz);")}let V=`
        int lastDim = coords.${T[h-1]};
        coords.${T[h-1]} = coords.${T[h-2]};
        coords.${T[h-2]} = lastDim;
      `,ee=`
      vec4 ${n}() {
        ${b} coords = getOutputCoords();
        ${V}
        ${y}
        vec4 outputValue = ${l}(${E});
        ${_}
      }
    `;return new Z(ee,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(n,t,o,i){let s=[o.width,o.height],a=[t.width,t.height],u=t.unpackedShape.length,l=o.unpackedShape.length,c=t.unpackedShape,h=o.unpackedShape,m=gi(i);if(u===l&&sn.arraysEqual(a,s)){let D=`
          float ${n}() {
            return sampleTexture(${i}, TexCoords);
          }
        `;return new Z(D,["coordinates.sampleTexture"])}let b=St(l),x=$t.getBroadcastDims(c,h),y=l-u,T,E=tr();u===0?T="":l<2&&x.length>=1?T="coords = 0;":T=x.map(D=>`coords.${E[D+y]} = 0;`).join(`
`);let _="";l<2&&u>0?_="coords":_=t.unpackedShape.map((D,z)=>`coords.${E[z+y]}`).join(", ");let C=`
        float ${n}() {
          ${b} coords = getOutputCoords();
          ${T}
          return ${m}(${_});
        }
      `;return new Z(C,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(n,t,o){switch(o.unpackedShape.length){case 0:return this.getPackedSamplerScalar(n,t);case 1:return this.getPackedSampler1D(n,t,o);case 2:return this.getPackedSampler2D(n,t,o);case 3:return this.getPackedSampler3D(n,t,o);default:return this.getPackedSamplerND(n,t,o)}}getUnpackedSamplerFromInput(n,t,o){let i=o.unpackedShape;switch(i.length){case 0:return this.getUnpackedSamplerScalar(n,t,o);case 1:return this.getUnpackedSampler1D(n,t,o);case 2:return this.getUnpackedSampler2D(n,t,o);case 3:return this.getUnpackedSampler3D(n,t,o);case 4:return this.getUnpackedSampler4D(n,t,o);case 5:return this.getUnpackedSampler5D(n,t,o);case 6:return this.getUnpackedSampler6D(n,t,o);default:throw new Error(`Unsupported dimension ${i.length}-D`)}}getPackedSamplerScalar(n,t){let o=de(this.context.glContext.version),i=`
          vec4 ${n}() {
            return ${o.texture2D}(${t}, halfCR);
          }
        `;return new Z(i)}getPackedSampler1D(n,t,o){let i=[o.width,o.height],s=[i[1],i[0]],a=de(this.context.glContext.version),l=`vec4 ${n}(int index) {
      vec2 uv = packedUVfrom1D(
      ${s[0]}, ${s[1]}, index);
      return ${a.texture2D}(${t}, uv);
    }`;return new Z(l,["coordinates.packedUVfrom1D"])}getPackedSampler2D(n,t,o){let i=o.unpackedShape,s=[o.width,o.height],a=de(this.context.glContext.version),u=s[0],l=s[1];if(s!=null&&sn.arraysEqual(i,s)){let x=`vec4 ${n}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${u}.0);
        return ${a.texture2D}(${t}, uv);
      }`;return new Z(x)}let c=s,h=Math.ceil(i[1]/2),b=`vec4 ${n}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c[1]}, ${c[0]}, ${h}, row, col);
      return ${a.texture2D}(${t}, uv);
    }`;return new Z(b,["coordinates.packedUVfrom2D"])}getPackedSampler3D(n,t,o){let i=o.unpackedShape,s=[o.width,o.height],a=[s[0],s[1]],u=de(this.context.glContext.version);if(i[0]===1){let y=i.slice(1),T=[1,2],E=Bn(i,y),_=["b","row","col"],C=JSON.parse(JSON.stringify(o));C.unpackedShape=E;let D=this.getPackedSamplerFromInput(n,t,C),F=`${D.routineBody}
      vec4 ${n}(int b, int row, int col) {
        return ${n}(${Rn(_,T)});
      } `;return new Z(F,D.dependencies)}let l=a[0],c=a[1],h=Math.ceil(i[2]/2),m=h*Math.ceil(i[1]/2),x=`vec4 ${n}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${c}, ${l}, ${m}, ${h}, b, row, col);
      return ${u.texture2D}(${t}, uv);}`;return new Z(x,["coordinates.packedUVfrom3D"])}getPackedSamplerND(n,t,o){let i=o.unpackedShape,s=i.length,a=[o.width,o.height],u=de(this.context.glContext.version),l=[a[0],a[1]],c=l[1],h=l[0],m=Math.ceil(i[s-1]/2),b=m*Math.ceil(i[s-2]/2),x="int b, int row, int col",y=`b * ${b} + (row / 2) * ${m} + (col / 2)`;for(let _=2;_<s-1;_++)x=`int b${_}, `+x,b*=i[s-_-1],y=`b${_} * ${b} + `+y;let E=`vec4 ${n}(${x}) {
      int index = ${y};
      int texR = index / ${h};
      int texC = index - texR * ${h};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}, ${c});
      return ${u.texture2D}(${t}, uv);
    }`;return new Z(E)}getUnpackedSamplerScalar(n,t,o){let[i,s]=[o.width,o.height];if(i===1&&s===1){let u=`
          float ${n}() {
            return sampleTexture(${t}, halfCR);
          }
        `;return new Z(u,["coordinates.sampleTexture"])}let a=`
        float ${n}() {
          int offset_${t} = coordsToOffset(TexCoords, ${i}, ${s});
          vec2 uv = uvFromFlat(${i}, ${s}, offset_${t});
          return sampleTexture(${t}, uv);
        }
      `;return new Z(a,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(n,t,o){let i=o.width,s=o.height;if(s===1&&i===1){let u=`
        float ${n}(int index) {
          return sampleTexture(${t}, halfCR);
        }
      `;return new Z(u,["coordinates.sampleTexture"])}if(s===1){let u=`
          float ${n}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${i}.0, 0.5);
            return sampleTexture(${t}, uv);
          }
        `;return new Z(u,["coordinates.sampleTexture"])}if(i===1){let u=`
          float ${n}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${s}.0);
            return sampleTexture(${t}, uv);
          }
        `;return new Z(u,["coordinates.sampleTexture"])}let a=`
        float ${n}(int index) {
          vec2 uv = uvFromFlat(${i}, ${s}, index);
          return sampleTexture(${t}, uv);
        }
      `;return new Z(a,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(n,t,o){let i=o.unpackedShape,s=[o.height,o.width];if(s!=null&&sn.arraysEqual(i,s)){let b=s[1],x=s[0],y=`
          float ${n}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${b}.0, ${x}.0);
            return sampleTexture(${t}, uv);
          }
        `;return new Z(y,["coordinates.sampleTexture"])}let{newShape:a,keptDims:u}=Fn(i),l=a;if(l.length<i.length){let b=Bn(i,l),x=JSON.parse(JSON.stringify(o));x.unpackedShape=b;let y=["col","row"],T=`
          ${this.getUnpackedSamplerFromInput(n,t,x).routineBody}
          float ${n}(int row, int col) {
            return ${n}(${Rn(y,u)});
          }
        `;return new Z(T,["coordinates.sampleTexture"])}let c=s[1],h=s[0];if(h===1){let b=`
          float ${n}(int row, int col) {
            int offset_${t} = coordsToOffset(TexCoords, ${c}, ${h});
            float index = dot(vec3(row, col, offset_${t}), vec3(${i[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
            return sampleTexture(${t}, uv);
          }
        `;return new Z(b,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(c===1){let b=`
          float ${n}(int row, int col) {
            int offset_${t} = coordsToOffset(TexCoords, ${c}, ${h});
            float index = dot(vec3(row, col, offset_${t}), vec3(${i[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${h}.0, 0.5);
            return sampleTexture(${t}, uv);
          }
        `;return new Z(b,["coordinates.sampleTexture","coordinates.coordsToOffset"])}let m=`
        float ${n}(int row, int col) {
          int index = col * ${i[1]} + row;
          vec2 uv = uvFromFlat(${c}, ${h}, index);
          return sampleTexture(${t}, uv);
        }
      `;return new Z(m,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(n,t,o){let i=o.unpackedShape,s=i[1]*i[2],a=i[2],{newShape:u,keptDims:l}=Fn(i),c=u;if(c.length<i.length){let x=Bn(i,c),y=["batch","col","row"],T=JSON.parse(JSON.stringify(o));T.unpackedShape=x;let E=this.getUnpackedSamplerFromInput(n,t,T),_=l.reverse(),C=`
          ${E.routineBody}
          float ${n}(int batch, int row, int col) {
            return ${n}(${Rn(y,_)});
          }
        `;return new Z(C,E.dependencies)}let h=o.width,m=o.height,b=`
          float ${n}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${s} + col * ${a} + row;
            vec2 uv = uvFromFlat(${h}, ${m}, index);
            return sampleTexture(${t}, uv);
          }
      `;return new Z(b,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(n,t,o){let i=o.unpackedShape,s=i[3],a=i[2]*s,u=i[1]*a,l=o.width,c=o.height,h=`
        float ${n}(int row, int col, int depth, int depth2) {
          int index = row * ${u} + col * ${a} +
              depth2 * ${s} + depth;
          vec2 uv = uvFromFlat(${l}, ${c}, index);
          return sampleTexture(${t}, uv);
        }
      `;return new Z(h,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(n,t,o){let i=o.unpackedShape,s=i[4],a=i[3]*s,u=i[2]*a,l=i[1]*u,{newShape:c,keptDims:h}=Fn(i);if(c.length<i.length){let y=Bn(i,c),T=["row","col","depth","depth2","depth3"],E=JSON.parse(JSON.stringify(o));E.unpackedShape=y;let _=`
          ${this.getUnpackedSamplerFromInput(n,t,E).routineBody}
          float ${n}(int row, int col, int depth, int depth2, int depth3) {
            return ${n}(${Rn(T,h)});
          }
        `;return new Z(_,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let m=o.width,b=o.height,x=`
        float ${n}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${l} + col * ${u} + depth * ${a} +
          depth3 * ${s} + depth2;
          vec2 uv = uvFromFlat(${m}, ${b}, index);
          return sampleTexture(${t}, uv);
        }
      `;return new Z(x,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(n,t,o){let i=o.unpackedShape,s=i[5],a=i[4]*s,u=i[3]*a,l=i[2]*u,c=i[1]*l,{newShape:h,keptDims:m}=Fn(i);if(h.length<i.length){let T=Bn(i,h),E=["row","col","depth","depth2","depth3","depth4"],_=JSON.parse(JSON.stringify(o));_.unpackedShape=T;let C=`
            ${this.getUnpackedSamplerFromInput(n,t,_).routineBody}
            float ${n}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${n}(${Rn(E,m)});
            }
          `;return new Z(C,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let b=o.width,x=o.height,y=`
          float ${n}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${c} + col * ${l} + depth * ${u} +
            depth2 * ${a} + depth3 * ${s} + depth4;
            vec2 uv = uvFromFlat(${b}, ${x}, index);
            return sampleTexture(${t}, uv);
          }
        `;return new Z(y,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){let n=this.context.outputTextureLayout,t=n.shape.length,o=n.strides,i=n.width,s=n.height,a=[];for(let l=0;l<t-1;++l)a.push(`
        c[${l}] = offset / ${o[l]};`),a.push(`
        offset -= c[${l}] * ${o[l]};`);a.push(`
        c[${t-1}] = offset;`);let u=`
      void toVec(vec2 texCoords, out int c[${t}]) {
        int offset = coordsToOffset(texCoords, ${i}, ${s});
        ${a.join("")}
      }
      void toVec(int offset, out int c[${t}]) {
        ${a.join("")}
      }
    `;return{toVec:new Z(u,["coordinates.coordsToOffset"])}}valueFrom(){let n={};return this.context.programInfo.inputNames.forEach((t,o)=>{let i=this.context.inputTextureLayouts[o],a=(i.unpackedShape.length>0?i.unpackedShape:i.shape).length,u=`_${t}`;n[u]=new Z(this.getValueFromSingle(t,a,i.width,i.height,!1),[`shapeUtils.indicesToOffset${u}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),u=u+"_T",n[u]=new Z(this.getValueFromSingle(t,a,i.width,i.height,!0),[`shapeUtils.indicesToOffset${u}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),n}getValueFromSingle(n,t,o,i,s){let a=`_${n}`;s&&(a=a+"_T");let u=de(this.context.glContext.version);return`
        float ${a}(int m[${t}]) {
          int offset = indicesToOffset${a}(m);
          vec2 coords = offsetToCoords(offset, ${o}, ${i});
          float value = getColorAsFloat(${u.texture2D}(${n}, coords));
          return value;
        }
        `}getPackedValueFrom(n,t,o,i,s){let a=`_${n}_Pack`;s&&(a=a+"_T");let u=de(this.context.glContext.version);return`
        vec4 ${a}(int m[${t}]) {
          int offset = indicesToOffset_${n}(m);
          vec2 coords = offsetToCoords(offset, ${o}, ${i});
          return ${u.texture2D}(${n}, coords);
        }
        `}}});var Di,Sh=M(()=>{"use strict";Cr();Di=class r extends Vt{constructor(e){super(e)}getFunctions(){return{...this.encodeFloat32(),...this.decodeFloat32()}}getCustomTypes(){return{}}encodeFloat32(){return{encode:new Z(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new Z(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){let e=r.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new Z(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${e}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){let e=r.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new Z(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${e}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){let e=new ArrayBuffer(4),n=new Uint32Array(e),t=new Uint8Array(e);if(n[0]=3735928559,t[0]===239)return!0;if(t[0]===222)return!1;throw new Error("unknown endianness")}}});var ki,Ih=M(()=>{"use strict";Cr();Qe();ki=class extends Vt{constructor(e){super(e)}getFunctions(){return{...this.setFragColor(),...this.getColorAsFloat()}}getCustomTypes(){return{}}setFragColor(){let e=de(this.context.glContext.version);return{setFragColor:new Z(`
        void setFragColor(float value) {
            ${e.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new Z(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}});var Bi,Ah=M(()=>{"use strict";Cr();Bi=class r extends Vt{constructor(e){super(e)}getFunctions(){return{...this.bcastIndex(),...this.bcastMatmulIndex(),...this.offsetToIndices(),...this.indicesToOffset(),...this.incrementIndices()}}getCustomTypes(){return{}}bcastIndex(){let e=this.context.outputTextureLayout.shape.length,n={};return this.context.programInfo.inputNames.forEach((t,o)=>{let i=this.context.inputTextureLayouts[o].unpackedShape;if(i.length<=e){let s=i.length,a=e-s,u=`bcastIndices_${t}`,l="";for(let h=0;h<s;++h)l+=`
          realIndices[${h}] = int( mod(float(bcastedIndices[${a+h}]), ${i[h]}.0) );
          `;let c=`
        void ${u} (int bcastedIndices[${e}], out int realIndices[${s}]) {
          ${l}
        }
        `;n[u]=new Z(c)}}),n}bcastMatmulIndex(){let e=this.context.outputTextureLayout.shape.length,n={};return this.context.programInfo.inputNames.forEach((t,o)=>{let i=this.context.inputTextureLayouts[o].shape;if(!(i.length<2||i.length>e)){let s=i.length,a=e-s,u=`bcastMatmulIndices_${t}`,l="";for(let h=0;h<s-2;++h)l+=`
          realIndices[${h}] = int( mod(float(bcastedIndices[${a+h}]), ${i[h]}.0) );
          `;let c=`
        void ${u}(int bcastedIndices[${e}], out int realIndices[${s}]) {
          ${l}
          realIndices[${s-1}] = bcastedIndices[${e-1}];
          realIndices[${s-2}] = bcastedIndices[${e-2}];
        }
        `;n[u]=new Z(c)}}),n}indicesToOffset(){let e={};return this.context.programInfo.inputNames.forEach((n,t)=>{let o=this.context.inputTextureLayouts[t].shape,i=this.context.inputTextureLayouts[t].strides,s=o.length,a=`indicesToOffset_${n}`;e[a]=new Z(r.indexToOffsetSingle(a,s,i)),a=`indicesToOffset_${n}_T`,e[a]=new Z(r.indexToOffsetSingle(a,s,i.slice().reverse()))}),e}static indexToOffsetSingle(e,n,t){let o="";for(let i=n-1;i>=0;--i)o+=`
        offset += indices[${i}] * ${t[i]};
        `;return`
      int ${e}(int indices[${n}]) {
        int offset = 0;
        ${o}
        return offset;
      }
      `}offsetToIndices(){let e={};return this.context.programInfo.inputNames.forEach((n,t)=>{let o=this.context.inputTextureLayouts[t].shape,i=this.context.inputTextureLayouts[t].strides,s=o.length,a=`offsetToIndices_${n}`;e[a]=new Z(r.offsetToIndicesSingle(a,s,i)),a=`offsetToIndices_${n}_T`,e[a]=new Z(r.offsetToIndicesSingle(a,s,i.slice().reverse()))}),e}static offsetToIndicesSingle(e,n,t){let o=[];for(let i=0;i<n-1;++i)o.push(`
      indices[${i}] = offset / ${t[i]};`),o.push(`
        offset -= indices[${i}] * ${t[i]};`);return o.push(`
      indices[${n-1}] = offset;`),`
      void ${e}(int offset, out int indices[${n}]) {
        ${o.join("")}
      }
      `}incrementIndices(){let e={};return this.context.programInfo.inputNames.forEach((n,t)=>{let o=this.context.inputTextureLayouts[t].shape,i=o.length,s=`incrementIndices_${n}`,a="";for(let l=0;l<i;++l)a+=`
        shape[${l}] = ${o[l]};`;let u=`
        void ${s}(int axis, out int indices[${i}]) {
          int shape[${i}];
          ${a};
          for(int i = ${i} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;e[s]=new Z(u)}),e}}});var Ri,_h=M(()=>{"use strict";Cr();Ri=class extends Vt{constructor(e){super(e)}getCustomTypes(){return{}}getFunctions(){return{...this.binaryVecFunctions(),...this.copyVec(),...this.setVecItem(),...this.getVecItem()}}binaryVecFunctions(){let n=this.context.outputTextureLayout.shape.length,t={add:"+=",sub:"-=",mul:"*=",div:"/="},o={};for(let i in t){let s=`${i}Vec`,a="";for(let l=0;l<n;++l)a+=`
          dest[${l}] ${t[i]} src[${l}];
          `;let u=`
        void ${s}(int src[${n}], out int dest[${n}]) {
          ${a}
        }
        `;o[s]=new Z(u)}return o}copyVec(){let n=this.context.outputTextureLayout.shape.length,t="";for(let i=0;i<n;++i)t+=`
        dest[${i}] = src[${i}];
        `;let o=`
      void copyVec(int src[${n}], out int dest[${n}]) {
        ${t}
      }
      `;return{copyVec:new Z(o)}}setVecItem(){let n=this.context.outputTextureLayout.shape.length,t=`
        if(index < 0)
            index =${n} + index;
        if (index == 0)
            m[0] = value;
        `;for(let i=1;i<n-1;++i)t+=`
        else if (index == ${i})
            m[${i}] = value;
            `;t+=`
        else
            m[${n-1}] = value;
        `;let o=`
      void setVecItem(out int m[${n}], int index, int value) {
        ${t}
      }
        `;return{setVecItem:new Z(o)}}getVecItem(){let n=this.context.outputTextureLayout.shape.length,t=`
        if(index < 0)
            index = ${n} + index;
        if (index == 0)
            return m[0];
      `;for(let i=1;i<n-1;++i)t+=`
        else if (index == ${i})
            return m[${i}];
      `;t+=`
        else
            return m[${n-1}];
        `;let o=`
      int getVecItem(int m[${n}], int index) {
        ${t}
      }
    `;return{getVecItem:new Z(o)}}}});var ks,Oh=M(()=>{"use strict";$h();Sh();Ih();Ah();_h();ks={encoding:Di,fragcolor:ki,vec:Ri,shapeUtils:Bi,coordinates:Pi}});var Mi,Ch=M(()=>{"use strict";Cr();wh();Oh();Qe();Mi=class{constructor(e,n,t,o){this.libs={};this.glslLibRoutineDependencyGraph={};this.context=new xi(e,n,t,o),Object.keys(ks).forEach(s=>{let a=new ks[s](this.context);this.libs[s]=a});let i=this.glslLibRoutineDependencyGraph;for(let s in this.libs){let u=this.libs[s].getFunctions();for(let l in u){let c=s+"."+l,h;i[c]?(h=i[c],h.routineBody=u[l].routineBody):(h=new bo(c,u[l].routineBody),i[c]=h);let m=u[l].dependencies;if(m)for(let b=0;b<m.length;++b)if(i[m[b]])h.addDependency(i[m[b]]);else{let x=new bo(m[b]);i[m[b]]=x,h.addDependency(x)}}}}preprocess(){let e=this.context.programInfo,n=e.shaderSource;return this.context.programInfo.hasMain||(n=`${n}
      ${ud(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),n=xh(n),`${sd(this.context.glContext.version)}
    ${this.getUniforms(e.inputNames,e.variables)}
    ${this.getImports(n)}
    ${n}`}getImports(e){let n=this.selectGlslLibRoutinesToBeIncluded(e);if(n.length===0)return"";let t="";for(let o=0;o<n.length;++o)if(n[o].routineBody)t+=n[o].routineBody+`
`;else throw new Error(`Missing body for the Glsl Library routine: ${n[o].name}`);return t}selectGlslLibRoutinesToBeIncluded(e){let n=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(t=>{let o=t.split(".")[1];e.indexOf(o)!==-1&&n.push(this.glslLibRoutineDependencyGraph[t])}),wi.returnOrderedNodes(n)}getUniforms(e,n){let t=[];if(e)for(let o of e)t.push(`uniform sampler2D ${o};`);if(n)for(let o of n)t.push(`uniform ${o.type} ${o.name}${o.arrayLength?`[${o.arrayLength}]`:""};`);return t.join(`
`)}}});var Li,Eh=M(()=>{"use strict";Lt();Nt();Ch();Qe();Li=class{constructor(e,n,t){this.profiler=e;this.glContext=n;this.textureLayoutStrategy=t;this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,n){this.repo.set(e,n)}run(e,n,t){this.profiler.event("op",`ProgramManager.run ${e.programInfo.name??"unknown kernel"}`,()=>{let o=this.glContext.gl,i=e.program;o.useProgram(i);try{this.bindOutput(t),this.attributesBound||this.bindAttributes(e.attribLocations),this.bindUniforms(e.uniformLocations,e.programInfo.variables??[],n)}catch(s){throw ze.error("ProgramManager",e.programInfo.shaderSource),s}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(e=>this.glContext.deleteProgram(e.program))}build(e,n,t){return this.profiler.event("backend","ProgramManager.build",()=>{let o=new Mi(this.glContext,e,n,t),i=o.preprocess(),s=this.compile(i);return{programInfo:e,program:s,uniformLocations:this.getUniformLocations(s,o.context.programInfo.inputNames,o.context.programInfo.variables),attribLocations:this.getAttribLocations(s)}})}compile(e){if(!this.vertexShader){ze.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");let o=ad(this.glContext.version);this.vertexShader=this.glContext.compileShader(o,this.glContext.gl.VERTEX_SHADER)}we.debug&&ze.verbose("ProrgramManager",`FragShader:
${e}
`);let n=this.glContext.compileShader(e,this.glContext.gl.FRAGMENT_SHADER),t=this.glContext.createProgram(this.vertexShader,n);return this.glContext.deleteShader(n),t}bindOutput(e){let n=e.width,t=e.height;ze.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${n}/${t}, shape=${e.shape}, type=${e.tensor.type}`),this.glContext.attachFramebuffer(e.texture,n,t)}bindAttributes(e){let n=e.position,t=e.textureCoord;this.glContext.setVertexAttributes(n,t),this.attributesBound=!0}bindUniforms(e,n,t){let o=this.glContext.gl,i=0;for(let{name:s,type:a,location:u,arrayLength:l}of e){let c=n.find(h=>h.name===s)?.data;if(a!=="sampler2D"&&!c)throw new Error(`variable '${s}' does not have data defined in program info`);switch(a){case"sampler2D":this.bindTexture(t[i],u,i),i++;break;case"float":l?o.uniform1fv(u,c):o.uniform1f(u,c);break;case"int":l?o.uniform1iv(u,c):o.uniform1i(u,c);break;default:throw new Error(`Uniform not implemented: ${a}`)}}}bindTexture(e,n,t){this.glContext.bindTextureToUniform(e.texture,t,n)}getAttribLocations(e){return{position:this.getAttribLocation(e,"position"),textureCoord:this.getAttribLocation(e,"textureCoord")}}getUniformLocations(e,n,t){let o=[];if(n)for(let i of n)o.push({name:i,type:"sampler2D",location:this.getUniformLocation(e,i)});if(t)for(let i of t)o.push({...i,location:this.getUniformLocation(e,i.name)});return o}getUniformLocation(e,n){let o=this.glContext.gl.getUniformLocation(e,n);if(o===null)throw new Error(`Uniform ${n} not found.`);return o}getAttribLocation(e,n){return this.glContext.gl.getAttribLocation(e,n)}}});var Ni,Ph=M(()=>{"use strict";Nt();mo();Ni=class{constructor(e,n,t,o){this.glContext=e;this.layoutStrategy=n;this.profiler=t;this.config=o;this.pendingRead=new Map;o.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(e,n,t,o){let i=this.toEncoderType(e),s=this.glContext.getEncoder(i,n.channels||1,o);if(n.isPacked&&o===1)throw new Error("not implemented");let a=n.width,u=n.height,l,c;if(this.config.reuseTextures){l=`${a}x${u}_${s.format}_${s.internalFormat}_${s.textureType}`,c=this.inUseTextures.get(l),c||(c=[],this.inUseTextures.set(l,c));let m=this.idleTextures.get(l);if(m&&m.length>0){let b=m.pop();return c.push(b),o===1&&this.glContext.updateTexture(b,a,u,s,this.toTextureData(e,t)),b}}ze.verbose("TextureManager",`Creating new texture of size ${n.width}x${n.height}`);let h=this.glContext.allocateTexture(a,u,s,this.toTextureData(e,t));return this.config.reuseTextures&&(c.push(h),this.textureLookup.set(h,l)),h}readTexture(e,n,t){return t||(t=1),this.profiler.event("backend","TextureManager.readTexture",()=>{let o=e.shape.reduce((s,a)=>s*a)*t,i=this.glContext.readTexture(e.texture,e.width,e.height,o,this.toEncoderType(n),t);return this.toTensorData(n,i)})}async readTextureAsync(e,n,t){let o=e.tensor.dataId;if(t||(t=1),this.pendingRead.has(o)){let i=this.pendingRead.get(o);return new Promise(s=>i?.push(s))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(o,[]);let i=e.shape.reduce((l,c)=>l*c)*t;await this.glContext.createAndWaitForFence();let s=this.glContext.readTexture(e.texture,e.width,e.height,i,this.toEncoderType(n),t),a=this.toTensorData(n,s),u=this.pendingRead.get(o);return this.pendingRead.delete(o),u?.forEach(l=>l(a)),a})}readUint8TextureAsFloat(e){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{let n=e.shape.reduce((o,i)=>o*i),t=this.glContext.readTexture(e.texture,e.width,e.height,n*4,"byte",4);return new Float32Array(t.buffer,t.byteOffset,n)})}releaseTexture(e,n){let t;if(this.config.reuseTextures&&(t=this.textureLookup.get(e.texture),t)){n&&this.textureLookup.delete(t);let o=this.inUseTextures.get(t);if(o){let i=o.indexOf(e.texture);if(i!==-1){o.splice(i,1);let s=this.idleTextures.get(t);s||(s=[],this.idleTextures.set(t,s)),s.push(e.texture)}}}(!t||n)&&(ze.verbose("TextureManager",`Deleting texture of size ${e.width}x${e.height}`),this.glContext.deleteTexture(e.texture))}toTensorData(e,n){switch(e){case"int16":return n instanceof Int16Array?n:Int16Array.from(n);case"int32":return n instanceof Int32Array?n:Int32Array.from(n);case"int8":return n instanceof Int8Array?n:Int8Array.from(n);case"uint16":return n instanceof Uint16Array?n:Uint16Array.from(n);case"uint32":return n instanceof Uint32Array?n:Uint32Array.from(n);case"uint8":case"bool":return n instanceof Uint8Array?n:Uint8Array.from(n);case"float32":return n instanceof Float32Array?n:Float32Array.from(n);case"float64":return n instanceof Float64Array?n:Float64Array.from(n);default:throw new Error(`TensorData type ${e} is not supported`)}}toTextureData(e,n){if(n)return n instanceof Float32Array?n:new Float32Array(n)}toEncoderType(e){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}});var Fi,Dh=M(()=>{"use strict";Nt();jl();$d();yh();Eh();Ds();Ph();Fi=class{constructor(e,n){this.backend=e;this.context=n;this.layoutStrategy=new Ei(e.glContext.maxTextureSize),this.programManager=new Li(this.context.profiler,e.glContext,this.layoutStrategy),this.textureManager=new Ni(e.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:e.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=e.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new vi(this)}onGraphInitialized(e){let n=e.getValues().filter(t=>t.from===-1&&t.tensor).map(t=>t.tensor.dataId);this.initializers=new Set(n)}isInitializer(e){return this.initializers?this.initializers.has(e):!1}addInitializer(e){this.initializers.add(e)}getTextureData(e,n){return n?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,n,t=!1){ze.verbose("WebGLSessionHandler","Storing Texture data in cache"),t?this.packedTextureDataCache.set(e,n):this.unpackedTextureDataCache.set(e,n)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.textureManager.releaseTexture(e,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.textureManager.releaseTexture(e,!0)),this.unpackedTextureDataCache=new Map}resolve(e,n,t){let o=Hl(e,n,bh);return{impl:o.opImpl,context:o.opInit?o.opInit(e,t):e}}}});function Lw(r){let e=0;for(;e<r.length&&r[e]();++e);return e-1}var xo,kh=M(()=>{"use strict";Lt();mo();mo();dr();xo=class{constructor(e,n){this.frameBufferBound=!1;this.itemsToPoll=[];this.gl=e,this.version=n,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(e,n,t,o){let i=this.gl,s=i.createTexture();i.bindTexture(i.TEXTURE_2D,s),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE);let a=o?t.encode(o,e*n):null;return i.texImage2D(i.TEXTURE_2D,0,t.internalFormat,e,n,0,t.format,t.textureType,a),this.checkError(),s}updateTexture(e,n,t,o,i){let s=this.gl;s.bindTexture(s.TEXTURE_2D,e);let a=o.encode(i,n*t);s.texSubImage2D(s.TEXTURE_2D,0,0,0,n,t,o.format,o.textureType,a),this.checkError()}attachFramebuffer(e,n,t){let o=this.gl;o.bindTexture(o.TEXTURE_2D,e),o.bindFramebuffer(o.FRAMEBUFFER,this.framebuffer),o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,e,0),this.checkError(),o.viewport(0,0,n,t),o.scissor(0,0,n,t)}readTexture(e,n,t,o,i,s){let a=this.gl;s||(s=1),this.frameBufferBound||this.attachFramebuffer(e,n,t);let u=this.getEncoder(i,s),l=u.allocate(n*t);return a.bindTexture(a.TEXTURE_2D,e),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e,0),a.readPixels(0,0,n,t,a.RGBA,u.textureType,l),this.checkError(),u.decode(l,o)}isFramebufferReady(){return!0}getActiveTexture(){let e=this.gl;return`TEXTURE${e.getParameter(this.gl.ACTIVE_TEXTURE)-e.TEXTURE0}`}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(e,n){let t=this.gl;t.vertexAttribPointer(e,3,t.FLOAT,!1,20,0),t.enableVertexAttribArray(e),n!==-1&&(t.vertexAttribPointer(n,2,t.FLOAT,!1,20,12),t.enableVertexAttribArray(n)),this.checkError()}createProgram(e,n){let t=this.gl,o=t.createProgram();return t.attachShader(o,e),t.attachShader(o,n),t.linkProgram(o),o}compileShader(e,n){let t=this.gl,o=t.createShader(n);if(!o)throw new Error(`createShader() returned null with type ${n}`);if(t.shaderSource(o,e),t.compileShader(o),t.getShaderParameter(o,t.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${t.getShaderInfoLog(o)}
Shader source:
${e}`);return o}deleteShader(e){this.gl.deleteShader(e)}bindTextureToUniform(e,n,t){let o=this.gl;o.activeTexture(o.TEXTURE0+n),this.checkError(),o.bindTexture(o.TEXTURE_2D,e),this.checkError(),o.uniform1i(t,n),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(we.debug){let e=this.gl,n=e.getError(),t="";switch(n){case e.NO_ERROR:return;case e.INVALID_ENUM:t="INVALID_ENUM";break;case e.INVALID_VALUE:t="INVALID_VALUE";break;case e.INVALID_OPERATION:t="INVALID_OPERATION";break;case e.INVALID_FRAMEBUFFER_OPERATION:t="INVALID_FRAMEBUFFER_OPERATION";break;case e.OUT_OF_MEMORY:t="OUT_OF_MEMORY";break;case e.CONTEXT_LOST_WEBGL:t="CONTEXT_LOST_WEBGL";break;default:t=`Unknown WebGL Error: ${n.toString(16)}`}throw new Error(t)}}deleteTexture(e){this.gl.deleteTexture(e)}deleteProgram(e){this.gl.deleteProgram(e)}getEncoder(e,n,t=0){if(this.version===2)return new bi(this.gl,n);switch(e){case"float":return t===1||this.isRenderFloat32Supported?new ho(this.gl,n):new ho(this.gl,n,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new yi(this.gl,n);default:throw new Error(`Invalid dataType: ${e}`)}}clearActiveTextures(){let e=this.gl;for(let n=0;n<this.maxTextureImageUnits;++n)e.activeTexture(e.TEXTURE0+n),e.bindTexture(e.TEXTURE_2D,null)}dispose(){if(this.disposed)return;let e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(this.framebuffer),e.bindBuffer(e.ARRAY_BUFFER,null),e.deleteBuffer(this.vertexbuffer),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),e.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){let e=this.gl,n=e.createBuffer();if(!n)throw new Error("createBuffer() returned null");let t=this.createDefaultGeometry();return e.bindBuffer(e.ARRAY_BUFFER,n),e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW),this.checkError(),n}createFramebuffer(){let e=this.gl.createFramebuffer();if(!e)throw new Error("createFramebuffer returned null");return e}queryVitalParameters(){let e=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=e.getParameter(e.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){let e=this.gl,n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);let t=this.version===2?e.RGBA32F:e.RGBA;e.texImage2D(e.TEXTURE_2D,0,t,1,1,0,e.RGBA,e.FLOAT,null);let o=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(o),i}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){let e=this.gl,n,t,o,i,s;try{n=e.createTexture(),t=e.createFramebuffer(),e.bindTexture(e.TEXTURE_2D,n);let a=this.version===2?e.RGBA32F:e.RGBA;return e.texImage2D(e.TEXTURE_2D,0,a,1,1,0,e.RGBA,e.FLOAT,null),e.bindFramebuffer(e.FRAMEBUFFER,t),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0),e.enable(e.BLEND),o=e.createShader(e.VERTEX_SHADER),!o||(e.shaderSource(o,"void main(){}"),e.compileShader(o),i=e.createShader(e.FRAGMENT_SHADER),!i)||(e.shaderSource(i,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),e.compileShader(i),s=e.createProgram(),!s)?!1:(e.attachShader(s,o),e.attachShader(s,i),e.linkProgram(s),e.useProgram(s),e.drawArrays(e.POINTS,0,1),e.getError()===e.NO_ERROR)}finally{e.disable(e.BLEND),s&&e.deleteProgram(s),o&&e.deleteShader(o),i&&e.deleteShader(i),t&&(e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(t)),n&&(e.bindTexture(e.TEXTURE_2D,null),e.deleteTexture(n))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let e=this.gl,n=this.disjointTimerQueryWebgl2Extension,t=e.createQuery();return e.beginQuery(n.TIME_ELAPSED_EXT,t),t}else throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let e=this.gl,n=this.disjointTimerQueryWebgl2Extension;e.endQuery(n.TIME_ELAPSED_EXT);return}else throw new Error("WebGL1 profiling currently not supported")}isTimerResultAvailable(e){let n=!1,t=!1;if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let o=this.gl,i=this.disjointTimerQueryWebgl2Extension;n=o.getQueryParameter(e,o.QUERY_RESULT_AVAILABLE),t=o.getParameter(i.GPU_DISJOINT_EXT)}else throw new Error("WebGL1 profiling currently not supported");return n&&!t}getTimerResult(e){let n=0;if(this.version===2){let t=this.gl;n=t.getQueryParameter(e,t.QUERY_RESULT),t.deleteQuery(e)}else throw new Error("WebGL1 profiling currently not supported");return n/1e6}async waitForQueryAndGetTime(e){return await os(()=>this.isTimerResultAvailable(e)),this.getTimerResult(e)}async createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let n,t=e,o=t.fenceSync(t.SYNC_GPU_COMMANDS_COMPLETE,0);return e.flush(),o===null?n=()=>!0:n=()=>{let i=t.clientWaitSync(o,0,0);return i===t.ALREADY_SIGNALED||i===t.CONDITION_SATISFIED},{query:o,isFencePassed:n}}async pollFence(e){return new Promise(n=>{this.addItemToPoll(()=>e.isFencePassed(),()=>n())})}pollItems(){let e=Lw(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=e;++n){let{resolveFn:t}=this.itemsToPoll[n];t()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}async addItemToPoll(e,n){this.itemsToPoll.push({isDoneFn:e,resolveFn:n}),!(this.itemsToPoll.length>1)&&await os(()=>(this.pollItems(),this.itemsToPoll.length===0))}}});function Bs(r){let e;if((!r||r==="webgl2")&&"webgl2"in zn?e=zn.webgl2:(!r||r==="webgl")&&"webgl"in zn&&(e=zn.webgl),!e)try{let t=Fw();e=Bh(t,r)}catch{let o=Nw();e=Bh(o,r)}r=r||e.version===1?"webgl":"webgl2";let n=e.gl;return zn[r]=e,n.isContextLost()?(delete zn[r],Bs(r)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),e)}function Bh(r,e){let n={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1},t,o=n;if((!e||e==="webgl2")&&(t=r.getContext("webgl2",o),t))try{return new xo(t,2)}catch(i){ze.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${i}`)}if((!e||e==="webgl")&&(t=r.getContext("webgl",o)||r.getContext("experimental-webgl",o),t))try{return new xo(t,1)}catch(i){ze.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${i}`)}throw new Error("WebGL is not supported")}function Nw(){if(typeof document>"u")throw new TypeError("failed to create canvas: document is not supported");let r=document.createElement("canvas");return r.width=1,r.height=1,r}function Fw(){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}var zn,Rh=M(()=>{"use strict";Nt();kh();zn={}});var zi,Mh=M(()=>{"use strict";Lt();Nt();Dh();Rh();zi=class{get contextId(){return we.webgl.contextId}set contextId(e){we.webgl.contextId=e}get matmulMaxBatchSize(){return we.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(e){we.webgl.matmulMaxBatchSize=e}get textureCacheMode(){return we.webgl.textureCacheMode}set textureCacheMode(e){we.webgl.textureCacheMode=e}get pack(){return we.webgl.pack}set pack(e){we.webgl.pack=e}get async(){return we.webgl.async}set async(e){we.webgl.async=e}initialize(){try{return this.glContext=Bs(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),ze.setWithEnv(we),we.webgl.context||Object.defineProperty(we.webgl,"context",{value:this.glContext.gl}),ze.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(e){return ze.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${e}`),!1}}createSessionHandler(e){return new Fi(this,e)}dispose(){this.glContext.dispose()}}});async function Rs(r){if(r){let e=typeof r=="string"?[r]:r;for(let n of e){let t=Lh.get(n);if(t)return t;let o=await Gw(n);if(o)return o}}else return Rs(["webgl"]);throw new Error("no available backend to use")}async function Gw(r){let e=zw;if(typeof e[r]<"u"&&Vw(e[r])){let n=e[r],t=n.initialize();if(typeof t=="object"&&"then"in t&&(t=await t),t)return Lh.set(r,n),n}}function Vw(r){let e=r;return"initialize"in e&&typeof e.initialize=="function"&&"createSessionHandler"in e&&typeof e.createSessionHandler=="function"&&"dispose"in e&&typeof e.dispose=="function"}var Lh,zw,Nh=M(()=>{"use strict";Mh();Lh=new Map,zw={webgl:new zi}});var Ms,Gi,Fh=M(()=>{"use strict";Nt();Ms=class{constructor(e,n){this.op=e;this.node=n}},Gi=class{constructor(e,n,t){this.graph=e;this.profiler=t;this.initialize(n)}initialize(e){this.profiler.event("session","ExecutionPlan.initialize",()=>{let n=this.graph.getNodes();if(n.length!==e.length)throw new Error("The size of nodes and OPs do not match.");this._ops=e.map((t,o)=>new Ms(t,n[o])),this.reset(),this._starter=[],this._ops.forEach((t,o)=>{let i=!0;for(let s of t.node.inputs)if(!this._values[s]&&this.graph.getInputIndices().indexOf(s)===-1){i=!1;break}i&&this._starter.push(o)})})}reset(){this._values=this.graph.getValues().map(e=>e.tensor)}async execute(e,n){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();let t=e.createInferenceHandler(),o=this.graph.getInputIndices();if(n.length!==o.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${n.length} expected: ${o.length}`);n.forEach((c,h)=>{let m=o[h];this._values[m]=c});let i=this._starter.slice(0),s=this.graph.getValues(),a=this.graph.getNodes(),u=0;for(;u<i.length;){let c=i[u++],h=this._ops[c],m=h.node.inputs.map(T=>this._values[T]);if(m.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${h.node}`);let b=m;ze.verbose("ExecPlan",`Runing op:${h.node.name} (${b.map((T,E)=>`'${h.node.inputs[E]}': ${T.type}[${T.dims.join(",")}]`).join(", ")})`);let x=await this.profiler.event("node",h.node.name,async()=>h.op.impl(t,b,h.op.context));if(x.length!==h.node.outputs.length)throw new Error("the size of output does not match model definition.");x.forEach((T,E)=>{let _=h.node.outputs[E];if(this._values[_])throw new Error(`output [${_}] already has value: op:${h.node.name}`);this._values[_]=T});let y=new Set;x.forEach((T,E)=>{let _=h.node.outputs[E];for(let C of s[_].to){let D=a[C],z=!0;for(let F of D.inputs)if(!this._values[F]){z=!1;break}z&&y.add(C)}}),i.push(...y)}let l=[];for(let c=0;c<this.graph.getOutputIndices().length;c++){let h=this.graph.getOutputIndices()[c],m=this._values[h];if(m===void 0)throw new Error(`required output [${h}] does not have value`);h===0?await m.getData():m.data,l.push(m)}return ze.verbose("ExecPlan","disposing of inferenceHandler"),t.dispose(),l})}}});var Oe,Ht,wo,zh=M(()=>{"use strict";so();Oe=On(Dn());dn();Fe();Ht=ie.experimental.fbs,wo=class r{constructor(e){if(this._attributes=new Map,e!=null){for(let n of e)n instanceof Oe.onnx.AttributeProto?this._attributes.set(n.name,[r.getValue(n),r.getType(n)]):n instanceof Ht.Attribute&&this._attributes.set(n.name(),[r.getValue(n),r.getType(n)]);if(this._attributes.size<e.length)throw new Error("duplicated attribute names")}}set(e,n,t){this._attributes.set(e,[t,n])}delete(e){this._attributes.delete(e)}getFloat(e,n){return this.get(e,"float",n)}getInt(e,n){return this.get(e,"int",n)}getString(e,n){return this.get(e,"string",n)}getTensor(e,n){return this.get(e,"tensor",n)}getFloats(e,n){return this.get(e,"floats",n)}getInts(e,n){return this.get(e,"ints",n)}getStrings(e,n){return this.get(e,"strings",n)}getTensors(e,n){return this.get(e,"tensors",n)}get(e,n,t){let o=this._attributes.get(e);if(o===void 0){if(t!==void 0)return t;throw new Error(`required attribute not found: ${e}`)}if(o[1]!==n)throw new Error(`type mismatch: expected ${n} but got ${o[1]}`);return o[0]}static getType(e){let n=e instanceof Oe.onnx.AttributeProto?e.type:e.type();switch(n){case Oe.onnx.AttributeProto.AttributeType.FLOAT:return"float";case Oe.onnx.AttributeProto.AttributeType.INT:return"int";case Oe.onnx.AttributeProto.AttributeType.STRING:return"string";case Oe.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case Oe.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case Oe.onnx.AttributeProto.AttributeType.INTS:return"ints";case Oe.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case Oe.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${Oe.onnx.AttributeProto.AttributeType[n]}`)}}static getValue(e){let n=e instanceof Oe.onnx.AttributeProto?e.type:e.type();if(n===Oe.onnx.AttributeProto.AttributeType.GRAPH||n===Oe.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");let t=this.getValueNoCheck(e);if(n===Oe.onnx.AttributeProto.AttributeType.INT&&Et.isLong(t))return Et.longToNumber(t);if(n===Oe.onnx.AttributeProto.AttributeType.INTS){let o=t,i=new Array(o.length);for(let s=0;s<o.length;s++){let a=o[s];i[s]=Et.longToNumber(a)}return i}if(n===Oe.onnx.AttributeProto.AttributeType.TENSOR)return e instanceof Oe.onnx.AttributeProto?dt.fromProto(t):dt.fromOrtTensor(t);if(n===Oe.onnx.AttributeProto.AttributeType.TENSORS){if(e instanceof Oe.onnx.AttributeProto)return t.map(i=>dt.fromProto(i));if(e instanceof Ht.Attribute)return t.map(i=>dt.fromOrtTensor(i))}return n===Oe.onnx.AttributeProto.AttributeType.STRING&&e instanceof Oe.onnx.AttributeProto?po(t):n===Oe.onnx.AttributeProto.AttributeType.STRINGS&&e instanceof Oe.onnx.AttributeProto?t.map(po):t}static getValueNoCheck(e){return e instanceof Oe.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(e):this.getValueNoCheckFromOrtFormat(e)}static getValueNoCheckFromOnnxFormat(e){switch(e.type){case Oe.onnx.AttributeProto.AttributeType.FLOAT:return e.f;case Oe.onnx.AttributeProto.AttributeType.INT:return e.i;case Oe.onnx.AttributeProto.AttributeType.STRING:return e.s;case Oe.onnx.AttributeProto.AttributeType.TENSOR:return e.t;case Oe.onnx.AttributeProto.AttributeType.GRAPH:return e.g;case Oe.onnx.AttributeProto.AttributeType.FLOATS:return e.floats;case Oe.onnx.AttributeProto.AttributeType.INTS:return e.ints;case Oe.onnx.AttributeProto.AttributeType.STRINGS:return e.strings;case Oe.onnx.AttributeProto.AttributeType.TENSORS:return e.tensors;case Oe.onnx.AttributeProto.AttributeType.GRAPHS:return e.graphs;default:throw new Error(`unsupported attribute type: ${Oe.onnx.AttributeProto.AttributeType[e.type]}`)}}static getValueNoCheckFromOrtFormat(e){switch(e.type()){case Ht.AttributeType.FLOAT:return e.f();case Ht.AttributeType.INT:return e.i();case Ht.AttributeType.STRING:return e.s();case Ht.AttributeType.TENSOR:return e.t();case Ht.AttributeType.GRAPH:return e.g();case Ht.AttributeType.FLOATS:return e.floatsArray();case Ht.AttributeType.INTS:{let n=[];for(let t=0;t<e.intsLength();t++)n.push(e.ints(t));return n}case Ht.AttributeType.STRINGS:{let n=[];for(let t=0;t<e.stringsLength();t++)n.push(e.strings(t));return n}case Ht.AttributeType.TENSORS:{let n=[];for(let t=0;t<e.tensorsLength();t++)n.push(e.tensors(t));return n}default:throw new Error(`unsupported attribute type: ${Ht.AttributeType[e.type()]}`)}}}});var Ns,Vi,Fs,hr,Wi,Ls,Gh=M(()=>{"use strict";zh();so();Ns=On(Dn());dn();Fe();Vi=ie.experimental.fbs,Fs={from:(r,e)=>new Ls(r,e)},hr=class{constructor(e){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,e&&(this.type=yt.tensorValueTypeFromProto(e.type.tensorType))}get from(){return this._from}get to(){return this._to}},Wi=class{constructor(e,n){e instanceof Ns.onnx.NodeProto?(this.name=e.name,this.opType=e.opType,this.attributes=new wo(e.attribute)):e instanceof Vi.Node&&(this.name=n??e.name(),this.opType=e.opType(),this.attributes=new wo(yt.tensorAttributesFromORTFormat(e))),this.inputs=[],this.outputs=[],this.executeNode=!0}},Ls=class{constructor(e,n){if(!e)throw new TypeError("graph is empty");this.buildGraph(e),this.transformGraph(n),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(e){if(e instanceof Ns.onnx.GraphProto)this.buildGraphFromOnnxFormat(e);else if(e instanceof Vi.Graph)this.buildGraphFromOrtFormat(e);else throw new TypeError("Graph type is not supported.")}buildGraphFromOnnxFormat(e){let n=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let t=new Map;if(!e.input)throw new Error("missing information in graph: input");let o=[];for(let i of e.input){if(n.has(i.name))throw new Error(`duplicated input name: ${i.name}`);let s=this._allData.push(new hr(i))-1;n.set(i.name,s),o.push(i.name)}if(!e.initializer)throw new Error("missing information in graph: initializer");for(let i of e.initializer){let s=n.get(i.name);if(s===void 0){let a=new hr;a.type={shape:{dims:yt.tensorDimsFromProto(i.dims)},tensorType:yt.tensorDataTypeFromProto(i.dataType)},s=this._allData.push(a)-1,n.set(i.name,s)}this._allData[s]._from=-1,this._allData[s].tensor=dt.fromProto(i)}for(let i=0;i<this._allData.length;i++)this._allData[i].tensor||(this._allInputIndices.push(i),this._allInputNames.push(o[i]));if(!e.output)throw new Error("missing information in graph: output");for(let i of e.output){if(n.has(i.name))throw new Error(`duplicated output name: ${i.name}`);let s=this._allData.push(new hr(i))-1;n.set(i.name,s),this._allOutputIndices.push(s),this._allOutputNames.push(i.name)}if(!e.node)throw new Error("missing information in graph: node");for(let i of e.node){if(!i.name)for(let a=0;;a++){let u=`unnamed_${i.opType}_${a}`;if(!t.has(u)){i.name=u;break}}if(t.has(i.name))throw new Error(`duplicated node name: ${i.name}`);let s=this._nodes.push(new Wi(i))-1;t.set(i.name,s)}for(let i=0;i<this._nodes.length;i++){let s=this._nodes[i],a=e.node[i];if(!a.output)throw new Error(`missing output for node: ${a.name}`);for(let u of a.output){let l=n.get(u);if(typeof l>"u"&&(l=this._allData.push(new hr)-1,n.set(u,l)),s.outputs.push(l),this._allData[l]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${l}`);if(this._allData[l]._from=i,a.opType==="Constant"){if(!a.attribute||a.attribute.length!==1||!a.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!a.output||a.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");s.outputs.pop(),s.executeNode=!1,this._allData[l]._from=-1,this._allData[l].tensor=dt.fromProto(a.attribute[0].t)}}}for(let i=0;i<this._nodes.length;i++){let s=this._nodes[i],a=e.node[i];if(!a.input)throw new Error(`missing input for node: ${a.name}`);for(let u of a.input){let l=n.get(u);if(typeof l>"u"){if(u===""&&(a.input.length===3||a.input.length===4)&&a.opType==="Resize")continue;throw new Error(`unrecognized input '${u}' for node: ${a.name}`)}s.inputs.push(l),this._allData[l]._to.push(i)}}return!0}buildGraphFromOrtFormat(e){let n=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let t=new Map,o=[];for(let i=0;i<e.inputsLength();i++){let s=e.inputs(i);if(n.has(s))throw new Error(`duplicated input name: ${s}`);for(let a=0;a<e.nodeArgsLength();a++)if(e.nodeArgs(a)?.name()===s){let u=new hr;if(e.nodeArgs(a)?.type()?.valueType()!==Vi.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");let c=e.nodeArgs(a).type().value(new Vi.TensorTypeAndShape),h=yt.tensorDataTypeFromProto(c.elemType()),m=c.shape(),b=[];for(let y=0;y<m.dimLength();y++)b.push(Et.longToNumber(m.dim(y).value().dimValue()));u.type={shape:{dims:b},tensorType:h};let x=this._allData.push(u)-1;n.set(s,x),o.push(s)}}for(let i=0;i<e.initializersLength();i++){let s=e.initializers(i),a=n.get(s.name());if(a===void 0){let u=new hr,l=yt.tensorDimsFromORTFormat(s),c=yt.tensorDataTypeFromProto(s.dataType());u.type={shape:{dims:l},tensorType:c},a=this._allData.push(u)-1,n.set(s.name(),a)}this._allData[a]._from=-1,this._allData[a].tensor=dt.fromOrtTensor(s)}for(let i=0;i<this._allData.length;i++)this._allData[i].tensor||(this._allInputIndices.push(i),this._allInputNames.push(o[i]));for(let i=0;i<e.outputsLength();i++){let s=e.outputs(i);if(n.has(s))throw new Error(`duplicated output name: ${s}`);let a=this._allData.push(new hr)-1;n.set(s,a),this._allOutputIndices.push(a),this._allOutputNames.push(s)}if(!e.nodes)throw new Error("missing information in graph: node");for(let i=0;i<e.nodesLength();i++){let s=e.nodes(i),a=s.name();if(!a)for(let l=0;a=`unnamed_${s.opType()}_${l}`,!!t.has(a);l++);if(t.has(a))throw new Error(`duplicated node name: ${a}`);let u=this._nodes.push(new Wi(s,a))-1;t.set(a,u)}for(let i=0;i<this._nodes.length;i++){let s=this._nodes[i],a=e.nodes(i);if(a==null)throw new Error(`No node exists at index ${i}`);if(a?.outputsLength()===0)throw new Error(`missing output for node: ${a.name}`);for(let u=0;u<a?.outputsLength();u++){let l=a?.outputs(u),c=n.get(l);if(typeof c>"u"&&(c=this._allData.push(new hr)-1,n.set(l,c)),s.outputs.push(c),this._allData[c]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${c}`);if(this._allData[c]._from=i,a.opType()==="Constant"){if(a.attributesLength()!==1||!a.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(a.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");s.outputs.pop(),s.executeNode=!1,this._allData[c]._from=-1,this._allData[c].tensor=dt.fromOrtTensor(a.attributes(0).t())}}}for(let i=0;i<this._nodes.length;i++){let s=this._nodes[i],a=e.nodes(i);if(a.inputsLength()===0)throw new Error(`missing input for node: ${a.name}`);for(let u=0;u<a.inputsLength();u++){let l=a.inputs(u),c=n.get(l);if(typeof c>"u")throw new Error(`unrecognized input '${l}' for node: ${a.name()}`);s.inputs.push(c),this._allData[c]._to.push(i)}}}checkIsAcyclic(){let e=new Set;this._allInputIndices.forEach(o=>{this._allData[o]._to.forEach(s=>{e.add(s)})});let n=Array.from(e),t=new Array(this._nodes.length).fill("white");for(;n.length>0;){let o=n.pop();t[o]==="gray"?t[o]="black":(n.push(o),t[o]="gray",this._nodes[o].outputs.forEach(i=>{let s=this._allData[i];if(typeof s.tensor<"u")throw new Error("node outputs should not be initialized");if(s._from!==o)throw new Error("from property of the Value object doesn't match index of Node being processed");s._to.forEach(a=>{if(t[a]==="gray")throw new Error("model graph is cyclic");t[a]==="white"&&n.push(a)})}))}}transformGraph(e){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),e&&e.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let e=0,n=new Array(this._nodes.length,0),t=0;for(let o=0;o<this._nodes.length;o++)n[o]=t,this._nodes[o].executeNode?(t!==o&&(this._nodes[t]=this._nodes[o]),t++):this._nodes[o].outputs.forEach(i=>{this._allData[i]._from=-2});this._nodes.splice(t,this._nodes.length-t);for(let o=0;o<this._allData.length;o++){let i=this._allData[o];i._from!==void 0&&i._from!==-1&&i._from!==-2&&(i._from=n[i._from]);for(let s=0;s<i._to.length;s++)if(i._to[s]>=0)i._to[s]=n[i._to[s]];else throw new Error("Trying to update a removed node")}e=0;for(let o=0;o<this._allData.length;o++){if(this._allData[o].from===-2&&this._allOutputIndices.indexOf(o+e)===-1){e++,this._allData.splice(o,1),o--;continue}if(e>0){let i=-1;this._allData[o].from!==void 0&&this._allData[o].from!==-1?(i=this._nodes[this._allData[o].from].outputs.indexOf(o+e),i!==-1&&(this._nodes[this._allData[o].from].outputs[i]=o)):(i=this._allInputIndices.indexOf(o+e),i!==-1&&(this._allInputIndices[i]=o)),this._allData[o].to.forEach(s=>{i=this._nodes[s].inputs.indexOf(o+e),i!==-1&&(this._nodes[s].inputs[i]=o)}),this._allData[o].to.length===0&&(i=this._allOutputIndices.indexOf(o+e),i!==-1&&(this._allOutputIndices[i]=o))}}}deleteNode(e){let n=this._nodes[e];if(n.outputs.length>1){for(let a=1;a<n.outputs.length;a++)if(this._allData[n.outputs[a]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}n.executeNode=!1;let t=n.inputs[0],o=n.outputs[0],i=this._allData[o].to;for(let a=0;a<n.inputs.length;a++){let u=this._allData[n.inputs[a]].to.indexOf(e);if(u===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[n.inputs[a]].to.splice(u,1)}this._allData[o]._to=[];let s=this._allOutputIndices.indexOf(o);if(s!==-1&&(this._allOutputIndices[s]=t),i&&i.length>0)for(let a of i){let u=this._nodes[a].inputs.indexOf(o);if(u===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[a].inputs[u]=t,this._allData[t].to.push(a)}}removeAllDropoutNodes(){let e=0;for(let n of this._nodes){if(n.opType==="Dropout"){if(n.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(n.outputs.length!==1&&n.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(n.outputs.length===2&&this._allData[n.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(e)}e++}}removeAllIdentityNodes(){let e=0;for(let n of this._nodes)n.opType==="Identity"&&this.deleteNode(e),e++}isActivation(e){switch(e.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(let e of this._nodes)if(e.opType==="Conv"){let n=this._allData[e.outputs[0]]._to;if(n.length===1&&this.isActivation(this._nodes[n[0]])){let t=this._nodes[n[0]];if(t.opType==="Clip")if(t.inputs.length===1)try{e.attributes.set("activation_params","floats",[t.attributes.getFloat("min"),t.attributes.getFloat("max")])}catch{e.attributes.set("activation_params","floats",[ln,cn])}else if(t.inputs.length>=3&&this._allData[t.inputs[1]].tensor!==void 0&&this._allData[t.inputs[2]].tensor!==void 0)e.attributes.set("activation_params","floats",[this._allData[t.inputs[1]].tensor.floatData[0],this._allData[t.inputs[2]].tensor.floatData[0]]);else continue;e.attributes.set("activation","string",t.opType),this.deleteNode(n[0])}}}}});var Vh,Ww,Ui,Wh=M(()=>{"use strict";ci();Gh();so();Vh=On(Dn());Fe();Ww=ie.experimental.fbs,Ui=class{constructor(){}load(e,n,t){if(!t)try{this.loadFromOnnxFormat(e,n);return}catch(o){if(t!==void 0)throw o}this.loadFromOrtFormat(e,n)}loadFromOnnxFormat(e,n){let t=Vh.onnx.ModelProto.decode(e);if(Et.longToNumber(t.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=t.opsetImport.map(i=>({domain:i.domain,version:Et.longToNumber(i.version)})),this._graph=Fs.from(t.graph,n)}loadFromOrtFormat(e,n){let t=new B.ByteBuffer(e),o=Ww.InferenceSession.getRootAsInferenceSession(t).model();if(Et.longToNumber(o.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let s=0;s<o.opsetImportLength();s++){let a=o.opsetImport(s);this._opsets.push({domain:a?.domain(),version:Et.longToNumber(a.version())})}this._graph=Fs.from(o.graph(),n)}get graph(){return this._graph}get opsets(){return this._opsets}}});var Hi,Uh=M(()=>{"use strict";Nh();Fh();Nt();Wh();Hi=class{constructor(e={}){this._initialized=!1,this.backendHint=e.backendHint,this.profiler=ui.create(e.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(e,n,t){await this.profiler.event("session","Session.loadModel",async()=>{let o=await Rs(this.backendHint);if(this.sessionHandler=o.createSessionHandler(this.context),this._model=new Ui,typeof e=="string"){let i=e.endsWith(".ort");if(typeof process<"u"&&process.versions&&process.versions.node){let s=await(void 0)(e);this.initialize(s,i)}else{let a=await(await fetch(e)).arrayBuffer();this.initialize(new Uint8Array(a),i)}}else if(ArrayBuffer.isView(e))this.initialize(e);else{let i=new Uint8Array(e,n||0,t||e.byteLength);this.initialize(i)}})}initialize(e,n){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{let t=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(e,t,n),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new Gi(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(e){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{let n=this.normalizeAndValidateInputs(e),t=await this._executionPlan.execute(this.sessionHandler,n);return this.createOutput(t)})}normalizeAndValidateInputs(e){let n=this._model.graph.getInputNames();if(Array.isArray(e)){if(e.length!==n.length)throw new Error(`incorrect input array length: expected ${n.length} but got ${e.length}`)}else{if(e.size!==n.length)throw new Error(`incorrect input map size: expected ${n.length} but got ${e.size}`);let t=new Array(e.size),o=0;for(let i=0;i<n.length;++i){let s=e.get(n[i]);if(!s)throw new Error(`missing input tensor for: '${name}'`);t[o++]=s}e=t}if(!this.context.graphInputTypes||this.context.graphInputTypes.length===0||!this.context.graphInputDims||this.context.graphInputDims.length===0){let t=this._model.graph.getInputIndices(),o=this._model.graph.getValues(),i=new Array(t.length);for(let s=0;s<t.length;++s){let a=o[t[s]];i[s]=a.type.shape.dims,this.context.graphInputTypes.push(a.type.tensorType),this.context.graphInputDims.push(e[s].dims)}this.validateInputTensorDims(i,e,!0)}else this.validateInputTensorDims(this.context.graphInputDims,e,!1);return this.validateInputTensorTypes(this.context.graphInputTypes,e),e}validateInputTensorTypes(e,n){for(let t=0;t<n.length;t++){let o=e[t],i=n[t].type;if(o!==i)throw new Error(`input tensor[${t}] check failed: expected type '${o}' but got ${i}`)}}validateInputTensorDims(e,n,t){for(let o=0;o<n.length;o++){let i=e[o],s=n[o].dims;if(!this.compareTensorDims(i,s,t))throw new Error(`input tensor[${o}] check failed: expected shape '[${i.join(",")}]' but got [${s.join(",")}]`)}}compareTensorDims(e,n,t){if(e.length!==n.length)return!1;for(let o=0;o<e.length;++o)if(e[o]!==n[o]&&(!t||e[o]!==0))return!1;return!0}createOutput(e){let n=this._model.graph.getOutputNames();if(e.length!==n.length)throw new Error("expected number of outputs do not match number of generated outputs");let t=new Map;for(let o=0;o<n.length;++o)t.set(n[o],e[o]);return t}initializeOps(e){let n=e.getNodes();this._ops=new Array(n.length);for(let t=0;t<n.length;t++)this._ops[t]=this.sessionHandler.resolve(n[t],this._model.opsets,e)}}});var ji,Hh=M(()=>{"use strict";Lt();dn();ji=class{constructor(e){this.session=e;this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(e,n,t){let o=new Map;for(let a in e)if(Object.hasOwnProperty.call(e,a)){let u=e[a];o.set(a,new dt(u.dims,u.type,void 0,void 0,u.data))}let i=await this.session.run(o),s={};return i.forEach((a,u)=>{s[u]=new ft(a.type,a.data,a.dims)}),s}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}});var jh={};Mr(jh,{onnxjsBackend:()=>Hw});var zs,Hw,qh=M(()=>{"use strict";Uh();Hh();zs=class{async init(){}async createInferenceSessionHandler(e,n){let t=new Hi(n);return typeof e=="string"?await t.loadModel(e):await t.loadModel(e),new ji(t)}},Hw=new zs});var Gs={};Mr(Gs,{readFile:()=>jw});var jw,Vs=M(()=>{jw=void 0});var Ws={};Mr(Ws,{join:()=>qw});var qw,Us=M(()=>{qw=void 0});var Yh=He((Xh,Hs)=>{"use strict";var Kh=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(e={}){var n=e,t,o;n.ready=new Promise((p,v)=>{t=p,o=v}),n.jsepInit=(p,v,S,I,P,U,K,pe)=>{n.ab=p,n.Ra=v,n.Ta=S,n.La=I,n.Sa=P,n.xa=U,n.Ua=K,n.Va=pe,v=(oe,me,he)=>(..._e)=>{let De=kt,N=me?.();_e=oe(..._e);let be=me?.();return N!==be&&(oe=be,he(N),me=he=null),kt!=De?Yn():_e},S=oe=>async(...me)=>{try{if(n.Fa)throw Error("Session already started");let he=n.Fa={Wa:me[0],errors:[]},_e=await oe(...me);if(n.Fa!==he)throw Error("Session mismatch");p.flush();let De=he.errors;if(0<De.length){let N=await Promise.all(De);if(N=N.filter(be=>be),0<N.length)throw Error(N.join(`
`))}return _e}finally{n.Fa=null}},n._OrtRun=S(v(n._OrtRun,()=>n._OrtRun,oe=>n._OrtRun=oe)),n._OrtRunWithBinding=S(v(n._OrtRunWithBinding,()=>n._OrtRunWithBinding,oe=>n._OrtRunWithBinding=oe)),n._OrtBindInput=v(n._OrtBindInput,()=>n._OrtBindInput,oe=>n._OrtBindInput=oe),n.jsepRegisterBuffer=(oe,me,he,_e)=>p.registerBuffer(oe,me,he,_e),n.jsepUnregisterBuffers=oe=>{p.unregisterBuffers(oe)},n.jsepGetBuffer=oe=>p.getBuffer(oe),n.jsepCreateDownloader=(oe,me,he)=>p.createDownloader(oe,me,he)};var i=Object.assign({},n),s="./this.program",a=(p,v)=>{throw v},u=typeof window=="object",l=typeof importScripts=="function",c=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",h="",m,b,x;if(c){var y=(Vs(),Ar(Gs)),T=(Us(),Ar(Ws));h=l?T.dirname(h)+"/":__dirname+"/",m=(p,v)=>(p=p.startsWith("file://")?new URL(p):T.normalize(p),y.readFileSync(p,v?void 0:"utf8")),x=p=>(p=m(p,!0),p.buffer||(p=new Uint8Array(p)),p),b=(p,v,S,I=!0)=>{p=p.startsWith("file://")?new URL(p):T.normalize(p),y.readFile(p,I?void 0:"utf8",(P,U)=>{P?S(P):v(I?U.buffer:U)})},!n.thisProgram&&1<process.argv.length&&(s=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),a=(p,v)=>{throw process.exitCode=p,v},n.inspect=()=>"[Emscripten Module object]"}else(u||l)&&(l?h=self.location.href:typeof document<"u"&&document.currentScript&&(h=document.currentScript.src),r&&(h=r),h.indexOf("blob:")!==0?h=h.substr(0,h.replace(/[?#].*/,"").lastIndexOf("/")+1):h="",m=p=>{var v=new XMLHttpRequest;return v.open("GET",p,!1),v.send(null),v.responseText},l&&(x=p=>{var v=new XMLHttpRequest;return v.open("GET",p,!1),v.responseType="arraybuffer",v.send(null),new Uint8Array(v.response)}),b=(p,v,S)=>{var I=new XMLHttpRequest;I.open("GET",p,!0),I.responseType="arraybuffer",I.onload=()=>{I.status==200||I.status==0&&I.response?v(I.response):S()},I.onerror=S,I.send(null)});var E=n.print||console.log.bind(console),_=n.printErr||console.error.bind(console);Object.assign(n,i),i=null,n.thisProgram&&(s=n.thisProgram),n.quit&&(a=n.quit);var C;n.wasmBinary&&(C=n.wasmBinary);var D=n.noExitRuntime||!0;typeof WebAssembly!="object"&&q("no native wasm support detected");var z,F,V=!1,ee,re,le,R,fe,Ye,se;function Le(){var p=z.buffer;n.HEAP8=re=new Int8Array(p),n.HEAP16=new Int16Array(p),n.HEAP32=R=new Int32Array(p),n.HEAPU8=le=new Uint8Array(p),n.HEAPU16=new Uint16Array(p),n.HEAPU32=fe=new Uint32Array(p),n.HEAPF32=Ye=new Float32Array(p),n.HEAPF64=se=new Float64Array(p)}var Je,ke=[],lt=[],We=[];function vt(){var p=n.preRun.shift();ke.unshift(p)}var Bt=0,Rt=null,Mt=null;function q(p){throw n.onAbort&&n.onAbort(p),p="Aborted("+p+")",_(p),V=!0,ee=1,p=new WebAssembly.RuntimeError(p+". Build with -sASSERTIONS for more info."),o(p),p}function Ie(p){return p.startsWith("data:application/octet-stream;base64,")}var $e;if($e="ort-wasm-simd.wasm",!Ie($e)){var wt=$e;$e=n.locateFile?n.locateFile(wt,h):h+wt}function It(p){if(p==$e&&C)return new Uint8Array(C);if(x)return x(p);throw"both async and sync fetching of the wasm failed"}function Ue(p){if(!C&&(u||l)){if(typeof fetch=="function"&&!p.startsWith("file://"))return fetch(p,{credentials:"same-origin"}).then(v=>{if(!v.ok)throw"failed to load wasm binary file at '"+p+"'";return v.arrayBuffer()}).catch(()=>It(p));if(b)return new Promise((v,S)=>{b(p,I=>v(new Uint8Array(I)),S)})}return Promise.resolve().then(()=>It(p))}function rt(p,v,S){return Ue(p).then(I=>WebAssembly.instantiate(I,v)).then(I=>I).then(S,I=>{_("failed to asynchronously prepare wasm: "+I),q(I)})}function kr(p,v){var S=$e;return C||typeof WebAssembly.instantiateStreaming!="function"||Ie(S)||S.startsWith("file://")||c||typeof fetch!="function"?rt(S,p,v):fetch(S,{credentials:"same-origin"}).then(I=>WebAssembly.instantiateStreaming(I,p).then(v,function(P){return _("wasm streaming compile failed: "+P),_("falling back to ArrayBuffer instantiation"),rt(S,p,v)}))}var Dt,vn={916496:p=>{n.xa("Abs",p,void 0)},916547:p=>{n.xa("Neg",p,void 0)},916598:p=>{n.xa("Floor",p,void 0)},916651:p=>{n.xa("Ceil",p,void 0)},916703:p=>{n.xa("Reciprocal",p,void 0)},916761:p=>{n.xa("Sqrt",p,void 0)},916813:p=>{n.xa("Exp",p,void 0)},916864:p=>{n.xa("Erf",p,void 0)},916915:p=>{n.xa("Sigmoid",p,void 0)},916970:p=>{n.xa("Log",p,void 0)},917021:p=>{n.xa("Sin",p,void 0)},917072:p=>{n.xa("Cos",p,void 0)},917123:p=>{n.xa("Tan",p,void 0)},917174:p=>{n.xa("Asin",p,void 0)},917226:p=>{n.xa("Acos",p,void 0)},917278:p=>{n.xa("Atan",p,void 0)},917330:p=>{n.xa("Sinh",p,void 0)},917382:p=>{n.xa("Cosh",p,void 0)},917434:p=>{n.xa("Asinh",p,void 0)},917487:p=>{n.xa("Acosh",p,void 0)},917540:p=>{n.xa("Atanh",p,void 0)},917593:p=>{n.xa("Tanh",p,void 0)},917645:p=>{n.xa("Not",p,void 0)},917696:(p,v,S)=>{n.xa("ClipV10",p,{min:v,max:S})},917768:p=>{n.xa("Clip",p,void 0)},917820:(p,v)=>{n.xa("Elu",p,{alpha:v})},917878:p=>{n.xa("Relu",p,void 0)},917930:(p,v)=>{n.xa("LeakyRelu",p,{alpha:v})},917994:(p,v)=>{n.xa("ThresholdedRelu",p,{alpha:v})},918064:(p,v)=>{n.xa("Cast",p,{to:v})},918122:p=>{n.xa("Add",p,void 0)},918173:p=>{n.xa("Sub",p,void 0)},918224:p=>{n.xa("Mul",p,void 0)},918275:p=>{n.xa("Div",p,void 0)},918326:p=>{n.xa("Pow",p,void 0)},918377:p=>{n.xa("Equal",p,void 0)},918430:p=>{n.xa("Greater",p,void 0)},918485:p=>{n.xa("GreaterOrEqual",p,void 0)},918547:p=>{n.xa("Less",p,void 0)},918599:p=>{n.xa("LessOrEqual",p,void 0)},918658:(p,v,S,I,P)=>{n.xa("ReduceMean",p,{keepDims:!!v,noopWithEmptyAxes:!!S,axes:I?Array.from(R.subarray(P>>>0,P+I>>>0)):[]})},918822:(p,v,S,I,P)=>{n.xa("ReduceMax",p,{keepDims:!!v,noopWithEmptyAxes:!!S,axes:I?Array.from(R.subarray(P>>>0,P+I>>>0)):[]})},918985:(p,v,S,I,P)=>{n.xa("ReduceMin",p,{keepDims:!!v,noopWithEmptyAxes:!!S,axes:I?Array.from(R.subarray(P>>>0,P+I>>>0)):[]})},919148:(p,v,S,I,P)=>{n.xa("ReduceProd",p,{keepDims:!!v,noopWithEmptyAxes:!!S,axes:I?Array.from(R.subarray(P>>>0,P+I>>>0)):[]})},919312:(p,v,S,I,P)=>{n.xa("ReduceSum",p,{keepDims:!!v,noopWithEmptyAxes:!!S,axes:I?Array.from(R.subarray(P>>>0,P+I>>>0)):[]})},919475:(p,v,S,I,P)=>{n.xa("ReduceL1",p,{keepDims:!!v,noopWithEmptyAxes:!!S,axes:I?Array.from(R.subarray(P>>>0,P+I>>>0)):[]})},919637:(p,v,S,I,P)=>{n.xa("ReduceL2",p,{keepDims:!!v,noopWithEmptyAxes:!!S,axes:I?Array.from(R.subarray(P>>>0,P+I>>>0)):[]})},919799:(p,v,S,I,P)=>{n.xa("ReduceLogSum",p,{keepDims:!!v,noopWithEmptyAxes:!!S,axes:I?Array.from(R.subarray(P>>>0,P+I>>>0)):[]})},919965:(p,v,S,I,P)=>{n.xa("ReduceSumSquare",p,{keepDims:!!v,noopWithEmptyAxes:!!S,axes:I?Array.from(R.subarray(P>>>0,P+I>>>0)):[]})},920134:(p,v,S,I,P)=>{n.xa("ReduceLogSumExp",p,{keepDims:!!v,noopWithEmptyAxes:!!S,axes:I?Array.from(R.subarray(P>>>0,P+I>>>0)):[]})},920303:p=>{n.xa("Where",p,void 0)},920356:(p,v,S)=>{n.xa("Transpose",p,{perm:v?Array.from(R.subarray(S>>>0,S+v>>>0)):[]})},920469:(p,v,S,I,P,U,K,pe,oe,me,he,_e,De,N,be)=>{n.xa("ConvTranspose",p,{format:oe?"NHWC":"NCHW",autoPad:v,dilations:[S],group:I,kernel_shape:[P],pads:[U,K],strides:[pe],wIsConst:()=>!!re[me>>>0],outputPadding:he?Array.from(R.subarray(_e>>>0,_e+he>>>0)):[],outputShape:De?Array.from(R.subarray(N>>>0,N+De>>>0)):[],activation:ct(be)})},920883:(p,v,S,I,P,U,K,pe,oe,me,he,_e,De,N)=>{n.xa("ConvTranspose",p,{format:pe?"NHWC":"NCHW",autoPad:v,dilations:Array.from(R.subarray(S>>>0,S+2>>>0)),group:I,kernelShape:Array.from(R.subarray(P>>>0,P+2>>>0)),pads:Array.from(R.subarray(U>>>0,U+4>>>0)),strides:Array.from(R.subarray(K>>>0,K+2>>>0)),wIsConst:()=>!!re[oe>>>0],outputPadding:0<me?Array.from(R.subarray(he>>>0,he+me>>>0)):[],outputShape:0<_e?Array.from(R.subarray(De>>>0,De+_e>>>0)):[],activation:ct(N)})},921440:(p,v,S,I,P,U,K,pe,oe,me,he,_e,De,N,be)=>{n.xa("ConvTranspose",p,{format:oe?"NHWC":"NCHW",autoPad:v,dilations:[S],group:I,kernel_shape:[P],pads:[U,K],strides:[pe],wIsConst:()=>!!re[me>>>0],outputPadding:he?Array.from(R.subarray(_e>>>0,_e+he>>>0)):[],outputShape:De?Array.from(R.subarray(N>>>0,N+De>>>0)):[],activation:ct(be)})},921854:(p,v,S,I,P,U,K,pe,oe,me,he,_e,De,N)=>{n.xa("ConvTranspose",p,{format:pe?"NHWC":"NCHW",autoPad:v,dilations:Array.from(R.subarray(S>>>0,S+2>>>0)),group:I,kernelShape:Array.from(R.subarray(P>>>0,P+2>>>0)),pads:Array.from(R.subarray(U>>>0,U+4>>>0)),strides:Array.from(R.subarray(K>>>0,K+2>>>0)),wIsConst:()=>!!re[oe>>>0],outputPadding:0<me?Array.from(R.subarray(he>>>0,he+me>>>0)):[],outputShape:0<_e?Array.from(R.subarray(De>>>0,De+_e>>>0)):[],activation:ct(N)})},922411:(p,v)=>{n.xa("GlobalAveragePool",p,{format:v?"NHWC":"NCHW"})},922502:(p,v,S,I,P,U,K,pe,oe,me,he,_e,De,N,be,Ce)=>{n.xa("AveragePool",p,{format:Ce?"NHWC":"NCHW",auto_pad:v,ceil_mode:S,count_include_pad:I,storage_order:P,dilations:[U,K],kernel_shape:[pe,oe],pads:[me,he,_e,De],strides:[N,be]})},922786:(p,v)=>{n.xa("GlobalAveragePool",p,{format:v?"NHWC":"NCHW"})},922877:(p,v,S,I,P,U,K,pe,oe,me,he,_e,De,N,be,Ce)=>{n.xa("AveragePool",p,{format:Ce?"NHWC":"NCHW",auto_pad:v,ceil_mode:S,count_include_pad:I,storage_order:P,dilations:[U,K],kernel_shape:[pe,oe],pads:[me,he,_e,De],strides:[N,be]})},923161:(p,v)=>{n.xa("GlobalMaxPool",p,{format:v?"NHWC":"NCHW"})},923248:(p,v,S,I,P,U,K,pe,oe,me,he,_e,De,N,be,Ce)=>{n.xa("MaxPool",p,{format:Ce?"NHWC":"NCHW",auto_pad:v,ceil_mode:S,count_include_pad:I,storage_order:P,dilations:[U,K],kernel_shape:[pe,oe],pads:[me,he,_e,De],strides:[N,be]})},923528:(p,v)=>{n.xa("GlobalMaxPool",p,{format:v?"NHWC":"NCHW"})},923615:(p,v,S,I,P,U,K,pe,oe,me,he,_e,De,N,be,Ce)=>{n.xa("MaxPool",p,{format:Ce?"NHWC":"NCHW",auto_pad:v,ceil_mode:S,count_include_pad:I,storage_order:P,dilations:[U,K],kernel_shape:[pe,oe],pads:[me,he,_e,De],strides:[N,be]})},923895:(p,v,S,I,P)=>{n.xa("Gemm",p,{alpha:v,beta:S,transA:I,transB:P})},923999:p=>{n.xa("MatMul",p,void 0)},924053:(p,v,S,I)=>{n.xa("ArgMax",p,{keepDims:!!v,selectLastIndex:!!S,axis:I})},924161:(p,v,S,I)=>{n.xa("ArgMin",p,{keepDims:!!v,selectLastIndex:!!S,axis:I})},924269:(p,v)=>{n.xa("Softmax",p,{axis:v})},924332:(p,v)=>{n.xa("Concat",p,{axis:v})},924392:(p,v,S,I,P)=>{n.xa("Split",p,{axis:v,numOutputs:S,splitSizes:I?Array.from(R.subarray(P>>>0,P+I>>>0)):[]})},924537:p=>{n.xa("Expand",p,void 0)},924591:(p,v)=>{n.xa("Gather",p,{axis:Number(v)})},924662:(p,v)=>{n.xa("GatherElements",p,{axis:Number(v)})},924741:(p,v,S,I,P,U,K,pe,oe,me,he)=>{n.xa("Resize",p,{antialias:v,axes:S?Array.from(R.subarray(I>>>0,I+S>>>0)):[],coordinateTransformMode:ct(P),cubicCoeffA:U,excludeOutside:K,extrapolationValue:pe,keepAspectRatioPolicy:ct(oe),mode:ct(me),nearestMode:ct(he)})},925092:(p,v,S,I,P,U,K)=>{n.xa("Slice",p,{starts:v?Array.from(R.subarray(S>>>0,S+v>>>0)):[],ends:I?Array.from(R.subarray(P>>>0,P+I>>>0)):[],axes:U?Array.from(R.subarray(K>>>0,K+U>>>0)):[]})},925323:p=>{n.xa("Tile",p,void 0)},925375:(p,v,S)=>{n.xa("LayerNormalization",p,{axis:Number(v),epsilon:Number(S)})},925482:(p,v,S)=>{n.xa("InstanceNormalization",p,{epsilon:v,format:S?"NHWC":"NCHW"})},925596:(p,v,S)=>{n.xa("InstanceNormalization",p,{epsilon:v,format:S?"NHWC":"NCHW"})},925710:p=>{n.xa("Range",p,void 0)},925763:(p,v)=>{n.xa("Einsum",p,{equation:ct(v)})},925844:(p,v,S,I,P)=>{n.xa("Pad",p,{mode:v,value:S,pads:I?Array.from(R.subarray(P>>>0,P+I>>>0)):[]})},925976:p=>{n.xa("Gelu",p,void 0)},926028:p=>{n.xa("BiasAdd",p,void 0)},926083:p=>{n.xa("BiasSplitGelu",p,void 0)},926144:(p,v)=>{n.xa("SkipLayerNormalization",p,{epsilon:v})},926225:(p,v,S,I,P,U,K,pe,oe,me,he,_e,De)=>{n.xa("Conv",p,{format:oe?"NHWC":"NCHW",auto_pad:v,dilations:[S],group:I,kernel_shape:[P],pads:U?Array.from(R.subarray(K>>>0,K+U>>>0)):[],strides:[pe],w_is_const:()=>!!re[me>>>0],activation:ct(he),activation_params:_e?Array.from(Ye.subarray(De>>>0,De+_e>>>0)):[]})},926606:(p,v,S,I,P,U,K,pe,oe,me,he,_e,De,N,be,Ce)=>{n.xa("Conv",p,{format:_e?"NHWC":"NCHW",auto_pad:v,dilations:[S,I],group:P,kernel_shape:[U,K],pads:pe?Array.from(R.subarray(oe>>>0,oe+pe>>>0)):[],strides:[me,he],w_is_const:()=>!!re[De>>>0],activation:ct(N),activation_params:be?Array.from(Ye.subarray(Ce>>>0,Ce+be>>>0)):[]})},927008:p=>{n.Ua(p)},927042:(p,v)=>n.Va(p,v,n.Fa.Wa,n.Fa.errors),927154:p=>n.Ra(p),927187:p=>n.Ta(p),927219:(p,v,S)=>{n.La(p,v,S,!0)},927258:(p,v,S)=>{n.La(p,v,S)}};function or(p){this.name="ExitStatus",this.message=`Program terminated with exit(${p})`,this.status=p}var Kr=p=>{for(;0<p.length;)p.shift()(n)};function Xr(p){this.Ka=p-24,this.Pa=function(v){fe[this.Ka+4>>2>>>0]=v},this.Oa=function(v){fe[this.Ka+8>>2>>>0]=v},this.Ma=function(v,S){this.Na(),this.Pa(v),this.Oa(S)},this.Na=function(){fe[this.Ka+16>>2>>>0]=0}}var Vn=0,qt=0,Wn=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Yr=(p,v,S)=>{v>>>=0;var I=v+S;for(S=v;p[S]&&!(S>=I);)++S;if(16<S-v&&p.buffer&&Wn)return Wn.decode(p.subarray(v,S));for(I="";v<S;){var P=p[v++];if(P&128){var U=p[v++]&63;if((P&224)==192)I+=String.fromCharCode((P&31)<<6|U);else{var K=p[v++]&63;P=(P&240)==224?(P&15)<<12|U<<6|K:(P&7)<<18|U<<12|K<<6|p[v++]&63,65536>P?I+=String.fromCharCode(P):(P-=65536,I+=String.fromCharCode(55296|P>>10,56320|P&1023))}}else I+=String.fromCharCode(P)}return I},ct=(p,v)=>(p>>>=0)?Yr(le,p,v):"",xn=p=>{for(var v=0,S=0;S<p.length;++S){var I=p.charCodeAt(S);127>=I?v++:2047>=I?v+=2:55296<=I&&57343>=I?(v+=4,++S):v+=3}return v},Un=(p,v,S,I)=>{if(S>>>=0,!(0<I))return 0;var P=S;I=S+I-1;for(var U=0;U<p.length;++U){var K=p.charCodeAt(U);if(55296<=K&&57343>=K){var pe=p.charCodeAt(++U);K=65536+((K&1023)<<10)|pe&1023}if(127>=K){if(S>=I)break;v[S++>>>0]=K}else{if(2047>=K){if(S+1>=I)break;v[S++>>>0]=192|K>>6}else{if(65535>=K){if(S+2>=I)break;v[S++>>>0]=224|K>>12}else{if(S+3>=I)break;v[S++>>>0]=240|K>>18,v[S++>>>0]=128|K>>12&63}v[S++>>>0]=128|K>>6&63}v[S++>>>0]=128|K&63}}return v[S>>>0]=0,S-P},Tr=p=>p%4===0&&(p%100!==0||p%400===0),Do=[0,31,60,91,121,152,182,213,244,274,305,335],wn=[0,31,59,90,120,151,181,212,243,273,304,334],Jr=p=>{var v=xn(p)+1,S=Sn(v);return S&&Un(p,le,S,v),S},Zr=[],Hn=(p,v)=>{Zr.length=0;var S;for(v>>=2;S=le[p++>>>0];)v+=S!=105&v,Zr.push(S==105?R[v>>>0]:se[v++>>>1]),++v;return Zr},Kt={},jn=()=>{if(!Tn){var p={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:s||"./this.program"},v;for(v in Kt)Kt[v]===void 0?delete p[v]:p[v]=Kt[v];var S=[];for(v in p)S.push(`${v}=${p[v]}`);Tn=S}return Tn},Tn,bt=[null,[],[]],qn=[31,29,31,30,31,30,31,31,30,31,30,31],$n=[31,28,31,30,31,30,31,31,30,31,30,31];function xa(p){var v=Array(xn(p)+1);return Un(p,v,0,v.length),v}function ve(p,v,S,I){function P(N,be,Ce){for(N=typeof N=="number"?N.toString():N||"";N.length<be;)N=Ce[0]+N;return N}function U(N,be){return P(N,be,"0")}function K(N,be){function Ce(en){return 0>en?-1:0<en?1:0}var Yt;return(Yt=Ce(N.getFullYear()-be.getFullYear()))===0&&(Yt=Ce(N.getMonth()-be.getMonth()))===0&&(Yt=Ce(N.getDate()-be.getDate())),Yt}function pe(N){switch(N.getDay()){case 0:return new Date(N.getFullYear()-1,11,29);case 1:return N;case 2:return new Date(N.getFullYear(),0,3);case 3:return new Date(N.getFullYear(),0,2);case 4:return new Date(N.getFullYear(),0,1);case 5:return new Date(N.getFullYear()-1,11,31);case 6:return new Date(N.getFullYear()-1,11,30)}}function oe(N){var be=N.Da;for(N=new Date(new Date(N.Ea+1900,0,1).getTime());0<be;){var Ce=N.getMonth(),Yt=(Tr(N.getFullYear())?qn:$n)[Ce];if(be>Yt-N.getDate())be-=Yt-N.getDate()+1,N.setDate(1),11>Ce?N.setMonth(Ce+1):(N.setMonth(0),N.setFullYear(N.getFullYear()+1));else{N.setDate(N.getDate()+be);break}}return Ce=new Date(N.getFullYear()+1,0,4),be=pe(new Date(N.getFullYear(),0,4)),Ce=pe(Ce),0>=K(be,N)?0>=K(Ce,N)?N.getFullYear()+1:N.getFullYear():N.getFullYear()-1}p>>>=0,v>>>=0,S>>>=0,I>>>=0;var me=R[I+40>>2>>>0];I={Za:R[I>>2>>>0],Ya:R[I+4>>2>>>0],Ga:R[I+8>>2>>>0],Ja:R[I+12>>2>>>0],Ha:R[I+16>>2>>>0],Ea:R[I+20>>2>>>0],Ca:R[I+24>>2>>>0],Da:R[I+28>>2>>>0],bb:R[I+32>>2>>>0],Xa:R[I+36>>2>>>0],$a:me?ct(me):""},S=ct(S),me={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var he in me)S=S.replace(new RegExp(he,"g"),me[he]);var _e="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),De="January February March April May June July August September October November December".split(" ");me={"%a":N=>_e[N.Ca].substring(0,3),"%A":N=>_e[N.Ca],"%b":N=>De[N.Ha].substring(0,3),"%B":N=>De[N.Ha],"%C":N=>U((N.Ea+1900)/100|0,2),"%d":N=>U(N.Ja,2),"%e":N=>P(N.Ja,2," "),"%g":N=>oe(N).toString().substring(2),"%G":N=>oe(N),"%H":N=>U(N.Ga,2),"%I":N=>(N=N.Ga,N==0?N=12:12<N&&(N-=12),U(N,2)),"%j":N=>{for(var be=0,Ce=0;Ce<=N.Ha-1;be+=(Tr(N.Ea+1900)?qn:$n)[Ce++]);return U(N.Ja+be,3)},"%m":N=>U(N.Ha+1,2),"%M":N=>U(N.Ya,2),"%n":()=>`
`,"%p":N=>0<=N.Ga&&12>N.Ga?"AM":"PM","%S":N=>U(N.Za,2),"%t":()=>"	","%u":N=>N.Ca||7,"%U":N=>U(Math.floor((N.Da+7-N.Ca)/7),2),"%V":N=>{var be=Math.floor((N.Da+7-(N.Ca+6)%7)/7);if(2>=(N.Ca+371-N.Da-2)%7&&be++,be)be==53&&(Ce=(N.Ca+371-N.Da)%7,Ce==4||Ce==3&&Tr(N.Ea)||(be=1));else{be=52;var Ce=(N.Ca+7-N.Da-1)%7;(Ce==4||Ce==5&&Tr(N.Ea%400-1))&&be++}return U(be,2)},"%w":N=>N.Ca,"%W":N=>U(Math.floor((N.Da+7-(N.Ca+6)%7)/7),2),"%y":N=>(N.Ea+1900).toString().substring(2),"%Y":N=>N.Ea+1900,"%z":N=>{N=N.Xa;var be=0<=N;return N=Math.abs(N)/60,(be?"+":"-")+("0000"+(N/60*100+N%60)).slice(-4)},"%Z":N=>N.$a,"%%":()=>"%"},S=S.replace(/%%/g,"\0\0");for(he in me)S.includes(he)&&(S=S.replace(new RegExp(he,"g"),me[he](I)));return S=S.replace(/\0\0/g,"%"),he=xa(S),he.length>v?0:(re.set(he,p>>>0),he.length-1)}function $r(p){try{p()}catch(v){q(v)}}function ko(p){var v={},S;for(S in p)(function(I){var P=p[I];v[I]=typeof P=="function"?function(){Qr.push(I);try{return P.apply(null,arguments)}finally{V||(Qr.pop()===I||q(),kt&&ir===1&&Qr.length===0&&(ir=0,$r(An),typeof Fibers<"u"&&Fibers.cb()))}}:P})(S);return v}var ir=0,kt=null,Bo=0,Qr=[],Kn={},Xn={},Ro=0,Br=null,Mo=[];function Yn(){return new Promise((p,v)=>{Br={resolve:p,reject:v}})}function Lo(){var p=Sn(65548),v=p+12;fe[p>>2>>>0]=v,fe[p+4>>2>>>0]=v+65536,v=Qr[0];var S=Kn[v];return S===void 0&&(S=Ro++,Kn[v]=S,Xn[S]=v),R[p+8>>2>>>0]=S,p}function No(p){if(!V){if(ir===0){var v=!1,S=!1;p((I=0)=>{if(!V&&(Bo=I,v=!0,S)){ir=2,$r(()=>Go(kt)),typeof Browser<"u"&&Browser.Ia.Qa&&Browser.Ia.resume(),I=!1;try{var P=(0,F[Xn[R[kt+8>>2>>>0]]])()}catch(pe){P=pe,I=!0}var U=!1;if(!kt){var K=Br;K&&(Br=null,(I?K.reject:K.resolve)(P),U=!0)}if(I&&!U)throw P}}),S=!0,v||(ir=1,kt=Lo(),typeof Browser<"u"&&Browser.Ia.Qa&&Browser.Ia.pause(),$r(()=>In(kt)))}else ir===2?(ir=0,$r(Xt),Qn(kt),kt=null,Mo.forEach(I=>{if(!V)try{if(I(),!D)try{ee=ee=I=ee,D||(n.onExit&&n.onExit(I),V=!0),a(I,new or(I))}catch(P){P instanceof or||P=="unwind"||a(1,P)}}catch(P){P instanceof or||P=="unwind"||a(1,P)}})):q(`invalid state: ${ir}`);return Bo}}function Fo(p){return No(v=>{p().then(v)})}var Sr=[],Ir=void 0,Jn=[];function Zn(p,v){if(!Ir){Ir=new WeakMap;var S=Je.length;if(Ir)for(var I=0;I<0+S;I++){var P=I,U=Sr[P];U||(P>=Sr.length&&(Sr.length=P+1),Sr[P]=U=Je.get(P)),(P=U)&&Ir.set(P,I)}}if(S=Ir.get(p)||0)return S;if(Jn.length)S=Jn.pop();else{try{Je.grow(1)}catch(pe){throw pe instanceof RangeError?"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.":pe}S=Je.length-1}try{I=S,Je.set(I,p),Sr[I]=Je.get(I)}catch(pe){if(!(pe instanceof TypeError))throw pe;if(typeof WebAssembly.Function=="function"){I=WebAssembly.Function,P={i:"i32",j:"i64",f:"f32",d:"f64",p:"i32"},U={parameters:[],results:v[0]=="v"?[]:[P[v[0]]]};for(var K=1;K<v.length;++K)U.parameters.push(P[v[K]]);v=new I(U,p)}else{for(I=[1],P=v.slice(0,1),v=v.slice(1),U={i:127,p:127,j:126,f:125,d:124},I.push(96),K=v.length,128>K?I.push(K):I.push(K%128|128,K>>7),K=0;K<v.length;++K)I.push(U[v[K]]);P=="v"?I.push(0):I.push(1,U[P]),v=[0,97,115,109,1,0,0,0,1],P=I.length,128>P?v.push(P):v.push(P%128|128,P>>7),v.push.apply(v,I),v.push(2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0),v=new WebAssembly.Module(new Uint8Array(v)),v=new WebAssembly.Instance(v,{e:{f:p}}).exports.f}I=S,Je.set(I,v),Sr[I]=Je.get(I)}return Ir.set(p,S),S}var zo={n:function(p,v,S){return Fo(async()=>{await n.Sa(p,v,S)})},a:function(p,v,S){throw p>>>=0,new Xr(p).Ma(v>>>0,S>>>0),Vn=p,qt++,Vn},g:function(){return 0},J:function(){},z:function(){},B:function(){},L:function(){return 0},H:function(){},C:function(){},F:function(){},m:function(){},A:function(){},x:function(){},I:function(){},y:function(){},M:()=>!0,q:function(p,v,S){p=v+2097152>>>0<4194305-!!p?(p>>>0)+4294967296*v:NaN,S>>>=0,p=new Date(1e3*p),R[S>>2>>>0]=p.getUTCSeconds(),R[S+4>>2>>>0]=p.getUTCMinutes(),R[S+8>>2>>>0]=p.getUTCHours(),R[S+12>>2>>>0]=p.getUTCDate(),R[S+16>>2>>>0]=p.getUTCMonth(),R[S+20>>2>>>0]=p.getUTCFullYear()-1900,R[S+24>>2>>>0]=p.getUTCDay(),R[S+28>>2>>>0]=(p.getTime()-Date.UTC(p.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(p,v,S){p=v+2097152>>>0<4194305-!!p?(p>>>0)+4294967296*v:NaN,S>>>=0,p=new Date(1e3*p),R[S>>2>>>0]=p.getSeconds(),R[S+4>>2>>>0]=p.getMinutes(),R[S+8>>2>>>0]=p.getHours(),R[S+12>>2>>>0]=p.getDate(),R[S+16>>2>>>0]=p.getMonth(),R[S+20>>2>>>0]=p.getFullYear()-1900,R[S+24>>2>>>0]=p.getDay(),R[S+28>>2>>>0]=(Tr(p.getFullYear())?Do:wn)[p.getMonth()]+p.getDate()-1|0,R[S+36>>2>>>0]=-(60*p.getTimezoneOffset()),v=new Date(p.getFullYear(),6,1).getTimezoneOffset();var I=new Date(p.getFullYear(),0,1).getTimezoneOffset();R[S+32>>2>>>0]=(v!=I&&p.getTimezoneOffset()==Math.min(I,v))|0},s:function(p){p>>>=0;var v=new Date(R[p+20>>2>>>0]+1900,R[p+16>>2>>>0],R[p+12>>2>>>0],R[p+8>>2>>>0],R[p+4>>2>>>0],R[p>>2>>>0],0),S=R[p+32>>2>>>0],I=v.getTimezoneOffset(),P=new Date(v.getFullYear(),6,1).getTimezoneOffset(),U=new Date(v.getFullYear(),0,1).getTimezoneOffset(),K=Math.min(U,P);return 0>S?R[p+32>>2>>>0]=+(P!=U&&K==I):0<S!=(K==I)&&(P=Math.max(U,P),v.setTime(v.getTime()+6e4*((0<S?K:P)-I))),R[p+24>>2>>>0]=v.getDay(),R[p+28>>2>>>0]=(Tr(v.getFullYear())?Do:wn)[v.getMonth()]+v.getDate()-1|0,R[p>>2>>>0]=v.getSeconds(),R[p+4>>2>>>0]=v.getMinutes(),R[p+8>>2>>>0]=v.getHours(),R[p+12>>2>>>0]=v.getDate(),R[p+16>>2>>>0]=v.getMonth(),R[p+20>>2>>>0]=v.getYear(),p=v.getTime()/1e3,eo((Dt=p,1<=+Math.abs(Dt)?0<Dt?+Math.floor(Dt/4294967296)>>>0:~~+Math.ceil((Dt-+(~~Dt>>>0))/4294967296)>>>0:0)),p>>>0},o:function(){return-52},p:function(){},v:function(p,v,S){function I(oe){return(oe=oe.toTimeString().match(/\(([A-Za-z ]+)\)$/))?oe[1]:"GMT"}S>>>=0;var P=new Date().getFullYear(),U=new Date(P,0,1),K=new Date(P,6,1);P=U.getTimezoneOffset();var pe=K.getTimezoneOffset();fe[p>>>0>>2>>>0]=60*Math.max(P,pe),R[v>>>0>>2>>>0]=+(P!=pe),p=I(U),v=I(K),p=Jr(p),v=Jr(v),pe<P?(fe[S>>2>>>0]=p,fe[S+4>>2>>>0]=v):(fe[S>>2>>>0]=v,fe[S+4>>2>>>0]=p)},e:()=>{q("")},b:function(p,v,S){return p>>>=0,v=Hn(v>>>0,S>>>0),vn[p].apply(null,v)},j:function(p,v,S){return p>>>=0,v=Hn(v>>>0,S>>>0),vn[p].apply(null,v)},h:function(){return Date.now()},w:function(){return 4294901760},c:()=>performance.now(),K:function(p,v,S){return v>>>=0,le.copyWithin(p>>>0>>>0,v>>>0,v+(S>>>0)>>>0)},u:function(p){p>>>=0;var v=le.length;if(4294901760<p)return!1;for(var S=1;4>=S;S*=2){var I=v*(1+.2/S);I=Math.min(I,p+100663296);var P=Math;I=Math.max(p,I);e:{P=P.min.call(P,4294901760,I+(65536-I%65536)%65536)-z.buffer.byteLength+65535>>>16;try{z.grow(P),Le();var U=1;break e}catch{}U=void 0}if(U)return!0}return!1},D:function(p,v){p>>>=0,v>>>=0;var S=0;return jn().forEach(function(I,P){var U=v+S;for(P=fe[p+4*P>>2>>>0]=U,U=0;U<I.length;++U)re[P++>>0>>>0]=I.charCodeAt(U);re[P>>0>>>0]=0,S+=I.length+1}),0},E:function(p,v){p>>>=0,v>>>=0;var S=jn();fe[p>>2>>>0]=S.length;var I=0;return S.forEach(function(P){I+=P.length+1}),fe[v>>2>>>0]=I,0},f:()=>52,l:function(){return 52},t:function(){return 70},k:function(p,v,S,I){v>>>=0,S>>>=0,I>>>=0;for(var P=0,U=0;U<S;U++){var K=fe[v>>2>>>0],pe=fe[v+4>>2>>>0];v+=8;for(var oe=0;oe<pe;oe++){var me=le[K+oe>>>0],he=bt[p];me===0||me===10?((p===1?E:_)(Yr(he,0)),he.length=0):he.push(me)}P+=pe}return fe[I>>2>>>0]=P,0},G:ve,d:function(p,v,S,I){return ve(p>>>0,v>>>0,S>>>0,I>>>0)},i:function(p,v,S,I){let P=Je.length;p=new Uint8Array(le.slice(p+v,p+S));try{var U=new WebAssembly.Module(p),K=new WebAssembly.Instance(U,{env:{memory:z}}),pe;for(pe in K.exports)Zn(K.exports[pe]);return P<Je.length?P:I}catch(oe){return console.log(oe),I}}};(function(){function p(S){if(S=S.exports,S=ko(S),F=S=wa(S),z=F.N,Le(),Je=F.sa,lt.unshift(F.O),Bt--,n.monitorRunDependencies&&n.monitorRunDependencies(Bt),Bt==0&&(Rt!==null&&(clearInterval(Rt),Rt=null),Mt)){var I=Mt;Mt=null,I()}return S}var v={a:zo};if(Bt++,n.monitorRunDependencies&&n.monitorRunDependencies(Bt),n.instantiateWasm)try{return n.instantiateWasm(v,p)}catch(S){_("Module.instantiateWasm callback failed with error: "+S),o(S)}return kr(v,function(S){p(S.instance)}).catch(o),{}})(),n._OrtInit=(p,v)=>(n._OrtInit=F.P)(p,v),n._OrtGetLastError=(p,v)=>(n._OrtGetLastError=F.Q)(p,v),n._OrtCreateSessionOptions=(p,v,S,I,P,U,K,pe,oe,me)=>(n._OrtCreateSessionOptions=F.R)(p,v,S,I,P,U,K,pe,oe,me),n._OrtAppendExecutionProvider=(p,v)=>(n._OrtAppendExecutionProvider=F.S)(p,v),n._OrtAddFreeDimensionOverride=(p,v,S)=>(n._OrtAddFreeDimensionOverride=F.T)(p,v,S),n._OrtAddSessionConfigEntry=(p,v,S)=>(n._OrtAddSessionConfigEntry=F.U)(p,v,S),n._OrtReleaseSessionOptions=p=>(n._OrtReleaseSessionOptions=F.V)(p),n._OrtCreateSession=(p,v,S)=>(n._OrtCreateSession=F.W)(p,v,S),n._OrtReleaseSession=p=>(n._OrtReleaseSession=F.X)(p),n._OrtGetInputOutputCount=(p,v,S)=>(n._OrtGetInputOutputCount=F.Y)(p,v,S),n._OrtGetInputName=(p,v)=>(n._OrtGetInputName=F.Z)(p,v),n._OrtGetOutputName=(p,v)=>(n._OrtGetOutputName=F._)(p,v),n._OrtFree=p=>(n._OrtFree=F.$)(p),n._OrtCreateTensor=(p,v,S,I,P,U)=>(n._OrtCreateTensor=F.aa)(p,v,S,I,P,U),n._OrtGetTensorData=(p,v,S,I,P)=>(n._OrtGetTensorData=F.ba)(p,v,S,I,P),n._OrtReleaseTensor=p=>(n._OrtReleaseTensor=F.ca)(p),n._OrtCreateRunOptions=(p,v,S,I)=>(n._OrtCreateRunOptions=F.da)(p,v,S,I),n._OrtAddRunConfigEntry=(p,v,S)=>(n._OrtAddRunConfigEntry=F.ea)(p,v,S),n._OrtReleaseRunOptions=p=>(n._OrtReleaseRunOptions=F.fa)(p),n._OrtCreateBinding=p=>(n._OrtCreateBinding=F.ga)(p),n._OrtBindInput=(p,v,S)=>(n._OrtBindInput=F.ha)(p,v,S),n._OrtBindOutput=(p,v,S,I)=>(n._OrtBindOutput=F.ia)(p,v,S,I),n._OrtClearBoundOutputs=p=>(n._OrtClearBoundOutputs=F.ja)(p),n._OrtReleaseBinding=p=>(n._OrtReleaseBinding=F.ka)(p),n._OrtRunWithBinding=(p,v,S,I,P)=>(n._OrtRunWithBinding=F.la)(p,v,S,I,P),n._OrtRun=(p,v,S,I,P,U,K,pe)=>(n._OrtRun=F.ma)(p,v,S,I,P,U,K,pe),n._OrtEndProfiling=p=>(n._OrtEndProfiling=F.na)(p),n._JsepOutput=(p,v,S)=>(n._JsepOutput=F.oa)(p,v,S),n._JsepGetNodeName=p=>(n._JsepGetNodeName=F.pa)(p);var Sn=n._malloc=p=>(Sn=n._malloc=F.qa)(p),Qn=n._free=p=>(Qn=n._free=F.ra)(p),eo=p=>(eo=F.ta)(p),to=()=>(to=F.ua)(),ro=p=>(ro=F.va)(p),At=p=>(At=F.wa)(p),In=p=>(In=F.ya)(p),An=()=>(An=F.za)(),Go=p=>(Go=F.Aa)(p),Xt=()=>(Xt=F.Ba)();n.___start_em_js=927291,n.___stop_em_js=928064;function wa(p){p=Object.assign({},p);var v=I=>()=>I()>>>0,S=I=>P=>I(P)>>>0;return p.__errno_location=v(p.__errno_location),p.malloc=S(p.malloc),p.stackSave=v(p.stackSave),p.stackAlloc=S(p.stackAlloc),p}n.stackAlloc=At,n.stackSave=to,n.stackRestore=ro,n.addFunction=Zn,n.UTF8ToString=ct,n.stringToUTF8=(p,v,S)=>Un(p,le,v,S),n.lengthBytesUTF8=xn;var _t;Mt=function p(){_t||no(),_t||(Mt=p)};function no(){function p(){if(!_t&&(_t=!0,n.calledRun=!0,!V)){if(Kr(lt),t(n),n.onRuntimeInitialized&&n.onRuntimeInitialized(),n.postRun)for(typeof n.postRun=="function"&&(n.postRun=[n.postRun]);n.postRun.length;){var v=n.postRun.shift();We.unshift(v)}Kr(We)}}if(!(0<Bt)){if(n.preRun)for(typeof n.preRun=="function"&&(n.preRun=[n.preRun]);n.preRun.length;)vt();Kr(ke),0<Bt||(n.setStatus?(n.setStatus("Running..."),setTimeout(function(){setTimeout(function(){n.setStatus("")},1),p()},1)):p())}}if(n.preInit)for(typeof n.preInit=="function"&&(n.preInit=[n.preInit]);0<n.preInit.length;)n.preInit.pop()();return no(),e.ready}})();typeof Xh=="object"&&typeof Hs=="object"?Hs.exports=Kh:typeof define=="function"&&define.amd&&define([],()=>Kh)});var Jh=He(()=>{});var Zh=He(()=>{});var Qh={};Mr(Qh,{cpus:()=>Kw});var Kw,em=M(()=>{Kw=void 0});var nm=He((rm,js)=>{"use strict";var tm=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(e={}){function n(){return Le.buffer!=We.buffer&&Ue(),We}function t(){return Le.buffer!=We.buffer&&Ue(),vt}function o(){return Le.buffer!=We.buffer&&Ue(),Bt}function i(){return Le.buffer!=We.buffer&&Ue(),Rt}function s(){return Le.buffer!=We.buffer&&Ue(),Mt}function a(){return Le.buffer!=We.buffer&&Ue(),q}function u(){return Le.buffer!=We.buffer&&Ue(),Ie}function l(){return Le.buffer!=We.buffer&&Ue(),It}var c=e,h,m;c.ready=new Promise((d,f)=>{h=d,m=f}),c.jsepInit=(d,f,g,w,A,k,G,H)=>{c.oc=d,c.Wb=f,c.Yb=g,c.Lb=w,c.Xb=A,c.cb=k,c.Zb=G,c.$b=H,f=(Y,Q,ce)=>(...xe)=>{let Ae=ar,L=Q?.();xe=Y(...xe);let ge=Q?.();return L!==ge&&(Y=ge,ce(L),Q=ce=null),ar!=Ae?s0():xe},g=Y=>async(...Q)=>{try{if(c.Cb)throw Error("Session already started");let ce=c.Cb={cc:Q[0],errors:[]},xe=await Y(...Q);if(c.Cb!==ce)throw Error("Session mismatch");d.flush();let Ae=ce.errors;if(0<Ae.length){let L=await Promise.all(Ae);if(L=L.filter(ge=>ge),0<L.length)throw Error(L.join(`
`))}return xe}finally{c.Cb=null}},c._OrtRun=g(f(c._OrtRun,()=>c._OrtRun,Y=>c._OrtRun=Y)),c._OrtRunWithBinding=g(f(c._OrtRunWithBinding,()=>c._OrtRunWithBinding,Y=>c._OrtRunWithBinding=Y)),c._OrtBindInput=f(c._OrtBindInput,()=>c._OrtBindInput,Y=>c._OrtBindInput=Y),c.jsepRegisterBuffer=(Y,Q,ce,xe)=>d.registerBuffer(Y,Q,ce,xe),c.jsepUnregisterBuffers=Y=>{d.unregisterBuffers(Y)},c.jsepGetBuffer=Y=>d.getBuffer(Y),c.jsepCreateDownloader=(Y,Q,ce)=>d.createDownloader(Y,Q,ce)};var b=Object.assign({},c),x="./this.program",y=(d,f)=>{throw f},T=typeof window=="object",E=typeof importScripts=="function",_=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",C=c.ENVIRONMENT_IS_PTHREAD||!1,D="";function z(d){return c.locateFile?c.locateFile(d,D):D+d}var F,V,ee;if(_){var re=(Vs(),Ar(Gs)),le=(Us(),Ar(Ws));D=E?le.dirname(D)+"/":__dirname+"/",F=(f,g)=>(f=Yr(f)?new URL(f):le.normalize(f),re.readFileSync(f,g?void 0:"utf8")),ee=f=>(f=F(f,!0),f.buffer||(f=new Uint8Array(f)),f),V=(f,g,w,A=!0)=>{f=Yr(f)?new URL(f):le.normalize(f),re.readFile(f,A?void 0:"utf8",(k,G)=>{k?w(k):g(A?G.buffer:G)})},!c.thisProgram&&1<process.argv.length&&(x=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),y=(f,g)=>{throw process.exitCode=f,g},c.inspect=()=>"[Emscripten Module object]";let d;try{d=Jh()}catch(f){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),f}global.Worker=d.Worker}else(T||E)&&(E?D=self.location.href:typeof document<"u"&&document.currentScript&&(D=document.currentScript.src),typeof r<"u"&&r&&(D=r),D.indexOf("blob:")!==0?D=D.substr(0,D.replace(/[?#].*/,"").lastIndexOf("/")+1):D="",_||(F=d=>{var f=new XMLHttpRequest;return f.open("GET",d,!1),f.send(null),f.responseText},E&&(ee=d=>{var f=new XMLHttpRequest;return f.open("GET",d,!1),f.responseType="arraybuffer",f.send(null),new Uint8Array(f.response)}),V=(d,f,g)=>{var w=new XMLHttpRequest;w.open("GET",d,!0),w.responseType="arraybuffer",w.onload=()=>{w.status==200||w.status==0&&w.response?f(w.response):g()},w.onerror=g,w.send(null)}));_&&typeof performance>"u"&&(global.performance=Zh().performance);var R=console.log.bind(console),fe=console.error.bind(console);_&&(R=(...d)=>re.writeSync(1,d.join(" ")+`
`),fe=(...d)=>re.writeSync(2,d.join(" ")+`
`));var Ye=R,se=fe;Object.assign(c,b),b=null,typeof WebAssembly!="object"&&qt("no native wasm support detected");var Le,Je,ke=!1,lt,We,vt,Bt,Rt,Mt,q,Ie,$e,wt,It;function Ue(){var d=Le.buffer;c.HEAP8=We=new Int8Array(d),c.HEAP16=Bt=new Int16Array(d),c.HEAPU8=vt=new Uint8Array(d),c.HEAPU16=Rt=new Uint16Array(d),c.HEAP32=Mt=new Int32Array(d),c.HEAPU32=q=new Uint32Array(d),c.HEAPF32=Ie=new Float32Array(d),c.HEAPF64=It=new Float64Array(d),c.HEAP64=$e=new BigInt64Array(d),c.HEAPU64=wt=new BigUint64Array(d)}var rt=16777216;if(5242880<=rt||qt("INITIAL_MEMORY should be larger than STACK_SIZE, was "+rt+"! (STACK_SIZE=5242880)"),C)Le=c.wasmMemory;else if(Le=new WebAssembly.Memory({initial:rt/65536,maximum:65536,shared:!0}),!(Le.buffer instanceof SharedArrayBuffer))throw se("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&se("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Ue(),rt=Le.buffer.byteLength;var kr=[],Dt=[],vn=[],or=0,Kr=null,Xr=null;function Vn(){if(or--,or==0&&(Kr!==null&&(clearInterval(Kr),Kr=null),Xr)){var d=Xr;Xr=null,d()}}function qt(d){throw d="Aborted("+d+")",se(d),ke=!0,lt=1,d=new WebAssembly.RuntimeError(d+". Build with -sASSERTIONS for more info."),m(d),d}var Wn=d=>d.startsWith("data:application/octet-stream;base64,"),Yr=d=>d.startsWith("file://"),ct;ct="ort-wasm-simd-threaded.wasm",Wn(ct)||(ct=z(ct));function xn(d){if(ee)return ee(d);throw"both async and sync fetching of the wasm failed"}function Un(d){if(T||E){if(typeof fetch=="function"&&!Yr(d))return fetch(d,{credentials:"same-origin"}).then(f=>{if(!f.ok)throw"failed to load wasm binary file at '"+d+"'";return f.arrayBuffer()}).catch(()=>xn(d));if(V)return new Promise((f,g)=>{V(d,w=>f(new Uint8Array(w)),g)})}return Promise.resolve().then(()=>xn(d))}function Tr(d,f,g){return Un(d).then(w=>WebAssembly.instantiate(w,f)).then(w=>w).then(g,w=>{se(`failed to asynchronously prepare wasm: ${w}`),qt(w)})}function Do(d,f){var g=ct;return typeof WebAssembly.instantiateStreaming!="function"||Wn(g)||Yr(g)||_||typeof fetch!="function"?Tr(g,d,f):fetch(g,{credentials:"same-origin"}).then(w=>WebAssembly.instantiateStreaming(w,d).then(f,function(A){return se(`wasm streaming compile failed: ${A}`),se("falling back to ArrayBuffer instantiation"),Tr(g,d,f)}))}var wn={1441368:d=>{c.cb("Abs",d,void 0)},1441419:d=>{c.cb("Neg",d,void 0)},1441470:d=>{c.cb("Floor",d,void 0)},1441523:d=>{c.cb("Ceil",d,void 0)},1441575:d=>{c.cb("Reciprocal",d,void 0)},1441633:d=>{c.cb("Sqrt",d,void 0)},1441685:d=>{c.cb("Exp",d,void 0)},1441736:d=>{c.cb("Erf",d,void 0)},1441787:d=>{c.cb("Sigmoid",d,void 0)},1441842:d=>{c.cb("Log",d,void 0)},1441893:d=>{c.cb("Sin",d,void 0)},1441944:d=>{c.cb("Cos",d,void 0)},1441995:d=>{c.cb("Tan",d,void 0)},1442046:d=>{c.cb("Asin",d,void 0)},1442098:d=>{c.cb("Acos",d,void 0)},1442150:d=>{c.cb("Atan",d,void 0)},1442202:d=>{c.cb("Sinh",d,void 0)},1442254:d=>{c.cb("Cosh",d,void 0)},1442306:d=>{c.cb("Asinh",d,void 0)},1442359:d=>{c.cb("Acosh",d,void 0)},1442412:d=>{c.cb("Atanh",d,void 0)},1442465:d=>{c.cb("Tanh",d,void 0)},1442517:d=>{c.cb("Not",d,void 0)},1442568:(d,f,g)=>{c.cb("ClipV10",d,{min:f,max:g})},1442640:d=>{c.cb("Clip",d,void 0)},1442692:(d,f)=>{c.cb("Elu",d,{alpha:f})},1442750:d=>{c.cb("Relu",d,void 0)},1442802:(d,f)=>{c.cb("LeakyRelu",d,{alpha:f})},1442866:(d,f)=>{c.cb("ThresholdedRelu",d,{alpha:f})},1442936:d=>{c.Zb(d)},1442970:(d,f)=>c.$b(d,f,c.Cb.cc,c.Cb.errors),1443082:(d,f)=>{c.cb("Cast",d,{to:f})},1443140:d=>{c.cb("Add",d,void 0)},1443191:d=>{c.cb("Sub",d,void 0)},1443242:d=>{c.cb("Mul",d,void 0)},1443293:d=>{c.cb("Div",d,void 0)},1443344:d=>{c.cb("Pow",d,void 0)},1443395:d=>{c.cb("Equal",d,void 0)},1443448:d=>{c.cb("Greater",d,void 0)},1443503:d=>{c.cb("GreaterOrEqual",d,void 0)},1443565:d=>{c.cb("Less",d,void 0)},1443617:d=>{c.cb("LessOrEqual",d,void 0)},1443676:(d,f,g,w,A)=>{c.cb("ReduceMean",d,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:w?Array.from(s().subarray(A>>>0,A+w>>>0)):[]})},1443840:(d,f,g,w,A)=>{c.cb("ReduceMax",d,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:w?Array.from(s().subarray(A>>>0,A+w>>>0)):[]})},1444003:(d,f,g,w,A)=>{c.cb("ReduceMin",d,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:w?Array.from(s().subarray(A>>>0,A+w>>>0)):[]})},1444166:(d,f,g,w,A)=>{c.cb("ReduceProd",d,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:w?Array.from(s().subarray(A>>>0,A+w>>>0)):[]})},1444330:(d,f,g,w,A)=>{c.cb("ReduceSum",d,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:w?Array.from(s().subarray(A>>>0,A+w>>>0)):[]})},1444493:(d,f,g,w,A)=>{c.cb("ReduceL1",d,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:w?Array.from(s().subarray(A>>>0,A+w>>>0)):[]})},1444655:(d,f,g,w,A)=>{c.cb("ReduceL2",d,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:w?Array.from(s().subarray(A>>>0,A+w>>>0)):[]})},1444817:(d,f,g,w,A)=>{c.cb("ReduceLogSum",d,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:w?Array.from(s().subarray(A>>>0,A+w>>>0)):[]})},1444983:(d,f,g,w,A)=>{c.cb("ReduceSumSquare",d,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:w?Array.from(s().subarray(A>>>0,A+w>>>0)):[]})},1445152:(d,f,g,w,A)=>{c.cb("ReduceLogSumExp",d,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:w?Array.from(s().subarray(A>>>0,A+w>>>0)):[]})},1445321:d=>{c.cb("Where",d,void 0)},1445374:(d,f,g)=>{c.cb("Transpose",d,{perm:f?Array.from(s().subarray(g>>>0,g+f>>>0)):[]})},1445487:(d,f,g,w,A,k,G,H,Y,Q,ce,xe,Ae)=>{c.cb("Conv",d,{format:Y?"NHWC":"NCHW",auto_pad:f,dilations:[g],group:w,kernel_shape:[A],pads:k?Array.from(s().subarray(G>>>0,G+k>>>0)):[],strides:[H],w_is_const:()=>!!n()[Q>>>0],activation:bt(ce),activation_params:xe?Array.from(u().subarray(Ae>>>0,Ae+xe>>>0)):[]})},1445868:(d,f,g,w,A,k,G,H,Y,Q,ce,xe,Ae,L,ge,Be)=>{c.cb("Conv",d,{format:xe?"NHWC":"NCHW",auto_pad:f,dilations:[g,w],group:A,kernel_shape:[k,G],pads:H?Array.from(s().subarray(Y>>>0,Y+H>>>0)):[],strides:[Q,ce],w_is_const:()=>!!n()[Ae>>>0],activation:bt(L),activation_params:ge?Array.from(u().subarray(Be>>>0,Be+ge>>>0)):[]})},1446270:(d,f,g,w,A,k,G,H,Y,Q,ce,xe,Ae,L,ge)=>{c.cb("ConvTranspose",d,{format:Y?"NHWC":"NCHW",autoPad:f,dilations:[g],group:w,kernel_shape:[A],pads:[k,G],strides:[H],wIsConst:()=>!!n()[Q>>>0],outputPadding:ce?Array.from(s().subarray(xe>>>0,xe+ce>>>0)):[],outputShape:Ae?Array.from(s().subarray(L>>>0,L+Ae>>>0)):[],activation:bt(ge)})},1446684:(d,f,g,w,A,k,G,H,Y,Q,ce,xe,Ae,L)=>{c.cb("ConvTranspose",d,{format:H?"NHWC":"NCHW",autoPad:f,dilations:Array.from(s().subarray(g>>>0,g+2>>>0)),group:w,kernelShape:Array.from(s().subarray(A>>>0,A+2>>>0)),pads:Array.from(s().subarray(k>>>0,k+4>>>0)),strides:Array.from(s().subarray(G>>>0,G+2>>>0)),wIsConst:()=>!!n()[Y>>>0],outputPadding:0<Q?Array.from(s().subarray(ce>>>0,ce+Q>>>0)):[],outputShape:0<xe?Array.from(s().subarray(Ae>>>0,Ae+xe>>>0)):[],activation:bt(L)})},1447241:(d,f,g,w,A,k,G,H,Y,Q,ce,xe,Ae,L,ge)=>{c.cb("ConvTranspose",d,{format:Y?"NHWC":"NCHW",autoPad:f,dilations:[g],group:w,kernel_shape:[A],pads:[k,G],strides:[H],wIsConst:()=>!!n()[Q>>>0],outputPadding:ce?Array.from(s().subarray(xe>>>0,xe+ce>>>0)):[],outputShape:Ae?Array.from(s().subarray(L>>>0,L+Ae>>>0)):[],activation:bt(ge)})},1447655:(d,f,g,w,A,k,G,H,Y,Q,ce,xe,Ae,L)=>{c.cb("ConvTranspose",d,{format:H?"NHWC":"NCHW",autoPad:f,dilations:Array.from(s().subarray(g>>>0,g+2>>>0)),group:w,kernelShape:Array.from(s().subarray(A>>>0,A+2>>>0)),pads:Array.from(s().subarray(k>>>0,k+4>>>0)),strides:Array.from(s().subarray(G>>>0,G+2>>>0)),wIsConst:()=>!!n()[Y>>>0],outputPadding:0<Q?Array.from(s().subarray(ce>>>0,ce+Q>>>0)):[],outputShape:0<xe?Array.from(s().subarray(Ae>>>0,Ae+xe>>>0)):[],activation:bt(L)})},1448212:(d,f)=>{c.cb("GlobalAveragePool",d,{format:f?"NHWC":"NCHW"})},1448303:(d,f,g,w,A,k,G,H,Y,Q,ce,xe,Ae,L,ge,Be)=>{c.cb("AveragePool",d,{format:Be?"NHWC":"NCHW",auto_pad:f,ceil_mode:g,count_include_pad:w,storage_order:A,dilations:[k,G],kernel_shape:[H,Y],pads:[Q,ce,xe,Ae],strides:[L,ge]})},1448587:(d,f)=>{c.cb("GlobalAveragePool",d,{format:f?"NHWC":"NCHW"})},1448678:(d,f,g,w,A,k,G,H,Y,Q,ce,xe,Ae,L,ge,Be)=>{c.cb("AveragePool",d,{format:Be?"NHWC":"NCHW",auto_pad:f,ceil_mode:g,count_include_pad:w,storage_order:A,dilations:[k,G],kernel_shape:[H,Y],pads:[Q,ce,xe,Ae],strides:[L,ge]})},1448962:(d,f)=>{c.cb("GlobalMaxPool",d,{format:f?"NHWC":"NCHW"})},1449049:(d,f,g,w,A,k,G,H,Y,Q,ce,xe,Ae,L,ge,Be)=>{c.cb("MaxPool",d,{format:Be?"NHWC":"NCHW",auto_pad:f,ceil_mode:g,count_include_pad:w,storage_order:A,dilations:[k,G],kernel_shape:[H,Y],pads:[Q,ce,xe,Ae],strides:[L,ge]})},1449329:(d,f)=>{c.cb("GlobalMaxPool",d,{format:f?"NHWC":"NCHW"})},1449416:(d,f,g,w,A,k,G,H,Y,Q,ce,xe,Ae,L,ge,Be)=>{c.cb("MaxPool",d,{format:Be?"NHWC":"NCHW",auto_pad:f,ceil_mode:g,count_include_pad:w,storage_order:A,dilations:[k,G],kernel_shape:[H,Y],pads:[Q,ce,xe,Ae],strides:[L,ge]})},1449696:(d,f,g,w,A)=>{c.cb("Gemm",d,{alpha:f,beta:g,transA:w,transB:A})},1449800:d=>{c.cb("MatMul",d,void 0)},1449854:(d,f,g,w)=>{c.cb("ArgMax",d,{keepDims:!!f,selectLastIndex:!!g,axis:w})},1449962:(d,f,g,w)=>{c.cb("ArgMin",d,{keepDims:!!f,selectLastIndex:!!g,axis:w})},1450070:(d,f)=>{c.cb("Softmax",d,{axis:f})},1450133:(d,f)=>{c.cb("Concat",d,{axis:f})},1450193:(d,f,g,w,A)=>{c.cb("Split",d,{axis:f,numOutputs:g,splitSizes:w?Array.from(s().subarray(A>>>0,A+w>>>0)):[]})},1450338:d=>{c.cb("Expand",d,void 0)},1450392:(d,f)=>{c.cb("Gather",d,{axis:Number(f)})},1450463:(d,f)=>{c.cb("GatherElements",d,{axis:Number(f)})},1450542:(d,f,g,w,A,k,G,H,Y,Q,ce)=>{c.cb("Resize",d,{antialias:f,axes:g?Array.from(s().subarray(w>>>0,w+g>>>0)):[],coordinateTransformMode:bt(A),cubicCoeffA:k,excludeOutside:G,extrapolationValue:H,keepAspectRatioPolicy:bt(Y),mode:bt(Q),nearestMode:bt(ce)})},1450893:(d,f,g,w,A,k,G)=>{c.cb("Slice",d,{starts:f?Array.from(s().subarray(g>>>0,g+f>>>0)):[],ends:w?Array.from(s().subarray(A>>>0,A+w>>>0)):[],axes:k?Array.from(s().subarray(G>>>0,G+k>>>0)):[]})},1451124:d=>{c.cb("Tile",d,void 0)},1451176:(d,f,g)=>{c.cb("LayerNormalization",d,{axis:Number(f),epsilon:Number(g)})},1451283:(d,f,g)=>{c.cb("InstanceNormalization",d,{epsilon:f,format:g?"NHWC":"NCHW"})},1451397:(d,f,g)=>{c.cb("InstanceNormalization",d,{epsilon:f,format:g?"NHWC":"NCHW"})},1451511:d=>{c.cb("Range",d,void 0)},1451564:(d,f)=>{c.cb("Einsum",d,{equation:bt(f)})},1451645:(d,f,g,w,A)=>{c.cb("Pad",d,{mode:f,value:g,pads:w?Array.from(s().subarray(A>>>0,A+w>>>0)):[]})},1451777:d=>{c.cb("Gelu",d,void 0)},1451829:d=>{c.cb("BiasAdd",d,void 0)},1451884:d=>{c.cb("BiasSplitGelu",d,void 0)},1451945:(d,f)=>{c.cb("SkipLayerNormalization",d,{epsilon:f})},1452026:d=>c.Wb(d),1452059:d=>c.Yb(d),1452091:(d,f,g)=>{c.Lb(d,f,g,!0)},1452130:(d,f,g)=>{c.Lb(d,f,g)}};function Jr(d){this.name="ExitStatus",this.message=`Program terminated with exit(${d})`,this.status=d}var Zr=d=>{d.terminate(),d.onmessage=()=>{}},Hn=d=>{if(ve.zb.length==0){var f=z("ort-wasm-simd-threaded.worker.js");f=new Worker(f),ve.zb.push(f),ve.ac(ve.zb[0])}if(f=ve.zb.pop(),!f)return 6;ve.wb.push(f),ve.nb[d.vb]=f,f.vb=d.vb;var g={cmd:"run",start_routine:d.dc,arg:d.Rb,pthread_ptr:d.vb};return _&&f.unref(),f.postMessage(g,d.kc),0},Kt=0,jn=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Tn=(d,f,g)=>{f>>>=0;var w=f+g;for(g=f;d[g]&&!(g>=w);)++g;if(16<g-f&&d.buffer&&jn)return jn.decode(d.buffer instanceof SharedArrayBuffer?d.slice(f,g):d.subarray(f,g));for(w="";f<g;){var A=d[f++];if(A&128){var k=d[f++]&63;if((A&224)==192)w+=String.fromCharCode((A&31)<<6|k);else{var G=d[f++]&63;A=(A&240)==224?(A&15)<<12|k<<6|G:(A&7)<<18|k<<12|G<<6|d[f++]&63,65536>A?w+=String.fromCharCode(A):(A-=65536,w+=String.fromCharCode(55296|A>>10,56320|A&1023))}}else w+=String.fromCharCode(A)}return w},bt=(d,f)=>(d>>>=0)?Tn(t(),d,f):"";function qn(d){if(C)return Ze(0,1,d);lt=d,0<Kt||(ve.ec(),ke=!0),y(d,new Jr(d))}var $n=d=>{if(lt=d,C)throw ko(d),"unwind";qn(d)};function xa(){kr.unshift(()=>{or++,Vn()})}var ve={zb:[],wb:[],Qb:[],nb:{},Fb(){C?(ve.receiveObjectTransfer=ve.bc,ve.threadInitTLS=ve.Pb,ve.setExitStatus=ve.Ob):xa()},Ob:d=>{lt=d},pc:["$terminateWorker"],ec:()=>{for(var d of ve.wb)Zr(d);for(d of ve.zb)Zr(d);ve.zb=[],ve.wb=[],ve.nb=[]},Nb:d=>{var f=d.vb;delete ve.nb[f],ve.zb.push(d),ve.wb.splice(ve.wb.indexOf(d),1),d.vb=0,Ca(f)},bc(){},Pb(){ve.Qb.forEach(d=>d())},ac:d=>new Promise(f=>{d.onmessage=k=>{k=k.data;var G=k.cmd;if(k.targetThread&&k.targetThread!=jo()){var H=ve.nb[k.targetThread];H?H.postMessage(k,k.transferList):se(`Internal error! Worker sent a message "${G}" to target pthread ${k.targetThread}, but that thread no longer exists!`)}else G==="checkMailbox"?en():G==="spawnThread"?Hn(k):G==="cleanupThread"?((k=ve.nb[k.thread])||qt(),ve.Nb(k)):G==="killThread"?(k=k.thread,G=ve.nb[k],delete ve.nb[k],Zr(G),Ca(k),ve.wb.splice(ve.wb.indexOf(G),1),G.vb=0):G==="cancelThread"?ve.nb[k.thread].postMessage({cmd:"cancel"}):G==="loaded"?(d.loaded=!0,f(d)):G==="alert"?alert(`Thread ${k.threadId}: ${k.text}`):k.target==="setimmediate"?d.postMessage(k):G==="callHandler"?c[k.handler](...k.args):G&&se(`worker sent an unknown command ${G}`)},d.onerror=k=>{throw se(`worker sent an error! ${k.filename}:${k.lineno}: ${k.message}`),k},_&&(d.on("message",k=>d.onmessage({data:k})),d.on("error",k=>d.onerror(k)));var g=[],w=[],A;for(A of w)c.hasOwnProperty(A)&&g.push(A);d.postMessage({cmd:"load",handlers:g,urlOrBlob:c.mainScriptUrlOrBlob||r,wasmMemory:Le,wasmModule:Je})})};c.PThread=ve;var $r=d=>{for(;0<d.length;)d.shift()(c)};c.establishStackSpace=()=>{var d=jo(),f=a()[d+52>>>2>>>0];d=a()[d+56>>>2>>>0],al(f,f-d),qo(f)};function ko(d){if(C)return Ze(1,0,d);$n(d)}c.invokeEntryPoint=(d,f)=>{d=sl.apply(null,[d,f]),0<Kt?ve.Ob(d):Ea(d)};function ir(d){this.Ab=d-24,this.lc=function(f){a()[this.Ab+4>>>2>>>0]=f},this.Ib=function(f){a()[this.Ab+8>>>2>>>0]=f},this.Fb=function(f,g){this.Hb(),this.lc(f),this.Ib(g)},this.Hb=function(){a()[this.Ab+16>>>2>>>0]=0}}var kt=0,Bo=0;function Qr(d,f,g,w){return C?Ze(2,1,d,f,g,w):Kn(d,f,g,w)}function Kn(d,f,g,w){if(d>>>=0,f>>>=0,g>>>=0,w>>>=0,typeof SharedArrayBuffer>"u")return se("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var A=[];return C&&A.length===0?Qr(d,f,g,w):(d={dc:g,vb:d,Rb:w,kc:A},C?(d.nc="spawnThread",postMessage(d,A),0):Hn(d))}function Xn(d,f,g){return C?Ze(3,1,d,f,g):0}function Ro(d,f){if(C)return Ze(4,1,d,f)}var Br=d=>{for(var f=0,g=0;g<d.length;++g){var w=d.charCodeAt(g);127>=w?f++:2047>=w?f+=2:55296<=w&&57343>=w?(f+=4,++g):f+=3}return f},Mo=(d,f,g,w)=>{if(g>>>=0,!(0<w))return 0;var A=g;w=g+w-1;for(var k=0;k<d.length;++k){var G=d.charCodeAt(k);if(55296<=G&&57343>=G){var H=d.charCodeAt(++k);G=65536+((G&1023)<<10)|H&1023}if(127>=G){if(g>=w)break;f[g++>>>0]=G}else{if(2047>=G){if(g+1>=w)break;f[g++>>>0]=192|G>>6}else{if(65535>=G){if(g+2>=w)break;f[g++>>>0]=224|G>>12}else{if(g+3>=w)break;f[g++>>>0]=240|G>>18,f[g++>>>0]=128|G>>12&63}f[g++>>>0]=128|G>>6&63}f[g++>>>0]=128|G&63}}return f[g>>>0]=0,g-A},Yn=(d,f,g)=>Mo(d,t(),f,g);function Lo(d,f){if(C)return Ze(5,1,d,f)}function No(d,f,g){if(C)return Ze(6,1,d,f,g)}function Fo(d,f,g){return C?Ze(7,1,d,f,g):0}function Sr(d,f){if(C)return Ze(8,1,d,f)}function Ir(d,f,g){if(C)return Ze(9,1,d,f,g)}function Jn(d,f,g,w){if(C)return Ze(10,1,d,f,g,w)}function Zn(d,f,g,w){if(C)return Ze(11,1,d,f,g,w)}function zo(d,f,g,w){if(C)return Ze(12,1,d,f,g,w)}function Sn(d){if(C)return Ze(13,1,d)}function Qn(d,f){if(C)return Ze(14,1,d,f)}function eo(d,f,g){if(C)return Ze(15,1,d,f,g)}var to=d=>{if(d===null)return"null";var f=typeof d;return f==="object"||f==="array"||f==="function"?d.toString():""+d},ro,At=d=>{for(var f="";t()[d>>>0];)f+=ro[t()[d++>>>0]];return f},In={},An={},Go={},Xt;function wa(d,f,g={}){var w=f.name;if(!d)throw new Xt(`type "${w}" must have a positive integer typeid pointer`);if(An.hasOwnProperty(d)){if(g.Ub)return;throw new Xt(`Cannot register type '${w}' twice`)}An[d]=f,delete Go[d],In.hasOwnProperty(d)&&(f=In[d],delete In[d],f.forEach(A=>A()))}function _t(d,f,g={}){if(!("argPackAdvance"in f))throw new TypeError("registerType registeredInstance requires argPackAdvance");wa(d,f,g)}var no=(d,f,g)=>{switch(f){case 1:return g?w=>n()[w>>>0>>>0]:w=>t()[w>>>0>>>0];case 2:return g?w=>o()[w>>>1>>>0]:w=>i()[w>>>1>>>0];case 4:return g?w=>s()[w>>>2>>>0]:w=>a()[w>>>2>>>0];case 8:return g?w=>$e[w>>>3]:w=>wt[w>>>3];default:throw new TypeError(`invalid integer width (${f}): ${d}`)}};function p(){this.ub=[void 0],this.Kb=[]}var v=new p;function S(d){d>>>=0,d>=v.Ab&&--v.get(d).Mb===0&&v.Ib(d)}var I=d=>{if(!d)throw new Xt("Cannot use deleted val. handle = "+d);return v.get(d).value},P=d=>{switch(d){case void 0:return 1;case null:return 2;case!0:return 3;case!1:return 4;default:return v.Hb({Mb:1,value:d})}};function U(d){return this.fromWireType(s()[d>>>2>>>0])}var K=(d,f)=>{switch(f){case 4:return function(g){return this.fromWireType(u()[g>>>2>>>0])};case 8:return function(g){return this.fromWireType(l()[g>>>3>>>0])};default:throw new TypeError(`invalid float width (${f}): ${d}`)}};function pe(d){return this.fromWireType(a()[d>>>2>>>0])}var oe=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,me=(d,f)=>{for(var g=d>>1,w=g+f/2;!(g>=w)&&i()[g>>>0];)++g;if(g<<=1,32<g-d&&oe)return oe.decode(t().slice(d,g));for(g="",w=0;!(w>=f/2);++w){var A=o()[d+2*w>>>1>>>0];if(A==0)break;g+=String.fromCharCode(A)}return g},he=(d,f,g)=>{if(g===void 0&&(g=2147483647),2>g)return 0;g-=2;var w=f;g=g<2*d.length?g/2:d.length;for(var A=0;A<g;++A){var k=d.charCodeAt(A);o()[f>>>1>>>0]=k,f+=2}return o()[f>>>1>>>0]=0,f-w},_e=d=>2*d.length,De=(d,f)=>{for(var g=0,w="";!(g>=f/4);){var A=s()[d+4*g>>>2>>>0];if(A==0)break;++g,65536<=A?(A-=65536,w+=String.fromCharCode(55296|A>>10,56320|A&1023)):w+=String.fromCharCode(A)}return w},N=(d,f,g)=>{if(f>>>=0,g===void 0&&(g=2147483647),4>g)return 0;var w=f;g=w+g-4;for(var A=0;A<d.length;++A){var k=d.charCodeAt(A);if(55296<=k&&57343>=k){var G=d.charCodeAt(++A);k=65536+((k&1023)<<10)|G&1023}if(s()[f>>>2>>>0]=k,f+=4,f+4>g)break}return s()[f>>>2>>>0]=0,f-w},be=d=>{for(var f=0,g=0;g<d.length;++g){var w=d.charCodeAt(g);55296<=w&&57343>=w&&++g,f+=4}return f},Ce=d=>{if(!ke)try{if(d(),!(0<Kt))try{C?Ea(lt):$n(lt)}catch(f){f instanceof Jr||f=="unwind"||y(1,f)}}catch(f){f instanceof Jr||f=="unwind"||y(1,f)}};function Yt(d){d>>>=0,typeof Atomics.mc=="function"&&(Atomics.mc(s(),d>>>2,d).value.then(en),d+=128,Atomics.store(s(),d>>>2,1))}c.__emscripten_thread_mailbox_await=Yt;var en=()=>{var d=jo();d&&(Yt(d),Ce(()=>il()))};c.checkMailbox=en;var Ky=d=>{var f=Pa();return d=d(),qo(f),d};function Ze(d,f){var g=arguments.length-2,w=arguments;return Ky(()=>{for(var A=2*g,k=Da(8*A),G=k>>>3,H=0;H<g;H++){var Y=w[2+H];typeof Y=="bigint"?($e[G+2*H]=1n,$e[G+2*H+1]=Y):($e[G+2*H]=0n,l()[G+2*H+1>>>0]=Y)}return ol(d,A,k,f)})}var Ta=[],Vo=(d,f)=>{var g=An[d];if(g===void 0)throw d=rl(d),g=At(d),sr(d),new Xt(f+" has unknown type "+g);return g},Xy={},$a=d=>{var f=Xy[d];return f===void 0?At(d):f},Sa=[],ku=()=>typeof globalThis=="object"?globalThis:Function("return this")(),Yy=d=>{var f=Sa.length;return Sa.push(d),f},Jy=(d,f)=>{for(var g=Array(d),w=0;w<d;++w)g[w]=Vo(a()[f+4*w>>>2>>>0],"parameter "+w);return g},Bu=d=>{if(d===void 0)return"_unknown";d=d.replace(/[^a-zA-Z0-9_]/g,"$");var f=d.charCodeAt(0);return 48<=f&&57>=f?`_${d}`:d};function Zy(d,f){return d=Bu(d),{[d]:function(){return f.apply(this,arguments)}}[d]}function Qy(d){var f=Function;if(!(f instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof f} which is not a function`);var g=Zy(f.name||"unknownFunctionName",function(){});return g.prototype=f.prototype,g=new g,d=f.apply(g,d),d instanceof Object?d:g}var e0=d=>{for(var f="",g=0;g<d;++g)f+=(g!==0?", ":"")+"arg"+g;var w="return function emval_allocator_"+d+`(constructor, argTypes, args) {
  var HEAPU32 = getMemory();
`;for(g=0;g<d;++g)w+="var argType"+g+" = requireRegisteredType(HEAPU32[((argTypes)>>>2)], 'parameter "+g+`');
var arg`+g+" = argType"+g+`.readValueFromPointer(args);
args += argType`+g+`['argPackAdvance'];
argTypes += 4;
`;return new Function("requireRegisteredType","Module","valueToHandle","getMemory",w+("var obj = new constructor("+f+`);
return valueToHandle(obj);
}
`))(Vo,c,P,()=>a())},Ru={},_n=d=>d%4===0&&(d%100!==0||d%400===0),Mu=[0,31,60,91,121,152,182,213,244,274,305,335],Lu=[0,31,59,90,120,151,181,212,243,273,304,334];function Nu(d,f,g,w,A,k,G){return C?Ze(16,1,d,f,g,w,A,k,G):-52}function Fu(d,f,g,w,A,k){if(C)return Ze(17,1,d,f,g,w,A,k)}var zu=d=>{var f=Br(d)+1,g=oo(f);return g&&Yn(d,g,f),g},Ia=[],Gu=(d,f)=>{Ia.length=0;for(var g;g=t()[d++>>>0];){var w=g!=105;w&=g!=112,f+=w&&f%8?4:0,Ia.push(g==112?a()[f>>>2>>>0]:g==106?$e[f>>>3]:g==105?s()[f>>>2>>>0]:l()[f>>>3>>>0]),f+=w?8:4}return Ia},Aa={},Vu=()=>{if(!_a){var d={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:x||"./this.program"},f;for(f in Aa)Aa[f]===void 0?delete d[f]:d[f]=Aa[f];var g=[];for(f in d)g.push(`${f}=${d[f]}`);_a=g}return _a},_a;function Wu(d,f){if(C)return Ze(18,1,d,f);d>>>=0,f>>>=0;var g=0;return Vu().forEach((w,A)=>{var k=f+g;for(A=a()[d+4*A>>>2>>>0]=k,k=0;k<w.length;++k)n()[A++>>>0>>>0]=w.charCodeAt(k);n()[A>>>0>>>0]=0,g+=w.length+1}),0}function Uu(d,f){if(C)return Ze(19,1,d,f);d>>>=0,f>>>=0;var g=Vu();a()[d>>>2>>>0]=g.length;var w=0;return g.forEach(A=>w+=A.length+1),a()[f>>>2>>>0]=w,0}function Hu(d){return C?Ze(20,1,d):52}function ju(d,f,g,w){return C?Ze(21,1,d,f,g,w):52}function qu(d,f,g,w){return C?Ze(22,1,d,f,g,w):70}var t0=[null,[],[]];function Ku(d,f,g,w){if(C)return Ze(23,1,d,f,g,w);f>>>=0,g>>>=0,w>>>=0;for(var A=0,k=0;k<g;k++){var G=a()[f>>>2>>>0],H=a()[f+4>>>2>>>0];f+=8;for(var Y=0;Y<H;Y++){var Q=t()[G+Y>>>0],ce=t0[d];Q===0||Q===10?((d===1?Ye:se)(Tn(ce,0)),ce.length=0):ce.push(Q)}A+=H}return a()[w>>>2>>>0]=A,0}var Xu=[31,29,31,30,31,30,31,31,30,31,30,31],Yu=[31,28,31,30,31,30,31,31,30,31,30,31];function r0(d){var f=Array(Br(d)+1);return Mo(d,f,0,f.length),f}var n0=(d,f)=>{n().set(d,f>>>0)};function Ju(d,f,g,w){function A(L,ge,Be){for(L=typeof L=="number"?L.toString():L||"";L.length<ge;)L=Be[0]+L;return L}function k(L,ge){return A(L,ge,"0")}function G(L,ge){function Be(pl){return 0>pl?-1:0<pl?1:0}var tn;return(tn=Be(L.getFullYear()-ge.getFullYear()))===0&&(tn=Be(L.getMonth()-ge.getMonth()))===0&&(tn=Be(L.getDate()-ge.getDate())),tn}function H(L){switch(L.getDay()){case 0:return new Date(L.getFullYear()-1,11,29);case 1:return L;case 2:return new Date(L.getFullYear(),0,3);case 3:return new Date(L.getFullYear(),0,2);case 4:return new Date(L.getFullYear(),0,1);case 5:return new Date(L.getFullYear()-1,11,31);case 6:return new Date(L.getFullYear()-1,11,30)}}function Y(L){var ge=L.xb;for(L=new Date(new Date(L.yb+1900,0,1).getTime());0<ge;){var Be=L.getMonth(),tn=(_n(L.getFullYear())?Xu:Yu)[Be];if(ge>tn-L.getDate())ge-=tn-L.getDate()+1,L.setDate(1),11>Be?L.setMonth(Be+1):(L.setMonth(0),L.setFullYear(L.getFullYear()+1));else{L.setDate(L.getDate()+ge);break}}return Be=new Date(L.getFullYear()+1,0,4),ge=H(new Date(L.getFullYear(),0,4)),Be=H(Be),0>=G(ge,L)?0>=G(Be,L)?L.getFullYear()+1:L.getFullYear():L.getFullYear()-1}d>>>=0,f>>>=0,g>>>=0,w>>>=0;var Q=a()[w+40>>>2>>>0];w={ic:s()[w>>>2>>>0],hc:s()[w+4>>>2>>>0],Db:s()[w+8>>>2>>>0],Jb:s()[w+12>>>2>>>0],Eb:s()[w+16>>>2>>>0],yb:s()[w+20>>>2>>>0],tb:s()[w+24>>>2>>>0],xb:s()[w+28>>>2>>>0],qc:s()[w+32>>>2>>>0],fc:s()[w+36>>>2>>>0],jc:Q?bt(Q):""},g=bt(g),Q={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ce in Q)g=g.replace(new RegExp(ce,"g"),Q[ce]);var xe="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Ae="January February March April May June July August September October November December".split(" ");Q={"%a":L=>xe[L.tb].substring(0,3),"%A":L=>xe[L.tb],"%b":L=>Ae[L.Eb].substring(0,3),"%B":L=>Ae[L.Eb],"%C":L=>k((L.yb+1900)/100|0,2),"%d":L=>k(L.Jb,2),"%e":L=>A(L.Jb,2," "),"%g":L=>Y(L).toString().substring(2),"%G":L=>Y(L),"%H":L=>k(L.Db,2),"%I":L=>(L=L.Db,L==0?L=12:12<L&&(L-=12),k(L,2)),"%j":L=>{for(var ge=0,Be=0;Be<=L.Eb-1;ge+=(_n(L.yb+1900)?Xu:Yu)[Be++]);return k(L.Jb+ge,3)},"%m":L=>k(L.Eb+1,2),"%M":L=>k(L.hc,2),"%n":()=>`
`,"%p":L=>0<=L.Db&&12>L.Db?"AM":"PM","%S":L=>k(L.ic,2),"%t":()=>"	","%u":L=>L.tb||7,"%U":L=>k(Math.floor((L.xb+7-L.tb)/7),2),"%V":L=>{var ge=Math.floor((L.xb+7-(L.tb+6)%7)/7);if(2>=(L.tb+371-L.xb-2)%7&&ge++,ge)ge==53&&(Be=(L.tb+371-L.xb)%7,Be==4||Be==3&&_n(L.yb)||(ge=1));else{ge=52;var Be=(L.tb+7-L.xb-1)%7;(Be==4||Be==5&&_n(L.yb%400-1))&&ge++}return k(ge,2)},"%w":L=>L.tb,"%W":L=>k(Math.floor((L.xb+7-(L.tb+6)%7)/7),2),"%y":L=>(L.yb+1900).toString().substring(2),"%Y":L=>L.yb+1900,"%z":L=>{L=L.fc;var ge=0<=L;return L=Math.abs(L)/60,(ge?"+":"-")+("0000"+(L/60*100+L%60)).slice(-4)},"%Z":L=>L.jc,"%%":()=>"%"},g=g.replace(/%%/g,"\0\0");for(ce in Q)g.includes(ce)&&(g=g.replace(new RegExp(ce,"g"),Q[ce](w)));return g=g.replace(/\0\0/g,"%"),ce=r0(g),ce.length>f?0:(n0(ce,d),ce.length-1)}var Wo=d=>{try{d()}catch(f){qt(f)}};function o0(){var d=ae,f={},g;for(g in d)(function(w){var A=d[w];f[w]=typeof A=="function"?function(){Uo.push(w);try{return A.apply(null,arguments)}finally{ke||(Uo.pop()===w||qt(),ar&&Rr===1&&Uo.length===0&&(Rr=0,Kt+=1,Wo(ll),typeof Fibers<"u"&&Fibers.rc()))}}:A})(g);return f}var Rr=0,ar=null,Zu=0,Uo=[],Qu={},el={},i0=0,Oa=null,a0=[];function s0(){return new Promise((d,f)=>{Oa={resolve:d,reject:f}})}function u0(){var d=oo(65548),f=d+12;a()[d>>>2>>>0]=f,a()[d+4>>>2>>>0]=f+65536,f=Uo[0];var g=Qu[f];return g===void 0&&(g=i0++,Qu[f]=g,el[g]=f),f=g,s()[d+8>>>2>>>0]=f,d}function l0(){var d=s()[ar+8>>>2>>>0];return d=ae[el[d]],--Kt,d()}function c0(d){if(!ke){if(Rr===0){var f=!1,g=!1;d((w=0)=>{if(!ke&&(Zu=w,f=!0,g)){Rr=2,Wo(()=>cl(ar)),typeof Browser<"u"&&Browser.Gb.Tb&&Browser.Gb.resume(),w=!1;try{var A=l0()}catch(H){A=H,w=!0}var k=!1;if(!ar){var G=Oa;G&&(Oa=null,(w?G.reject:G.resolve)(A),k=!0)}if(w&&!k)throw A}}),g=!0,f||(Rr=1,ar=u0(),typeof Browser<"u"&&Browser.Gb.Tb&&Browser.Gb.pause(),Wo(()=>ul(ar)))}else Rr===2?(Rr=0,Wo(dl),sr(ar),ar=null,a0.forEach(w=>Ce(w))):qt(`invalid state: ${Rr}`);return Zu}}function d0(d){return c0(f=>{d().then(f)})}ve.Fb();for(var tl=Array(256),Ho=0;256>Ho;++Ho)tl[Ho]=String.fromCharCode(Ho);ro=tl,Xt=c.BindingError=class extends Error{constructor(d){super(d),this.name="BindingError"}},c.InternalError=class extends Error{constructor(d){super(d),this.name="InternalError"}},Object.assign(p.prototype,{get(d){return this.ub[d]},has(d){return this.ub[d]!==void 0},Hb(d){var f=this.Kb.pop()||this.ub.length;return this.ub[f]=d,f},Ib(d){this.ub[d]=void 0,this.Kb.push(d)}}),v.ub.push({value:void 0},{value:null},{value:!0},{value:!1}),v.Ab=v.ub.length,c.count_emval_handles=()=>{for(var d=0,f=v.Ab;f<v.ub.length;++f)v.ub[f]!==void 0&&++d;return d};var f0=[qn,ko,Qr,Xn,Ro,Lo,No,Fo,Sr,Ir,Jn,Zn,zo,Sn,Qn,eo,Nu,Fu,Wu,Uu,Hu,ju,qu,Ku],p0={ta:function(d,f,g){return d0(async()=>{await c.Xb(d,f,g)})},b:function(d,f,g){throw d>>>=0,new ir(d).Fb(f>>>0,g>>>0),kt=d,Bo++,kt},fa:function(d){nl(d>>>0,!E,1,!T,131072,!1),ve.Pb()},D:function(d){d>>>=0,C?postMessage({cmd:"cleanupThread",thread:d}):((d=ve.nb[d])||qt(),ve.Nb(d))},X:Kn,u:Xn,la:Ro,T:Lo,V:No,M:Fo,ja:Sr,ca:Ir,ia:Jn,F:Zn,U:zo,R:Sn,ka:Qn,S:eo,I:function(d,f,g,w,A){d>>>=0,f>>>=0,g>>>=0,f=At(f);var k=f.indexOf("u")!=-1;k&&(A=(1n<<64n)-1n),_t(d,{name:f,fromWireType:G=>G,toWireType:function(G,H){if(typeof H!="bigint"&&typeof H!="number")throw new TypeError(`Cannot convert "${to(H)}" to ${this.name}`);if(H<w||H>A)throw new TypeError(`Passing a number "${to(H)}" from JS side to C/C++ side to an argument of type "${f}", which is outside the valid range [${w}, ${A}]!`);return H},argPackAdvance:8,readValueFromPointer:no(f,g,!k),Bb:null})},ra:function(d,f,g,w){d>>>=0,f=At(f>>>0),_t(d,{name:f,fromWireType:function(A){return!!A},toWireType:function(A,k){return k?g:w},argPackAdvance:8,readValueFromPointer:function(A){return this.fromWireType(t()[A>>>0])},Bb:null})},qa:function(d,f){d>>>=0,f=At(f>>>0),_t(d,{name:f,fromWireType:g=>{var w=I(g);return S(g),w},toWireType:(g,w)=>P(w),argPackAdvance:8,readValueFromPointer:U,Bb:null})},H:function(d,f,g){d>>>=0,g>>>=0,f=At(f>>>0),_t(d,{name:f,fromWireType:w=>w,toWireType:(w,A)=>A,argPackAdvance:8,readValueFromPointer:K(f,g),Bb:null})},w:function(d,f,g,w,A){if(d>>>=0,g>>>=0,f=At(f>>>0),A===-1&&(A=4294967295),A=H=>H,w===0){var k=32-8*g;A=H=>H<<k>>>k}var G=f.includes("unsigned")?function(H,Y){return Y>>>0}:function(H,Y){return Y};_t(d,{name:f,fromWireType:A,toWireType:G,argPackAdvance:8,readValueFromPointer:no(f,g,w!==0),Bb:null})},p:function(d,f,g){function w(k){var G=a()[k>>>2>>>0];return k=a()[k+4>>>2>>>0],new A(n().buffer,k,G)}d>>>=0;var A=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][f];g=At(g>>>0),_t(d,{name:g,fromWireType:w,argPackAdvance:8,readValueFromPointer:w},{Ub:!0})},J:function(d,f){d>>>=0,f=At(f>>>0);var g=f==="std::string";_t(d,{name:f,fromWireType:function(w){var A=a()[w>>>2>>>0],k=w+4;if(g)for(var G=k,H=0;H<=A;++H){var Y=k+H;if(H==A||t()[Y>>>0]==0){if(G=bt(G,Y-G),Q===void 0)var Q=G;else Q+=String.fromCharCode(0),Q+=G;G=Y+1}}else{for(Q=Array(A),H=0;H<A;++H)Q[H]=String.fromCharCode(t()[k+H>>>0]);Q=Q.join("")}return sr(w),Q},toWireType:function(w,A){A instanceof ArrayBuffer&&(A=new Uint8Array(A));var k=typeof A=="string";if(!(k||A instanceof Uint8Array||A instanceof Uint8ClampedArray||A instanceof Int8Array))throw new Xt("Cannot pass non-string to std::string");var G=g&&k?Br(A):A.length,H=oo(4+G+1),Y=H+4;if(a()[H>>>2>>>0]=G,g&&k)Yn(A,Y,G+1);else if(k)for(k=0;k<G;++k){var Q=A.charCodeAt(k);if(255<Q)throw sr(Y),new Xt("String has UTF-16 code units that do not fit in 8 bits");t()[Y+k>>>0]=Q}else for(k=0;k<G;++k)t()[Y+k>>>0]=A[k];return w!==null&&w.push(sr,H),H},argPackAdvance:8,readValueFromPointer:pe,Bb(w){sr(w)}})},B:function(d,f,g){if(d>>>=0,f>>>=0,g>>>=0,g=At(g),f===2)var w=me,A=he,k=_e,G=()=>i(),H=1;else f===4&&(w=De,A=N,k=be,G=()=>a(),H=2);_t(d,{name:g,fromWireType:Y=>{for(var Q=a()[Y>>>2>>>0],ce=G(),xe,Ae=Y+4,L=0;L<=Q;++L){var ge=Y+4+L*f;(L==Q||ce[ge>>>H]==0)&&(Ae=w(Ae,ge-Ae),xe===void 0?xe=Ae:(xe+=String.fromCharCode(0),xe+=Ae),Ae=ge+f)}return sr(Y),xe},toWireType:(Y,Q)=>{if(typeof Q!="string")throw new Xt(`Cannot pass non-string to C++ string type ${g}`);var ce=k(Q),xe=oo(4+ce+f);return a()[xe>>>2]=ce>>H,A(Q,xe+4,ce+f),Y!==null&&Y.push(sr,xe),xe},argPackAdvance:8,readValueFromPointer:U,Bb(Y){sr(Y)}})},sa:function(d,f){d>>>=0,f=At(f>>>0),_t(d,{Vb:!0,name:f,argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})},oa:()=>!0,P:function(d,f){d>>>=0,d==f>>>0?setTimeout(()=>en()):C?postMessage({targetThread:d,cmd:"checkMailbox"}):(d=ve.nb[d])&&d.postMessage({cmd:"checkMailbox"})},Y:function(d,f,g,w){f>>>=0,g/=2,Ta.length=g,w=w>>>0>>>3;for(var A=0;A<g;A++)Ta[A]=$e[w+2*A]?$e[w+2*A+1]:l()[w+2*A+1>>>0];return d=0>d?wn[-d-1]:f0[d],ve.Sb=f,f=d.apply(null,Ta),ve.Sb=0,f},ea:Yt,na:function(d){_&&ve.nb[d>>>0].ref()},v:function(d,f,g){f>>>=0,g>>>=0,d=I(d>>>0),f=Vo(f,"emval::as");var w=[],A=P(w);return a()[g>>>2>>>0]=A,f.toWireType(w,d)},l:function(d,f,g,w,A){g>>>=0,w>>>=0,A>>>=0,d=Sa[d>>>0],f=I(f>>>0),g=$a(g);var k=[];return d=d(f,g,k,A),k.length&&(a()[w>>>2>>>0]=P(k)),d},c:S,L:function(d,f){return f>>>=0,d=I(d>>>0),f=I(f),d==f},q:function(d){return d>>>=0,d===0?P(ku()):(d=$a(d),P(ku()[d]))},k:function(d,f){f=Jy(d,f>>>0);var g=f.shift();d--;for(var w=["retType"],A=[g],k="",G=0;G<d;++G)k+=(G!==0?", ":"")+"arg"+G,w.push("argType"+G),A.push(f[G]);G=g.name+"_$"+f.map(Q=>Q.name).join("_")+"$";var H="return function "+Bu("methodCaller_"+G)+`(handle, name, destructors, args) {
`,Y=0;for(G=0;G<d;++G)H+="    var arg"+G+" = argType"+G+".readValueFromPointer(args"+(Y?"+"+Y:"")+`);
`,Y+=f[G].argPackAdvance;for(H+="    var rv = handle[name]("+k+`);
`,G=0;G<d;++G)f[G].deleteObject&&(H+="    argType"+G+".deleteObject(arg"+G+`);
`);return g.Vb||(H+=`    return retType.toWireType(destructors, rv);
`),w.push(H+`};
`),d=Qy(w).apply(null,A),Yy(d)},t:function(d,f){return f>>>=0,d=I(d>>>0),f=I(f),P(d[f])},h:function(d){d>>>=0,4<d&&(v.get(d).Mb+=1)},r:function(d,f,g,w){g>>>=0,w>>>=0,d=I(d>>>0);var A=Ru[f];return A||(A=e0(f),Ru[f]=A),A(d,g,w)},x:function(){return P([])},m:function(d){d=I(d>>>0);for(var f=Array(d.length),g=0;g<d.length;g++)f[g]=d[g];return P(f)},e:function(d){return P($a(d>>>0))},j:function(){return P({})},i:function(d){d>>>=0;for(var f=I(d);f.length;){var g=f.pop();f.pop()(g)}S(d)},g:function(d,f,g){f>>>=0,g>>>=0,d=I(d>>>0),f=I(f),g=I(g),d[f]=g},d:function(d,f){return f>>>=0,d=Vo(d>>>0,"_emval_take_value"),d=d.readValueFromPointer(f),P(d)},$:function(d,f){d=-9007199254740992>d||9007199254740992<d?NaN:Number(d),f>>>=0,d=new Date(1e3*d),s()[f>>>2>>>0]=d.getUTCSeconds(),s()[f+4>>>2>>>0]=d.getUTCMinutes(),s()[f+8>>>2>>>0]=d.getUTCHours(),s()[f+12>>>2>>>0]=d.getUTCDate(),s()[f+16>>>2>>>0]=d.getUTCMonth(),s()[f+20>>>2>>>0]=d.getUTCFullYear()-1900,s()[f+24>>>2>>>0]=d.getUTCDay(),d=(d.getTime()-Date.UTC(d.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,s()[f+28>>>2>>>0]=d},aa:function(d,f){d=-9007199254740992>d||9007199254740992<d?NaN:Number(d),f>>>=0,d=new Date(1e3*d),s()[f>>>2>>>0]=d.getSeconds(),s()[f+4>>>2>>>0]=d.getMinutes(),s()[f+8>>>2>>>0]=d.getHours(),s()[f+12>>>2>>>0]=d.getDate(),s()[f+16>>>2>>>0]=d.getMonth(),s()[f+20>>>2>>>0]=d.getFullYear()-1900,s()[f+24>>>2>>>0]=d.getDay();var g=(_n(d.getFullYear())?Mu:Lu)[d.getMonth()]+d.getDate()-1|0;s()[f+28>>>2>>>0]=g,s()[f+36>>>2>>>0]=-(60*d.getTimezoneOffset()),g=new Date(d.getFullYear(),6,1).getTimezoneOffset();var w=new Date(d.getFullYear(),0,1).getTimezoneOffset();d=(g!=w&&d.getTimezoneOffset()==Math.min(w,g))|0,s()[f+32>>>2>>>0]=d},ba:function(d){d>>>=0;var f=new Date(s()[d+20>>>2>>>0]+1900,s()[d+16>>>2>>>0],s()[d+12>>>2>>>0],s()[d+8>>>2>>>0],s()[d+4>>>2>>>0],s()[d>>>2>>>0],0),g=s()[d+32>>>2>>>0],w=f.getTimezoneOffset(),A=new Date(f.getFullYear(),6,1).getTimezoneOffset(),k=new Date(f.getFullYear(),0,1).getTimezoneOffset(),G=Math.min(k,A);return 0>g?s()[d+32>>>2>>>0]=+(A!=k&&G==w):0<g!=(G==w)&&(A=Math.max(k,A),f.setTime(f.getTime()+6e4*((0<g?G:A)-w))),s()[d+24>>>2>>>0]=f.getDay(),g=(_n(f.getFullYear())?Mu:Lu)[f.getMonth()]+f.getDate()-1|0,s()[d+28>>>2>>>0]=g,s()[d>>>2>>>0]=f.getSeconds(),s()[d+4>>>2>>>0]=f.getMinutes(),s()[d+8>>>2>>>0]=f.getHours(),s()[d+12>>>2>>>0]=f.getDate(),s()[d+16>>>2>>>0]=f.getMonth(),s()[d+20>>>2>>>0]=f.getYear(),BigInt(f.getTime()/1e3)},Z:Nu,_:Fu,O:function(d,f,g){function w(Q){return(Q=Q.toTimeString().match(/\(([A-Za-z ]+)\)$/))?Q[1]:"GMT"}d>>>=0,f>>>=0,g>>>=0;var A=new Date().getFullYear(),k=new Date(A,0,1),G=new Date(A,6,1);A=k.getTimezoneOffset();var H=G.getTimezoneOffset(),Y=Math.max(A,H);a()[d>>>2>>>0]=60*Y,s()[f>>>2>>>0]=+(A!=H),d=w(k),f=w(G),d=zu(d),f=zu(f),H<A?(a()[g>>>2>>>0]=d,a()[g+4>>>2>>>0]=f):(a()[g>>>2>>>0]=f,a()[g+4>>>2>>>0]=d)},o:()=>{qt("")},f:function(d,f,g){return d>>>=0,f=Gu(f>>>0,g>>>0),wn[d].apply(null,f)},K:function(d,f,g){return d>>>=0,f=Gu(f>>>0,g>>>0),wn[d].apply(null,f)},E:()=>{},G:()=>Date.now(),ma:()=>{throw Kt+=1,"unwind"},Q:function(){return 4294901760},n:()=>performance.timeOrigin+performance.now(),z:()=>_?(em(),Ar(Qh)).cpus().length:navigator.hardwareConcurrency,N:function(d){d>>>=0;var f=t().length;if(d<=f||4294901760<d)return!1;for(var g=1;4>=g;g*=2){var w=f*(1+.2/g);w=Math.min(w,d+100663296);var A=Math;w=Math.max(d,w);e:{A=(A.min.call(A,4294901760,w+(65536-w%65536)%65536)-Le.buffer.byteLength+65535)/65536;try{Le.grow(A),Ue();var k=1;break e}catch{}k=void 0}if(k)return!0}return!1},ga:Wu,ha:Uu,W:$n,y:Hu,C:ju,da:qu,A:Ku,a:Le||c.wasmMemory,pa:Ju,s:function(d,f,g,w){return Ju(d>>>0,f>>>0,g>>>0,w>>>0)}},ae=function(){var d={a:p0};return or++,Do(d,function(f){var g=f.module;ae=f.instance.exports,ae=o0(),ae=h0(),ve.Qb.push(ae.$a),Dt.unshift(ae.ua),Je=g,Vn()}).catch(m),{}}();c._OrtInit=(d,f)=>(c._OrtInit=ae.va)(d,f),c._OrtGetLastError=(d,f)=>(c._OrtGetLastError=ae.wa)(d,f),c._OrtCreateSessionOptions=(d,f,g,w,A,k,G,H,Y,Q)=>(c._OrtCreateSessionOptions=ae.xa)(d,f,g,w,A,k,G,H,Y,Q),c._OrtAppendExecutionProvider=(d,f)=>(c._OrtAppendExecutionProvider=ae.ya)(d,f),c._OrtAddFreeDimensionOverride=(d,f,g)=>(c._OrtAddFreeDimensionOverride=ae.za)(d,f,g),c._OrtAddSessionConfigEntry=(d,f,g)=>(c._OrtAddSessionConfigEntry=ae.Aa)(d,f,g),c._OrtReleaseSessionOptions=d=>(c._OrtReleaseSessionOptions=ae.Ba)(d),c._OrtCreateSession=(d,f,g)=>(c._OrtCreateSession=ae.Ca)(d,f,g),c._OrtReleaseSession=d=>(c._OrtReleaseSession=ae.Da)(d),c._OrtGetInputOutputCount=(d,f,g)=>(c._OrtGetInputOutputCount=ae.Ea)(d,f,g),c._OrtGetInputName=(d,f)=>(c._OrtGetInputName=ae.Fa)(d,f),c._OrtGetOutputName=(d,f)=>(c._OrtGetOutputName=ae.Ga)(d,f),c._OrtFree=d=>(c._OrtFree=ae.Ha)(d),c._OrtCreateTensor=(d,f,g,w,A,k)=>(c._OrtCreateTensor=ae.Ia)(d,f,g,w,A,k),c._OrtGetTensorData=(d,f,g,w,A)=>(c._OrtGetTensorData=ae.Ja)(d,f,g,w,A),c._OrtReleaseTensor=d=>(c._OrtReleaseTensor=ae.Ka)(d),c._OrtCreateRunOptions=(d,f,g,w)=>(c._OrtCreateRunOptions=ae.La)(d,f,g,w),c._OrtAddRunConfigEntry=(d,f,g)=>(c._OrtAddRunConfigEntry=ae.Ma)(d,f,g),c._OrtReleaseRunOptions=d=>(c._OrtReleaseRunOptions=ae.Na)(d),c._OrtCreateBinding=d=>(c._OrtCreateBinding=ae.Oa)(d),c._OrtBindInput=(d,f,g)=>(c._OrtBindInput=ae.Pa)(d,f,g),c._OrtBindOutput=(d,f,g,w)=>(c._OrtBindOutput=ae.Qa)(d,f,g,w),c._OrtClearBoundOutputs=d=>(c._OrtClearBoundOutputs=ae.Ra)(d),c._OrtReleaseBinding=d=>(c._OrtReleaseBinding=ae.Sa)(d),c._OrtRunWithBinding=(d,f,g,w,A)=>(c._OrtRunWithBinding=ae.Ta)(d,f,g,w,A),c._OrtRun=(d,f,g,w,A,k,G,H)=>(c._OrtRun=ae.Ua)(d,f,g,w,A,k,G,H),c._OrtEndProfiling=d=>(c._OrtEndProfiling=ae.Va)(d),c._JsepOutput=(d,f,g)=>(c._JsepOutput=ae.Wa)(d,f,g),c._JsepGetNodeName=d=>(c._JsepGetNodeName=ae.Xa)(d);var jo=c._pthread_self=()=>(jo=c._pthread_self=ae.Ya)(),oo=c._malloc=d=>(oo=c._malloc=ae.Za)(d),sr=c._free=d=>(sr=c._free=ae._a)(d);c.__emscripten_tls_init=()=>(c.__emscripten_tls_init=ae.$a)();var rl=d=>(rl=ae.ab)(d);c.__embind_initialize_bindings=()=>(c.__embind_initialize_bindings=ae.bb)();var nl=c.__emscripten_thread_init=(d,f,g,w,A,k)=>(nl=c.__emscripten_thread_init=ae.db)(d,f,g,w,A,k);c.__emscripten_thread_crashed=()=>(c.__emscripten_thread_crashed=ae.eb)();var ol=(d,f,g,w)=>(ol=ae.fb)(d,f,g,w),Ca=d=>(Ca=ae.gb)(d),Ea=c.__emscripten_thread_exit=d=>(Ea=c.__emscripten_thread_exit=ae.hb)(d),il=c.__emscripten_check_mailbox=()=>(il=c.__emscripten_check_mailbox=ae.ib)(),al=(d,f)=>(al=ae.jb)(d,f),Pa=()=>(Pa=ae.kb)(),qo=d=>(qo=ae.lb)(d),Da=d=>(Da=ae.mb)(d),sl=c.dynCall_ii=(d,f)=>(sl=c.dynCall_ii=ae.ob)(d,f),ul=d=>(ul=ae.pb)(d),ll=()=>(ll=ae.qb)(),cl=d=>(cl=ae.rb)(d),dl=()=>(dl=ae.sb)();c.___start_em_js=1452163,c.___stop_em_js=1452324;function h0(){var d=ae;d=Object.assign({},d);var f=w=>()=>w()>>>0,g=w=>A=>w(A)>>>0;return d.__errno_location=f(d.__errno_location),d.Ya=f(d.Ya),d.Za=g(d.Za),d.ab=g(d.ab),d.kb=f(d.kb),d.mb=g(d.mb),d}c.wasmMemory=Le,c.stackAlloc=Da,c.stackSave=Pa,c.stackRestore=qo,c.keepRuntimeAlive=()=>0<Kt,c.UTF8ToString=bt,c.stringToUTF8=Yn,c.lengthBytesUTF8=Br,c.ExitStatus=Jr,c.PThread=ve;var Ko;Xr=function d(){Ko||fl(),Ko||(Xr=d)};function fl(){0<or||(C?(h(c),C||$r(Dt),startWorker(c)):($r(kr),0<or||Ko||(Ko=!0,c.calledRun=!0,ke||(C||$r(Dt),h(c),C||$r(vn)))))}return fl(),e.ready}})();typeof rm=="object"&&typeof js=="object"?js.exports=tm:typeof define=="function"&&define.amd&&define([],()=>tm)});var om=He((fP,Xw)=>{Xw.exports='"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\n'});var am,Yw,qs,Ks,qi,im,Jw,Zw,Qw,sm,tt,Gn=M(()=>{"use strict";am=Yh();Yw=nm(),Ks=!1,qi=!1,im=!1,Jw=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},Zw=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Qw=(r,e)=>r?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":e?"ort-wasm-threaded.wasm":"ort-wasm.wasm",sm=async r=>{if(Ks)return Promise.resolve();if(qi)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(im)throw new Error("previous call to 'initializeWebAssembly()' failed.");qi=!0;let e=r.initTimeout,n=r.numThreads,t=r.simd,o=n>1&&Jw(),i=t&&Zw(),s=r.wasmPaths,a=typeof s=="string"?s:void 0,u=Qw(i,o),l=typeof s=="object"?s[u]:void 0,c=!1,h=[];if(e>0&&h.push(new Promise(m=>{setTimeout(()=>{c=!0,m()},e)})),h.push(new Promise((m,b)=>{let x=o?Yw:am,y={locateFile:(T,E)=>{if(o&&T.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([om()],{type:"text/javascript"}));if(T.endsWith(".wasm")){if(l)return l;let _=a??E;return u==="ort-wasm-simd.wasm"?_+"ort-wasm-simd.jsep.wasm":u==="ort-wasm-simd-threaded.wasm"?_+"ort-wasm-simd-threaded.jsep.wasm":_+u}return E+T}};if(o)if(typeof Blob>"u")y.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let T=`var ortWasmThreaded=${x.toString()};`;y.mainScriptUrlOrBlob=new Blob([T],{type:"text/javascript"})}x(y).then(T=>{qi=!1,Ks=!0,qs=T,m()},T=>{qi=!1,im=!0,b(T)})})),await Promise.race(h),c)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},tt=()=>{if(Ks&&qs)return qs;throw new Error("WebAssembly is not initialized yet.")}});var at,To,Xe,Ki=M(()=>{"use strict";Gn();at=(r,e)=>{let n=tt(),t=n.lengthBytesUTF8(r)+1,o=n._malloc(t);return n.stringToUTF8(r,o,t),e.push(o),o},To=(r,e,n,t)=>{if(typeof r=="object"&&r!==null){if(n.has(r))throw new Error("Circular reference in options");n.add(r)}Object.entries(r).forEach(([o,i])=>{let s=e?e+o:o;if(typeof i=="object")To(i,s+".",n,t);else if(typeof i=="string"||typeof i=="number")t(s,i.toString());else if(typeof i=="boolean")t(s,i?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof i}`)})},Xe=r=>{let e=tt(),n=e.stackSave();try{let t=e.stackAlloc(8);e._OrtGetLastError(t,t+4);let o=e.HEAP32[t/4],i=e.HEAPU32[t/4+1],s=i?e.UTF8ToString(i):"";throw new Error(`${r} ERROR_CODE: ${o}, ERROR_MESSAGE: ${s}`)}finally{e.stackRestore(n)}}});var um,lm=M(()=>{"use strict";Gn();Ki();um=r=>{let e=tt(),n=0,t=[],o=r||{};try{if(r?.logSeverityLevel===void 0)o.logSeverityLevel=2;else if(typeof r.logSeverityLevel!="number"||!Number.isInteger(r.logSeverityLevel)||r.logSeverityLevel<0||r.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${r.logSeverityLevel}`);if(r?.logVerbosityLevel===void 0)o.logVerbosityLevel=0;else if(typeof r.logVerbosityLevel!="number"||!Number.isInteger(r.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${r.logVerbosityLevel}`);r?.terminate===void 0&&(o.terminate=!1);let i=0;return r?.tag!==void 0&&(i=at(r.tag,t)),n=e._OrtCreateRunOptions(o.logSeverityLevel,o.logVerbosityLevel,!!o.terminate,i),n===0&&Xe("Can't create run options."),r?.extra!==void 0&&To(r.extra,"",new WeakSet,(s,a)=>{let u=at(s,t),l=at(a,t);e._OrtAddRunConfigEntry(n,u,l)!==0&&Xe(`Can't set a run config entry: ${s} - ${a}.`)}),[n,t]}catch(i){throw n!==0&&e._OrtReleaseRunOptions(n),t.forEach(s=>e._free(s)),i}}});var e2,t2,r2,n2,cm,dm=M(()=>{"use strict";Gn();Ki();e2=r=>{switch(r){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${r}`)}},t2=r=>{switch(r){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${r}`)}},r2=r=>{r.extra||(r.extra={}),r.extra.session||(r.extra.session={});let e=r.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1"),r.executionProviders&&r.executionProviders.some(n=>(typeof n=="string"?n:n.name)==="webgpu")&&(r.enableMemPattern=!1)},n2=(r,e,n)=>{for(let t of e){let o=typeof t=="string"?t:t.name;switch(o){case"xnnpack":o="XNNPACK";break;case"webnn":if(o="WEBNN",typeof t!="string"){let s=t;if(s?.deviceType){let a=at("deviceType",n),u=at(s.deviceType,n);tt()._OrtAddSessionConfigEntry(r,a,u)!==0&&Xe(`Can't set a session config entry: 'deviceType' - ${s.deviceType}.`)}if(s?.numThreads){let a=s.numThreads;(typeof a!="number"||!Number.isInteger(a)||a<0)&&(a=0);let u=at("numThreads",n),l=at(a.toString(),n);tt()._OrtAddSessionConfigEntry(r,u,l)!==0&&Xe(`Can't set a session config entry: 'numThreads' - ${s.numThreads}.`)}if(s?.powerPreference){let a=at("powerPreference",n),u=at(s.powerPreference,n);tt()._OrtAddSessionConfigEntry(r,a,u)!==0&&Xe(`Can't set a session config entry: 'powerPreference' - ${s.powerPreference}.`)}}break;case"webgpu":if(o="JS",typeof t!="string"){let s=t;if(s?.preferredLayout){if(s.preferredLayout!=="NCHW"&&s.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${s.preferredLayout}`);let a=at("preferredLayout",n),u=at(s.preferredLayout,n);tt()._OrtAddSessionConfigEntry(r,a,u)!==0&&Xe(`Can't set a session config entry: 'preferredLayout' - ${s.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${o}`)}let i=at(o,n);tt()._OrtAppendExecutionProvider(r,i)!==0&&Xe(`Can't append execution provider: ${o}.`)}},cm=r=>{let e=tt(),n=0,t=[],o=r||{};r2(o);try{let i=e2(o.graphOptimizationLevel??"all"),s=t2(o.executionMode??"sequential"),a=typeof o.logId=="string"?at(o.logId,t):0,u=o.logSeverityLevel??2;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log serverity level is not valid: ${u}`);let l=o.logVerbosityLevel??0;if(!Number.isInteger(l)||l<0||l>4)throw new Error(`log verbosity level is not valid: ${l}`);let c=typeof o.optimizedModelFilePath=="string"?at(o.optimizedModelFilePath,t):0;if(n=e._OrtCreateSessionOptions(i,!!o.enableCpuMemArena,!!o.enableMemPattern,s,!!o.enableProfiling,0,a,u,l,c),n===0&&Xe("Can't create session options."),o.executionProviders&&n2(n,o.executionProviders,t),o.freeDimensionOverrides)for(let[h,m]of Object.entries(o.freeDimensionOverrides)){if(typeof h!="string")throw new Error(`free dimension override name must be a string: ${h}`);if(typeof m!="number"||!Number.isInteger(m)||m<0)throw new Error(`free dimension override value must be a non-negative integer: ${m}`);let b=at(h,t);e._OrtAddFreeDimensionOverride(n,b,m)!==0&&Xe(`Can't set a free dimension override: ${h} - ${m}.`)}return o.extra!==void 0&&To(o.extra,"",new WeakSet,(h,m)=>{let b=at(h,t),x=at(m,t);e._OrtAddSessionConfigEntry(n,b,x)!==0&&Xe(`Can't set a session config entry: ${h} - ${m}.`)}),[n,t]}catch(i){throw n!==0&&e._OrtReleaseSessionOptions(n),t.forEach(s=>e._free(s)),i}}});var Xs,$o,So,Xi,Io,Yi,Ys,pt=M(()=>{"use strict";Xs=r=>{switch(r){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${r}`)}},$o=r=>{switch(r){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${r}`)}},So=r=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][r],Xi=r=>{switch(r){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${r}`)}},Io=r=>{switch(r){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${r}`)}},Yi=r=>r==="float32"||r==="int32"||r==="int64"||r==="bool"||r==="float16"||r==="uint32",Ys=r=>{switch(r){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${r}`)}}});var o2,i2,fm,pm,hm,a2,et,Wr=M(()=>{"use strict";pt();o2=["V","I","W","E","F"],i2=(r,e)=>{console.log(`[${o2[r]},${new Date().toISOString()}]${e}`)},hm=(r,e)=>{fm=r,pm=e},a2=(r,e)=>{let n=Io(r),t=Io(fm);n>=t&&i2(n,typeof e=="function"?e():e)},et=(...r)=>{pm&&a2(...r)}});var mm,gm=M(()=>{"use strict";pt();mm=(r,e)=>new(Xi(e))(r)});var bm=M(()=>{"use strict"});var Ji,s2,ym,Zs,Js,vm,xm=M(()=>{"use strict";Wr();bm();Ji=r=>Math.ceil(r/16)*16,s2=1,ym=()=>s2++,Zs=async(r,e,n,t)=>{let o=Ji(n),i=r.device.createBuffer({size:o,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let s=r.getCommandEncoder();r.endComputePass(),s.copyBufferToBuffer(e,0,i,0,o),r.flush(),await i.mapAsync(GPUMapMode.READ);let a=i.getMappedRange();if(t){let u=t();return u.set(new Uint8Array(a,0,n)),u}else return new Uint8Array(a.slice(0,n))}finally{i.destroy()}},Js=class{constructor(e){this.backend=e;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(e,n){let t=n.buffer,o=n.byteOffset,i=n.byteLength,s=Ji(i),a=this.storageCache.get(e);if(!a)throw new Error("gpu data for uploading does not exist");if(a.originalSize!==i)throw new Error(`inconsistent data size. gpu data size=${a.originalSize}, data size=${i}`);let u=this.backend.device.createBuffer({mappedAtCreation:!0,size:s,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),l=u.getMappedRange();new Uint8Array(l).set(new Uint8Array(t,o,i)),u.unmap();let c=this.backend.getCommandEncoder();this.backend.endComputePass(),c.copyBufferToBuffer(u,0,a.gpuData.buffer,0,s),et("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${e})`),this.buffersForUploadingPending.push(u)}memcpy(e,n){let t=this.storageCache.get(e);if(!t)throw new Error("source gpu data for memcpy does not exist");let o=this.storageCache.get(n);if(!o)throw new Error("destination gpu data for memcpy does not exist");if(t.originalSize!==o.originalSize)throw new Error("inconsistent source and destination gpu data size");let i=Ji(t.originalSize),s=this.backend.getCommandEncoder();this.backend.endComputePass(),s.copyBufferToBuffer(t.gpuData.buffer,0,o.gpuData.buffer,0,i)}registerExternalBuffer(e,n,t){let o;if(t){if(o=this.externalBuffers.get(t),o===void 0)throw new Error("previous buffer is not registered");if(e===t)return et("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${n}) => id=${o}, buffer is the same, skip.`),o;this.externalBuffers.delete(t)}else o=ym();return this.storageCache.set(o,{gpuData:{id:o,type:0,buffer:e},originalSize:n}),this.externalBuffers.set(e,o),et("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${n}) => id=${o}, registered.`),o}unregisterExternalBuffer(e){let n=this.externalBuffers.get(e);n!==void 0&&(this.storageCache.delete(n),this.externalBuffers.delete(e),et("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${n}`))}create(e,n=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let t=Ji(e),o,i=(n&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,s=(n&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(i||s){let u=i?this.freeBuffers:this.freeUniformBuffers,l=u.get(t);l||(l=[],u.set(t,l)),l.length>0?o=l.pop():o=this.backend.device.createBuffer({size:t,usage:n})}else o=this.backend.device.createBuffer({size:t,usage:n});let a={id:ym(),type:0,buffer:o};return this.storageCache.set(a.id,{gpuData:a,originalSize:e}),et("verbose",()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${a.id}`),a}get(e){return this.storageCache.get(e)?.gpuData}release(e){let n=this.storageCache.get(e);if(!n)throw new Error("releasing data does not exist");return et("verbose",()=>`[WebGPU] GpuDataManager.release(id=${e}), gpuDataId=${n.gpuData.id}`),this.storageCache.delete(e),this.buffersPending.push(n.gpuData.buffer),n.originalSize}async download(e,n){let t=this.storageCache.get(e);if(!t)throw new Error("data does not exist");await Zs(this.backend,t.gpuData.buffer,t.originalSize,n)}refreshPendingBuffers(){for(let e of this.buffersForUploadingPending)e.destroy();this.buffersForUploadingPending=[];for(let e of this.buffersPending)(e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(e.size).push(e):(e.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(e.size).push(e):e.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(e=>{e.forEach(n=>{n.destroy()})}),this.freeUniformBuffers.forEach(e=>{e.forEach(n=>{n.destroy()})}),this.storageCache.forEach(e=>{e.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},vm=(...r)=>new Js(...r)});var Qs,ye,st=M(()=>{"use strict";Qs=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this._cacheKey}},ye=r=>new Qs(r)});var eu,mr,W,gn,Zi,Qi,ea,Pe=M(()=>{"use strict";eu=class{static calcMatMulShape(e,n){return e[1]!==n[0]?void 0:[e[0],n[1]]}},mr=class{static calcShape(e,n,t=!1){let o=e.length,i=n.length;if(o===0)return n;if(i===0)return e;let s=Math.max(e.length,n.length),a=new Array(s);if(t){if(o<2||i<2)return;let u=eu.calcMatMulShape([e[o-2],e[o-1]],[n[i-2],n[i-1]]);if(u===void 0)return;[a[s-2],a[s-1]]=u}for(let u=t?3:1;u<=s;u++){let l=o-u<0?1:e[o-u],c=i-u<0?1:n[i-u];if(l!==c&&l>1&&c>1)return;a[s-u]=Math.max(l,c)}return a}static isValidBroadcast(e,n){let t=e.length,o=n.length;if(t>o)return!1;for(let i=1;i<=t;i++)if(e[t-i]!==1&&e[t-i]!==n[o-i])return!1;return!0}},W=class r{static size(e){return r.getSizeFromDimensionRange(e,0,e.length)}static sizeFromDimension(e,n){if(n<0||n>e.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return r.getSizeFromDimensionRange(e,n,e.length)}static sizeToDimension(e,n){if(n<0||n>e.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${e.length} dimensions.`);return r.getSizeFromDimensionRange(e,0,n)}static getSizeFromDimensionRange(e,n,t){let o=1;for(let i=n;i<t;i++){if(e[i]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");o*=e[i]}return o}static computeStrides(e){let n=e.length;if(n===0)return[];if(n===1)return[1];let t=new Array(n);t[n-1]=1,t[n-2]=e[n-1];for(let o=n-3;o>=0;--o)t[o]=t[o+1]*e[o+1];return t}static normalizeAxis(e,n){if(e<-n&&e>=n)throw new Error("unsupported axis for this operation.");return e<0?e+n:e}static normalizeAxes(e,n){return e.map(t=>this.normalizeAxis(t,n??e.length))}static sortBasedOnPerm(e,n){return n?n.map(t=>e[t]):e.slice().reverse()}static padShape(e,n){let t=e.length;return e.map((o,i)=>o+n[i]+n[i+t])}static areEqual(e,n){return e.length!==n.length?!1:e.every((t,o)=>t===n[o])}},gn=class r{static adjustPoolAttributes(e,n,t,o,i,s){if(!e&&t.length!==n.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let a=0;a<n.length-2;a++)a>=t.length?t.push(n[a+2]):t[a]=n[a+2];for(let a=0;a<t.length;a++)if(a<o.length){if(o[a]<0)throw new Error("strides should be greater than or equal to 1")}else o.push(1);for(let a=0;a<t.length;a++)if(a<i.length){if(i[a]<0)throw new Error("dilations should be greater than or equal to 1")}else i.push(1);for(let a=0;a<t.length*2;a++)if(a<s.length){if(s[a]<0)throw new Error("pad should be greater than or equal to 1")}else s.push(0);for(let a=0;a<t.length;a++){if(t[a]<=0)throw new Error("kernel shapes need to be greater than 0");if(s[a]>=t[a]||s[a+t.length]>=t[a])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,n,t,o,i,s,a){if(a){if(i.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(o.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let u=0;u<e.length-2;u++)r.adjustPadAndReturnShape(e[u+(s?1:2)],n[u],t[u],o[u],i,u,u+e.length-2,a)}}static computePoolOutputShape(e,n,t,o,i,s,a){if(n.length<=0)throw new Error("input shape must be of size greater than 0");let u=[n[0],n[1]];return r.computeShapeHelper(e,n,u,t,o,i,s,a),u}static computeConvOutputShape(e,n,t,o,i,s,a){if(e.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let u=[e[0],n[0]];return r.computeShapeHelper(!1,e,u,t,o,i,s,a),u}static computeShapeHelper(e,n,t,o,i,s,a,u){if(e)for(let l=0;l<n.length-2;l++)t.push(1);else for(let l=0;l<n.length-2;l++)t.push(r.adjustPadAndReturnShape(n[l+2],o[l],i[l],s[l],a,l,l+n.length-2,u))}static adjustPadAndReturnShape(e,n,t,o,i,s,a,u){let l=t*(o-1)+1;if(u&&u!=="NOTSET")switch(u){case"VALID":return i[s]=0,i[a]=0,Math.floor((e-l)/n+1);case"SAME_LOWER":case"SAME_UPPER":if(t!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let h=((e+n-1)/n-1)*n+o-e;return i[s]=Math.floor(u==="SAME_LOWER"?(h+1)/2:h/2),i[a]=h-i[s],Math.floor((e+h-o)/n+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((e+i[s]+i[a]-l)/n+1)}},Zi=class{static getShapeOfGemmResult(e,n,t,o,i){if(e.length!==2||t.length!==2)throw new Error("shape need to be of size 2");let s,a,u;n?(s=e[1],a=e[0]):(s=e[0],a=e[1]);let l=-1;if(o?(u=t[0],l=1):(u=t[1],l=0),t[l]!==a)throw new Error("dimension mismatch");if(s<=0||u<=0||a<=0)throw new Error("invalid shape specified");if(i&&!mr.isValidBroadcast(i,[s,u]))throw new Error("gemm: invalid bias shape for broadcast");return[s,u,a]}},Qi=-34028234663852886e22,ea=34028234663852886e22});var u2,wm,ut,gr,Er,rr,bn,Ur,Tm,J,ne,tu,$m,ru,Pr,Ge=M(()=>{"use strict";pt();Pe();u2=64,wm=(r,e)=>{if(e===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(r){case 10:return e>1?`vec${e}<f16>`:"f16";case 1:return e>1?`vec${e}<f32>`:"f32";case 6:return e>1?`vec${e}<i32>`:"i32";case 12:return e>1?`vec${e}<u32>`:"u32";case 7:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(e!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${r}`)}},ut=(r,e=1)=>{let n=wm(r,e);return typeof n=="string"?n:n[0]},gr=r=>r.length===0?[]:[{type:"uint32",data:r},{type:"uint32",data:W.computeStrides(r)}],Er=r=>r%4===0?4:r%2===0?2:1,rr=(r="f32",e,n="0")=>!e||e===1?`${r}(${n})`:`vec${e}<${r}>(${n})`,bn=(r,e,n)=>r==="f32"?n:e===1?`f32(${n})`:`vec${e}f(${n})`,Ur=(r,e)=>e===4?`(${r}.x + ${r}.y + ${r}.z + ${r}.w)`:e===2?`(${r}.x + ${r}.y)`:e===3?`(${r}.x + ${r}.y + ${r}.z)`:r,Tm=(r,e,n,t,o)=>{let i=typeof n=="number",s=i?n:n.length,a=[...new Array(s).keys()],u=s<2?"u32":s<=4?`vec${s}<u32>`:`array<u32, ${s}>`,l=wm(e,o),c=typeof l=="string"?l:l[1],h=typeof l=="string"?l:l[0],m={indices:u,value:c,storage:h,tensor:e},b=q=>typeof q=="string"?q:`${q}u`,x={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},y=i?"uniforms.":"",T=`${y}${r}_shape`,E=`${y}${r}_strides`,_="";for(let q=0;q<s-1;q++)_+=`
    let dim${q} = current / ${E}[${q}];
    let rest${q} = current % ${E}[${q}];
    indices[${q}] = dim${q};
    current = rest${q};
    `;_+=`indices[${s-1}] = current;`;let C=s<2?"":`
  fn o2i_${r}(offset: u32) -> ${m.indices} {
    var indices: ${m.indices};
    var current = offset;
    ${_}
    return indices;
  }`,D=q=>(x.offsetToIndices=!0,s<2?q:`o2i_${r}(${q})`),z=[];if(s>=2)for(let q=s-1;q>=0;q--)z.push(`${E}[${q}] * (indices[${q}])`);let F=s<2?"":`
  fn i2o_${r}(indices: ${m.indices}) -> u32 {
    return ${z.join("+")};
  }`,V=q=>(x.indicesToOffset=!0,s<2?q:`i2o_${r}(${q})`),ee=(...q)=>s===0?"0u":`${m.indices}(${q.map(b).join(",")})`,re=(q,Ie)=>s<2?`${q}`:`${q}[${Ie}]`,le=(q,Ie,$e)=>s<2?`${q}=${$e};`:`${q}[${Ie}]=${$e};`,R={},fe=(q,Ie)=>{x.broadcastedIndicesToOffset=!0;let $e=`${Ie.name}broadcastedIndicesTo${r}Offset`;if($e in R)return`${$e}(${q})`;let wt=[];for(let It=s-1;It>=0;It--){let Ue=Ie.indicesGet("outputIndices",It+Ie.rank-s);wt.push(`${re(E,It)} * (${Ue} % ${re(T,It)})`)}return R[$e]=`fn ${$e}(outputIndices: ${Ie.type.indices}) -> u32 {
             return ${wt.length>0?wt.join("+"):"0u"};
           }`,`${$e}(${q})`},Ye=(q,Ie)=>(()=>{if(m.storage===m.value)return`${r}[${q}]=${Ie};`;if(m.storage==="vec2<u32>"&&m.value==="i32")return`${r}[${q}]=vec2<u32>(u32(${Ie}), select(0u, 0xFFFFFFFFu, ${Ie} < 0));`;if(m.storage==="vec2<u32>"&&m.value==="u32")return`${r}[${q}]=vec2<u32>(u32(${Ie}), 0u);`;if(m.storage==="u32"&&m.value==="vec4<bool>")return`${r}[${q}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${Ie}));`;throw new Error(`not supported combination of storage type ${m.storage} and value type ${m.value} yet`)})(),se=q=>(()=>{if(m.storage===m.value)return`${r}[${q}]`;if(m.storage==="vec2<u32>"&&m.value==="i32")return`i32(${r}[${q}].x)`;if(m.storage==="vec2<u32>"&&m.value==="u32")return`u32(${r}[${q}].x)`;if(m.storage==="u32"&&m.value==="vec4<bool>")return`vec4<bool>(bool(${r}[${q}] & 0xFFu), bool(${r}[${q}] & 0xFF00u), bool(${r}[${q}] & 0xFF0000u), bool(${r}[${q}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${m.storage} and value type ${m.value} yet`)})(),Le=s<2?"":`
  fn get_${r}ByIndices(indices: ${m.indices}) -> ${c} {
    return ${se(`i2o_${r}(indices)`)};
  }`,Je=s<2?"":(()=>{let q=a.map($e=>`d${$e}: u32`).join(", "),Ie=a.map($e=>`d${$e}`).join(", ");return`
  fn get_${r}(${q}) -> ${c} {
    return get_${r}ByIndices(${ee(Ie)});
  }`})(),ke=(...q)=>{if(q.length!==s)throw new Error(`indices length must be ${s}`);let Ie=q.map(b).join(",");return s===0?se("0u"):s===1?se(Ie[0]):(x.get=!0,x.getByIndices=!0,x.indicesToOffset=!0,`get_${r}(${Ie})`)},lt=q=>s<2?se(q):(x.getByIndices=!0,x.indicesToOffset=!0,`get_${r}ByIndices(${q})`),We=s<2?"":`
  fn set_${r}ByIndices(indices: ${m.indices}, value: ${c}) {
    ${Ye(`i2o_${r}(indices)`,"value")}
  }`,vt=s<2?"":(()=>{let q=a.map($e=>`d${$e}: u32`).join(", "),Ie=a.map($e=>`d${$e}`).join(", ");return`
  fn set_${r}(${q}, value: ${c}) {
    set_${r}ByIndices(${ee(Ie)}, value);
  }`})();return{impl:()=>{let q=[];return i||(q.push(`const ${T} = ${m.indices}(${n.join(",")});`),q.push(`const ${E} = ${m.indices}(${W.computeStrides(n).join(",")});`)),x.offsetToIndices&&q.push(C),x.indicesToOffset&&q.push(F),x.broadcastedIndicesToOffset&&Object.values(R).forEach(Ie=>q.push(Ie)),x.set&&q.push(vt),x.setByIndices&&q.push(We),x.get&&q.push(Je),x.getByIndices&&q.push(Le),q.join(`
`)},type:m,offsetToIndices:D,indicesToOffset:V,broadcastedIndicesToOffset:fe,indices:ee,indicesGet:re,indicesSet:le,set:(...q)=>{if(q.length!==s+1)throw new Error(`indices length must be ${s}`);let Ie=q[s];if(typeof Ie!="string")throw new Error("value must be string");let $e=q.slice(0,s).map(b).join(",");return s===0?Ye("0u",Ie):s===1?Ye($e[0],Ie):(x.set=!0,x.setByIndices=!0,x.indicesToOffset=!0,`set_${r}(${$e}, ${Ie})`)},setByOffset:Ye,setByIndices:(q,Ie)=>s<2?Ye(q,Ie):(x.setByIndices=!0,x.indicesToOffset=!0,`set_${r}ByIndices(${q}, ${Ie});`),get:ke,getByOffset:se,getByIndices:lt,usage:t?"input":"output",name:r,strides:E,shape:T,rank:s}},J=(r,e,n,t=1)=>Tm(r,e,n,!0,t),ne=(r,e,n,t=1)=>Tm(r,e,n,!1,t),tu=class{constructor(e){this.normalizedDispatchGroup=e;this.indicesHelpers=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${typeof e=="number"?`${e}u`:e}) { return; }`}mainStart(e=u2){let n=typeof e=="number"?e:e[0],t=typeof e=="number"?1:e[1],o=typeof e=="number"?1:e[2],i=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,s=i?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,a=i?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${n*t*o}u + local_index;`;return`@compute @workgroup_size(${n}, ${t}, ${o})
  fn main(${s}) {
    ${a}
  `}declareVariable(e,n){this.indicesHelpers.push(e),e.rank!==0&&(e.shape.startsWith("uniforms.")&&this.uniforms.push({name:e.shape.replace("uniforms.",""),type:e.type.indices}),e.strides.startsWith("uniforms.")&&this.uniforms.push({name:e.strides.replace("uniforms.",""),type:e.type.indices}));let t=e.usage==="input"?"read":"read_write",o=e.type.storage;return`@group(0) @binding(${n}) var<storage, ${t}> ${e.name}: array<${o}>;`}declareVariables(...e){return e.map(n=>this.declareVariable(n,this.variableIndex++)).join(`
`)}registerUniform(e,n){return this.uniforms.push({name:e,type:n}),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let e=[];for(let{name:n,type:t}of this.uniforms)e.push(`${n}:${t}`);return`
      struct Uniforms { ${e.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.indicesHelpers.map(e=>e.impl()).join(`
`)}},$m=r=>new tu(r),ru=(r,e)=>{let n=r.length,t=[];for(let o=0;o<n;o++){let i=n-1-o,s=r[i]||1;(e[e.length-1-o]||1)>1&&s===1&&t.unshift(i)}return t},Pr=r=>r<=4});var l2,Sm,c2,d2,Hr,Im,Am,Ao=M(()=>{"use strict";Pe();st();Ge();l2=r=>{if(!r||r.length!==1)throw new Error("Transpose requires 1 input.")},Sm=(r,e)=>e&&e.length!==r?[...new Array(r).keys()].reverse():e,c2=(r,e)=>W.sortBasedOnPerm(r,Sm(r.length,e)),d2=(r,e,n,t)=>{let o=[];o.push(`fn perm(i: ${t.type.indices}) -> ${n.type.indices} {
    var a: ${n.type.indices};`);for(let i=0;i<e;++i)o.push(n.indicesSet("a",r[i],`i[${i}]`));return o.push("return a;}"),o.join(`
`)},Hr=(r,e)=>{let n=r.dataType,t=r.dims.length,o=Sm(t,e),i=Pr(t),s=c2(r.dims,o),a=i?s.length:s,u=i?t:r.dims,l=ne("output",n,a),c=J("a",n,u),h=m=>`
  ${m.registerUniform("output_size","u32").declareVariables(c,l)}

  ${d2(o,t,c,l)}

  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${l.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${l.setByOffset("global_idx",c.getByIndices("aIndices"))}
  }`;return{name:"Transpose",shaderCache:{hint:`${e}`,inputDependencies:i?["rank"]:["dims"]},getRunData:m=>{let b=W.size(s);return{outputs:[{dims:s,dataType:m[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:i?[{type:"uint32",data:b},...gr(m[0].dims),...gr(s)]:[{type:"uint32",data:b}]}},getShaderSource:h}},Im=(r,e)=>{l2(r.inputs),r.compute(Hr(r.inputs[0],e.perm))},Am=r=>ye({perm:r.perm})});var f2,p2,h2,m2,g2,b2,y2,v2,x2,w2,br,_m,Om,Cm,Em,Pm,Dm,km,Bm,Rm,Mm,Lm=M(()=>{"use strict";Pe();Ge();ta();Ao();f2={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},p2={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},h2={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},m2={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},g2=(r,e)=>{let n=[];for(let t=e-r;t<e;++t)n.push(t);return n},b2=(r,e)=>{let n=[],t=r.length;for(let i=0;i<t;i++)e.indexOf(i)===-1&&n.push(r[i]);let o=e.map(i=>r[i]);return[n,o]},y2=(r,e)=>{let n=r.length+e.length,t=[],o=0;for(let i=0;i<n;i++)e.indexOf(i)===-1?t.push(r[o++]):t.push(1);return t},v2=(r,e)=>{for(let n=0;n<r.length;++n)if(r[r.length-n-1]!==e-1-n)return!1;return!0},x2=(r,e)=>{let n=[];if(!v2(r,e)){for(let t=0;t<e;++t)r.indexOf(t)===-1&&n.push(t);r.forEach(t=>n.push(t))}return n},w2=(r,e,n,t,o,i,s)=>{let a=n[0].dims,u=W.size(i),l=W.size(s),c=J("_A",n[0].dataType,a),h=ne("output",o,i),m=32,b=`
          var<workgroup> aBestValues : array<${h.type.storage}, ${m}>;
       `;return{name:r,shaderCache:e,getShaderSource:y=>`
        ${y.registerUniform("reduceSize","u32").declareVariables(c,h)}
        ${b}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${y.mainStart(m)}
          let local_idx = local_id.x;

          let outputIndex = global_idx / ${m};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = ${h.type.storage}(${h2[t]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${m}) {
           let candidate = ${h.type.storage}(${c.getByOffset("offset + k")});
           bestValue = ${f2[t]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${m}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${p2[t]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${h.setByOffset("outputIndex",`${t==="mean"?`bestValue / ${h.type.storage}(uniforms.reduceSize)`:`${m2[t]}`}`)};
         }
        }`,getRunData:()=>({outputs:[{dims:i,dataType:o}],dispatchGroup:{x:u},programUniforms:[{type:"uint32",data:l}]})}},br=(r,e,n,t)=>{let o=r.inputs.length===1?n:nu(r.inputs,n),i=o.axes;i.length===0&&!o.noopWithEmptyAxes&&(i=r.inputs[0].dims.map((b,x)=>x));let s=W.normalizeAxes(i,r.inputs[0].dims.length),a=s,u=r.inputs[0],l=x2(a,r.inputs[0].dims.length);l.length>0&&(u=r.compute(Hr(r.inputs[0],l),{inputs:[0],outputs:[-1]})[0],a=g2(a.length,u.dims.length));let[c,h]=b2(u.dims,a),m=c;o.keepDims&&(m=y2(c,s)),r.compute(w2(e,{hint:o.cacheKey,inputDependencies:["type"]},[u],t,r.inputs[0].dataType,m,h),{inputs:[u]})},_m=(r,e)=>{br(r,"ReduceMeanShared",e,"mean")},Om=(r,e)=>{br(r,"ReduceL1Shared",e,"l1")},Cm=(r,e)=>{br(r,"ReduceL2Shared",e,"l2")},Em=(r,e)=>{br(r,"ReduceLogSumExpShared",e,"logSumExp")},Pm=(r,e)=>{br(r,"ReduceMaxShared",e,"max")},Dm=(r,e)=>{br(r,"ReduceMinShared",e,"min")},km=(r,e)=>{br(r,"ReduceProdShared",e,"prod")},Bm=(r,e)=>{br(r,"ReduceSumShared",e,"sum")},Rm=(r,e)=>{br(r,"ReduceSumSquareShared",e,"sumSquare")},Mm=(r,e)=>{br(r,"ReduceLogSumShared",e,"logSum")}});var yr,T2,ra,nu,vr,$2,S2,I2,A2,_2,O2,C2,E2,P2,D2,xr,Nm,Fm,zm,Gm,Vm,Wm,Um,Hm,jm,qm,nr,ta=M(()=>{"use strict";Pe();st();Ge();Lm();yr=r=>{if(!r||r.length===0||r.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(r.length===2&&r[1].dims.length!==1)throw new Error("Invalid axes input dims.")},T2=r=>["","",`var value = ${r.getByOffset("inputOffset")};`,""],ra=(r,e,n,t,o,i,s=!1,a=!1)=>{let u=[],l=n[0].dims,c=W.normalizeAxes(o,n[0].dims.length),h=!a&&c.length===0;l.forEach((V,ee)=>{h||c.indexOf(ee)>=0?s&&u.push(1):u.push(V)});let m=[],b=J("_A",n[0].dataType,l),x=ne("output",i,u),y=t(b,x,c),T=`inputOffset = ${b.indicesToOffset("inputIndices")};`,E=`let ${T};`,_=`var ${T};`,C=y[1]===""?"":_,D=(y[1]===""?E:T)+`
`+y[2];for(let V=0,ee=0;V<n[0].dims.length;V++)h||c.indexOf(V)>=0?(s&&ee++,D=`for(var j${V}: u32 = 0; j${V} < ${n[0].dims[V]}; j${V}++) {
                ${y[2].includes("lastIndex")?`let lastIndex = j${V};`:""}
                ${b.indicesSet("inputIndices",V,`j${V}`)}
                ${D}
              }`):(m.push(`${b.indicesSet("inputIndices",V,x.indicesGet("outputIndices",ee))};`),ee++);let z=W.size(u);return{name:r,shaderCache:e,getShaderSource:V=>`
        ${V.declareVariables(b,x)}

        ${V.mainStart()}
          ${V.guardAgainstOutOfBoundsWorkgroupSizes(z)}
          var inputIndices: ${b.type.indices};
          let outputIndices = ${x.offsetToIndices("global_idx")};

          ${m.join(`
`)}
          ${y[0]}       // init ops for reduce max/min
          ${C}
          ${y[1]}
          ${D}
          ${y[3]}
          ${y.length===4?x.setByOffset("global_idx","value"):y.slice(4).join(`
`)}
        }`,getRunData:()=>({outputs:[{dims:u,dataType:i}],dispatchGroup:{x:Math.ceil(z/64)}})}},nu=(r,e)=>{let n=[];return r[1].dims[0]>0&&r[1].getBigInt64Array().forEach(t=>n.push(Number(t))),ye({axes:n,keepDims:e.keepDims,noopWithEmptyAxes:e.noopWithEmptyAxes})},vr=(r,e,n,t)=>{let o=r.inputs,i=o.length===1?n:nu(o,n);r.compute(ra(e,{hint:i.cacheKey},[o[0]],i.noopWithEmptyAxes&&i.axes.length===0?T2:t,i.axes,o[0].dataType,i.keepDims,i.noopWithEmptyAxes),{inputs:[0]})},$2=(r,e)=>{yr(r.inputs),vr(r,"ReduceLogSum",e,(t,o)=>[`var value = ${o.type.storage}(0);`,"",`value += ${t.getByOffset("inputOffset")};`,"value = log(value);"])},S2=(r,e)=>{yr(r.inputs),vr(r,"ReduceL1",e,(t,o)=>[`var value = ${o.type.storage}(0);`,"",`value += abs(${t.getByOffset("inputOffset")});`,""])},I2=(r,e)=>{yr(r.inputs),vr(r,"ReduceL2",e,(t,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,"",`t = ${t.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])},A2=(r,e)=>{yr(r.inputs),vr(r,"ReduceLogSumExp",e,(t,o)=>[`var value = ${o.type.storage}(0);`,"",`value += exp(${t.getByOffset("inputOffset")});`,"value = log(value);"])},_2=(r,e)=>{yr(r.inputs),vr(r,"ReduceMax",e,(t,o,i)=>{let s=[];for(let a=0;a<t.rank;a++)(i.indexOf(a)>=0||i.length===0)&&s.push(t.indicesSet("inputIndices",a,0));return[`${s.join(`
`)}`,`var value = ${t.getByOffset("inputOffset")};`,`value = max(value, ${t.getByOffset("inputOffset")});`,""]})},O2=(r,e)=>{yr(r.inputs),vr(r,"ReduceMean",e,(t,o,i)=>{let s=1;for(let a=0;a<t.rank;a++)(i.indexOf(a)>=0||i.length===0)&&(s*=r.inputs[0].dims[a]);return["var sum = f32(0);","",`sum += f32(${t.getByOffset("inputOffset")});`,`let value = ${o.type.value}(sum / ${s});`]})},C2=(r,e)=>{yr(r.inputs),vr(r,"ReduceMin",e,(t,o,i)=>{let s=[];for(let a=0;a<t.rank;a++)(i.indexOf(a)>=0||i.length===0)&&s.push(`inputIndices[${a}] = 0;`);return[`${s.join(`
`)}`,`var value = ${t.getByOffset("inputOffset")};`,`value = min(value, ${t.getByOffset("inputOffset")});`,""]})},E2=(r,e)=>{yr(r.inputs),vr(r,"ReduceProd",e,(t,o)=>[`var value = ${o.type.storage}(1);`,"",`value *= ${t.getByOffset("inputOffset")};`,""])},P2=(r,e)=>{yr(r.inputs),vr(r,"ReduceSum",e,(t,o)=>[`var value = ${o.type.storage}(0);`,"",`value += ${t.getByOffset("inputOffset")};`,""])},D2=(r,e)=>{yr(r.inputs),vr(r,"ReduceSumSquare",e,(t,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,"",`t = ${t.getByOffset("inputOffset")}; value += t * t;`,""])},xr=(r,e,n)=>{if(e.length===0)return!!n;let t=1,o=1;for(let i=0;i<e.length;i++)e.indexOf(i)===-1?t*=r[i]:o*=r[i];return o<32&&t>1024},Nm=(r,e)=>{xr(r.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?O2(r,e):_m(r,e)},Fm=(r,e)=>{xr(r.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?S2(r,e):Om(r,e)},zm=(r,e)=>{xr(r.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?I2(r,e):Cm(r,e)},Gm=(r,e)=>{xr(r.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?A2(r,e):Em(r,e)},Vm=(r,e)=>{xr(r.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?_2(r,e):Pm(r,e)},Wm=(r,e)=>{xr(r.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?C2(r,e):Dm(r,e)},Um=(r,e)=>{xr(r.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?E2(r,e):km(r,e)},Hm=(r,e)=>{xr(r.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?P2(r,e):Bm(r,e)},jm=(r,e)=>{xr(r.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?D2(r,e):Rm(r,e)},qm=(r,e)=>{xr(r.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?$2(r,e):Mm(r,e)},nr=r=>ye(r)});var Km,Xm,Ym,Jm,ou,Zm=M(()=>{"use strict";pt();st();ta();Km=r=>{if(!r||r.length===0||r.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(r[0].dataType!==1)throw new Error("Invalid input type.")},Xm=(r,e)=>ye({axis:e.axis,keepDims:e.keepDims,selectLastIndex:e.selectLastIndex}),Ym=(r,e)=>{Km(r.inputs);let n=(o,i,s)=>{let a=[];for(let u=0;u<o.rank;u++)(s.indexOf(u)>=0||s.length===0)&&a.push(`inputIndices[${u}] = 0;`);return[`${a.join(`
`)}`,`var value = ${o.getByOffset("inputOffset")};
var bestIndex : i32 = 0;`,`if (${o.getByOffset("inputOffset")} ${e.selectLastIndex>0?"<=":"<"} value) {
         value = ${o.getByOffset("inputOffset")};
         bestIndex = i32(lastIndex);
       }`,"",i.setByOffset("global_idx","bestIndex")]},t=r.inputs.length===1?e:Xm(r.inputs,e);r.compute(ra("ArgMin",{hint:t.cacheKey},[r.inputs[0]],n,[t.axis],7,t.keepDims),{inputs:[0]})},Jm=(r,e)=>{Km(r.inputs);let n=(o,i,s)=>{let a=[];for(let u=0;u<o.rank;u++)(s.indexOf(u)>=0||s.length===0)&&a.push(`inputIndices[${u}] = 0;`);return[`${a.join(`
`)}`,`var value = ${o.getByOffset("inputOffset")};
var bestIndex : i32 = 0;`,`if (${o.getByOffset("inputOffset")} ${e.selectLastIndex>0?">=":">"} value) {
         value = ${o.getByOffset("inputOffset")};
         bestIndex = i32(lastIndex);
       }`,"",i.setByOffset("global_idx","bestIndex")]},t=r.inputs.length===1?e:Xm(r.inputs,e);r.compute(ra("argMax",{hint:t.cacheKey},[r.inputs[0]],n,[t.axis],7,t.keepDims),{inputs:[0]})},ou=r=>ye(r)});var k2,B2,Qm,eg=M(()=>{"use strict";Pe();Ge();k2=r=>{if(r[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(r[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(r[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(r[0].dims[2]!==r[1].dims[0])throw new Error("last dimension of input and bias are not the same")},B2=r=>{let e=r[0].dims,n=r[0].dims[2],t=W.size(e)/4,o=r[0].dataType,i=J("input",o,e,4),s=J("bias",o,[n],4),a=J("residual",o,e,4),u=ne("output",o,e,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:e,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(t/64)}}),getShaderSource:c=>`
  const channels = ${n}u / 4;
  ${c.declareVariables(i,s,a,u)}

  ${c.mainStart()}
    ${c.guardAgainstOutOfBoundsWorkgroupSizes(t)}
    let value = ${i.getByOffset("global_idx")}
      + ${s.getByOffset("global_idx % channels")} + ${a.getByOffset("global_idx")};
    ${u.setByOffset("global_idx","value")}
  }`}},Qm=r=>{k2(r.inputs),r.compute(B2(r.inputs))}});var R2,Ve,tg,rg,ng,og,ig,ag,sg,ug,lg,iu,M2,cg,dg,fg,pg,na,hg,oa,mg,gg,bg,yg,vg,xg,wg,Tg,$g,Sg,Ig,Ag,_g,Og,Cg,Eg,Pg,au=M(()=>{"use strict";pt();Pe();st();Ge();R2=(r,e,n,t,o,i)=>{let s=Math.ceil(e/4),a="";typeof o=="string"?a=`${o}(a)`:a=o("a");let u=J("inputData",n,[s],4),l=ne("outputData",t,[s],4);return`
      ${r.registerUniform("vec_size","u32").declareVariables(u,l)}

  ${i??""}

  ${r.mainStart()}
    ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${u.getByOffset("global_idx")};
    ${l.setByOffset("global_idx",a)}
  }`},Ve=(r,e,n,t,o,i=r.dataType)=>({name:e,shaderCache:{hint:o,inputDependencies:["type"]},getShaderSource:s=>R2(s,W.size(r.dims),r.dataType,i,n,t),getRunData:s=>({outputs:[{dims:r.dims,dataType:i}],dispatchGroup:{x:Math.ceil(W.size(s[0].dims)/64/4)},programUniforms:[{type:"uint32",data:Math.ceil(W.size(r.dims)/4)}]})}),tg=r=>{r.compute(Ve(r.inputs[0],"Abs","abs"))},rg=r=>{r.compute(Ve(r.inputs[0],"Acos","acos"))},ng=r=>{r.compute(Ve(r.inputs[0],"Acosh","acosh"))},og=r=>{r.compute(Ve(r.inputs[0],"Asin","asin"))},ig=r=>{r.compute(Ve(r.inputs[0],"Asinh","asinh"))},ag=r=>{r.compute(Ve(r.inputs[0],"Atan","atan"))},sg=r=>{r.compute(Ve(r.inputs[0],"Atanh","atanh"))},ug=r=>ye(r),lg=(r,e)=>{let n;switch(e.to){case 10:n="vec4<f16>";break;case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${e.to}`)}r.compute(Ve(r.inputs[0],"Cast",n,void 0,e.cacheKey,e.to))},iu=(r,e)=>{let n=ut(r.inputs[0].dataType);r.compute(Ve(r.inputs[0],"Clip",t=>`clamp(${t}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<${n}> = vec4(${n}(${e.min}));
    const clip_max_: vec4<${n}> = vec4(${n}(${e.max}));
`,e.cacheKey),{inputs:[0]})},M2=r=>{let e=r.length>=2?r[1].getFloat32Array()[0]:Qi,n=r.length>=3?r[2].getFloat32Array()[0]:ea;return ye({min:e,max:n})},cg=r=>{let e=M2(r.inputs);iu(r,e)},dg=r=>{r.compute(Ve(r.inputs[0],"Ceil","ceil"))},fg=r=>{r.compute(Ve(r.inputs[0],"Cos","cos"))},pg=r=>{r.compute(Ve(r.inputs[0],"Cosh","cosh"))},na=r=>ye(r),hg=(r,e)=>{r.compute(Ve(r.inputs[0],"Elu",n=>`elu_vf32(${n})`,`
  const elu_alpha_: f32 = f32(${e.alpha});

  fn elu_f32(a: f32) -> f32 {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,e.cacheKey))},oa=(r,e="f32")=>`
const r0: ${e} = 0.3275911;
const r1: ${e} = 0.254829592;
const r2: ${e} = -0.284496736;
const r3: ${e} = 1.421413741;
const r4: ${e} = -1.453152027;
const r5: ${e} = 1.061405429;

fn erf_vf32(v: ${r}) -> ${r} {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,mg=r=>{let e=ut(r.inputs[0].dataType);r.compute(Ve(r.inputs[0],"Erf",n=>`erf_vf32(${n})`,oa(`vec4<${e}>`,e)))},gg=r=>{r.compute(Ve(r.inputs[0],"Exp","exp"))},bg=r=>{r.compute(Ve(r.inputs[0],"Floor","floor"))},yg=r=>{let e=ut(r.inputs[0].dataType);r.compute(Ve(r.inputs[0],"Gelu",n=>`0.5 * ${n} * (1.0 + erf_vf32(${n} * 0.7071067811865475))`,oa(`vec4<${e}>`,e)))},vg=(r,e)=>{r.compute(Ve(r.inputs[0],"LeakyRelu",n=>`select(leaky_relu_alpha_ * ${n}, ${n}, ${n} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${e.alpha});`,e.cacheKey))},xg=r=>{r.compute(Ve(r.inputs[0],"Not",e=>`!${e}`))},wg=r=>{r.compute(Ve(r.inputs[0],"Neg",e=>`-${e}`))},Tg=r=>{r.compute(Ve(r.inputs[0],"Reciprocal",e=>`1.0/${e}`))},$g=r=>{r.compute(Ve(r.inputs[0],"Relu",e=>`select(vec4<f32>(0.0), ${e}, ${e} > vec4<f32>(0.0))`))},Sg=r=>{r.compute(Ve(r.inputs[0],"Sigmoid",e=>`(1.0 / (1.0 + exp(-${e})))`))},Ig=r=>{r.compute(Ve(r.inputs[0],"Sin","sin"))},Ag=r=>{r.compute(Ve(r.inputs[0],"Sinh","sinh"))},_g=r=>{r.compute(Ve(r.inputs[0],"Sqrt","sqrt"))},Og=r=>{r.compute(Ve(r.inputs[0],"Tan","tan"))},Cg=r=>{r.compute(Ve(r.inputs[0],"Tanh","tanh"))},Eg=(r,e)=>(r.compute(Ve(r.inputs[0],"ThresholdedRelu",n=>`select(vec4<f32>(0.0), ${n}, ${n} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${e.alpha});`,e.cacheKey)),0),Pg=r=>{r.compute(Ve(r.inputs[0],"Log","log"))}});var N2,F2,Dg,kg=M(()=>{"use strict";Pe();Ge();au();N2=r=>{if(r[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(r[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(r[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(r[0].dims[2]!==r[1].dims[0])throw new Error("last dimension of input and bias are not the same")},F2=r=>{let e=r[0].dims.slice();e[2]=e[2]/2;let n=J("input",r[0].dataType,r[0].dims,4),t=J("bias",r[0].dataType,[r[0].dims[2]],4),o=ne("output",r[0].dataType,e,4),i=W.size(e)/4;return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:e,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:a=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${r[0].dims[2]/4/2}u;

  ${a.declareVariables(n,t,o)}

  ${oa("vec4f")}

  ${a.mainStart()}
    ${a.guardAgainstOutOfBoundsWorkgroupSizes(i)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${o.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},Dg=r=>{N2(r.inputs),r.compute(F2(r.inputs))}});var z2,G2,wr,Bg,Rg,Mg,Lg,Ng,Fg,zg,Gg,Vg,Wg,Ug=M(()=>{"use strict";pt();Pe();Ge();z2=(r,e,n,t,o,i,s,a,u,l,c,h)=>{let m,b;typeof s=="string"?m=b=(z,F)=>`${s}((${z}),(${F}))`:typeof s=="function"?m=b=s:(m=s.scalar,b=s.vector);let x=c?e.length:e,y=c?n.length:n,T=c?t.length:t,E=ne("outputData",l,T,4),_=J("aData",a,x,4),C=J("bData",u,y,4),D;if(o)if(i){let z=W.size(e)===1,F=W.size(n)===1;z||F?D=E.setByOffset("global_idx",b(z?`${_.type.value}(${_.getByOffset("0")}.x)`:_.getByOffset("global_idx"),F?`${C.type.value}(${C.getByOffset("0")}.x)`:C.getByOffset("global_idx"))):D=`
            let outputIndices = ${E.offsetToIndices("global_idx * 4u")};
            let offsetA = ${_.broadcastedIndicesToOffset("outputIndices",E)};
            let offsetB = ${C.broadcastedIndicesToOffset("outputIndices",E)};
            ${E.setByOffset("global_idx",b(_.getByOffset("offsetA / 4u"),C.getByOffset("offsetB / 4u")))}
          `}else D=E.setByOffset("global_idx",b(_.getByOffset("global_idx"),C.getByOffset("global_idx")));else{if(!i)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let z=(F,V,ee="")=>{let re=`aData[indexA${V}][componentA${V}]`,le=`bData[indexB${V}][componentB${V}]`;return`
            let outputIndices${V} = ${E.offsetToIndices(`global_idx * 4u + ${V}u`)};
            let offsetA${V} = ${_.broadcastedIndicesToOffset(`outputIndices${V}`,E)};
            let offsetB${V} = ${C.broadcastedIndicesToOffset(`outputIndices${V}`,E)};
            let indexA${V} = offsetA${V} / 4u;
            let indexB${V} = offsetB${V} / 4u;
            let componentA${V} = offsetA${V} % 4u;
            let componentB${V} = offsetB${V} % 4u;
            ${F}[${V}] = ${ee}(${m(re,le)});
          `};l===9?D=`
            var data = vec4<u32>(0);
            ${z("data",0,"u32")}
            ${z("data",1,"u32")}
            ${z("data",2,"u32")}
            ${z("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:D=`
            ${z("outputData[global_idx]",0)}
            ${z("outputData[global_idx]",1)}
            ${z("outputData[global_idx]",2)}
            ${z("outputData[global_idx]",3)}
          `}return`
        ${r.registerUniform("vec_size","u32").declareVariables(_,C,E)}

        ${h??""}

        ${r.mainStart()}
        ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${D}
      }`},G2=(r,e,n,t,o,i,s=n.dataType)=>{let a=!W.areEqual(n.dims,t.dims),u=n.dims,l=W.size(n.dims),c=!1,h=[a];if(a){let b=mr.calcShape(n.dims,t.dims,!1);if(!b)throw new Error("Can't perform binary op on the given tensors");u=b,l=W.size(u);let x=W.size(n.dims)===1,y=W.size(t.dims)===1;h.push(x),h.push(y);let T=1;for(let E=1;E<u.length;E++){let _=n.dims[n.dims.length-E]??1,C=t.dims[t.dims.length-E]??1;if(_===C)T*=_;else break}(T%4===0||x||y)&&(c=!0)}else c=!0;h.push(c);let m=Pr(n.dims.length)&&Pr(t.dims.length)&&Pr(u.length);return{name:r,shaderCache:{hint:e+h.map(b=>b.toString()).join("_"),inputDependencies:m?["rank","rank"]:["dims","dims"]},getShaderSource:b=>z2(b,n.dims,t.dims,u,c,a,o,n.dataType,t.dataType,s,m,i),getRunData:()=>({outputs:[{dims:u,dataType:s}],dispatchGroup:{x:Math.ceil(l/64/4)},programUniforms:m?[{type:"uint32",data:Math.ceil(W.size(u)/4)},...gr(n.dims),...gr(t.dims),...gr(u)]:[{type:"uint32",data:Math.ceil(W.size(u)/4)}]})}},wr=(r,e,n,t,o,i)=>{r.compute(G2(e,o??"",r.inputs[0],r.inputs[1],n,t,i))},Bg=r=>{wr(r,"Add",(e,n)=>`${e}+${n}`)},Rg=r=>{wr(r,"Div",(e,n)=>`${e}/${n}`)},Mg=r=>{wr(r,"Equal",{scalar:(e,n)=>`u32(${e}==${n})`,vector:(e,n)=>`vec4<u32>(${e}==${n})`},void 0,void 0,9)},Lg=r=>{wr(r,"Mul",(e,n)=>`${e}*${n}`)},Ng=r=>{let e=J("input",r.inputs[0].dataType,r.inputs[0].dims).type.value;wr(r,"Pow",{scalar:(t,o)=>`pow_custom(${t},${o})`,vector:(t,o)=>`pow_vector_custom(${t},${o})`},`
    fn pow_custom(a : ${e}, b : ${e}) -> ${e} {
      if (b == ${e}(0.0)) {
        return ${e}(1.0);
      } else if (a < ${e}(0.0) && f32(b) != floor(f32(b))) {
        return ${e}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${e}(1.0), round(f32(abs(b) % ${e}(2.0))) != 1.0) * ${e}(${e==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${e}>, b : vec4<${e}>) -> vec4<${e}> {
      // TODO: implement vectorized pow
      return vec4<${e}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},Fg=r=>{wr(r,"Sub",(e,n)=>`${e}-${n}`)},zg=r=>{wr(r,"Greater",{scalar:(e,n)=>`u32(${e}>${n})`,vector:(e,n)=>`vec4<u32>(${e}>${n})`},void 0,void 0,9)},Gg=r=>{wr(r,"Less",{scalar:(e,n)=>`u32(${e}<${n})`,vector:(e,n)=>`vec4<u32>(${e}<${n})`},void 0,void 0,9)},Vg=r=>{wr(r,"GreaterOrEqual",{scalar:(e,n)=>`u32(${e}>=${n})`,vector:(e,n)=>`vec4<u32>(${e}>=${n})`},void 0,void 0,9)},Wg=r=>{wr(r,"LessOrEqual",{scalar:(e,n)=>`u32(${e}<=${n})`,vector:(e,n)=>`vec4<u32>(${e}<=${n})`},void 0,void 0,9)}});var W2,U2,H2,j2,Hg,jg,qg=M(()=>{"use strict";Pe();st();Ge();W2=r=>{if(!r||r.length<1)throw new Error("too few inputs");let e=r[0].dataType,n=r[0].dims.length;for(let t of r){if(t.dataType!==e)throw new Error("input tensors should be one type");if(t.dims.length!==n)throw new Error("input tensors should have the same shape")}},U2=(r,e)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${r}u>(${e});
    for (var i: u32 = 0u; i < ${r}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${r}u;
  }`,H2=(r,e)=>{let n=r.length,t=[];for(let o=0;o<n;++o){let i=e.setByOffset("global_idx",r[o].getByIndices("indices"));n===1?t.push(i):o===0?t.push(`if (inputIndex == ${o}u) { ${i} }`):o===n-1?t.push(`else { ${i} }`):t.push(`else if (inputIndex == ${o}) { ${i} }`)}return t.join(`
`)},j2=(r,e)=>{let n=r[0].dims.slice();if(e>=n.length||e<-1*n.length)throw new Error("axis specified for concat doesn't match input dimensionality");let t=e<0?n.length+e:e,o=n.slice(0);for(let D=1;D<r.length;D++){let z=r[D].dims.slice();for(let F=0;F<n.length;F++)if(F===t)o[t]+=z[F];else if(n[F]!==z[F])throw new Error("non concat dimensions must match")}let i=W.size(o),s=new Array(r.length),a=new Array(r.length),u=r[0].dataType,l=0,c=[],h=[],m=[],b=[{type:"uint32",data:i}];for(let D=0;D<r.length;++D)l+=r[D].dims[t],s[D]=l,m.push(Pr(r[D].dims.length)),h.push(m[D]?r[D].dims.length:r[D].dims),a[D]=J(`input${D}`,u,h[D]),c.push(m[D]?"rank":"dims"),b.push({type:"uint32",data:s[D]});for(let D=0;D<r.length;++D)m[D]&&b.push(...gr(r[D].dims));let x=Pr(o.length);x&&b.push(...gr(o));let y=x?o.length:o,T=ne("output",u,y),E=T.indicesGet("indices",t),_=Array.from(Array(s.length).keys()).map(D=>`uniforms.sizeInConcatAxis${D}`).join(","),C=D=>`

  ${(()=>{D.registerUniform("outputSize","u32");for(let z=0;z<r.length;z++)D.registerUniform(`sizeInConcatAxis${z}`,"u32");return D.declareVariables(...a,T)})()}

  ${U2(s.length,_)}

  ${D.mainStart()}
    ${D.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${T.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${E});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${s.length}u>(${_});
      ${E} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${H2(a,T)}
  }`;return{name:"Concat",shaderCache:{hint:`${e}`,inputDependencies:c},getRunData:()=>({outputs:[{dims:o,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:b}),getShaderSource:C}},Hg=(r,e)=>{W2(r.inputs),r.compute(j2(r.inputs,e.axis))},jg=r=>ye({axis:r.axis})});var jr,ia,yn=M(()=>{"use strict";Pe();jr=(r,e)=>{switch(r.activation){case"Relu":return{activationFunction:"",applyActivation:`value = max(value, ${e}(0.0));`};case"Sigmoid":return{activationFunction:"",applyActivation:`value = (${e}(1.0) / (${e}(1.0) + exp(-value)));`};case"Clip":return{activationFunction:`const clip_min_=${e}(${r.clipMin});const clip_max_=${e}(${r.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},ia=r=>{let e=r?.activation||"";if(e==="Clip"){let[n,t]=r?.activation_params||[Qi,ea];return{activation:e,clipMax:t,clipMin:n,activationCacheKey:`${e}:${n},${t}`}}return{activation:e,activationCacheKey:e}}});var gt,aa,sa=M(()=>{"use strict";gt=(r,e)=>{switch(r){case 1:return e;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${r}-component is not supported.`)}},aa=r=>`
      ${r?"value = value + getBiasByOutputCoords(coords);":""}
      `});var ua,su=M(()=>{"use strict";ua=`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));
}
`});var q2,K2,_o,Kg,X2,Oo,Y2,la,Co=M(()=>{"use strict";Pe();Ge();yn();sa();q2=(r,e)=>r?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${e?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${e?", batchIndices":""});
        `,K2=(r,e)=>r?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${e===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,_o=(r,e,n="f32",t,o=!1,i=32,s=!1,a=32)=>{let u=e[1]*r[1],l=e[0]*r[0],c=o?u:i,h=o?i:u,m=c/e[0],b=i/e[1];if(!((o&&m===4&&r[1]===4||!o&&(m===3||m===4))&&c%e[0]===0&&i%e[1]===0&&r[0]===4))throw new Error(`If transposeA ${o} is true, innerElementSize ${m} and workPerThread[1] ${r[1]} must be 4.
      Otherwise, innerElementSize ${m} must be 3 or 4.
  tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}. tileInner ${i} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${r[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${m}<${n}>, ${c/m}>, ${h}>;
var<workgroup> mm_Bsub: array<array<vec4<${n}>, ${l/r[0]}>, ${i}>;

const rowPerThread = ${r[1]};
const colPerThread = ${r[0]};
const innerElementSize = ${m};
const tileInner = ${i};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${s?"0":"i32(globalId.z)"};
  ${t?`let batchIndices = ${t.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${u};

  let numTiles = ${s?`${Math.ceil(a/i)}`:"(dimInner - 1) / tileInner + 1"};
  var kStart = ${s?`i32(globalId.z) * ${a}`:"0"};

  var acc: array<vec4<${n}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${b};
  for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${q2(o,t)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${b}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${t?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${m===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${K2(o,m)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},Kg=(r,e)=>r?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${e?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${e?", batchIndices":""});
            `,X2=r=>r?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",Oo=(r,e,n="f32",t,o=!1,i=32,s=!1,a=32,u=!1)=>{let l=r[1]*e[1],c=r[0]*e[0],h=o?l:i,m=o?i:l;if(!(m%e[1]===0&&h%e[0]===0&&i%e[1]===0))throw new Error(`tileAHight ${m} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${h} must be divisible by workgroupSize[0]${e[0]}, tileInner ${i} must be divisible by workgroupSize[1]${e[1]}`);let b=m/e[1],x=h/e[0],y=i/e[1],T=u?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${l};
    let globalColStart = i32(workgroupId.x) * ${c};

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${m}; inputRow = inputRow + ${e[1]}) {
        for (var inputCol = localCol; inputCol < ${h}; inputCol = inputCol + ${e[0]}) {
          ${Kg(o,t)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${i}; inputRow = inputRow + ${e[1]}) {
            for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${t?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${n}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${o?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${e[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${e[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${l};

let tileRowA = i32(localId.y) * ${b};
let tileColA = i32(localId.x) * ${x};
let tileRowB = i32(localId.y) * ${y};
// Loop over shared dimension.
for (var t = 0; t < numTiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${b}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${x}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${Kg(o,t)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${y}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${t?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${n}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${X2(o)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${n}, ${h}>, ${m}>;
  var<workgroup> mm_Bsub : array<array<${n}, ${c}>, ${i}>;
  const rowPerThread = ${r[1]};
  const colPerThread = ${r[0]};
  const tileInner = ${i};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${s?"0":"i32(globalId.z)"};
    ${t?`let batchIndices = ${t.offsetToIndices("u32(batch)")};`:""}
    let numTiles = ${s?`${Math.ceil(a/i)}`:"(dimInner - 1) / tileInner + 1"};
    var kStart = ${s?`i32(globalId.z) * ${a}`:"0"};

    var acc : array<array<${n}, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${T}
  }
`},Y2=(r,e,n,t,o,i=!1)=>{let s=o[0],a=o[1],u=o[2],l=t[0],c=t[1],h=t[2],m=t[3],b=ru(s,u),x=ru(a,u),y=ut(t[0].type.tensor),T=()=>{let C=c.rank,D=l.rank,z=`var aIndices: ${c.type.indices};`;for(let F=C-2-1,V=D-1;F>=0;F--,V--)z+=`
aIndices[${F}] = ${D>1?`batchIndices[${V}]`:"batchIndices"};`;return b.forEach(F=>{z+=`
aIndices[${F}] = 0;`}),z+=`
aIndices[${C-2}] = u32(row);
                   aIndices[${C-1}] = u32(colIn);`,z},E=()=>{let C=h.rank,D=l.rank,z=`var bIndices: ${h.type.indices};`;for(let F=C-2-1,V=D-1;F>=0;F--,V--)z+=`
bIndices[${F}] = ${D>1?`batchIndices[${V}]`:"batchIndices"};`;return x.forEach(F=>{z+=`
bIndices[${F}] = 0;`}),z+=`
bIndices[${C-2}] = u32(row);
                   bIndices[${C-1}] = u32(colIn);`,z};return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${l.type.indices}) -> ${gt(r,y)} {
      var value = ${gt(r,y)}(0.0);
      let col = colIn * ${r};
      if(row < dimAOuter && col < dimInner)
      {
        ${T()}
        value = ${c.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${l.type.indices}) -> ${gt(r,y)} {
      var value = ${gt(r,y)}(0.0);
      let col = colIn * ${r};
      if(row < dimInner && col < dimBOuter)
      {
        ${E()}
        value = ${h.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${gt(r,y)}) {
      let col = colIn * ${r};
      if (row < dimAOuter && col < dimBOuter) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${e?`value = value + ${i?"bias[colIn]":`${gt(r,y)}(bias[row])`};`:""}
        ${n}
        ${m.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},la=(r,e,n,t,o=!1)=>{let i=r[0].dims,s=r[1].dims,a=i.slice(0,-2),u=s.slice(0,-2),l=t?t.slice(0,-2):n.slice(0,-2),c=J("batchDims",r[0].dataType,l),h=[c],m=[a,u,l],b=W.size(l),x=i[i.length-2],y=i[i.length-1],T=s[s.length-1],E=y%4===0&&T%4===0,_=x<=8?[4,1,1]:[4,4,1],C=[8,8,1],D=[Math.ceil(T/C[0]/_[0]),Math.ceil(x/C[1]/_[1]),Math.ceil(b/C[2]/_[2])],z=ut(r[0].dataType),F=E?4:1,V=J("a",r[0].dataType,[...a,x,y/F],F),ee=J("b",r[1].dataType,[...u,y,T/F],F),re=ne("result",r[0].dataType,[b,x,T/F],F);h.push(V),h.push(ee),h.push(re);let le=[V,ee],R=r.length>2,{activationFunction:fe,applyActivation:Ye}=jr(e,re.type.value),se=Y2(F,R,Ye,h,m,o);if(R){let Je=o?F:1;le.push(J("bias",r[2].dataType,r[2].dims,Je))}let Le=Je=>`
  const dimAOuter: i32 = ${x};
  const dimBOuter: i32 = ${T};
  const dimInner: i32 = ${y};
  ${Je.declareVariables(...le,re)}
  ${fe}
  ${se}
  ${E?_o(_,C,z,c):Oo(_,C,z,c)}
                   ${c.impl()}`;return{name:"MatMul",shaderCache:{hint:e.activationCacheKey},getRunData:()=>({outputs:[{dims:n,dataType:r[0].dataType}],dispatchGroup:{x:D[0],y:D[1],z:D[2]}}),getShaderSource:Le}}});var J2,Xg,Yg=M(()=>{"use strict";Wr();Pe();Ge();yn();sa();su();Co();J2=(r,e,n,t,o=!1,i,s=4,a=4,u=4,l="f32")=>{let c=R=>{switch(R){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${l}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${R} is not supported.`)}},h=R=>{switch(R){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${R} is not supported.`)}},m=r?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,b=r?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,x=r?"xShape[1]":"xShape[2]",y=r?"xShape[2]":"xShape[3]",T=r?"row":"col",E=r?"col":"row",_=`
    let inChannels = wShape[2];
    let outWidth = ${r?"outShape[2]":"outShape[3]"};
    let outRow = ${T} / outWidth;
    let outCol = ${T} % outWidth;

    let WRow = ${E} / (filterDims[1] * inChannels);
    let WCol = ${E} / inChannels % filterDims[1];
    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];
    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];
    let xCh = ${E} % inChannels;
    var resData = ${gt(s,l)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${x} && xCol >= 0 && xCol < ${y}) {
      ${m}
      let xIndex = getIndexFromCoords4D(coord, xShape);
      ${c(s)}
    }
    return resData;`,C=r?e&&t?`
    let col = colIn * ${s};
    ${_}`:`
    let col = colIn * ${s};
    if (row < dimAOuter && col < dimInner) {
      ${_}
    }
    return ${gt(s,l)}(0.0);`:t&&n?`
    let col = colIn * ${s};
    ${_}`:`
    let col = colIn * ${s};
    if (row < dimInner && col < dimBOuter) {
      ${_}
    }
    return ${gt(s,l)}(0.0);`,D=`${h(a)}`,z=gt(u,l),F=r?gt(s,l):gt(a,l),V=r?gt(a,l):gt(s,l),{activationFunction:ee,applyActivation:re}=jr(i,z);return`
    ${ee}
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${F} {
      ${r?C:D}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${V} {
      ${r?D:C}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${z}) {
      let col = colIn * ${u};
      if (row < dimAOuter && col < dimBOuter)
      {
      var value = valueIn;
      let outWidth = ${r?"outShape[2]":"outShape[3]"};
      ${b}
      ${aa(o)}
      ${re}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},Xg=(r,e,n,t,o,i,s,a)=>{let u=e.format==="NHWC",l=u?r[0].dims[3]:r[0].dims[1],c=n[0],h=u?n[2]:n[3],m=u?n[1]:n[2],b=u?n[3]:n[1],x=u&&(l%4===0||l%3===0)&&b%4===0,y=u?b:h*m,T=u?h*m:b,E=[8,8,1],_=t<=8?[4,1,1]:[4,4,1],C=[Math.ceil(y/E[0]/_[0]),Math.ceil(T/E[1]/_[1]),Math.ceil(c/E[2]/_[2])];et("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${C}`);let D=x?u&&l%4!==0?3:4:_[0],z=E[1]*_[1],F=E[0]*_[0],V=Math.max(E[0]*D,E[1]),ee=t%z===0,re=o%F===0,le=i%V===0,R=x?[D,4,4]:[1,1,1],fe=ut(r[0].dataType),Ye=[`@group(0) @binding(0) var<storage, read> x: array<${x&&D===4?`vec4<${fe}>`:fe}>;`,`@group(0) @binding(1) var<storage, read> w: array<${x?`vec4<${fe}>`:fe}>;`],se=`
      fn setOutputAtIndex(flatIndex : i32, value : ${x?`vec4<${fe}>`:fe}) {
        result[flatIndex] = ${x?`vec4<${fe}>`:fe}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${x?`vec4<${fe}>`:fe}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${x?"/ 4":""}, value);
      }`;return s&&(Ye.push(`@group(0) @binding(2) var<storage, read> bias: array<${x?`vec4<${fe}>`:fe}>;`),se+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${x?`vec4<${fe}>`:fe} {
          return bias[coords.${u?"w":"y"}${x?"/ 4":""}];
        }`),{name:"Conv2DMatMul",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:n,dataType:r[0].dataType}],dispatchGroup:{x:C[0],y:C[1],z:C[2]}}),getShaderSource:()=>`
        ${ua}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${Ye.join("")}
        @group(0) @binding(${Ye.length}) var<storage, read_write> result: array<${x?`vec4<${fe}>`:fe}>;
        //@group(0) @binding(${Ye.length+1}) var<uniform> uniforms: Uniforms;

        const xShape : vec4<i32> = vec4<i32>(${r[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${r[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${n.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${W.computeStrides(n).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${e.kernelShape[0]}, ${e.kernelShape[1]});
        const pad : vec2<i32> = vec2<i32>(${e.pads[0]}, ${e.pads[1]});
        const stride : vec2<i32> = vec2<i32>(${e.strides[0]}, ${e.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${e.dilations[0]}, ${e.dilations[1]});
        const dimAOuter : i32 = ${t};
        const dimBOuter : i32 = ${o};
        const dimInner : i32 = ${i};
        ${se}
        ${J2(u,ee,re,le,s,e,R[0],R[1],R[2],fe)}
            ${x?_o(_,E,fe,void 0,!u,V):Oo(_,E,fe,void 0,!u,V,!1,void 0,a)}`}}});var uu,Jg=M(()=>{"use strict";Pe();Ge();cu();yn();uu=(r,e,n)=>{let t=r.length>2,o=t?"value += b[output_channel];":"",i=r[0].dims,s=r[1].dims,a=s[0]/e.group,u=e.format==="NHWC",l=lu(i,s,e.dilations,e.pads,e.strides,u),c=W.size(l),h=ne("output",r[0].dataType,l),{activationFunction:m,applyActivation:b}=jr(e,h.type.value),x=J("x",r[0].dataType,i),y=J("w",r[1].dataType,s),T=[x,y];t&&T.push(J("b",r[2].dataType,r[2].dims));let E=_=>`
  const strides: vec2<u32> = vec2(${e.strides[0]}u, ${e.strides[1]}u);
  const pads: vec2<u32> = vec2(${e.pads[0]}u, ${e.pads[1]}u);

  ${_.declareVariables(...T,h)}

  ${m}

  ${_.mainStart()}
    ${_.guardAgainstOutOfBoundsWorkgroupSizes(c)}

    let outputIndices = ${h.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${u?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${u?1:2}], outputIndices[${u?2:3}]) * strides - pads;
    let group_id: u32 = output_channel / ${a}u;

    var value: ${h.type.value} = ${h.type.value}(0);
    for (var wInChannel: u32 = 0u; wInChannel < ${s[1]}u; wInChannel++) {
      let input_channel = group_id * ${s[1]}u + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < ${s[2]}u; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * ${e.dilations[0]}u;

        if (xHeight < 0u || xHeight >= ${i[u?1:2]}u) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < ${s[3]}u; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * ${e.dilations[1]}u;
          if (xWidth < 0u || xWidth >= ${i[u?2:3]}u) {
            continue;
          }

          let xVal = ${u?x.get("batch","xHeight","xWidth","input_channel"):x.get("batch","input_channel","xHeight","xWidth")};
          let wVal = ${y.get("output_channel","wInChannel","wHeight","wWidth")};
          value += xVal*wVal;
        }
      }
    }
    ${o}
    ${b}
    ${h.setByOffset("global_idx","value")}
  }`;return{name:"GroupedConv",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:n?n(l):l,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)}}),getShaderSource:E}}});var lu,Zg,Z2,Qg,du,Q2,e1,fu,cu=M(()=>{"use strict";Pe();st();Yg();Co();Jg();yn();Ao();lu=(r,e,n,t,o,i)=>{let s=r[0],a=r.slice(i?1:2,i?3:4),u=a.length,l=e[0],h=e.slice(2).map((x,y)=>x+(x-1)*(n[y]-1)),b=a.map((x,y)=>x+t[y]+t[y+u]).map((x,y)=>Math.floor((x-h[y]+o[y])/o[y]));return b.splice(0,0,s),b.splice(i?3:1,0,l),b},Zg=[2,3,1,0],Z2=(r,e)=>{if(!r||r.length!==2&&r.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(r[0].dims.length!==4&&r[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(r[0].dims.length!==r[1].dims.length)throw new Error("filter does not have same dimension as input");let n=r[0].dims[e.format==="NHWC"?r[0].dims.length-1:1],t=r[1].dims[1]*e.group;if(n!==t)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(r.length===3&&(r[2].dims.length!==1||r[1].dims[0]!==r[2].dims[0]))throw new Error("invalid bias");let o=r[0].dims.length-2;if(e.dilations.length!==o)throw new Error(`dilations should be ${o}D`);if(e.strides.length!==o)throw new Error(`strides should be ${o}D`);if(e.pads.length!==o*2)throw new Error(`pads should be ${o*2}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==r[1].dims.length-2)throw new Error("invalid kernel shape")},Qg=(r,e)=>{let n=r.kernelShape.slice();for(let i=2;i<e[1].dims.length;++i)n[i-2]===0&&(n[i-2]=e[1].dims[i]);let t=r.pads.slice();gn.adjustPadsBasedOnAutoPad(e[0].dims,r.strides,r.dilations,n,t,r.format==="NHWC",r.autoPad);let o=Object.assign({},r);return Object.assign(o,{kernelShape:n,pads:t,cacheKey:r.cacheKey}),o},du=r=>{let e=ia(r),n=r.format,t=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][r.auto_pad],o=r.dilations,i=r.group,s=r.kernel_shape,a=r.pads,u=r.strides,l=r.w_is_const();return ye({autoPad:t,format:n,dilations:o,group:i,kernelShape:s,pads:a,strides:u,wIsConst:l,...e})},Q2=(r,e,n)=>{let t=Qg(n,e);if(n.group!==1){r.compute(uu(e,t));return}let o=n.format==="NHWC",i=e.length===3,s=e[0].dims[o?1:2],a=e[0].dims[o?2:3],u=e[0].dims[o?3:1],l=e[1].dims[2],c=e[1].dims[3],h=lu(e[0].dims,e[1].dims,n.dilations,t.pads,n.strides,o),m=h[o?1:2],b=h[o?2:3],x=h[o?3:1],y=o&&l===s&&c===a&&n.pads[0]===0&&n.pads[1]===0;if(y||l===1&&c===1&&n.dilations[0]===1&&n.dilations[1]===1&&n.strides[0]===1&&n.strides[1]===1&&n.pads[0]===0&&n.pads[1]===0){let F=h[0],V,ee,re,le=[];if(o){let R=r.kernelCustomData.wT??r.compute(Hr(e[1],Zg),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!r.kernelCustomData.wT&&(r.kernelCustomData.wT=R),y){let fe=s*a*u;V=e[0].reshape([1,F,fe]),ee=R.reshape([1,fe,x]),re=[1,F,x]}else V=e[0].reshape([F,s*a,u]),ee=R.reshape([1,u,x]),re=[F,m*b,x];le.push(V),le.push(ee)}else V=e[0].reshape([F,u,s*a]),ee=e[1].reshape([1,x,u]),re=[F,x,m*b],le.push(ee),le.push(V);i&&le.push(e[2]),r.compute(la(le,t,h,re,o),{inputs:le});return}let T=!0,E=r.kernelCustomData.wT??r.compute(Hr(e[1],Zg),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!r.kernelCustomData.wT&&(r.kernelCustomData.wT=E);let _=[e[0],E];i&&_.push(e[2]);let C=o?m*b:x,D=o?x:m*b,z=l*c*u;r.compute(Xg(_,t,h,C,D,z,i,T),{inputs:_})},e1=(r,e)=>{let n=e.format==="NHWC",t=[r.inputs[0].reshape(n?[r.inputs[0].dims[0],1,r.inputs[0].dims[1],r.inputs[0].dims[2]]:[r.inputs[0].dims[0],r.inputs[0].dims[1],1,r.inputs[0].dims[2]]),r.inputs[1].reshape([r.inputs[1].dims[0],r.inputs[1].dims[1],1,r.inputs[1].dims[2]])];r.inputs.length===3&&t.push(r.inputs[2]);let o=[0,e.pads[0],0,e.pads[1]],i=[1].concat(e.strides),s=[1].concat(e.dilations),a=[1].concat(e.kernelShape),u=Qg({...e,pads:o,strides:i,dilations:s,kernelShape:a},t);r.compute(uu(t,u,l=>n?[l[0],l[2],l[3]]:[]))},fu=(r,e)=>{Z2(r.inputs,e),r.inputs[0].dims.length===3?e1(r,e):Q2(r,r.inputs,e)}});var t1,eb,tb=M(()=>{"use strict";Wr();Pe();yn();sa();su();Co();t1=(r,e=!1,n,t=4)=>{let o=gt(t,"f32"),i=_=>{switch(_){case 1:return"return W[getIndexFromCoords4D(coord, wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${_} is not supported.`)}},s=r?`
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `,a=r?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,u=r?"outBackprop[1]":"outBackprop[2]",l=r?"outBackprop[2]":"outBackprop[3]",c=r?"row":"col",h=r?"col":"row",m=`
      let inChannels = ${r?"outBackprop[3]":"outBackprop[1]"};
      let outWidth = ${r?"outShape[2]":"outShape[3]"};
      let outRow = ${c} / outWidth;
      let outCol = ${c} % outWidth;

      let WRow = ${h} / (filterDims[1] * inChannels);
      let WCol = ${h} / inChannels % filterDims[1];
      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);
      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);
      if (xR < 0.0 || xR >= f32(${u}) || fract(xR) > 0.0) {
        return ${o}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${l}) || fract(xC) > 0.0) {
        return ${o}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${h} % inChannels;
      ${s}
      return x[getIndexFromCoords4D(coord, xShape)/${t}];`,b=r?`
      let col = colIn * ${t};
      if (row < dimAOuter && col < dimInner) {
        ${m}
      }
      return ${o}(0.0);`:`
      let col = colIn * ${t};
      if (row < dimInner && col < dimBOuter) {
        ${m}
      }
      return ${o}(0.0);`,x=`
      let col = colIn * ${t};
      let inChannels = ${r?"outBackprop[3]":"outBackprop[1]"};
      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);
      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];
      if (${r?"row < dimInner && col < dimBOuter":"row < dimInner && col < dimAOuter"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${i(t)}
      }
      return ${o}(0.0);
      `,{activationFunction:y,applyActivation:T}=jr(n,o);return`
      ${y}
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${o} {
    ${r?b:x}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${o} {
    ${r?x:b}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${o}) {
    let col = colIn * ${t};
    if (row < dimAOuter && col < dimBOuter) {
      var value = valueInput;
      let outWidth = ${r?"outShape[2]":"outShape[3]"};
      ${a}
      ${aa(e)}
      ${T}
      result[getIndexFromCoords4D(coords, outShape)/${t}] = value;
    }
  }`},eb=(r,e,n,t,o,i,s,a)=>{let u=e.format==="NHWC",l=u?r[0].dims[3]:r[0].dims[1],c=n[0],h=u?n[2]:n[3],m=u?n[1]:n[2],b=u?n[3]:n[1],x=u?l%4===0&&b%4===0:h%4===0&&b%4===0,y=u?b:h*m,T=u?h*m:b,E=x?[8,8,1]:[y<=4||T<=4?4:16,y>4&&T<=4?4:16,1],_=x?[4,4,1]:[y<=4?1:4,y>4&&T<=4?1:4,1],C=[Math.ceil(y/E[0]/_[0]),Math.ceil(T/E[1]/_[1]),Math.ceil(c/E[2]/_[2])];et("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${C}`);let D=x?4:1,z=Math.max(E[0]*D,E[1]),F=[`@group(0) @binding(0) var<storage, read> x: array<${x?"vec4<f32>":"f32"}>;`,"@group(0) @binding(1) var<storage, read> W: array<f32>;"],V="";return s&&(F.push(`@group(0) @binding(2) var<storage, read> bias: array<${x?"vec4<f32>":"f32"}>;`),V+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${x?"vec4<f32>":"f32"} {
          return bias[coords.${u?"w":"y"}${x?"/ 4":""}];
        }`),{name:"Conv2DTransposeMatMul",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:n,dataType:r[0].dataType}],dispatchGroup:{x:C[0],y:C[1],z:C[2]}}),getShaderSource:()=>`
        ${ua}
        ${F.join(`
`)}
        @group(0) @binding(${F.length}) var<storage, read_write> result: array<${x?"vec4<f32>":"f32"}>;
        const outBackprop : vec4<i32> = vec4<i32>(${r[0].dims.join(",")});
        const xShape : vec4<i32> = vec4<i32>(${r[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${r[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${n.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${W.computeStrides(n).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${e.kernelShape[u?1:2]}, ${e.kernelShape[u?2:3]});
        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(
              ${e.dilations[0]<=1?0:(e.kernelShape[u?1:2]-1)*(e.dilations[0]-1)},
              ${e.dilations[1]<=1?0:(e.kernelShape[u?2:3]-1)*(e.dilations[1]-1)});
        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${e.pads[0]+e.pads[2]})/2,
                                         i32(effectiveFilterDims[1]) - 1 - (${e.pads[1]+e.pads[3]})/2);
        const strides : vec2<i32> = vec2<i32>(${e.strides[0]}, ${e.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${e.dilations[0]}, ${e.dilations[1]});
        const dimAOuter : i32 = ${t};
        const dimBOuter : i32 = ${o};
        const dimInner : i32 = ${i};
        ${V}
        ${t1(u,s,e,D)}
        ${x?_o(_,E,"f32",void 0,!u,z):Oo(_,E,"f32",void 0,!u,z,!1,void 0,a)}`}}});var r1,pu,rb=M(()=>{"use strict";Wr();Pe();Ge();r1=(r,e,n,t,o,i,s=!1,a)=>{let u=n.format==="NHWC",l=u?1:2,c=u?2:3,h=u?3:1,m=W.size(t),b=s?2:1,x=n.group,y=e[1].dims,T=y[0]/x,E=y[1],_=`
  fn setOutputAtIndex(flatIndex : u32, value : ${s?`vec4<${a}>`:a}) {
    result[flatIndex] = ${s?`vec4<${a}>`:a}(value);
  }`;o&&(_+=`
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${s?`vec4<${a}>`:a} {
      return bias[coords.${u?"w":"y"}${s?"/ 4":""}];
    }`);let C=s?4:1,D=J("W",e[1].dataType,e[1].dims,C),z=J("Dy",e[0].dataType,e[0].dims,C),F=[z,D];o&&F.push(J("bias",e[2].dataType,[t[h]],C));let V=ne("result",e[0].dataType,t,C),ee=`{
        let batch: u32 = ${i?"global_id.z":"workgroup_id.z"} / outShape[1];
        let r = ${i?"global_id.z":"workgroup_id.z"} % outShape[1];
        let c = ${i?"global_id.y":"workgroup_id.y"} * ${b};
        let d1: u32 = ${i?"global_id.x":"workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${a}>, ${b}>;
        for (var i = 0; i < ${b}; i++) {
          dotProd[i] = vec4<${a}>(0.0);
        }
        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {
          var dyR = (${a}(dyCorner.x) + ${a}(wR)) / ${a}(strides.x);
          let wRPerm = filterDims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${a}(outBackprop[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {
            let dyC = (${a}(dyCorner.y) + ${a}(wC)) / ${a}(strides.y);
            let dyC2 = (${a}(dyCorner.y) + 1.0 + ${a}(wC)) / ${a}(strides.y);
            let wCPerm = filterDims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${a}(outBackprop[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${a}(outBackprop[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${D.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${D.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${D.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${D.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${z.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${a}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${z.get("batch","idyR","idyC2","d2")};

                dotProd[1] = dotProd[1] + vec4<${a}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = outBackprop[${h}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${D.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${D.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${D.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${D.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${z.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${a}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${D.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${D.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${D.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${D.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${z.get("batch","idyR","idyC2","d2")};
                let tmpval = vec4<${a}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${b}; i = i + 1) {
          let value = dotProd[i] + ${o?"bias[c+i]":"0.0"};
          ${V.set("batch","r","c + i","d1","value")};
        }
      }`,re=`
          let outputIndices = ${V.offsetToIndices("global_idx")};
          let batch = ${V.indicesGet("outputIndices",0)};
          let d1 = ${V.indicesGet("outputIndices",h)};
          let r = ${V.indicesGet("outputIndices",l)};
          let c = ${V.indicesGet("outputIndices",c)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / ${E};
          let wOutChannel = d1 - groupId * ${E};
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = 0.0;
          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {
            if (wR % dilations.x != 0) {
              continue;
            }
            let dyR = (${a}(dyRCorner) + ${a}(wR)) / ${a}(strides[0]);
            let wRPerm = filterDims.x - 1 - wR / dilations.x;
            if (dyR < 0.0 || dyR >= ${a}(outBackprop[${l}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {
              if (wC % dilations.y != 0) {
                continue;
              }
              let dyC = (${a}(dyCCorner) + ${a}(wC)) / ${a}(strides.y);
              let wCPerm = filterDims.y - 1 - wC / dilations.y;
              if (dyC < 0.0 || dyC >= ${a}(outBackprop[${c}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * ${T};
              for (var d2: u32 = 0; d2 < ${T}; d2 = d2 + 1) {
                let xValue = ${u?z.get("batch","idyR","idyC","inputChannel"):z.get("batch","inputChannel","idyR","idyC")};
                let wValue = ${D.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${o?"bias[d1]":"0.0"};
          ${V.setByOffset("global_idx","value")};
        `;return`
  ${r.declareVariables(...F,V)}
  ${_}
  const outShape : vec4<u32> = vec4<u32>(${t.join(",")});
  const outBackprop : vec4<u32> = vec4<u32>(${e[0].dims.join(",")});
  const strides : vec2<u32> = vec2<u32>(${n.strides[0]}, ${n.strides[1]});
  const filterDims : vec2<u32> = vec2<u32>(${n.kernelShape[u?1:2]}, ${n.kernelShape[u?2:3]});
  const dilations : vec2<u32> = vec2<u32>(${n.dilations[0]}, ${n.dilations[1]});
  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(
          ${n.dilations[0]<=1?0:(n.kernelShape[u?1:2]-1)*(n.dilations[0]-1)},
          ${n.dilations[1]<=1?0:(n.kernelShape[u?2:3]-1)*(n.dilations[1]-1)});
  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${n.pads[0]+n.pads[2]})/2,
                                     i32(effectiveFilterDims[1]) - 1 - (${n.pads[1]+n.pads[3]})/2);
    ${r.mainStart()}
    ${r.guardAgainstOutOfBoundsWorkgroupSizes(m)};
  ${s?ee:re}}`},pu=(r,e,n)=>{let t=r.length>2,o=e.outputShape,i=W.size(o),s=[Math.ceil(i/64),1,1];et("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${s}`);let a=ut(r[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:e.cacheKey},getRunData:()=>({dispatchGroup:{x:s[0],y:s[1],z:s[2]},outputs:[{dims:n?n(o):o,dataType:r[0].dataType}]}),getShaderSource:u=>r1(u,r,e,o,t,s[1]===1&&s[2]===1,!1,a)}}});var n1,o1,i1,nb,ob,a1,s1,u1,l1,ib,ab=M(()=>{"use strict";st();tb();rb();yn();Ao();n1=(r,e,n,t,o,i)=>(r-1)*e+n+(t-1)*o+1-i,o1=(r,e,n,t,o)=>{let i=Math.floor(r/2);e==="SAME_UPPER"?(n[t]=i,n[o]=r-i):e==="SAME_LOWER"&&(n[t]=r-i,n[o]=i)},i1=(r,e,n,t,o,i,s,a,u,l)=>{let c=r.length-2,h=l.length===0;if(u.length===0)for(let x=0;x<c;++x)u.push(0);let m=r[0],b=e[a?3:1]*o;for(let x=0,y=r.length-c-(a?1:0);x<c;++x,++y){let T=r[y],E=h?T*s[x]:l[x],_=n1(T,s[x],i[x],e[y],n[x],E);o1(_,t,i,x,x+c),h&&l.push(s[x]*(T-1)+u[x]+(e[y]-1)*n[x]+1-i[x]-i[x+c])}l.splice(0,0,m),l.splice(a?3:1,0,b)},nb=(r,e)=>{let n=r.kernelShape.slice();if(r.kernelShape.length===0||r.kernelShape.reduce((m,b)=>m*b,1)===0){n.length=0;for(let m=2;m<e[1].dims.length;++m)n.push(e[1].dims[m])}let t=r.format==="NHWC";n.splice(0,0,e[1].dims[0]),n.splice(t?3:1,0,e[1].dims[1]);let o=r.pads.slice(),i=r.outputShape.slice(),s=r.outputPadding.slice(),a=e[0].dims,u=r.dilations.slice();if(u.reduce((m,b)=>m+b,0)===0){let m=e[0].dims.length-2;u=new Array(m).fill(1)}let l=r.strides.slice();if(l.reduce((m,b)=>m+b,0)===0){let m=e[0].dims.length-2;l=new Array(m).fill(1)}i1(a,n,u,r.autoPad,r.group,o,l,t,s,i);let c=Object.assign({},r),h=r.cacheKey+[n.join("n,"),o.join(","),l.join(","),s.join(","),i.join(","),u.join(",")].join("_");return Object.assign(c,{kernelShape:n,pads:o,outputPadding:s,outputShape:i,dilations:u,strides:l,cacheKey:h}),c},ob=r=>{let e=ia(r),n=r.format,t=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof r.autoPad>"u"?0:r.autoPad],o=r.dilations,i=r.group,s=r.kernelShape,a=r.pads,u=r.strides,l=r.wIsConst(),c=r.outputPadding,h=r.outputShape;return ye({autoPad:t,format:n,dilations:o,group:i,kernelShape:s,outputPadding:c,outputShape:h,pads:a,strides:u,wIsConst:l,...e})},a1=(r,e)=>{if(!r||r.length!==2&&r.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(r[0].dims.length!==4&&r[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(r[0].dims.length!==r[1].dims.length)throw new Error("filter does not have same dimension as input");let n=r[0].dims[e.format==="NHWC"?r[0].dims.length-1:1],t=r[1].dims[0];if(n!==t)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let o=r[1].dims[1]*e.group;if(r.length===3&&(r[2].dims.length!==1||r[2].dims[0]!==o))throw new Error("invalid bias");let i=r[0].dims.length-2;if(e.dilations.reduce((c,h)=>c+h,0)>0&&e.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(e.strides.reduce((c,h)=>c+h,0)>0&&e.strides.length!==i)throw new Error(`strides should be ${i}D`);if(e.pads.reduce((c,h)=>c+h,0)>0&&e.pads.length!==i*2)throw new Error(`pads should be ${i*2}D`);if(e.outputPadding.length!==i&&e.outputPadding.length!==0)throw new Error(`output_padding should be ${i}D`);if(e.kernelShape.reduce((c,h)=>c+h,0)>0&&e.kernelShape.length!==0&&e.kernelShape.length!==r[1].dims.length-2)throw new Error("invalid kernel shape");if(e.outputShape.length!==0&&e.outputShape.length!==r[0].dims.length-2)throw new Error("invalid output shape")},s1=[2,3,1,0],u1=(r,e,n)=>{let t=nb(n,e),o=n.format==="NHWC",i=e.length===3;if(t.group!==1){r.compute(pu(e,t));return}let s=t.outputShape,a=s[o?1:2],u=s[o?2:3],l=s[o?3:1],c=e[1].dims[2],h=e[1].dims[3],m=e[0].dims[o?3:1],b=o?a*u:l,x=o?l:a*u,y=c*h*m,T=!0,E=r.kernelCustomData.wT??r.compute(Hr(e[1],s1),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!r.kernelCustomData.wT&&(r.kernelCustomData.wT=E);let _=[e[0],E];i&&(!o&&e[2].dims.length===1?_.push(e[2].reshape([e[2].dims[0],1,1])):_.push(e[2])),r.compute(eb(_,t,s,b,x,y,i,T),{inputs:_})},l1=(r,e)=>{let n=e.format==="NHWC",t=[r.inputs[0].reshape(n?[r.inputs[0].dims[0],1,r.inputs[0].dims[1],r.inputs[0].dims[2]]:[r.inputs[0].dims[0],r.inputs[0].dims[1],1,r.inputs[0].dims[2]]),r.inputs[1].reshape([r.inputs[1].dims[0],r.inputs[1].dims[1],1,r.inputs[1].dims[2]])];t.length===3&&t.push(r.inputs[2]);let o=e.kernelShape;(o.length===0||o[0]===0)&&(o=[r.inputs[1].dims[2]]);let i=e.dilations;(i.length===0||i[0]===0)&&(i=[1]);let s=e.strides;(s.length===0||s[0]===0)&&(s=[1]);let a=e.pads;a.length===0&&(a=[0,0]),a=[0,a[0],0,a[1]],s=[1].concat(s),i=[1].concat(i),o=[1].concat(o);let u=nb({...e,pads:a,strides:s,dilations:i,kernelShape:o},t);r.compute(pu(t,u,l=>n?[l[0],l[2],l[3]]:[l[0],l[1],l[3]]))},ib=(r,e)=>{a1(r.inputs,e),r.inputs[0].dims.length===3?l1(r,e):u1(r,r.inputs,e)}});var hu,ca,sb,c1,d1,mu,gu,f1,ub,lb,cb=M(()=>{"use strict";Pe();st();Ge();hu="[a-zA-Z]|\\.\\.\\.",ca="("+hu+")+",sb="^"+ca+"$",c1="("+ca+",)*"+ca,d1="^"+c1+"$",mu=class{constructor(e=-1){this.symbolToIndices=new Map,this.inputIndex=e}addSymbol(e,n){let t=this.symbolToIndices.get(e);t===void 0?t=[n]:t.push(n),this.symbolToIndices.set(e,t)}},gu=class{constructor(e,n){this.equation=n;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[t,o]=n.includes("->")?n.split("->",2):[n,""];if(!t.match(RegExp(d1)))throw new Error("Invalid LHS term");if(t.split(",").forEach((a,u)=>{let l=e[u].dims.slice();if(!a.match(RegExp(sb)))throw new Error("Invalid LHS term");let c=this.processTerm(a,!0,l,u);this.lhs.push(c)}),o==="")o+=[...this.symbolToInfo.entries()].filter(([a,u])=>u.count===1||a==="...").map(([a])=>a).join("");else if(!o.match(RegExp(ca)))throw new Error("Invalid RHS");o.match(RegExp(hu,"g"))?.forEach(a=>{if(a==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let u=this.symbolToInfo.get(a);if(u===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(u.dimValue)}}),this.rhs=this.processTerm(o,!0,this.outputDims)}addSymbol(e,n,t){let o=this.symbolToInfo.get(e);if(o!==void 0){if(o.dimValue!==n&&o.count!==1)throw new Error("Dimension mismatch");o.count++,o.inputIndices.push(t)}else o={count:1,dimValue:n,inputIndices:[t]};this.symbolToInfo.set(e,o)}processTerm(e,n,t,o=-1){let i=t.length,s=!1,a=[],u=0;if(!e.match(RegExp(sb))&&!n&&e!=="")throw new Error("Invalid LHS term");let l=e.match(RegExp(hu,"g")),c=new mu(o);return l?.forEach((h,m)=>{if(h==="..."){if(s)throw new Error("Only one ellipsis is allowed per input term");s=!0;let b=i-l.length+1;if(b<0)throw new Error("Ellipsis out of bounds");if(a=t.slice(u,u+b),this.hasEllipsis){if(this.ellipsisDims.length!==a.length||this.ellipsisDims.toString()!==a.toString())throw new Error("Ellipsis dimensions mismatch")}else if(n)this.hasEllipsis=!0,this.ellipsisDims=a;else throw new Error("Ellipsis must be specified in the LHS");for(let x=0;x<a.length;x++){let y=String.fromCharCode("0".charCodeAt(0)+m);c.addSymbol(y,m+x),this.addSymbol(y,t[u++],o)}}else c.addSymbol(h,m),this.addSymbol(h,t[u++],o)}),c}},f1=(r,e)=>{let n=r[0].dataType,t=new Array(r.length);for(let C=0;C<r.length;++C)t[C]=J(`input${C}`,n,r[C].dims);let o=e.outputDims,i=W.size(o),s=ne("output",n,o),a=[],u=Array.from(e.rhs.symbolToIndices.keys()),l="var prod = 1.0;",c="var sum = 0.0;",h="sum += prod;",m=[],b=[],x=[],y=[],T=e.symbolToInfo.size===u.length;e.symbolToInfo.forEach((C,D)=>{if(u.includes(D)){let z=u.indexOf(D);e.lhs.forEach((F,V)=>{if(C.inputIndices.includes(V)){let ee=F.symbolToIndices.get(D);if(ee===void 0)throw new Error("Invalid symbol error");ee.forEach(re=>{a.push(`${t[V].indicesSet(`input${V}Indices`,re,s.indicesGet("outputIndices",z))}`)})}})}else e.lhs.forEach((z,F)=>{let V=e.symbolToInfo.get(D);if(V===void 0)throw new Error("Invalid symbol error");if(V.inputIndices.includes(F)){let ee=z.symbolToIndices.get(D);if(ee===void 0)throw new Error("Invalid symbol error");ee.forEach(re=>{m.push(`${t[F].indicesSet(`input${F}Indices`,re,`${D}`)}`)}),y.push(`prod *= ${t[F].getByIndices(`input${F}Indices`)};`)}}),b.push(`for(var ${D}: u32 = 0; ${D} < ${e.symbolToInfo.get(D)?.dimValue}; ${D}++) {`),x.push("}")});let E=T?[...a,`let sum = ${t.map((C,D)=>C.getByIndices(`input${D}Indices`)).join(" * ")};`]:[...a,c,...b,...m,l,...y,h,...x],_=C=>`
      ${C.declareVariables(...t,s)}

      ${C.mainStart()}
        ${C.guardAgainstOutOfBoundsWorkgroupSizes(i)}
        var outputIndices = ${s.offsetToIndices("global_idx")};
        ${t.map((D,z)=>`var input${z}Indices: ${t[z].type.indices};`).join(`
`)}
        ${E.join(`
`)};
        ${s.setByOffset("global_idx","sum")};
      }`;return{name:"Einsum",shaderCache:{hint:e.equation},getRunData:()=>({outputs:[{dims:o,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:_}},ub=(r,e)=>{let n=new gu(r.inputs,e.equation);r.compute(f1(r.inputs,n))},lb=r=>{let e=r.equation.replace(/\s+/g,"");return ye({equation:e})}});var p1,db,h1,m1,fb,pb=M(()=>{"use strict";Pe();Ge();p1=r=>{if(!r||r.length!==2)throw new Error("Expand requires 2 input.");let e=r[0].dims,n=Array.from(r[1].getBigInt64Array(),Number),t=n.length<e.length?0:n.length-e.length,o=e.length<n.length?0:e.length-n.length;for(;t<n.length&&o<e.length;++t,++o)if(n[t]!==e[o]&&n[t]!==1&&e[o]!==1)throw new Error("Expand requires shape to be broadcastable to input")},db=(r,e)=>{let n=r.length-e.length,t=[];for(let o=0;o<n;++o)t.push(r[o]);for(let o=0;o<e.length;++o)t.push(e[o]===1?r[o+n]:e[o]);return t},h1=(r,e)=>r.length>e.length?db(r,e):db(e,r),m1=r=>{let e=r[0].dims,n=Array.from(r[1].getBigInt64Array(),Number),t=h1(e,n),o=W.size(t),i=r[0].dataType,s=J("input",i,e),a=ne("output",i,t),u=l=>`
  const inputShape = ${s.indices(...e)};
  ${l.declareVariables(s,a)}
  ${l.mainStart()}
  ${l.guardAgainstOutOfBoundsWorkgroupSizes(o)}
    let outputIndices = ${a.offsetToIndices("global_idx")};
    var inputIndices: ${s.type.indices};
    for (var i = 0; i < ${e.length}; i++) {
      if (${s.indicesGet("inputShape","i")} == 1) {
        ${s.indicesSet("inputIndices","i",0)}
      } else {
        ${s.indicesSet("inputIndices","i",a.indicesGet("outputIndices",`i + ${t.length-e.length}`))}
      }
    }
    ${a.setByOffset("global_idx",s.getByIndices("inputIndices"))}
  }`;return{name:"Expand",shaderCache:{hint:`${t}`},getShaderSource:u,getRunData:()=>({outputs:[{dims:t,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}})}},fb=r=>{p1(r.inputs),r.compute(m1(r.inputs),{inputs:[0]})}});var g1,b1,hb,mb,gb=M(()=>{"use strict";Pe();st();Ge();g1=r=>{if(!r||r.length!==2)throw new Error("Gather requires 2 inputs.")},b1=(r,e)=>{let n=r[0].dims,t=r[1].dims,o=n.length,i=W.normalizeAxis(e.axis,o),s=n.slice(0);s.splice(i,1,...t);let a=n[i],u=W.size(s),l=J("data",r[0].dataType,r[0].dims),c=J("inputIndices",r[1].dataType,r[1].dims),h=ne("output",r[0].dataType,s),m=()=>{let x=t.length,y=`var indicesIndices  = ${c.type.indices}(0);`;for(let T=0;T<x;T++)y+=`${x>1?`indicesIndices[${T}]`:"indicesIndices"} = ${s.length>1?`outputIndices[${i+T}]`:"outputIndices"};`;y+=`
        var idx = ${c.getByIndices("indicesIndices")};
        if (idx < 0) {
          idx = idx + ${a};
        }
        var dataIndices = ${l.type.indices}(0);
      `;for(let T=0,E=0;T<o;T++)T===i?(y+=`${o>1?`dataIndices[${T}]`:"dataIndices"} = u32(idx);`,E+=x):(y+=`${o>1?`dataIndices[${T}]`:"dataIndices"} = ${s.length>1?`outputIndices[${E}]`:"outputIndices"};`,E++);return y},b=x=>`
      ${x.declareVariables(l,c,h)}
      ${x.mainStart()}
        ${x.guardAgainstOutOfBoundsWorkgroupSizes(u)}
        let outputIndices = ${h.offsetToIndices("global_idx")};
        ${m()};
        let value = ${l.getByIndices("dataIndices")};
        ${h.setByOffset("global_idx","value")};
      }`;return{name:"Gather",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:b}},hb=r=>ye({axis:r.axis}),mb=(r,e)=>{let n=r.inputs;g1(n),r.compute(b1(r.inputs,e))}});var y1,v1,bb,yb,vb=M(()=>{"use strict";Pe();st();Ge();y1=r=>{if(!r||r.length!==2)throw new Error("GatherElements requires 2 inputs.");if(r[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(r[0].dims.length!==r[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},v1=(r,e)=>{let n=r[0].dims,t=r[0].dataType,o=n.length,i=W.computeStrides(n),s=W.size(n),a=r[1].dims,u=r[1].dataType,l=W.size(a),c=W.normalizeAxis(e.axis,o),h=n[c],m=a.slice(0),b=W.size(m),x=J("input",t,n),y=J("indices",u,[l]),T=ne("output",t,m),E=_=>`
      const inputStrides = array<u32, ${i.length}>(${i.map(C=>`${C}u`).join(",")});
      ${_.declareVariables(x,y,T)}
      ${_.mainStart()}
      ${_.guardAgainstOutOfBoundsWorkgroupSizes(b)}

      let outputIndices = ${T.offsetToIndices("global_idx")};

      var idx = ${y.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + ${h};
      }

      var srcOffset = u32(0);

      for (var i = 0; i < ${n.length}; i++) {
        if (i == ${c}) {
          srcOffset +=  u32(idx) * inputStrides[i];
        } else {
          srcOffset += ${T.indicesGet("outputIndices","i")} * inputStrides[i];
        }
      }

      // Should never hit this with valid values in indices
      // This is a guard against malicious data in the indices input
      if (srcOffset < 0 || srcOffset >= ${s}) {
        return;
      }

      output[global_idx] = input[srcOffset];
  }`;return{name:"GatherElements",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:m,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)}}),getShaderSource:E}},bb=r=>ye({axis:r.axis}),yb=(r,e)=>{let n=r.inputs;y1(n),r.compute(v1(r.inputs,e))}});var x1,w1,T1,xb,wb,Tb=M(()=>{"use strict";Pe();st();Ge();x1=r=>{if(!r)throw new Error("Input is missing");if(r.length<2||r.length>3)throw new Error("Invaid input number.");if(r.length===3&&r[2].dims.length>2)throw new Error("Invalid input shape of C");if(r[0].dataType!==r[1].dataType||r.length===3&&r[0].dataType!==r[2].dataType)throw new Error("Input types are mismatched")},w1=(r,e,n)=>{if(n.length===0)return"0u";let t=n.length===1&&r!==1||n.length===2&&n[0]!==r,o=n[n.length-1]!==e,i="0u";return t||(i+=`+ m * ${n[n.length-1]}u`),o||(i+="+n"),i},T1=(r,e)=>{let n=r[0].dims.slice(),t=r[1].dims.slice(),[o,i,s]=Zi.getShapeOfGemmResult(n,e.transA,t,e.transB,r.length===3?r[2].dims:void 0),a=[o,i];if(!a)throw new Error("Can't use gemm on the given tensors");let u=W.size(a),l="";e.transA&&e.transB?l="value += a[k * M + m] * b[n * K + k];":e.transA&&!e.transB?l="value += a[k * M + m] * b[k * N + n];":!e.transA&&e.transB?l="value += a[m * K + k] * b[n * K + k];":!e.transA&&!e.transB&&(l="value += a[m * K + k] * b[k * N + n];");let c=ut(r[0].dataType),h=e.alpha===1?"":"value *= alpha;",m=r.length===3?`value += beta * c[${w1(o,i,r[2].dims)}];`:"",b=[`@group(0) @binding(0) var<storage, read> a : array<${c}>;`,`@group(0) @binding(1) var<storage, read> b : array<${c}>;`];r.length===3&&b.push(`@group(0) @binding(2) var<storage, read> c : array<${c}>;`);let x=y=>`
  const M: u32 = ${o}u;
  const N: u32 = ${i}u;
  const K: u32 = ${s}u;
  const alpha = ${c}(${e.alpha});
  const beta = ${c}(${e.beta});

  ${b.join(`
`)}
  @group(0) @binding(${r.length}) var<storage, read_write> output : array<${c}>;

  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes(u)}

    let m = global_id.x / N;
    let n = global_id.x % N;

    var value = ${c}(0);
    for (var k: u32 = 0u; k<${s}u; k++) {
      ${l}
    }

    ${h}
    ${m}
    output[global_id.x] = value;

  }`;return{name:"Gemm",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:a,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:x}},xb=(r,e)=>{x1(r.inputs),r.compute(T1(r.inputs,e))},wb=r=>ye(r)});var $1,S1,I1,A1,$b,Sb,Ib=M(()=>{"use strict";pt();Pe();st();Ge();$1={name:"InstanceNormalization"},S1=(r,e)=>{let n=r[0].dims,t=n,o=2,i=W.sizeToDimension(n,o),s=W.sizeFromDimension(n,o),a=n[1],u=J("x",r[0].dataType,[n[0],n[1],s]),l=J("scale",r[1].dataType,r[1].dims),c=J("bias",r[2].dataType,r[2].dims),h=ne("output",r[0].dataType,[n[0],n[1],s]),m=[u,l,c,h],b=u.type.value,x=64,y=T=>`

  const C: u32 = ${a};
  const normSize: u32 = ${s};
  const epsilon: f32 = ${e.epsilon};
  var<workgroup> meanShared : ${b};
  var<workgroup> squaredNormShared : ${b};
  var<workgroup> workgroupShared : array<${b}, ${x}>;
  const workgroupSize = ${x}u;
  ${T.declareVariables(...m)}
  ${T.mainStart(x)}
    let norm = global_idx / workgroupSize;
    let batch = norm / C;
    let channel = norm % C;
    let localIndex = local_id.x;

    // initialize workgroup memory
    var initial: ${b} = 0;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      initial = initial + ${u.get("batch","channel","h")};
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the mean of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      meanShared = workgroupShared[0] / ${b}(normSize);
    }
    workgroupBarrier();

    // reinitialize workgroup memory.
    initial = 0;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      let deviation =  ${u.get("batch","channel","h")} - meanShared;
      initial = initial + deviation * deviation;
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the sum of square of deviation of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      squaredNormShared = workgroupShared[0];
    }
    workgroupBarrier();

    let invStdDev = 1 / sqrt(squaredNormShared / ${b}(normSize) + epsilon);
    let channelScale = invStdDev * ${l.getByOffset("channel")};
    let channelShift = ${c.getByOffset("channel")} - meanShared * channelScale;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      let value = ${u.get("batch","channel","h")} * channelScale + channelShift;
      ${h.set("batch","channel","h","value")};
    }
  }`;return{...$1,shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:t,dataType:r[0].dataType}],dispatchGroup:{x:i}}),getShaderSource:y}},I1=(r,e,n,t,o,i,s,a)=>{let u=Er(s),l=J("input",e.dataType,e.dims,u),c=J("scale",n.dataType,n.dims,u),h=J("bias",t.dataType,t.dims,u),m=64,b=u===1?"vec2f":`mat2x${u}f`,x=u===1?"f32":`vec${u}f`,y=(z,F)=>`${b}(${z}, ${F})`,T=o*s/u,E=Math.ceil(i/m),_=z=>`
  const H: u32 = ${i};
  const C: u32 = ${s/u};
  const imageSize: u32 = ${i*s/u};

  ${z.declareVariables(l)}
  @group(0) @binding(1) var<storage, read_write> output : array<${b}>;

  ${z.mainStart(m)}
    let currentImageNumber = global_idx / ${m} / C;
    let currentChannelNumber = (global_idx / ${m}) % C;
    let wgId = global_idx % ${m};
    let wgOffset = wgId * ${E};
    if (wgOffset >= H) {
        return;
    }
    let wgMax = min(wgOffset + ${E}, H);

    let offset = currentImageNumber * imageSize + currentChannelNumber;
    var sum = ${rr("f32",u)};
    var squaredSum = ${rr("f32",u)};
    for (var i: u32 = wgOffset; i < wgMax; i++) {
        let value = ${x}(input[offset + i * C]);
        sum += value;
        squaredSum += value * value;
    }
    output[global_idx] = ${y("sum","squaredSum")};
  }`,C=r.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:u,n:o,h:i,c:s})},getRunData:()=>({outputs:[{dims:[o,s,m,2],dataType:1}],dispatchGroup:{x:o*s/u}}),getShaderSource:_},{inputs:[e],outputs:[-1]})[0],D=z=>`
  const H: u32 = ${i};
  const C: u32 = ${s/u};
  const imageSize: u32 = ${m*s/u};
  const epsilon: f32 = ${a};

  @group(0) @binding(0) var<storage, read> input : array<${b}>;
  @group(0) @binding(1) var<storage, read> scale : array<${c.type.storage}>;
  @group(0) @binding(2) var<storage, read> bias : array<${h.type.storage}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${b}>;

  ${z.mainStart()}
    ${z.guardAgainstOutOfBoundsWorkgroupSizes(T)}
    let currentImageNumber = global_idx / C;
    let currentChannelNumber = global_idx % C;

    let offset = currentImageNumber * imageSize;
    var sum = ${rr("f32",u)};
    var squaredSum = ${rr("f32",u)};
    for (var i: u32 = 0; i < ${m}; i++) {
        let value = input[offset + i + currentChannelNumber * ${m}];
        sum += value[0];
        squaredSum += value[1];
    }
    sum = sum / f32(H);
    squaredSum = squaredSum / f32(H);
    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);
    let channelScale = invStdDev * ${x}(scale[currentChannelNumber]);
    let channelShift = ${x}(bias[currentChannelNumber]) - sum * channelScale;

    output[global_idx] = ${y("channelScale","channelShift")};
  }`;return r.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:u,n:o,h:i,c:s,epsilon:a})},getRunData:()=>({outputs:[{dims:[o,s,2],dataType:1}],dispatchGroup:{x:Math.ceil(T/64)}}),getShaderSource:D},{inputs:[C,n,t],outputs:[-1]})[0]},A1=(r,e,n)=>{let t=e[0].dims,o=t,i=t[0],s=t[t.length-1],a=W.sizeFromDimension(t,1)/s,u=Er(s),l=W.size(o)/u,c=J("input",e[0].dataType,e[0].dims,u),h=ne("output",e[0].dataType,o,u),m=ut(e[0].dataType),b=u===1?"vec2f":`mat2x${u}f`,x=u===1?m:`vec${u}<${m}>`,y=I1(r,e[0],e[1],e[2],i,a,s,n.epsilon),T=E=>`
  const H: u32 = ${a};
  const C: u32 = ${s/u};

  @group(0) @binding(0) var<storage, read> input : array<${c.type.storage}>;
  @group(0) @binding(1) var<storage, read> scaleInput : array<${b}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${h.type.storage}>;

  ${E.mainStart()}
    let currentImageNumber = global_idx / (C * H);
    let currentChannelNumber = global_idx % C;

    let scaleOffset = currentImageNumber * C + currentChannelNumber;
    let scale = scaleInput[scaleOffset];
    output[global_idx] = fma(input[global_idx], ${x}(scale[0]), ${x}(scale[1]));
  }`;r.compute({name:"InstanceNormalization",shaderCache:{hint:`${n.cacheKey}`},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)}}),getShaderSource:T},{inputs:[e[0],y]})},$b=r=>ye({epsilon:r.epsilon,format:r.format}),Sb=(r,e)=>{e.format==="NHWC"?A1(r,r.inputs,e):r.compute(S1(r.inputs,e))}});var _1,O1,Ab,_b,Ob=M(()=>{"use strict";pt();Pe();st();Ge();_1=r=>{if(!r||r.length<2)throw new Error("layerNorm requires at least 2 inputs.")},O1=(r,e,n)=>{let t=r[0].dims,o=r[1],i=r[2],s=t,a=W.normalizeAxis(e.axis,t.length),u=W.sizeToDimension(t,a),l=W.sizeFromDimension(t,a),c=W.size(o.dims),h=i?W.size(i.dims):0;if(c!==l||i&&h!==l)throw new Error(`Size of X.shape()[axis:] == ${l}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${c} and bias size of ${h}`);let m=[];for(let D=0;D<t.length;++D)D<a?m.push(t[D]):m.push(1);let b=Er(l),x=ut(r[0].dataType),y=[J("x",r[0].dataType,r[0].dims,b),J("scale",o.dataType,o.dims,b)];i&&y.push(J("bias",i.dataType,i.dims,b)),y.push(ne("output",r[0].dataType,s,b));let T=n>1,E=n>2;T&&y.push(ne("meanDataOutput",1,m)),E&&y.push(ne("invStdOutput",1,m));let _=D=>`
  const normSize: f32 = ${l};
  const normSizeVectorized: u32 = ${l/b};
  const epsilon: f32 = ${e.epsilon};

  ${D.declareVariables(...y)}
  ${D.mainStart()}
    ${D.guardAgainstOutOfBoundsWorkgroupSizes(u)}
    let offset = global_idx * normSizeVectorized;
    var meanVector = ${rr("f32",b)};
    var meanSquareVector = ${rr("f32",b)};

    for (var h: u32 = 0u; h < normSizeVectorized; h++) {
      let value = ${bn(x,b,"x[h + offset]")};
      meanVector += value;
      meanSquareVector += value * value;
    }
    let mean = ${Ur("meanVector",b)} / normSize;
    let meanSquare = sqrt(${Ur("meanSquareVector",b)} 
      / normSize - mean * mean + epsilon);

    for (var j: u32 = 0; j < normSizeVectorized; j++) {
      let f32input = ${bn(x,b,"x[j + offset]")};
      let f32scale = ${bn(x,b,"scale[j]")};
      output[j + offset] = ${y[0].type.value}((f32input - mean) / meanSquare * f32scale
        ${i?`+ ${bn(x,b,"bias[j]")}`:""}
      );
    }

    ${T?"meanDataOutput[global_idx] = mean":""};
    ${E?"invStdOutput[global_idx] = 1 / meanSquare":""};
  }`,C=[{dims:s,dataType:r[0].dataType}];return T&&C.push({dims:m,dataType:1}),E&&C.push({dims:m,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${e.cacheKey}|${n}|${r.length}`},getRunData:()=>({outputs:C,dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:_}},Ab=r=>ye({axis:r.axis,epsilon:r.epsilon}),_b=(r,e)=>{_1(r.inputs),r.compute(O1(r.inputs,e,r.outputCount))}});var C1,Cb,Eb=M(()=>{"use strict";Pe();Co();C1=r=>{if(!r||r.length!==2)throw new Error("MatMul requires 2 inputs.");if(r[0].dims[r[0].dims.length-1]!==r[1].dims[r[1].dims.length-2])throw new Error("shared dimension does not match.")},Cb=r=>{C1(r.inputs);let e=mr.calcShape(r.inputs[0].dims,r.inputs[1].dims,!0);if(!e)throw new Error("Can't use matmul on the given tensors");r.compute(la(r.inputs,{activation:"",activationCacheKey:""},e))}});var E1,P1,D1,k1,B1,R1,M1,L1,N1,Pb,Db,kb=M(()=>{"use strict";pt();Pe();st();Ge();E1=r=>{if(!r||r.length<1)throw new Error("Too few inputs");if(r[0].dataType!==1)throw new Error("Input type must be float.");if(r.length>=2){let e=r[0].dims.length*2===r[1].dims[0];if(r.length===4&&(e=r[3].dims[0]*2===r[1].dims[0]),!e)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},P1=(r,e,n,t,o,i,s)=>{let a=n.length,u="";for(let l=a-1;l>=0;--l)u+=`
            k = i32(${r.indicesGet("indices",l)}) - ${o[l]};
            if (k < 0) {
              break;
            }
            if (k >= ${n[l]}) {
              break;
            }
            offset += k * ${t[l]};
        `;return`
          value = ${i}(${s});
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${u}
            value = x[offset];
          }
      `},D1=(r,e,n,t,o)=>{let i=n.length,s="";for(let a=i-1;a>=0;--a)s+=`
                k = i32(${r.indicesGet("indices",a)}) - ${o[a]};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = ${2*(n[a]-1)};
                  k = k % _2n_1;
                  if(k >= ${n[a]}) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * ${t[a]};
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},k1=(r,e,n,t,o)=>{let i=n.length,s="";for(let a=i-1;a>=0;--a)s+=`
                k = i32(${r.indicesGet("indices",a)}) - ${o[a]};
                if (k < 0) {
                  k = 0;
                }
                if (k >= ${n[a]}) {
                  k = ${n[a]-1};
                }
                offset += k * ${t[a]};
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},B1=(r,e,n,t,o)=>{let i=n.length,s="";for(let a=i-1;a>=0;--a)s+=`
                k = i32(${r.indicesGet("indices",a)}) - ${o[a]};
                if (k < 0)  {
                  k += ${n[a]};
                }
                if (k >= ${n[a]}) {
                  k -= ${n[a]};
                }
                offset += k * ${t[a]};
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},R1=(r,e,n,t,o,i)=>{switch(o.mode){case 0:return P1(r,e,n,t,o.pads,i,o.value);case 1:return D1(r,e,n,t,o.pads);case 2:return k1(r,e,n,t,o.pads);case 3:return B1(r,e,n,t,o.pads);default:throw new Error("Invalid mode")}},M1=(r,e,n,t)=>{let o=e[0].dims,i=W.padShape(o.slice(),n.pads),s=W.size(i),a=W.computeStrides(o),u=ne("output",e[0].dataType,i),l=J("x",e[0].dataType,o),c=R1(u,i,o,a,n,t);return`
              ${r.declareVariables(l,u)}
              ${r.mainStart()}
              ${r.guardAgainstOutOfBoundsWorkgroupSizes(s)}

              let indices = ${u.offsetToIndices("global_idx")};

              var value = ${t}(0);
              ${c}
              output[global_idx] = value;
          }`},L1=(r,e)=>{let n=W.padShape(r[0].dims.slice(),e.pads);return{name:"Pad",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:n,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(W.size(n)/64)}}),getShaderSource:t=>M1(t,r,e,"f32")}},N1=(r,e)=>{if(r.length>1){let n=r[1].getBigInt64Array(),t=r.length>=3&&r[2].data?r[2].getFloat32Array()[0]:0,o=r[0].dims.length,i=new Int32Array(2*o).fill(0);if(r.length>=4){let a=r[3].getBigInt64Array();for(let u=0;u<a.length;u++)i[Number(a[u])]=Number(n[u]),i[Number(a[u])+o]=Number(n[u+a.length])}else n.forEach((a,u)=>i[Number(u)]=Number(a));let s=[];return i.forEach(a=>s.push(a)),ye({mode:e.mode,value:t,pads:s})}else return e},Pb=(r,e)=>{E1(r.inputs);let n=N1(r.inputs,e);r.compute(L1(r.inputs,n),{inputs:[0]})},Db=r=>{let e=r.mode,n=r.value,t=r.pads;return ye({mode:e,value:n,pads:t})}});var da,Bb,Rb,Mb,Lb,Nb,Fb,zb,Gb,Vb,Wb,Ub,Hb,jb,qb,Kb=M(()=>{"use strict";Pe();st();Ge();da=r=>{if(!r||r.length!==1)throw new Error("Pool ops requires 1 input.");if(r[0].dims.length!==4&&r[0].dims.length!==3)throw new Error("Pool ops supports 1-D or 2-D inputs only for now.")},Bb=(r,e,n)=>{let t=e.format==="NHWC",o=r.dims.slice();t&&o.splice(1,0,o.pop());let i=Object.hasOwnProperty.call(e,"dilations"),s=e.kernelShape.slice(),a=e.strides.slice(),u=i?e.dilations.slice():[],l=e.pads.slice();gn.adjustPoolAttributes(n,o,s,a,u,l);let c=gn.computePoolOutputShape(n,o,a,u,s,l,e.autoPad),h=Object.assign({},e);i?Object.assign(h,{kernelShape:s,strides:a,pads:l,dilations:u,cacheKey:e.cacheKey}):Object.assign(h,{kernelShape:s,strides:a,pads:l,cacheKey:e.cacheKey});let m=c.slice();return m.push(m.splice(1,1)[0]),[h,t?m:c]},Rb=(r,e,n,t,o,i,s,a)=>{let u=o.format==="NHWC",l=n,c=e.type.value,h=l.length,m=W.size(t),b=ne("output",e.type.tensor,t);if(o.kernelShape.length<=2){let x=o.kernelShape[o.kernelShape.length-1],y=o.strides[o.strides.length-1],T=o.pads[o.pads.length/2-1],E=o.pads[o.pads.length-1],_=h-(u?2:1),C="",D="",z="";if(T+E!==0?C=`
                for (var i: u32 = 0u; i < ${x}u; i++) {
                  xIndices[${_}] = indices[${_}] * ${y} - ${T} + i;
                  if (xIndices[${_}] < 0 || xIndices[${_}] >= ${l[_]}) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${i}
                }`:C=`
                for (var i: u32 = 0u; i < ${x}u; i++) {
                  xIndices[${_}] = indices[${_}] * ${y} - ${T} + i;
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${i}
                }`,o.kernelShape.length===2){let V=o.kernelShape[o.kernelShape.length-2],ee=o.strides[o.strides.length-2],re=o.pads[o.pads.length/2-2],le=o.pads[o.pads.length-2],R=h-(u?3:2),fe=l[R];re+le!==0?D=`
                for (var j: u32 = 0u; j < ${V}u; j++) {
                  xIndices[${R}] = indices[${R}] * ${ee} - ${re} + j;
                  if (xIndices[${R}] < 0 || xIndices[${R}] >= ${fe}) {
                    pad+= ${x};
                    continue;
                  }
              `:D=`
                for (var j: u32 = 0u; j < ${V}u; j++) {
                  xIndices[${R}] = indices[${R}] * ${ee} - ${re} + j;
                `,z=`
              }
            `}return`
            ${r.declareVariables(e,b)}

            ${r.mainStart()}
              ${r.guardAgainstOutOfBoundsWorkgroupSizes(m)}

              let indices = ${b.offsetToIndices("global_idx")};
              var xIndices = ${b.offsetToIndices("global_idx")};

              var value: ${c} = ${c}(${a});
              var pad = 0;
              ${D}
              ${C}
              ${z}
              ${s}

              output[global_idx] = value;
            }`}else{if(u)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let x=W.size(o.kernelShape),y=W.computeStrides(o.kernelShape),T=y.length,E=o.pads.length,_=o.pads.reduce((z,F)=>z+F),C="";return _?C=`
                if (xIndices[j] >= inputDims[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${e.indicesToOffset("xIndices")}];
                ${i}
              }`:C=`
              }
              let x_val = x[${e.indicesToOffset("xIndices")}];
              ${i}
            `,`
            ${r.declareVariables(e,b)}

            const pads = array<u32, ${E}>(${o.pads.map(z=>`${z}u`).join(",")});
            const inputDims = array<u32, ${h}>(${l.map(z=>`${z}u`).join(",")});
            const kernelStrides = array<u32, ${T}>(${y.map(z=>`${z}u`).join(",")});
            const strides = array<u32, ${T}>(${o.strides.map(z=>`${z}u`).join(",")});

            ${r.mainStart()}
              ${r.guardAgainstOutOfBoundsWorkgroupSizes(m)}

              let indices = ${b.offsetToIndices("global_idx")};
              let xIndices = ${b.offsetToIndices("global_idx")};

              var offsets: array<u32, ${T}>;

              var value = ${b.type.value}(${a});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < ${x}u; i++) {
                var offset = i;
                for (var j = 0u; j < ${T-1}u; j++) {
                  offsets[j] = offset / kernelStrides[j];
                  offset -= offsets[j] * kernelStrides[j];
                }
                offsets[${T-1}] = offset;

                isPad = false;
                for (var j = ${h-T}u; j < ${h}u; j++) {
                  xIndices[j] = indices[j] * strides[j - ${h-T}u]
                    + offsets[j - ${h-T}u] - pads[j - 2u];
                  ${C}
              }
              ${s}

              output[global_idx] = value;
            }`}},Mb=r=>({format:r.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][r.auto_pad],ceilMode:r.ceil_mode,kernelShape:r.kernel_shape,strides:r.strides,pads:r.pads}),Lb=(r,e,n,t)=>{let[o,i]=Bb(e,t,n),s=W.size(o.kernelShape),a=J("x",e.dataType,e.dims),u=a.type.value,l="value += x_val;",c="";return o.countIncludePad?c+=`value /= ${u}(${s});`:c+=`value /= ${u}(${s} - pad);`,{name:r,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(W.size(i)/64)}}),getShaderSource:h=>Rb(h,a,e.dims,i,o,l,c,"0.0")}},Nb=r=>{let e=r.count_include_pad!==0,n=Mb(r);if(n.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return ye({countIncludePad:e,...n})},Fb=(r,e)=>{da(r.inputs),r.compute(Lb("AveragePool",r.inputs[0],!1,e))},zb={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},Gb=r=>{let e=r.format;return{format:e,...zb,cacheKey:e}},Vb=(r,e)=>{da(r.inputs),r.compute(Lb("GlobalAveragePool",r.inputs[0],!0,e))},Wb=(r,e,n,t)=>{let[o,i]=Bb(e,t,n),s=`
      value = max(x_val, value);
    `,a="",u=J("x",e.dataType,e.dims);return{name:r,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(W.size(i)/64)}}),getShaderSource:l=>Rb(l,u,e.dims,i,o,s,a,"-1e5")}},Ub=(r,e)=>{da(r.inputs),r.compute(Wb("MaxPool",r.inputs[0],!1,e))},Hb=r=>{let e=r.storage_order,n=r.dilations,t=Mb(r);if(e!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(t.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return ye({storageOrder:e,dilations:n,...t})},jb=r=>{let e=r.format;return{format:e,...zb,cacheKey:e}},qb=(r,e)=>{da(r.inputs),r.compute(Wb("GlobalMaxPool",r.inputs[0],!0,e))}});var z1,G1,Xb,Yb=M(()=>{"use strict";Lt();pt();Ge();z1=(r,e,n)=>{let t=r===e,o=r<e&&n<0,i=r>e&&n>0;if(t||o||i)throw new Error("Range these inputs' contents are invalid.")},G1=(r,e,n,t)=>{let o=Math.abs(Math.ceil((e-r)/n)),i=[o],s=o,a=ne("output",t,i),u=a.type.storage,l=c=>`
        ${c.declareVariables(a)}
        ${c.mainStart()}
        ${c.guardAgainstOutOfBoundsWorkgroupSizes(s)}
        output[global_idx] = ${u}(${r}) + ${u}(global_idx) * ${u}(${n});
      }`;return{name:"Range",shaderCache:{hint:[r,e,n].map(c=>c.toString()).join("_")},getShaderSource:l,getRunData:()=>({outputs:[{dims:i,dataType:t}],dispatchGroup:{x:Math.ceil(s/64)}})}},Xb=r=>{let e=0,n=0,t=0;r.inputs[0].dataType===6?(e=r.inputs[0].getInt32Array()[0],n=r.inputs[1].getInt32Array()[0],t=r.inputs[2].getInt32Array()[0]):r.inputs[0].dataType===1&&(e=r.inputs[0].getFloat32Array()[0],n=r.inputs[1].getFloat32Array()[0],t=r.inputs[2].getFloat32Array()[0]),we.webgpu.validateInputContent&&z1(e,n,t),r.compute(G1(e,n,t,r.inputs[0].dataType),{inputs:[]})}});var V1,W1,U1,H1,j1,q1,K1,X1,Y1,J1,Z1,Q1,eT,tT,rT,Jb,Zb,Qb=M(()=>{"use strict";Pe();st();Ge();V1=(r,e)=>{if(r.every(n=>n>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),r.length>0){if(e.mode==="linear"){if(!(r.length===2||r.length===4&&r[0]===1&&r[1]===1||r.length===4&&r[0]===1&&r[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(e.mode==="cubic"&&!(r.length===2||r.length===4&&r[0]===1&&r[1]===1||r.length===4&&r[0]===1&&r[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},W1=(r,e,n)=>{e.every(o=>o>=0&&o<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let t=new Array(n).fill(1);return e.forEach((o,i)=>t[o]=r[i]),t},U1=(r,e,n,t,o,i)=>{let[s,a,u]=n>10?[1,2,3]:[-1,r.length>1?1:-1,-1],l=r[0].dims.length;if(s>0&&r.length>s&&r[s].dims.length>0)r[s].getFloat32Array().forEach(c=>i.push(c));else if(e.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(a>0&&r.length>a&&r[a].dims.length>0){if(r[a].getFloat32Array().forEach(c=>t.push(c)),t.length!==0&&t.length!==l&&n>=18&&t.length!==e.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");V1(t,e),e.axes.length>0&&W1(t,e.axes,l).forEach((c,h)=>t[h]=c)}if(u>0&&r.length>u&&(r[u].getBigInt64Array().forEach(c=>o.push(Number(c))),o.length!==l||n>=18&&o.length===e.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(e.axes.length>0){if(t.length!==e.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(o.length!==e.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof t<"u"&&typeof o<"u"&&t.length>0&&o.length>l)throw new Error("Resize requires only of scales or sizes to be specified")},H1=r=>"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(r){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`
`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${r} is not supported`)}})()+"}",j1=(r,e)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(r){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(e<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${r} is not supported`)}})()+"}",q1=(r,e,n)=>{let t=new Array(n).fill(0).concat(new Array(n).fill(1)),o=r.length===0?t:r.slice();return e.length>0?(e.forEach((i,s)=>{t[i]=o[s],t[s+n]=o[e.length+s]}),t):o},K1=(r,e,n,t)=>{let o=[];if(n.length>0)if(t.length>0){if(r.forEach(i=>o.push(i)),Math.max(...t)>r.length)throw new Error("axes is out of bound");t.forEach((i,s)=>o[i]=n[s])}else n.forEach(i=>o.push(i));else{if(e.length===0)throw new Error("Resize requires either scales or sizes.");o=r.map((i,s)=>Math.round(i*e[s]))}return o},X1=(r,e,n,t)=>{let o=(()=>{switch(t.keepAspectRatioPolicy){case"not_larger":return t.axes.length>0?Math.min(...t.axes.map(s=>n[s]),Number.MAX_VALUE):Math.min(...n,Number.MAX_VALUE);case"not_smaller":return t.axes.length>0?Math.max(...t.axes.map(s=>n[s]),Number.MIN_VALUE):Math.max(...n,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${t.keepAspectRatioPolicy} is not supported`)}})();n.fill(1,0,n.length);let i=r.slice();return t.axes.length>0?(t.axes.forEach(s=>n[s]=o),t.axes.forEach(s=>i[s]=Math.round(r[s]*n[s]))):(n.fill(o,0,n.length),i.forEach((s,a)=>i[a]=Math.round(s*n[a]))),i},Y1=(r,e,n,t,o)=>`
    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${r.type.indices}) -> array<f32, ${n.length}> {
      const inputShape = array<u32, ${e.length}>(${e.map(i=>`${i}u`).join(",")});
      const outputShape = array<u32, ${n.length}>(${n.map(i=>`${i}u`).join(",")});
      const scales = array<f32, ${t.length}>(${t.map(i=>`${i}f`).join(",")});
      const roi = array<f32, ${o.length}>(${o.map(i=>`${i}f`).join(",")});
      var originalIndices: array<f32, ${n.length}>;
      for (var i:u32 = 0; i < ${n.length}; i++) {
        var outputIndex = ${n.length===1?"outputIndices":"outputIndices[i]"};
        if (scales[i] == 1.0) {
          originalIndices[i] = f32(outputIndex);
        } else {
          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],
                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${e.length}]);
        }
      }
      return originalIndices;
    }`,J1=(r,e,n,t,o,i,s)=>`
    fn calculateInputIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> ${r.type.indices} {
        const inputShape = array<u32, ${n.length}>(${n.map(a=>`${a}u`).join(",")});
        const outputShape = array<u32, ${t.length}>(${t.map(a=>`${a}u`).join(",")});
        const scales = array<f32, ${o.length}>(${o.map(a=>`${a}f`).join(",")});
        const roi = array<f32, ${i.length}>(${i.map(a=>`${a}f`).join(",")});
        var inputIndices: ${r.type.indices};
        for (var i:u32 = 0; i < ${t.length}; i++) {
          var outputIndex = ${t.length===1?"outputIndices":"outputIndices[i]"};
          var inputIndex: u32;
          if (scales[i] == 1.0) {
            inputIndex = outputIndex;
          } else {
            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],
                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${n.length}]);
            if (!${s} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {
              if (original_idx < 0) {
                inputIndex = 0;
              } else if (original_idx > (f32(inputShape[i]) - 1)) {
                inputIndex = inputShape[i] - 1;
              } else {
                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));
              }
            } else {
              inputIndex = u32(original_idx);
            }
          }
          ${r.indicesSet("inputIndices","i","inputIndex")}
        }
        return inputIndices;
    }`,Z1=(r,e)=>`
    fn checkInputIndices(inputIndices: ${r.type.indices}) -> bool {
      const inputShape = array<u32, ${e.length}>(${e.map(n=>`${n}u`).join(",")});
      for (var i:u32 = 0; i < ${e.length}; i++) {
        var inputIndex = ${e.length===1?"inputIndices":"inputIndices[i]"};
        if (inputIndex < 0 || inputIndex >= inputShape[i]) {
          return false;
        }
      }
      return true;
    }`,Q1=(r,e,n,t,o,i,s)=>{let[a,u,l,c]=n.length===2?[-1,0,1,-1]:o[1]===1?[0,2,3,1]:[0,1,2,3];return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {
      var inputIndices: ${r.type.indices};
      inputIndices[${u}] = max(0, min(row, ${n[u]} - 1));
      inputIndices[${l}] = max(0, min(col, ${n[l]} - 1));
      if (${n.length} > 2) {
        inputIndices[${c}] = channel;
        inputIndices[${a}] = batch;
      };
      return input[${r.indicesToOffset("inputIndices")}];
    }

    fn bilinearInterpolation(outputIndices: ${e.type.indices}) -> f32 {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);
      var row:f32 = originalIndices[${u}];
      var col:f32 = originalIndices[${l}];
      if (${i} && (row < 0 || row > (${n[u]} - 1) || col < 0 || col > ${n[l]} - 1)) {
        return ${s};
      }
      row = max(0, min(row, ${n[u]} - 1));
      col = max(0, min(col, ${n[l]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = 0;
      var batch: u32 = 0;
      if (${n.length>2}) {
        channel = u32(originalIndices[${c}]);
        batch = u32(originalIndices[${a}]);
      }
      var x11: f32 = getInputValue(batch, channel, row1, col1);
      var x12: f32 = getInputValue(batch, channel, row1, col2);
      var x21: f32 = getInputValue(batch, channel, row2, col1);
      var x22: f32 = getInputValue(batch, channel, row2, col2);
      var dx1: f32 = row - f32(row1);
      var dx2: f32 = f32(row2 ) - row;
      var dy1 = col - f32(col1);
      var dy2 = f32(col2) - col;
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},eT=(r,e,n,t,o,i,s,a,u,l)=>{let[c,h]=n.length===2?[0,1]:o[1]===1?[2,3]:[1,2],m=b=>{let x=b===c?"row":"col";return`
      fn ${x}CubicInterpolation(inputIndices: ${r.type.indices}, outputIndices: ${e.type.indices}) -> f32 {
        var outputIndex = ${t.length===1?"outputIndices":`outputIndices[${b}]`};
        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${o[b]},
        f32(${t[b]}), f32(${n[b]}), ${i[b]}, ${i[b]} + ${n.length});
        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${a} && (originalIdx < 0 || originalIdx > (${n[b]} - 1))) {
          return ${u};
        }
        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${x}: f32 = originalIdx + f32(i);
          if (${x} < 0 || ${x} >= ${n[b]}) {
            if (${l}) {
              coefs[i + 1] = 0.0;
              continue;
            } else if (${a}) {
              return ${u};
            } else {
              ${x} = max(0, min(${x}, ${n[b]} - 1));
            }
          }
          var inputIndicesCopy: ${r.type.indices} = inputIndices;
          inputIndicesCopy[${b}] = u32(${x});
          data[i + 1] = ${b===c?`input[${r.indicesToOffset("inputIndicesCopy")}];`:`
                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);`}
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${m(c)};
    ${m(h)};
  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {
    var absS = abs(s);
    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: f32 = 1.0 - absS;
    var twoMinusAbsS: f32 = 2.0 - absS;
    var onePlusAbsS: f32 = 1.0 + absS;
    coeffs[0] = ((${s} * onePlusAbsS - 5 * ${s}) * onePlusAbsS + 8 * ${s}) * onePlusAbsS - 4 * ${s};
    coeffs[1] = ((${s} + 2) * absS - (${s} + 3)) * absS * absS + 1;
    coeffs[2] = ((${s} + 2) * oneMinusAbsS - (${s} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${s} * twoMinusAbsS - 5 * ${s}) * twoMinusAbsS + 8 * ${s}) * twoMinusAbsS - 4 * ${s};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {
    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(outputIndices: ${e.type.indices}) -> f32 {
    var inputIndices: ${r.type.indices} = outputIndices;
    return colCubicInterpolation(inputIndices, outputIndices);
  }
    `},tT=(r,e,n,t,o,i)=>{let s=r.dims,a=q1(i,e.axes,s.length),u=K1(s,t,o,e.axes),l=t.slice();t.length===0&&(l=s.map((T,E)=>T===0?1:u[E]/T),e.keepAspectRatioPolicy!=="stretch"&&(u=X1(s,u,l,e)));let c=ne("output",r.dataType,u),h=J("input",r.dataType,s),m=W.size(u),b=s.length===u.length&&s.every((T,E)=>T===u[E]),x=e.coordinateTransformMode==="tf_crop_and_resize",y=T=>`
      ${b?"":`
      ${H1(e.coordinateTransformMode)};
      ${(()=>{switch(e.mode){case"nearest":return`
              ${Z1(h,s)};
              ${j1(e.nearestMode,n)};
              ${J1(h,c,s,u,l,a,x)};
              `;case"linear":return`
              ${Y1(c,s,u,l,a)};
              ${Q1(h,c,s,u,l,x,e.extrapolationValue)};
              `;case"cubic":return`
            ${eT(h,c,s,u,l,a,e.cubicCoeffA,x,e.extrapolationValue,e.excludeOutside)};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${T.declareVariables(h,c)}
      ${T.mainStart()}
        ${T.guardAgainstOutOfBoundsWorkgroupSizes(m)}
        ${b?"output[global_idx] = input[global_idx];":`
        let outputIndices = ${c.offsetToIndices("global_idx")};
        var inputIndices: ${h.type.indices};
        ${(()=>{switch(e.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);
                if (checkInputIndices(inputIndices)) {
                  output[global_idx] = input[${h.indicesToOffset("inputIndices")}];
                } else {
                  output[global_idx] = ${e.extrapolationValue};
                }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${e.mode}`)}})()};
        `}
      }`;return{name:"Resize",shaderCache:{hint:`${e.cacheKey}|${n}|${l.length>0?l:""}|${o.length>0?o:""}|${b}`},getShaderSource:y,getRunData:()=>({outputs:[{dims:u,dataType:r.dataType}],dispatchGroup:{x:Math.ceil(m/64)}})}},rT=r=>{let e=r.customDataBuffer;return new Uint32Array(e,e.byteOffset,1)[0]},Jb=(r,e)=>{let n=[],t=[],o=[],i=rT(r);U1(r.inputs,e,i,n,t,o),r.compute(tT(r.inputs[0],e,i,n,t,o),{inputs:[0]})},Zb=r=>{let e=r.antialias,n=r.axes,t=r.coordinateTransformMode,o=r.cubicCoeffA,i=r.excludeOutside!==0,s=r.extrapolationValue,a=r.keepAspectRatioPolicy,u=r.mode,l=r.nearestMode===""?"simple":r.nearestMode;return ye({antialias:e,axes:n,coordinateTransformMode:t,cubicCoeffA:o,excludeOutside:i,extrapolationValue:s,keepAspectRatioPolicy:a,mode:u,nearestMode:l})}});var nT,oT,ey,ty,ry=M(()=>{"use strict";pt();Pe();st();Ge();nT=r=>{if(!r||r.length<3)throw new Error("layerNorm requires at least 3 inputs.");let e=r[0],n=r[1],t=r[2];if(e.dataType!==n.dataType||e.dataType!==t.dataType)throw new Error("All inputs must have the same data type");if(e.dims.length!==3&&e.dims.length!==2)throw new Error("Input must be 2D or 3D");if(n.dims.length!==3&&n.dims.length!==2)throw new Error("Skip must be 2D or 3D");let o=e.dims[e.dims.length-1],i=e.dims[e.dims.length-2];if(n.dims[n.dims.length-1]!==o)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==i)throw new Error("Skip must have the same sequence length as input");if(t.dims.length!==1)throw new Error("Gamma must be 1D");if(t.dims[t.dims.length-1]!==o)throw new Error("Gamma must have the same hidden size as input");if(r.length>3){let s=r[3];if(s.dims.length!==1)throw new Error("Beta must be 1D");if(s.dims[s.dims.length-1]!==o)throw new Error("Beta must have the same hidden size as input")}if(r.length>4){let s=r[4];if(s.dims.length!==1)throw new Error("Bias must be 1D");if(s.dims[s.dims.length-1]!==o)throw new Error("Bias must have the same hidden size as input")}},oT=(r,e,n,t)=>{let o=r[0].dims,i=W.size(o),s=o,a=i,u=o.slice(-1)[0],l=t?o.slice(0,-1).concat(1):[],c=r.length>3,h=r.length>4,m=t&&n>1,b=t&&n>2,x=n>3,y=Er(u),T=[J("x",r[0].dataType,r[0].dims,y),J("skip",r[1].dataType,r[1].dims,y),J("gamma",r[2].dataType,r[2].dims,y)];c&&T.push(J("beta",r[3].dataType,r[3].dims,y)),h&&T.push(J("bias",r[4].dataType,r[4].dims,y)),T.push(ne("output",r[0].dataType,s,y)),m&&T.push(ne("meanOutput",1,l)),b&&T.push(ne("invStdOutput",1,l)),x&&T.push(ne("inputSkipBiasSum",r[0].dataType,s,y));let E=ut(r[0].dataType),_=D=>`
      const hiddenSize: f32 = ${u};
      const hiddenSizeVectorized: u32 = ${u/y};
      const epsilon: f32 = ${e.epsilon};

      ${D.declareVariables(...T)}

      ${D.mainStart()}
        ${D.guardAgainstOutOfBoundsWorkgroupSizes(a/u)}
        let offset = global_idx * hiddenSizeVectorized;
        var sum = ${rr("f32",y)};
        var squareSum = ${rr("f32",y)};
        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {
          let skipValue = skip[offset + i];
          let biasValue = ${h?"bias[i]":"0.0"};
          let inputValue = x[offset + i];
          let value = inputValue + skipValue + biasValue;
          ${x?"inputSkipBiasSum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32Value = ${bn(E,y,"value")};
          sum += f32Value;
          squareSum += f32Value * f32Value;
        }
        let mean = ${Ur("sum",y)} / hiddenSize;
        let variance = sqrt(${Ur("squareSum",y)} / hiddenSize - mean * mean + epsilon);
        ${m?"meanOutput[global_idx] = mean;":""}
        ${b?"invStdOutput[global_idx] = 1.0 / variance;":""}
        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {
          output[offset + i] = (output[offset + i] - ${E}(mean)) / ${E}(variance) * gamma[i]
           + ${c?"beta[i]":"0.0"};
        }
      }`,C=[{dims:s,dataType:r[0].dataType}];return n>1&&C.push({dims:l,dataType:1}),n>2&&C.push({dims:l,dataType:1}),n>3&&C.push({dims:o,dataType:r[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:e.cacheKey},getShaderSource:_,getRunData:()=>({outputs:C,dispatchGroup:{x:Math.ceil(a/u/64)}})}},ey=(r,e)=>{nT(r.inputs);let t=[0];r.outputCount>1&&t.push(-3),r.outputCount>2&&t.push(-3),r.outputCount>3&&t.push(3),r.compute(oT(r.inputs,e,r.outputCount,!1),{outputs:t})},ty=r=>{let e=r.epsilon;return ye({epsilon:e})}});var iT,fa,aT,ny,sT,uT,oy,iy,ay=M(()=>{"use strict";pt();Pe();st();Ge();iT=(r,e)=>{if(!r||r.length<1)throw new Error("too few inputs");if(e.axes.length!==0){if(e.axes.length!==e.starts.length||e.axes.length!==e.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(e.starts.length!==e.ends.length)throw new Error("starts and ends must have the same length");r.slice(1).forEach((n,t)=>{if(r[t+1].dataType!==6&&r[t+1].dataType!==7)throw new Error(`Input ${t} must be an array of int32 or int64`)})},fa=(r,e)=>{let n=[];if(r.length>e)if(r[e].dataType===7)r[e].getBigInt64Array().forEach(t=>n.push(Number(t)));else if(r[e].dataType===6)r[e].getInt32Array().forEach(t=>n.push(Number(t)));else throw new Error(`Input ${e} must be an array of int32 or int64`);return n},aT=(r,e)=>{if(r.length>1){let n=fa(r,1),t=fa(r,2),o=fa(r,3);return o.length===0&&(o=[...Array(r[0].dims.length).keys()]),ye({starts:n,ends:t,axes:o})}else return e},ny=(r,e,n,t,o)=>{let i=r;return r<0&&(i+=n[t[e]]),o[e]<0?Math.max(0,Math.min(i,n[t[e]]-1)):Math.max(0,Math.min(i,n[t[e]]))},sT=(r,e,n,t)=>`fn calculateInputIndices(outputIndices: ${e.type.indices}) -> ${r.type.indices} {
          var inputIndices: ${r.type.indices};
          var carry = 0u;
          for (var i = ${n.length}; i >= 0; i--) {
            var outputIndex = ${t.length===1?"outputIndices":"outputIndices[i]"};
            var inputIndex = outputIndex * steps[i] + starts[i] + carry;
            carry = inputIndex / inputShape[i];
            inputIndex = inputIndex % inputShape[i];
            if (signs[i] < 0) {
              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];
            }
            ${n.length===1?"inputIndices":"inputIndices[i]"} = inputIndex;
          }
          return inputIndices;
      }`,uT=(r,e)=>{let n=r[0].dims,t=W.size(n),o=e.axes.length>0?W.normalizeAxes(e.axes,n.length):[...Array(n.length).keys()],i=fa(r,4);i.forEach(y=>y!==0||(()=>{throw new Error("step cannot be 0")})),i.length===0&&(i=Array(o.length).fill(1));let s=e.starts.map((y,T)=>ny(y,T,n,o,i)),a=e.ends.map((y,T)=>ny(y,T,n,o,i));if(o.length!==n.length)for(let y=0;y<n.length;++y)o.includes(y)||(s.splice(y,0,0),a.splice(y,0,n[y]),i.splice(y,0,1));let u=i.map(y=>Math.sign(y));i.forEach((y,T,E)=>{if(y<0){let _=(a[T]-s[T])/y,C=s[T],D=C+_*i[T];s[T]=D,a[T]=C,E[T]=-y}});let l=n.slice(0);o.forEach((y,T)=>{l[y]=Math.ceil((a[y]-s[y])/i[y])});let c={dims:l,dataType:r[0].dataType},h=ne("output",r[0].dataType,l),m=J("input",r[0].dataType,n),b=W.size(l),x=y=>`
      ${y.declareVariables(m,h)}
        const signs = array<i32, ${u.length}>(${u.map(T=>`${T}i`).join(",")});
        const starts = array<u32, ${s.length}>(${s.map(T=>`${T}u`).join(",")});
        const ends = array<u32, ${a.length}>(${a.map(T=>`${T}u`).join(",")});
        const steps = array<u32, ${i.length}>(${i.map(T=>`${T}u`).join(",")});
        const inputShape = array<u32, ${n.length}>(${n.map(T=>`${T}u`).join(",")});

        ${sT(m,h,n,l)}
        ${y.mainStart()}
          ${y.guardAgainstOutOfBoundsWorkgroupSizes(b)}
          let outputIndices = ${h.offsetToIndices("global_idx")};
          let inputIndices = calculateInputIndices(outputIndices);
          ${h.setByOffset("global_idx",m.getByIndices("inputIndices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${e.cacheKey}|${r[4]?.dims??""}`},getShaderSource:x,getRunData:()=>({outputs:[c],dispatchGroup:{x:Math.ceil(t/64)}})}},oy=(r,e)=>{iT(r.inputs,e);let n=aT(r.inputs,e);r.compute(uT(r.inputs,n),{inputs:[0]})},iy=r=>{let e=r.starts,n=r.ends,t=r.axes;return ye({starts:e,ends:n,axes:t})}});var lT,cT,sy,uy,ly=M(()=>{"use strict";Pe();st();Ge();lT=r=>{if(!r||r.length!==1)throw new Error("Softmax op requires 1 input.")},cT=(r,e)=>{let n=r.dims,t=W.size(n),o=64,i=e.axis;if(i<0&&(i=n.length+i),i<n.length-1)throw new Error("softmax only supports last axis for now.");let s=n[i],a=t/s,u=Er(s),l=s/u,c=(T,E)=>E===4?`max(max(${T}.x, ${T}.y), max(${T}.z, ${T}.w))`:E===2?`max(${T}.x, ${T}.y)`:E===3?`max(max(${T}.x, ${T}.y), ${T}.z)`:T,h=J("x",r.dataType,r.dims,u),m=ne("result",r.dataType,r.dims,u),b=h.type.value,x=ut(r.dataType)==="f32"?`var threadMax = ${b}(-3.402823e+38f);`:`var threadMax = ${b}(-65504.0h);`,y=T=>`
      var<workgroup> rowMaxShared : ${b};
      var<workgroup> rowSumShared : ${b};
      var<workgroup> threadShared : array<${b}, ${o}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${b} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${b}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${T.registerUniform("packedCols","i32").declareVariables(h,m)}
      ${T.mainStart()}
        let gindex = i32(global_id.x);
        let lindex = i32(local_id.x);
        const wg = ${o};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${x}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${b}(${c("threadShared[0]",u)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${b}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${b}(${Ur("threadShared[0]",u)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`;return{name:"Softmax",shaderCache:{hint:`${u}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:n,dataType:r.dataType}],dispatchGroup:{x:a},programUniforms:[{type:"uint32",data:l}]}),getShaderSource:y}},sy=(r,e)=>{lT(r.inputs),r.compute(cT(r.inputs[0],e))},uy=r=>ye({axis:r.axis})});var dT,fT,pT,hT,mT,cy,dy,fy=M(()=>{"use strict";Pe();st();Ge();dT=r=>{if(!r||r.length<1)throw new Error("too few inputs")},fT=(r,e)=>{let n=[],t=e.numOutputs;return r[1].dims[0]>0&&(r[1].getBigInt64Array().forEach(o=>n.push(Number(o))),t=n.length),ye({numOutputs:t,axis:e.axis,splitSizes:n})},pT=r=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${r}u; i += 1u ) {
    if (index < sizeInConcatAxis[i]) {
        return i;
    }
    }
    return ${r}u;
}`,hT=r=>{let e=r.length,n=[];for(let t=0;t<e;++t){let o=r[t].setByIndices("indices","input[global_idx]");e===1?n.push(o):t===0?n.push(`if (outputNumber == ${t}u) { ${o} }`):t===e-1?n.push(`else { ${o} }`):n.push(`else if (outputNumber == ${t}) { ${o} }`)}return`
      fn writeBufferData(outputNumber: u32, indices: ${r[0].type.indices}, global_idx: u32) {
        ${n.join(`
`)}
      }`},mT=(r,e)=>{let n=r[0].dims,t=W.size(n),o=r[0].dataType,i=n.length,s=e.axis,a=s<0?n.length+s:s,u=new Array(e.numOutputs),l=J("input",o,n),c=new Array(e.numOutputs),h=[],m=[],b=0;for(let T=0;T<e.numOutputs;T++){b+=e.splitSizes[T],c[T]=b;let E=n.slice();E[e.axis]=e.splitSizes[T],m.push(E),u[T]=ne(`output${T}`,o,m[T]),h.push({dims:m[T],dataType:r[0].dataType})}let x=i<2?"indices":`indices[${a}]`,y=T=>`
  ${T.declareVariables(l,...u)}
  const sizeInConcatAxis = array<u32, ${c.length}>(${c.map(E=>`${E}u`).join(",")});
  ${pT(c.length)}
  ${hT(u)}

  ${T.mainStart()}
    ${T.guardAgainstOutOfBoundsWorkgroupSizes(t)}

    var indices = ${l.offsetToIndices("global_idx")};
    let outputNumber = calculateOutputIndex(${x});
    if (outputNumber != 0) {
        ${x} -= sizeInConcatAxis[outputNumber - 1u];
    }
    writeBufferData(outputNumber, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:e.cacheKey},getShaderSource:y,getRunData:()=>({outputs:h,dispatchGroup:{x:Math.ceil(t/64)}})}},cy=(r,e)=>{dT(r.inputs);let n=r.inputs.length===1?e:fT(r.inputs,e);r.compute(mT(r.inputs,n),{inputs:[0]})},dy=r=>{let e=r.axis,n=r.splitSizes,t=r.numOutputs<0?n.length:r.numOutputs;if(t!==n.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ye({axis:e,numOutputs:t,splitSizes:n})}});var py,gT,bT,yT,hy,my=M(()=>{"use strict";pt();Pe();Ge();py=r=>Array.from(r.getBigInt64Array(),Number),gT=r=>{if(!r||r.length!==2)throw new Error("Tile requires 2 inputs.");if(r[0].dataType!==1&&r[0].dataType!==6&&r[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(r[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(r[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(py(r[1]).length!==r[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},bT=(r,e)=>{let n=[];for(let t=0;t<r.length;++t)n.push(r[t]*e[t]);return n},yT=r=>{let e=r[0].dims,n=py(r[1]),t=bT(e,n),o=W.size(t),i=r[0].dataType,s=J("input",i,e),a=ne("output",i,t),u=l=>`
      const inputShape = ${s.indices(...e)};
      ${l.declareVariables(s,a)}
      ${l.mainStart()}
      ${l.guardAgainstOutOfBoundsWorkgroupSizes(o)}
      let outputIndices = ${a.offsetToIndices("global_idx")};
      var inputIndices: ${s.type.indices};
      for (var i = 0; i < ${e.length}; i++) {
        let inputDimValue = ${a.indicesGet("outputIndices","i")}  % ${s.indicesGet("inputShape","i")};

        ${s.indicesSet("inputIndices","i","inputDimValue")}
      }
      ${a.setByOffset("global_idx",s.getByIndices("inputIndices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${n}`},getRunData:()=>({outputs:[{dims:t,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:u}},hy=r=>{gT(r.inputs),r.compute(yT(r.inputs),{inputs:[0]})}});var vT,xT,gy,by=M(()=>{"use strict";pt();Pe();Ge();vT=(r,e,n,t,o)=>{let i=W.size(n),s=Math.ceil(i/4),a=ne("outputData",o,n,4),u=J("aData",e[1].dataType,e[1].dims,4),l=J("bData",e[2].dataType,e[2].dims,4),c=J("cData",e[0].dataType,e[0].dims,4),h,m=(b,x,y)=>`select(${x}, ${b}, ${y})`;if(!t)h=a.setByOffset("global_idx",m(u.getByOffset("global_idx"),l.getByOffset("global_idx"),c.getByOffset("global_idx")));else{let b=(x,y,T="")=>{let E=`aData[indexA${y}][componentA${y}]`,_=`bData[indexB${y}][componentB${y}]`,C=`bool(cData[indexC${y}] & ${4278190080>>>(3-y)*8}u)`;return`
            let outputIndices${y} = ${a.offsetToIndices(`global_idx * 4u + ${y}u`)};
            let offsetA${y} = ${u.broadcastedIndicesToOffset(`outputIndices${y}`,a)};
            let offsetB${y} = ${l.broadcastedIndicesToOffset(`outputIndices${y}`,a)};
            let offsetC${y} = ${c.broadcastedIndicesToOffset(`outputIndices${y}`,a)};
            let indexA${y} = offsetA${y} / 4u;
            let indexB${y} = offsetB${y} / 4u;
            let indexC${y} = offsetC${y} / 4u;
            let componentA${y} = offsetA${y} % 4u;
            let componentB${y} = offsetB${y} % 4u;
            ${x}[${y}] = ${T}(${m(E,_,C)});
          `};o===9?h=`
            var data = vec4<u32>(0);
            ${b("data",0,"u32")}
            ${b("data",1,"u32")}
            ${b("data",2,"u32")}
            ${b("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:h=`
            ${b("outputData[global_idx]",0)}
            ${b("outputData[global_idx]",1)}
            ${b("outputData[global_idx]",2)}
            ${b("outputData[global_idx]",3)}
          `}return`
        ${r.declareVariables(c,u,l,a)}
        ${r.mainStart()}
        ${r.guardAgainstOutOfBoundsWorkgroupSizes(s)}
        ${h}
      }`},xT=r=>{let e=r[1].dims,n=r[2].dims,t=r[0].dims,o=r[1].dataType,i=!(W.areEqual(e,n)&&W.areEqual(n,t)),s=e,a=W.size(e);if(i){let u=mr.calcShape(mr.calcShape(e,n,!1),t,!1);if(!u)throw new Error("Can't perform where op on the given tensors");s=u,a=W.size(s)}return{name:"Where",getShaderSource:u=>vT(u,r,s,i,o),getRunData:()=>({outputs:[{dims:s,dataType:o}],dispatchGroup:{x:Math.ceil(a/64/4)}})}},gy=r=>{r.compute(xT(r.inputs))}});var yy,vy=M(()=>{"use strict";Zm();eg();kg();Ug();qg();cu();ab();cb();pb();gb();vb();Tb();Ib();Ob();Eb();kb();Kb();Yb();ta();Qb();ry();ay();ly();fy();my();Ao();au();by();yy=new Map([["Abs",[tg]],["Acos",[rg]],["Acosh",[ng]],["Add",[Bg]],["ArgMax",[Jm,ou]],["ArgMin",[Ym,ou]],["Asin",[og]],["Asinh",[ig]],["Atan",[ag]],["Atanh",[sg]],["AveragePool",[Fb,Nb]],["BiasAdd",[Qm]],["BiasSplitGelu",[Dg]],["Cast",[lg,ug]],["Ceil",[dg]],["ClipV10",[iu]],["Clip",[cg]],["Concat",[Hg,jg]],["Conv",[fu,du]],["ConvTranspose",[ib,ob]],["Cos",[fg]],["Cosh",[pg]],["Div",[Rg]],["Einsum",[ub,lb]],["Elu",[hg,na]],["Equal",[Mg]],["Erf",[mg]],["Exp",[gg]],["Expand",[fb]],["Floor",[bg]],["FusedConv",[fu,du]],["Gather",[mb,hb]],["GatherElements",[yb,bb]],["Gelu",[yg]],["Gemm",[xb,wb]],["GlobalAveragePool",[Vb,Gb]],["GlobalMaxPool",[qb,jb]],["Greater",[zg]],["GreaterOrEqual",[Vg]],["InstanceNormalization",[Sb,$b]],["LayerNormalization",[_b,Ab]],["LeakyRelu",[vg,na]],["Less",[Gg]],["LessOrEqual",[Wg]],["Log",[Pg]],["MatMul",[Cb]],["MaxPool",[Ub,Hb]],["Mul",[Lg]],["Neg",[wg]],["Not",[xg]],["Pad",[Pb,Db]],["Pow",[Ng]],["Range",[Xb]],["Reciprocal",[Tg]],["ReduceMin",[Wm,nr]],["ReduceMean",[Nm,nr]],["ReduceMax",[Vm,nr]],["ReduceSum",[Hm,nr]],["ReduceProd",[Um,nr]],["ReduceL1",[Fm,nr]],["ReduceL2",[zm,nr]],["ReduceLogSum",[qm,nr]],["ReduceLogSumExp",[Gm,nr]],["ReduceSumSquare",[jm,nr]],["Relu",[$g]],["Resize",[Jb,Zb]],["Sigmoid",[Sg]],["Sin",[Ig]],["Sinh",[Ag]],["Slice",[oy,iy]],["SkipLayerNormalization",[ey,ty]],["Split",[cy,dy]],["Sqrt",[_g]],["Softmax",[sy,uy]],["Sub",[Fg]],["Tan",[Og]],["Tanh",[Cg]],["ThresholdedRelu",[Eg,na]],["Tile",[hy]],["Transpose",[Im,Am]],["Where",[gy]]])});var pa,xy=M(()=>{"use strict";pt();Wr();Ge();pa=class{constructor(e){this.backend=e;this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,n){this.repo.set(e,n)}run(e,n,t,o,i,s,a){let u=this.backend.device,l=this.backend.getComputePassEncoder();l.setPipeline(e.computePipeline);let c=[];for(let m of o)c.push({binding:c.length,resource:{buffer:m.buffer}});for(let m of i)c.push({binding:c.length,resource:{buffer:m.buffer}});a&&c.push({binding:c.length,resource:a});let h=u.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:c,label:e.programInfo.name});if(l.setBindGroup(0,h),l.dispatchWorkgroups(...s),this.backend.pendingDispatchNumber++,this.backend.isQueryEnabled()){typeof this.backend.queryData>"u"&&(this.backend.queryData=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let m=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.querySet,0,2,this.backend.queryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.queryData.buffer,0,m.buffer,0,this.backend.querySetCount*8),this.backend.flush();let b=this.backend.currentKernelId,x=this.backend.kernels.get(b),y=`[${x[0]}] ${x[1]}`;m.buffer.mapAsync(GPUMapMode.READ).then(()=>{let T=new BigUint64Array(m.buffer.getMappedRange()),E=T[0],_=T[1];m.buffer.unmap(),typeof this.backend.queryTimeBase>"u"&&(this.backend.queryTimeBase=E);let C=Number(E-this.backend.queryTimeBase),D=Number(_-this.backend.queryTimeBase);if(!Number.isSafeInteger(C)||!Number.isSafeInteger(D))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(m.id);let z="";n.forEach((V,ee)=>{z+=`input[${ee}]: [${V.dims}] | ${$o(V.dataType)}, `});let F="";t.forEach((V,ee)=>{F+=`output[${ee}]: [${V.dims}] | ${$o(V.dataType)}, `}),console.log(`[profiling] kernel "${b}|${y}" ${z}${F}execution time: ${D-C} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(e,n){let t=this.backend.device,o=[];t.features.has("shader-f16")&&o.push("enable f16;");let i=$m(n),s=e.getShaderSource(i),a=`${o.join(`
`)}
${i.additionalImplementations}
${s}`,u=t.createShaderModule({code:a,label:e.name});et("verbose",()=>`[WebGPU] ${e.name} shader code: ${a}`);let l=t.createComputePipeline({compute:{module:u,entryPoint:"main"},layout:"auto",label:e.name});return{programInfo:e,computePipeline:l}}normalizeDispatchGroupSize(e){let n=typeof e=="number"?e:e.x,t=typeof e=="number"?1:e.y||1,o=typeof e=="number"?1:e.z||1,i=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(n<=i&&t<=i&&o<=i)return[n,t,o];let s=n*t*o,a=Math.ceil(Math.sqrt(s));if(a>i){if(a=Math.ceil(Math.cbrt(s)),a>i)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[a,a,a]}else return[a,a,1]}}});var wT,TT,ha,wy=M(()=>{"use strict";Wr();gm();xm();vy();xy();wT=(r,e)=>{if(e.length!==r.length)throw new Error(`inputDependencies length ${e.length} is not equal to inputTensors length ${r.length}.`);let n=[];for(let t=0;t<r.length;++t){let o=r[t].dataType;switch(e[t]){case"none":{n.push("");break}case"type":{n.push(`${o}`);break}case"rank":{let i=r[t].dims.length;n.push(`${o};${i}`);break}case"dims":{let i=r[t].dims.join(",");n.push(`${o};${i}`);break}default:throw new Error(`unsupported input dependency: ${e[t]}`)}}return n.join("|")},TT=(r,e,n)=>{let t=r.name;return r.shaderCache?.hint&&(t+="["+r.shaderCache.hint+"]"),t+=":"+n+`:${wT(e,r.shaderCache?.inputDependencies??new Array(e.length).fill("dims"))}`,t},ha=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.querySetCount=2;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let n=await navigator.gpu.requestAdapter();if(!n)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=e;let t=[],o={requiredLimits:{maxComputeWorkgroupStorageSize:n.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:n.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:n.limits.maxStorageBufferBindingSize,maxBufferSize:n.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:n.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:n.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:n.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:n.limits.maxComputeWorkgroupSizeZ},requiredFeatures:t};n.features.has("timestamp-query")&&t.push("timestamp-query"),n.features.has("shader-f16")&&t.push("shader-f16"),this.device=await n.requestDevice(o),this.gpuDataManager=vm(this),this.programManager=new pa(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,hm(e.logLevel,!!e.debug),this.device.onuncapturederror=i=>{i.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${i.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let e={};this.isQueryEnabled()&&(typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),e.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(e)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}isQueryEnabled(){return!!(this.device.features.has("timestamp-query")&&this.env.webgpu.profilingMode==="default")}run(e,n,t,o,i){let s=[];for(let _=0;_<n.length;++_){let C=this.gpuDataManager.get(n[_].data);if(!C)throw new Error(`no GPU data for input: ${n[_].data}`);s[_]=C}let{outputs:a,dispatchGroup:u,programUniforms:l}=e.getRunData(n),c=t.length===0?a.map((_,C)=>C):t;if(c.length!==a.length)throw new Error(`Output size ${c.length} must be equal to ${a.length}.`);let h=[],m=[];for(let _=0;_<a.length;++_){if(!Number.isInteger(c[_])||c[_]<-3||c[_]>=a.length)throw new Error(`Invalid output index: ${c[_]}`);if(c[_]===-3)continue;let C=c[_]===-1,D=c[_]===-2,z=C||D?i(a[_].dataType,a[_].dims):o(c[_],a[_].dataType,a[_].dims),F=this.gpuDataManager.get(z.data);if(!F)throw new Error(`no GPU data for output: ${z.data}`);if(C&&this.temporaryData.push(F),D){let V=this.kernelPersistentData.get(this.currentKernelId);V||(V=[],this.kernelPersistentData.set(this.currentKernelId,V)),V.push(F)}h.push(z),m.push(F)}let b;if(l){let _=0,C=0,D=[],z=1;l.forEach(ee=>{let re=typeof ee.data=="number"?[ee.data]:ee.data;if(re.length===0)return;let le;switch(re.length){case 1:le=4;break;case 2:le=8;break;case 3:le=16;break;case 4:le=16;break;case 5:le=16;break;case 6:le=16;break;default:throw new Error(`unsupported data length: ${re.length}`)}(C===5||C===6)&&(le=16),le>z&&(z=le),_=Math.ceil(_/le)*le,C=re.length,D.push(_),_+=re.length*4}),_=Math.ceil(_/z)*z;let F=new ArrayBuffer(_);l.forEach((ee,re)=>{let le=D[re],R=typeof ee.data=="number"?[ee.data]:ee.data;ee.type==="int32"?new Int32Array(F,le,R.length).set(R):ee.type==="uint32"?new Uint32Array(F,le,R.length).set(R):new Float32Array(F,le,R.length).set(R)});let V=this.gpuDataManager.create(_,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(V.buffer,0,F,0,_),this.gpuDataManager.release(V.id),b={offset:0,size:_,buffer:V.buffer}}let x=this.programManager.normalizeDispatchGroupSize(u),y=x[1]===1&&x[2]===1,T=TT(e,n,y),E=this.programManager.getArtifact(T);return E||(E=this.programManager.build(e,x),this.programManager.setArtifact(T,E)),et("info",()=>`[ProgramManager] run "${e.name}" (key=${T}) with ${x[0]}x${x[1]}x${x[2]}`),this.programManager.run(E,n,h,s,m,x,b),h}upload(e,n){this.gpuDataManager.upload(e,n)}memcpy(e,n){this.gpuDataManager.memcpy(e,n)}async download(e,n){await this.gpuDataManager.download(e,n)}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,n,t,o){let i=yy.get(e);if(!i)throw new Error(`kernel not implemented: ${e}`);this.kernels.set(n,[e,o,i[0],[i[1],t]])}releaseKernel(e){let n=this.kernelPersistentData.get(e);if(n){for(let t of n)this.gpuDataManager.release(t.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,n,t){let o=this.kernels.get(e);if(!o)throw new Error(`kernel not created: ${e}`);let[i,s,a,u]=o;if(this.currentKernelId!==null)throw new Error(`kernel "[${i}] ${s}" is not allowed to be called recursively`);this.currentKernelId=e,u[0]&&(u[1]=u[0](u[1]),u[0]=void 0),et("info",()=>`[WebGPU] Start to run kernel "[${i}] ${s}"...`);let l=this.env.debug;this.temporaryData=[];try{return l&&this.device.pushErrorScope("validation"),a(n,u[1]),0}catch(c){return t.push(Promise.resolve(`[WebGPU] Kernel "[${i}] ${s}" failed. ${c}`)),1}finally{l&&t.push(this.device.popErrorScope().then(c=>c?`GPU validation error for kernel "[${i}] ${s}": ${c.message}`:null));for(let c of this.temporaryData)this.gpuDataManager.release(c.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(e,n,t,o){let i=this.sessionExternalDataMapping.get(e);i||(i=new Map,this.sessionExternalDataMapping.set(e,i));let s=i.get(n),a=this.gpuDataManager.registerExternalBuffer(t,o,s?.[1]);return i.set(n,[a,t]),a}unregisterBuffers(e){let n=this.sessionExternalDataMapping.get(e);n&&(n.forEach(t=>this.gpuDataManager.unregisterExternalBuffer(t[1])),this.sessionExternalDataMapping.delete(e))}getBuffer(e){let n=this.gpuDataManager.get(e);if(!n)throw new Error(`no GPU data for buffer: ${e}`);return n.buffer}createDownloader(e,n,t){return async()=>{let o=await Zs(this,e,n);return mm(o.buffer,t)}}}});var Ty={};Mr(Ty,{init:()=>$T});var Eo,bu,$T,$y=M(()=>{"use strict";pt();wy();Wr();Pe();Eo=class r{constructor(e,n,t,o){this.module=e;this.dataType=n;this.data=t;this.dims=o}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let e=W.size(this.dims);return e===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let e=W.size(this.dims);return e===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let e=W.size(this.dims);return e===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}reshape(e){if(W.size(e)!==W.size(this.dims))throw new Error("Invalid new shape");return new r(this.module,this.dataType,this.data,e)}},bu=class{constructor(e,n,t){this.module=e;this.backend=n;this.customDataOffset=0;this.customDataSize=0;let o=e.HEAPU32,i=t>>2;this.opKernelContext=o[i++];let s=o[i++];this.outputCount=o[i++],this.customDataOffset=o[i++],this.customDataSize=o[i++];let a=[];for(let u=0;u<s;u++){let l=o[i++],c=o[i++],h=o[i++],m=[];for(let b=0;b<h;b++)m.push(o[i++]);a.push(new Eo(e,l,c,m))}this.inputs=a}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(e,n){let t=n?.inputs?.map(a=>typeof a=="number"?this.inputs[a]:a)??this.inputs,o=n?.outputs??[],i=(a,u,l)=>new Eo(this.module,u,this.output(a,l),l),s=(a,u)=>{let l=So(a);if(!l)throw new Error(`Unsupported data type: ${a}`);let c=l*W.size(u);return new Eo(this.module,a,this.backend.gpuDataManager.create(c).id,u)};return this.backend.run(e,t,o,i,s)}output(e,n){let t=this.module.stackSave();try{let o=this.module.stackAlloc((1+n.length)*4),i=o>>2;this.module.HEAPU32[i++]=n.length;for(let s=0;s<n.length;s++)this.module.HEAPU32[i++]=n[s];return this.module._JsepOutput(this.opKernelContext,e,o)}catch(o){throw new Error(`Failed to generate kernel's output[${e}] with dims [${n}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${o}`)}finally{this.module.stackRestore(t)}}},$T=async(r,e)=>{let n=r.jsepInit;if(n&&navigator.gpu){if(!e.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let t=new ha;await t.initialize(e),n(t,o=>t.alloc(o),o=>t.free(o),(o,i,s,a=!1)=>{if(a)et("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${o}, dst=${i}, size=${s}`),t.memcpy(o,i);else{et("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${o}, gpuDataId=${i}, size=${s}`);let u=r.HEAPU8.subarray(o,o+s);t.upload(i,u)}},async(o,i,s)=>{et("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${o}, dataOffset=${i}, size=${s}`),await t.download(o,()=>r.HEAPU8.subarray(i,i+s))},(o,i,s)=>t.createKernel(o,i,s,e.debug||e.webgpu.profilingMode==="default"?r.UTF8ToString(r._JsepGetNodeName(i)):`${i}`),o=>t.releaseKernel(o),(o,i,s,a)=>{et("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${s}, kernel=${o}, contextDataOffset=${i}`);let u=new bu(r,t,i);return t.computeKernel(o,u,a)})}}});var Iy,ST,IT,Ay,Po,_y,yu,vu,Oy,Cy,Sy,Ey,Py,Dy,ky=M(()=>{"use strict";lm();dm();pt();Gn();Ki();Iy=!1,ST=r=>{let e=tt(),n=e.stackSave();try{let t=e.stackAlloc(8);return e._OrtGetInputOutputCount(r,t,t+4)!==0&&Xe("Can't get session input/output count."),[e.HEAP32[t/4],e.HEAP32[t/4+1]]}finally{e.stackRestore(n)}},IT=(r,e)=>{tt()._OrtInit(r,e)!==0&&Xe("Can't initialize onnxruntime.")},Ay=async r=>{IT(r.wasm.numThreads,Io(r.logLevel));{let e=($y(),Ar(Ty)).init;await e(tt(),r)}Iy=!0},Po=new Map,_y=()=>Iy,yu=r=>{let e=tt(),n=e._malloc(r.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${r.byteLength}.`);return e.HEAPU8.set(r,n),[n,r.byteLength]},vu=(r,e)=>{let n=tt(),t=0,o=0,i=0,s=[],a=[],u=[];try{[o,s]=cm(e),t=n._OrtCreateSession(r[0],r[1],o),t===0&&Xe("Can't create a session.");let[l,c]=ST(t),h=[],m=[],b=[];for(let y=0;y<l;y++){let T=n._OrtGetInputName(t,y);T===0&&Xe("Can't get an input name."),a.push(T),h.push(n.UTF8ToString(T))}for(let y=0;y<c;y++){let T=n._OrtGetOutputName(t,y);T===0&&Xe("Can't get an output name."),u.push(T);let E=n.UTF8ToString(T);m.push(E);{let _=typeof e?.preferredOutputLocation=="string"?e.preferredOutputLocation:e?.preferredOutputLocation?.[E]??"cpu";if(_!=="cpu"&&_!=="cpu-pinned"&&_!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${_}.`);b.push(_)}}let x=null;return b.some(y=>y==="gpu-buffer")&&(i=n._OrtCreateBinding(t),i===0&&Xe("Can't create IO binding."),x={handle:i,outputPreferredLocations:b,outputPreferredLocationsEncoded:b.map(y=>Ys(y))}),Po.set(t,[t,a,u,x]),[t,h,m]}catch(l){throw a.forEach(c=>n._OrtFree(c)),u.forEach(c=>n._OrtFree(c)),i!==0&&n._OrtReleaseBinding(i),t!==0&&n._OrtReleaseSession(t),l}finally{n._free(r[0]),o!==0&&n._OrtReleaseSessionOptions(o),s.forEach(l=>n._free(l))}},Oy=(r,e)=>{let n=yu(r);return vu(n,e)},Cy=r=>{let e=tt(),n=Po.get(r);if(!n)throw new Error(`cannot release session. invalid session id: ${r}`);let[t,o,i,s]=n;s&&e._OrtReleaseBinding(s.handle),e.jsepUnregisterBuffers?.(r),o.forEach(a=>e._OrtFree(a)),i.forEach(a=>e._OrtFree(a)),e._OrtReleaseSession(t),Po.delete(r)},Sy=(r,e,n,t,o)=>{if(!r){e.push(0);return}let i=tt(),s=r[0],a=r[1],u=r[3],l,c;if(s==="string"&&u==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(u==="gpu-buffer"){let b=r[2].gpuBuffer,x=So(Xs(s));c=a.reduce((y,T)=>y*T,1)*x,l=i.jsepRegisterBuffer(t,o,b,c)}else{let b=r[2];if(Array.isArray(b)){c=4*b.length,l=i._malloc(c),n.push(l);let x=l/4;for(let y=0;y<b.length;y++){if(typeof b[y]!="string")throw new TypeError(`tensor data at index ${y} is not a string`);i.HEAPU32[x++]=at(b[y],n)}}else c=b.byteLength,l=i._malloc(c),n.push(l),i.HEAPU8.set(new Uint8Array(b.buffer,b.byteOffset,c),l)}let h=i.stackSave(),m=i.stackAlloc(4*a.length);try{let b=m/4;a.forEach(y=>i.HEAP32[b++]=y);let x=i._OrtCreateTensor(Xs(s),l,c,m,a.length,Ys(u));x===0&&Xe(`Can't create tensor for input/output. session=${t}, index=${o}.`),e.push(x)}finally{i.stackRestore(h)}},Ey=async(r,e,n,t,o,i)=>{let s=tt(),a=Po.get(r);if(!a)throw new Error(`cannot run inference. invalid session id: ${r}`);let[u,l,c,h]=a,m=e.length,b=t.length,x=0,y=[],T=[],E=[],_=[],C=s.stackSave(),D=s.stackAlloc(m*4),z=s.stackAlloc(m*4),F=s.stackAlloc(b*4),V=s.stackAlloc(b*4);try{[x,y]=um(i);for(let se=0;se<m;se++)Sy(n[se],T,_,r,e[se]);for(let se=0;se<b;se++)Sy(o[se],E,_,r,m+t[se]);let ee=D/4,re=z/4,le=F/4,R=V/4;for(let se=0;se<m;se++)s.HEAPU32[ee++]=T[se],s.HEAPU32[re++]=l[e[se]];for(let se=0;se<b;se++)s.HEAPU32[le++]=E[se],s.HEAPU32[R++]=c[t[se]];if(h){let{handle:se,outputPreferredLocations:Le,outputPreferredLocationsEncoded:Je}=h;if(l.length!==m)throw new Error(`input count from feeds (${m}) is expected to be always equal to model's input count (${l.length}).`);for(let ke=0;ke<m;ke++){let lt=e[ke];await s._OrtBindInput(se,l[lt],T[ke])!==0&&Xe(`Can't bind input[${ke}] for session=${r}.`)}for(let ke=0;ke<b;ke++){let lt=t[ke];o[ke]?.[3]?s._OrtBindOutput(se,c[lt],E[ke],0)!==0&&Xe(`Can't bind pre-allocated output[${ke}] for session=${r}.`):s._OrtBindOutput(se,c[lt],0,Je[lt])!==0&&Xe(`Can't bind output[${ke}] to ${Le[ke]} for session=${r}.`)}}let fe;h?fe=await s._OrtRunWithBinding(u,h.handle,b,F,x):fe=await s._OrtRun(u,z,D,m,V,b,F,x),fe!==0&&Xe("failed to call OrtRun().");let Ye=[];for(let se=0;se<b;se++){let Le=s.HEAPU32[F/4+se];if(Le===E[se]){Ye.push(o[se]);continue}let Je=s.stackSave(),ke=s.stackAlloc(4*4),lt=!1,We,vt=0;try{s._OrtGetTensorData(Le,ke,ke+4,ke+8,ke+12)!==0&&Xe(`Can't access output tensor data on index ${se}.`);let Rt=ke/4,Mt=s.HEAPU32[Rt++];vt=s.HEAPU32[Rt++];let q=s.HEAPU32[Rt++],Ie=s.HEAPU32[Rt++],$e=[];for(let Ue=0;Ue<Ie;Ue++)$e.push(s.HEAPU32[q/4+Ue]);s._OrtFree(q);let wt=$e.reduce((Ue,rt)=>Ue*rt,1);We=$o(Mt);let It=h?.outputPreferredLocations[t[se]];if(We==="string"){if(It==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Ue=[],rt=vt/4;for(let kr=0;kr<wt;kr++){let Dt=s.HEAPU32[rt++],vn=kr===wt-1?void 0:s.HEAPU32[rt]-Dt;Ue.push(s.UTF8ToString(Dt,vn))}Ye.push([We,$e,Ue,"cpu"])}else if(It==="gpu-buffer"&&wt>0){let Ue=s.jsepGetBuffer(vt),rt=So(Mt);if(rt===void 0||!Yi(We))throw new Error(`Unsupported data type: ${We}`);lt=!0,Ye.push([We,$e,{gpuBuffer:Ue,download:s.jsepCreateDownloader(Ue,wt*rt,We),dispose:()=>{s._OrtReleaseTensor(Le)}},"gpu-buffer"])}else{let Ue=Xi(We),rt=new Ue(wt);new Uint8Array(rt.buffer,rt.byteOffset,rt.byteLength).set(s.HEAPU8.subarray(vt,vt+rt.byteLength)),Ye.push([We,$e,rt,"cpu"])}}finally{s.stackRestore(Je),We==="string"&&vt&&s._free(vt),lt||s._OrtReleaseTensor(Le)}}return h&&s._OrtClearBoundOutputs(h.handle),Ye}finally{s.stackRestore(C),T.forEach(ee=>s._OrtReleaseTensor(ee)),E.forEach(ee=>s._OrtReleaseTensor(ee)),_.forEach(ee=>s._free(ee)),x!==0&&s._OrtReleaseRunOptions(x),y.forEach(ee=>s._free(ee))}},Py=r=>{let e=tt(),n=Po.get(r);if(!n)throw new Error("invalid session id");let t=n[0],o=e._OrtEndProfiling(t);o===0&&Xe("Can't get an profile file name."),e._OrtFree(o)},Dy=r=>{let e=[];for(let n of r){let t=n[2];!Array.isArray(t)&&"buffer"in t&&e.push(t.buffer)}return e}});var By=He((LR,_T)=>{_T.exports='/*!\n * ONNX Runtime Web v1.17.0\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var Sn=Object.defineProperty;var ll=Object.getOwnPropertyDescriptor;var cl=Object.getOwnPropertyNames;var dl=Object.prototype.hasOwnProperty;var K=(e,t)=>()=>(e&&(t=e(e=0)),t);var dr=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Vr=(e,t)=>{for(var r in t)Sn(e,r,{get:t[r],enumerable:!0})},pl=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let a of cl(t))!dl.call(e,a)&&a!==r&&Sn(e,a,{get:()=>t[a],enumerable:!(o=ll(t,a))||o.enumerable});return e};var qt=e=>pl(Sn({},"__esModule",{value:!0}),e);var Cn={};Vr(Cn,{readFile:()=>fl});var fl,An=K(()=>{fl=void 0});var In={};Vr(In,{join:()=>ml});var ml,Tn=K(()=>{ml=void 0});var Go=dr((No,On)=>{"use strict";var Uo=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){var r=t,o,a;r.ready=new Promise((l,m)=>{o=l,a=m}),r.jsepInit=(l,m,y,w,I,U,F,re)=>{r.ab=l,r.Ra=m,r.Ta=y,r.La=w,r.Sa=I,r.xa=U,r.Ua=F,r.Va=re,m=(J,ae,ne)=>(...me)=>{let ye=je,_=ae?.();me=J(...me);let se=ae?.();return _!==se&&(J=se,ne(_),ae=ne=null),je!=ye?rr():me},y=J=>async(...ae)=>{try{if(r.Fa)throw Error("Session already started");let ne=r.Fa={Wa:ae[0],errors:[]},me=await J(...ae);if(r.Fa!==ne)throw Error("Session mismatch");l.flush();let ye=ne.errors;if(0<ye.length){let _=await Promise.all(ye);if(_=_.filter(se=>se),0<_.length)throw Error(_.join(`\n`))}return me}finally{r.Fa=null}},r._OrtRun=y(m(r._OrtRun,()=>r._OrtRun,J=>r._OrtRun=J)),r._OrtRunWithBinding=y(m(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,J=>r._OrtRunWithBinding=J)),r._OrtBindInput=m(r._OrtBindInput,()=>r._OrtBindInput,J=>r._OrtBindInput=J),r.jsepRegisterBuffer=(J,ae,ne,me)=>l.registerBuffer(J,ae,ne,me),r.jsepUnregisterBuffers=J=>{l.unregisterBuffers(J)},r.jsepGetBuffer=J=>l.getBuffer(J),r.jsepCreateDownloader=(J,ae,ne)=>l.createDownloader(J,ae,ne)};var u=Object.assign({},r),i="./this.program",d=(l,m)=>{throw m},f=typeof window=="object",h=typeof importScripts=="function",c=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",C="",b,$,S;if(c){var x=(An(),qt(Cn)),A=(Tn(),qt(In));C=h?A.dirname(C)+"/":__dirname+"/",b=(l,m)=>(l=l.startsWith("file://")?new URL(l):A.normalize(l),x.readFileSync(l,m?void 0:"utf8")),S=l=>(l=b(l,!0),l.buffer||(l=new Uint8Array(l)),l),$=(l,m,y,w=!0)=>{l=l.startsWith("file://")?new URL(l):A.normalize(l),x.readFile(l,w?void 0:"utf8",(I,U)=>{I?y(I):m(w?U.buffer:U)})},!r.thisProgram&&1<process.argv.length&&(i=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),d=(l,m)=>{throw process.exitCode=l,m},r.inspect=()=>"[Emscripten Module object]"}else(f||h)&&(h?C=self.location.href:typeof document<"u"&&document.currentScript&&(C=document.currentScript.src),e&&(C=e),C.indexOf("blob:")!==0?C=C.substr(0,C.replace(/[?#].*/,"").lastIndexOf("/")+1):C="",b=l=>{var m=new XMLHttpRequest;return m.open("GET",l,!1),m.send(null),m.responseText},h&&(S=l=>{var m=new XMLHttpRequest;return m.open("GET",l,!1),m.responseType="arraybuffer",m.send(null),new Uint8Array(m.response)}),$=(l,m,y)=>{var w=new XMLHttpRequest;w.open("GET",l,!0),w.responseType="arraybuffer",w.onload=()=>{w.status==200||w.status==0&&w.response?m(w.response):y()},w.onerror=y,w.send(null)});var k=r.print||console.log.bind(console),O=r.printErr||console.error.bind(console);Object.assign(r,u),u=null,r.thisProgram&&(i=r.thisProgram),r.quit&&(d=r.quit);var P;r.wasmBinary&&(P=r.wasmBinary);var R=r.noExitRuntime||!0;typeof WebAssembly!="object"&&G("no native wasm support detected");var V,B,W=!1,q,ee,oe,D,te,Ie,Z;function ve(){var l=V.buffer;r.HEAP8=ee=new Int8Array(l),r.HEAP16=new Int16Array(l),r.HEAP32=D=new Int32Array(l),r.HEAPU8=oe=new Uint8Array(l),r.HEAPU16=new Uint16Array(l),r.HEAPU32=te=new Uint32Array(l),r.HEAPF32=Ie=new Float32Array(l),r.HEAPF64=Z=new Float64Array(l)}var Te,be=[],Be=[],Se=[];function Ue(){var l=r.preRun.shift();be.unshift(l)}var qe=0,Ke=null,Ye=null;function G(l){throw r.onAbort&&r.onAbort(l),l="Aborted("+l+")",O(l),W=!0,q=1,l=new WebAssembly.RuntimeError(l+". Build with -sASSERTIONS for more info."),a(l),l}function pe(l){return l.startsWith("data:application/octet-stream;base64,")}var de;if(de="ort-wasm-simd.wasm",!pe(de)){var Ne=de;de=r.locateFile?r.locateFile(Ne,C):C+Ne}function Ge(l){if(l==de&&P)return new Uint8Array(P);if(S)return S(l);throw"both async and sync fetching of the wasm failed"}function Ce(l){if(!P&&(f||h)){if(typeof fetch=="function"&&!l.startsWith("file://"))return fetch(l,{credentials:"same-origin"}).then(m=>{if(!m.ok)throw"failed to load wasm binary file at \'"+l+"\'";return m.arrayBuffer()}).catch(()=>Ge(l));if($)return new Promise((m,y)=>{$(l,w=>m(new Uint8Array(w)),y)})}return Promise.resolve().then(()=>Ge(l))}function Pe(l,m,y){return Ce(l).then(w=>WebAssembly.instantiate(w,m)).then(w=>w).then(y,w=>{O("failed to asynchronously prepare wasm: "+w),G(w)})}function vt(l,m){var y=de;return P||typeof WebAssembly.instantiateStreaming!="function"||pe(y)||y.startsWith("file://")||c||typeof fetch!="function"?Pe(y,l,m):fetch(y,{credentials:"same-origin"}).then(w=>WebAssembly.instantiateStreaming(w,l).then(m,function(I){return O("wasm streaming compile failed: "+I),O("falling back to ArrayBuffer instantiation"),Pe(y,l,m)}))}var He,zt={916496:l=>{r.xa("Abs",l,void 0)},916547:l=>{r.xa("Neg",l,void 0)},916598:l=>{r.xa("Floor",l,void 0)},916651:l=>{r.xa("Ceil",l,void 0)},916703:l=>{r.xa("Reciprocal",l,void 0)},916761:l=>{r.xa("Sqrt",l,void 0)},916813:l=>{r.xa("Exp",l,void 0)},916864:l=>{r.xa("Erf",l,void 0)},916915:l=>{r.xa("Sigmoid",l,void 0)},916970:l=>{r.xa("Log",l,void 0)},917021:l=>{r.xa("Sin",l,void 0)},917072:l=>{r.xa("Cos",l,void 0)},917123:l=>{r.xa("Tan",l,void 0)},917174:l=>{r.xa("Asin",l,void 0)},917226:l=>{r.xa("Acos",l,void 0)},917278:l=>{r.xa("Atan",l,void 0)},917330:l=>{r.xa("Sinh",l,void 0)},917382:l=>{r.xa("Cosh",l,void 0)},917434:l=>{r.xa("Asinh",l,void 0)},917487:l=>{r.xa("Acosh",l,void 0)},917540:l=>{r.xa("Atanh",l,void 0)},917593:l=>{r.xa("Tanh",l,void 0)},917645:l=>{r.xa("Not",l,void 0)},917696:(l,m,y)=>{r.xa("ClipV10",l,{min:m,max:y})},917768:l=>{r.xa("Clip",l,void 0)},917820:(l,m)=>{r.xa("Elu",l,{alpha:m})},917878:l=>{r.xa("Relu",l,void 0)},917930:(l,m)=>{r.xa("LeakyRelu",l,{alpha:m})},917994:(l,m)=>{r.xa("ThresholdedRelu",l,{alpha:m})},918064:(l,m)=>{r.xa("Cast",l,{to:m})},918122:l=>{r.xa("Add",l,void 0)},918173:l=>{r.xa("Sub",l,void 0)},918224:l=>{r.xa("Mul",l,void 0)},918275:l=>{r.xa("Div",l,void 0)},918326:l=>{r.xa("Pow",l,void 0)},918377:l=>{r.xa("Equal",l,void 0)},918430:l=>{r.xa("Greater",l,void 0)},918485:l=>{r.xa("GreaterOrEqual",l,void 0)},918547:l=>{r.xa("Less",l,void 0)},918599:l=>{r.xa("LessOrEqual",l,void 0)},918658:(l,m,y,w,I)=>{r.xa("ReduceMean",l,{keepDims:!!m,noopWithEmptyAxes:!!y,axes:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[]})},918822:(l,m,y,w,I)=>{r.xa("ReduceMax",l,{keepDims:!!m,noopWithEmptyAxes:!!y,axes:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[]})},918985:(l,m,y,w,I)=>{r.xa("ReduceMin",l,{keepDims:!!m,noopWithEmptyAxes:!!y,axes:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[]})},919148:(l,m,y,w,I)=>{r.xa("ReduceProd",l,{keepDims:!!m,noopWithEmptyAxes:!!y,axes:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[]})},919312:(l,m,y,w,I)=>{r.xa("ReduceSum",l,{keepDims:!!m,noopWithEmptyAxes:!!y,axes:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[]})},919475:(l,m,y,w,I)=>{r.xa("ReduceL1",l,{keepDims:!!m,noopWithEmptyAxes:!!y,axes:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[]})},919637:(l,m,y,w,I)=>{r.xa("ReduceL2",l,{keepDims:!!m,noopWithEmptyAxes:!!y,axes:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[]})},919799:(l,m,y,w,I)=>{r.xa("ReduceLogSum",l,{keepDims:!!m,noopWithEmptyAxes:!!y,axes:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[]})},919965:(l,m,y,w,I)=>{r.xa("ReduceSumSquare",l,{keepDims:!!m,noopWithEmptyAxes:!!y,axes:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[]})},920134:(l,m,y,w,I)=>{r.xa("ReduceLogSumExp",l,{keepDims:!!m,noopWithEmptyAxes:!!y,axes:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[]})},920303:l=>{r.xa("Where",l,void 0)},920356:(l,m,y)=>{r.xa("Transpose",l,{perm:m?Array.from(D.subarray(y>>>0,y+m>>>0)):[]})},920469:(l,m,y,w,I,U,F,re,J,ae,ne,me,ye,_,se)=>{r.xa("ConvTranspose",l,{format:J?"NHWC":"NCHW",autoPad:m,dilations:[y],group:w,kernel_shape:[I],pads:[U,F],strides:[re],wIsConst:()=>!!ee[ae>>>0],outputPadding:ne?Array.from(D.subarray(me>>>0,me+ne>>>0)):[],outputShape:ye?Array.from(D.subarray(_>>>0,_+ye>>>0)):[],activation:De(se)})},920883:(l,m,y,w,I,U,F,re,J,ae,ne,me,ye,_)=>{r.xa("ConvTranspose",l,{format:re?"NHWC":"NCHW",autoPad:m,dilations:Array.from(D.subarray(y>>>0,y+2>>>0)),group:w,kernelShape:Array.from(D.subarray(I>>>0,I+2>>>0)),pads:Array.from(D.subarray(U>>>0,U+4>>>0)),strides:Array.from(D.subarray(F>>>0,F+2>>>0)),wIsConst:()=>!!ee[J>>>0],outputPadding:0<ae?Array.from(D.subarray(ne>>>0,ne+ae>>>0)):[],outputShape:0<me?Array.from(D.subarray(ye>>>0,ye+me>>>0)):[],activation:De(_)})},921440:(l,m,y,w,I,U,F,re,J,ae,ne,me,ye,_,se)=>{r.xa("ConvTranspose",l,{format:J?"NHWC":"NCHW",autoPad:m,dilations:[y],group:w,kernel_shape:[I],pads:[U,F],strides:[re],wIsConst:()=>!!ee[ae>>>0],outputPadding:ne?Array.from(D.subarray(me>>>0,me+ne>>>0)):[],outputShape:ye?Array.from(D.subarray(_>>>0,_+ye>>>0)):[],activation:De(se)})},921854:(l,m,y,w,I,U,F,re,J,ae,ne,me,ye,_)=>{r.xa("ConvTranspose",l,{format:re?"NHWC":"NCHW",autoPad:m,dilations:Array.from(D.subarray(y>>>0,y+2>>>0)),group:w,kernelShape:Array.from(D.subarray(I>>>0,I+2>>>0)),pads:Array.from(D.subarray(U>>>0,U+4>>>0)),strides:Array.from(D.subarray(F>>>0,F+2>>>0)),wIsConst:()=>!!ee[J>>>0],outputPadding:0<ae?Array.from(D.subarray(ne>>>0,ne+ae>>>0)):[],outputShape:0<me?Array.from(D.subarray(ye>>>0,ye+me>>>0)):[],activation:De(_)})},922411:(l,m)=>{r.xa("GlobalAveragePool",l,{format:m?"NHWC":"NCHW"})},922502:(l,m,y,w,I,U,F,re,J,ae,ne,me,ye,_,se,he)=>{r.xa("AveragePool",l,{format:he?"NHWC":"NCHW",auto_pad:m,ceil_mode:y,count_include_pad:w,storage_order:I,dilations:[U,F],kernel_shape:[re,J],pads:[ae,ne,me,ye],strides:[_,se]})},922786:(l,m)=>{r.xa("GlobalAveragePool",l,{format:m?"NHWC":"NCHW"})},922877:(l,m,y,w,I,U,F,re,J,ae,ne,me,ye,_,se,he)=>{r.xa("AveragePool",l,{format:he?"NHWC":"NCHW",auto_pad:m,ceil_mode:y,count_include_pad:w,storage_order:I,dilations:[U,F],kernel_shape:[re,J],pads:[ae,ne,me,ye],strides:[_,se]})},923161:(l,m)=>{r.xa("GlobalMaxPool",l,{format:m?"NHWC":"NCHW"})},923248:(l,m,y,w,I,U,F,re,J,ae,ne,me,ye,_,se,he)=>{r.xa("MaxPool",l,{format:he?"NHWC":"NCHW",auto_pad:m,ceil_mode:y,count_include_pad:w,storage_order:I,dilations:[U,F],kernel_shape:[re,J],pads:[ae,ne,me,ye],strides:[_,se]})},923528:(l,m)=>{r.xa("GlobalMaxPool",l,{format:m?"NHWC":"NCHW"})},923615:(l,m,y,w,I,U,F,re,J,ae,ne,me,ye,_,se,he)=>{r.xa("MaxPool",l,{format:he?"NHWC":"NCHW",auto_pad:m,ceil_mode:y,count_include_pad:w,storage_order:I,dilations:[U,F],kernel_shape:[re,J],pads:[ae,ne,me,ye],strides:[_,se]})},923895:(l,m,y,w,I)=>{r.xa("Gemm",l,{alpha:m,beta:y,transA:w,transB:I})},923999:l=>{r.xa("MatMul",l,void 0)},924053:(l,m,y,w)=>{r.xa("ArgMax",l,{keepDims:!!m,selectLastIndex:!!y,axis:w})},924161:(l,m,y,w)=>{r.xa("ArgMin",l,{keepDims:!!m,selectLastIndex:!!y,axis:w})},924269:(l,m)=>{r.xa("Softmax",l,{axis:m})},924332:(l,m)=>{r.xa("Concat",l,{axis:m})},924392:(l,m,y,w,I)=>{r.xa("Split",l,{axis:m,numOutputs:y,splitSizes:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[]})},924537:l=>{r.xa("Expand",l,void 0)},924591:(l,m)=>{r.xa("Gather",l,{axis:Number(m)})},924662:(l,m)=>{r.xa("GatherElements",l,{axis:Number(m)})},924741:(l,m,y,w,I,U,F,re,J,ae,ne)=>{r.xa("Resize",l,{antialias:m,axes:y?Array.from(D.subarray(w>>>0,w+y>>>0)):[],coordinateTransformMode:De(I),cubicCoeffA:U,excludeOutside:F,extrapolationValue:re,keepAspectRatioPolicy:De(J),mode:De(ae),nearestMode:De(ne)})},925092:(l,m,y,w,I,U,F)=>{r.xa("Slice",l,{starts:m?Array.from(D.subarray(y>>>0,y+m>>>0)):[],ends:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[],axes:U?Array.from(D.subarray(F>>>0,F+U>>>0)):[]})},925323:l=>{r.xa("Tile",l,void 0)},925375:(l,m,y)=>{r.xa("LayerNormalization",l,{axis:Number(m),epsilon:Number(y)})},925482:(l,m,y)=>{r.xa("InstanceNormalization",l,{epsilon:m,format:y?"NHWC":"NCHW"})},925596:(l,m,y)=>{r.xa("InstanceNormalization",l,{epsilon:m,format:y?"NHWC":"NCHW"})},925710:l=>{r.xa("Range",l,void 0)},925763:(l,m)=>{r.xa("Einsum",l,{equation:De(m)})},925844:(l,m,y,w,I)=>{r.xa("Pad",l,{mode:m,value:y,pads:w?Array.from(D.subarray(I>>>0,I+w>>>0)):[]})},925976:l=>{r.xa("Gelu",l,void 0)},926028:l=>{r.xa("BiasAdd",l,void 0)},926083:l=>{r.xa("BiasSplitGelu",l,void 0)},926144:(l,m)=>{r.xa("SkipLayerNormalization",l,{epsilon:m})},926225:(l,m,y,w,I,U,F,re,J,ae,ne,me,ye)=>{r.xa("Conv",l,{format:J?"NHWC":"NCHW",auto_pad:m,dilations:[y],group:w,kernel_shape:[I],pads:U?Array.from(D.subarray(F>>>0,F+U>>>0)):[],strides:[re],w_is_const:()=>!!ee[ae>>>0],activation:De(ne),activation_params:me?Array.from(Ie.subarray(ye>>>0,ye+me>>>0)):[]})},926606:(l,m,y,w,I,U,F,re,J,ae,ne,me,ye,_,se,he)=>{r.xa("Conv",l,{format:me?"NHWC":"NCHW",auto_pad:m,dilations:[y,w],group:I,kernel_shape:[U,F],pads:re?Array.from(D.subarray(J>>>0,J+re>>>0)):[],strides:[ae,ne],w_is_const:()=>!!ee[ye>>>0],activation:De(_),activation_params:se?Array.from(Ie.subarray(he>>>0,he+se>>>0)):[]})},927008:l=>{r.Ua(l)},927042:(l,m)=>r.Va(l,m,r.Fa.Wa,r.Fa.errors),927154:l=>r.Ra(l),927187:l=>r.Ta(l),927219:(l,m,y)=>{r.La(l,m,y,!0)},927258:(l,m,y)=>{r.La(l,m,y)}};function nt(l){this.name="ExitStatus",this.message=`Program terminated with exit(${l})`,this.status=l}var Tt=l=>{for(;0<l.length;)l.shift()(r)};function Ot(l){this.Ka=l-24,this.Pa=function(m){te[this.Ka+4>>2>>>0]=m},this.Oa=function(m){te[this.Ka+8>>2>>>0]=m},this.Ma=function(m,y){this.Na(),this.Pa(m),this.Oa(y)},this.Na=function(){te[this.Ka+16>>2>>>0]=0}}var Kt=0,Xe=0,Yt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Et=(l,m,y)=>{m>>>=0;var w=m+y;for(y=m;l[y]&&!(y>=w);)++y;if(16<y-m&&l.buffer&&Yt)return Yt.decode(l.subarray(m,y));for(w="";m<y;){var I=l[m++];if(I&128){var U=l[m++]&63;if((I&224)==192)w+=String.fromCharCode((I&31)<<6|U);else{var F=l[m++]&63;I=(I&240)==224?(I&15)<<12|U<<6|F:(I&7)<<18|U<<12|F<<6|l[m++]&63,65536>I?w+=String.fromCharCode(I):(I-=65536,w+=String.fromCharCode(55296|I>>10,56320|I&1023))}}else w+=String.fromCharCode(I)}return w},De=(l,m)=>(l>>>=0)?Et(oe,l,m):"",Vt=l=>{for(var m=0,y=0;y<l.length;++y){var w=l.charCodeAt(y);127>=w?m++:2047>=w?m+=2:55296<=w&&57343>=w?(m+=4,++y):m+=3}return m},Jt=(l,m,y,w)=>{if(y>>>=0,!(0<w))return 0;var I=y;w=y+w-1;for(var U=0;U<l.length;++U){var F=l.charCodeAt(U);if(55296<=F&&57343>=F){var re=l.charCodeAt(++U);F=65536+((F&1023)<<10)|re&1023}if(127>=F){if(y>=w)break;m[y++>>>0]=F}else{if(2047>=F){if(y+1>=w)break;m[y++>>>0]=192|F>>6}else{if(65535>=F){if(y+2>=w)break;m[y++>>>0]=224|F>>12}else{if(y+3>=w)break;m[y++>>>0]=240|F>>18,m[y++>>>0]=128|F>>12&63}m[y++>>>0]=128|F>>6&63}m[y++>>>0]=128|F&63}}return m[y>>>0]=0,y-I},mt=l=>l%4===0&&(l%100!==0||l%400===0),xr=[0,31,60,91,121,152,182,213,244,274,305,335],Ut=[0,31,59,90,120,151,181,212,243,273,304,334],_t=l=>{var m=Vt(l)+1,y=Ft(m);return y&&Jt(l,oe,y,m),y},Pt=[],Xt=(l,m)=>{Pt.length=0;var y;for(m>>=2;y=oe[l++>>>0];)m+=y!=105&m,Pt.push(y==105?D[m>>>0]:Z[m++>>>1]),++m;return Pt},Ze={},Zt=()=>{if(!Nt){var l={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:i||"./this.program"},m;for(m in Ze)Ze[m]===void 0?delete l[m]:l[m]=Ze[m];var y=[];for(m in l)y.push(`${m}=${l[m]}`);Nt=y}return Nt},Nt,Ve=[null,[],[]],Qt=[31,29,31,30,31,30,31,31,30,31,30,31],Gt=[31,28,31,30,31,30,31,31,30,31,30,31];function cn(l){var m=Array(Vt(l)+1);return Jt(l,m,0,m.length),m}function le(l,m,y,w){function I(_,se,he){for(_=typeof _=="number"?_.toString():_||"";_.length<se;)_=he[0]+_;return _}function U(_,se){return I(_,se,"0")}function F(_,se){function he(Mt){return 0>Mt?-1:0<Mt?1:0}var et;return(et=he(_.getFullYear()-se.getFullYear()))===0&&(et=he(_.getMonth()-se.getMonth()))===0&&(et=he(_.getDate()-se.getDate())),et}function re(_){switch(_.getDay()){case 0:return new Date(_.getFullYear()-1,11,29);case 1:return _;case 2:return new Date(_.getFullYear(),0,3);case 3:return new Date(_.getFullYear(),0,2);case 4:return new Date(_.getFullYear(),0,1);case 5:return new Date(_.getFullYear()-1,11,31);case 6:return new Date(_.getFullYear()-1,11,30)}}function J(_){var se=_.Da;for(_=new Date(new Date(_.Ea+1900,0,1).getTime());0<se;){var he=_.getMonth(),et=(mt(_.getFullYear())?Qt:Gt)[he];if(se>et-_.getDate())se-=et-_.getDate()+1,_.setDate(1),11>he?_.setMonth(he+1):(_.setMonth(0),_.setFullYear(_.getFullYear()+1));else{_.setDate(_.getDate()+se);break}}return he=new Date(_.getFullYear()+1,0,4),se=re(new Date(_.getFullYear(),0,4)),he=re(he),0>=F(se,_)?0>=F(he,_)?_.getFullYear()+1:_.getFullYear():_.getFullYear()-1}l>>>=0,m>>>=0,y>>>=0,w>>>=0;var ae=D[w+40>>2>>>0];w={Za:D[w>>2>>>0],Ya:D[w+4>>2>>>0],Ga:D[w+8>>2>>>0],Ja:D[w+12>>2>>>0],Ha:D[w+16>>2>>>0],Ea:D[w+20>>2>>>0],Ca:D[w+24>>2>>>0],Da:D[w+28>>2>>>0],bb:D[w+32>>2>>>0],Xa:D[w+36>>2>>>0],$a:ae?De(ae):""},y=De(y),ae={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ne in ae)y=y.replace(new RegExp(ne,"g"),ae[ne]);var me="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),ye="January February March April May June July August September October November December".split(" ");ae={"%a":_=>me[_.Ca].substring(0,3),"%A":_=>me[_.Ca],"%b":_=>ye[_.Ha].substring(0,3),"%B":_=>ye[_.Ha],"%C":_=>U((_.Ea+1900)/100|0,2),"%d":_=>U(_.Ja,2),"%e":_=>I(_.Ja,2," "),"%g":_=>J(_).toString().substring(2),"%G":_=>J(_),"%H":_=>U(_.Ga,2),"%I":_=>(_=_.Ga,_==0?_=12:12<_&&(_-=12),U(_,2)),"%j":_=>{for(var se=0,he=0;he<=_.Ha-1;se+=(mt(_.Ea+1900)?Qt:Gt)[he++]);return U(_.Ja+se,3)},"%m":_=>U(_.Ha+1,2),"%M":_=>U(_.Ya,2),"%n":()=>`\n`,"%p":_=>0<=_.Ga&&12>_.Ga?"AM":"PM","%S":_=>U(_.Za,2),"%t":()=>"	","%u":_=>_.Ca||7,"%U":_=>U(Math.floor((_.Da+7-_.Ca)/7),2),"%V":_=>{var se=Math.floor((_.Da+7-(_.Ca+6)%7)/7);if(2>=(_.Ca+371-_.Da-2)%7&&se++,se)se==53&&(he=(_.Ca+371-_.Da)%7,he==4||he==3&&mt(_.Ea)||(se=1));else{se=52;var he=(_.Ca+7-_.Da-1)%7;(he==4||he==5&&mt(_.Ea%400-1))&&se++}return U(se,2)},"%w":_=>_.Ca,"%W":_=>U(Math.floor((_.Da+7-(_.Ca+6)%7)/7),2),"%y":_=>(_.Ea+1900).toString().substring(2),"%Y":_=>_.Ea+1900,"%z":_=>{_=_.Xa;var se=0<=_;return _=Math.abs(_)/60,(se?"+":"-")+("0000"+(_/60*100+_%60)).slice(-4)},"%Z":_=>_.$a,"%%":()=>"%"},y=y.replace(/%%/g,"\\0\\0");for(ne in ae)y.includes(ne)&&(y=y.replace(new RegExp(ne,"g"),ae[ne](w)));return y=y.replace(/\\0\\0/g,"%"),ne=cn(y),ne.length>m?0:(ee.set(ne,l>>>0),ne.length-1)}function ht(l){try{l()}catch(m){G(m)}}function Sr(l){var m={},y;for(y in l)(function(w){var I=l[w];m[w]=typeof I=="function"?function(){Rt.push(w);try{return I.apply(null,arguments)}finally{W||(Rt.pop()===w||G(),je&&ot===1&&Rt.length===0&&(ot=0,ht(Ht),typeof Fibers<"u"&&Fibers.cb()))}}:I})(y);return m}var ot=0,je=null,Cr=0,Rt=[],er={},tr={},Ar=0,$t=null,Ir=[];function rr(){return new Promise((l,m)=>{$t={resolve:l,reject:m}})}function Tr(){var l=Ft(65548),m=l+12;te[l>>2>>>0]=m,te[l+4>>2>>>0]=m+65536,m=Rt[0];var y=er[m];return y===void 0&&(y=Ar++,er[m]=y,tr[y]=m),D[l+8>>2>>>0]=y,l}function Or(l){if(!W){if(ot===0){var m=!1,y=!1;l((w=0)=>{if(!W&&(Cr=w,m=!0,y)){ot=2,ht(()=>Pr(je)),typeof Browser<"u"&&Browser.Ia.Qa&&Browser.Ia.resume(),w=!1;try{var I=(0,B[tr[D[je+8>>2>>>0]]])()}catch(re){I=re,w=!0}var U=!1;if(!je){var F=$t;F&&($t=null,(w?F.reject:F.resolve)(I),U=!0)}if(w&&!U)throw I}}),y=!0,m||(ot=1,je=Tr(),typeof Browser<"u"&&Browser.Ia.Qa&&Browser.Ia.pause(),ht(()=>Lt(je)))}else ot===2?(ot=0,ht(Qe),ar(je),je=null,Ir.forEach(w=>{if(!W)try{if(w(),!R)try{q=q=w=q,R||(r.onExit&&r.onExit(w),W=!0),d(w,new nt(w))}catch(I){I instanceof nt||I=="unwind"||d(1,I)}}catch(I){I instanceof nt||I=="unwind"||d(1,I)}})):G(`invalid state: ${ot}`);return Cr}}function Er(l){return Or(m=>{l().then(m)})}var gt=[],yt=void 0,nr=[];function or(l,m){if(!yt){yt=new WeakMap;var y=Te.length;if(yt)for(var w=0;w<0+y;w++){var I=w,U=gt[I];U||(I>=gt.length&&(gt.length=I+1),gt[I]=U=Te.get(I)),(I=U)&&yt.set(I,w)}}if(y=yt.get(l)||0)return y;if(nr.length)y=nr.pop();else{try{Te.grow(1)}catch(re){throw re instanceof RangeError?"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.":re}y=Te.length-1}try{w=y,Te.set(w,l),gt[w]=Te.get(w)}catch(re){if(!(re instanceof TypeError))throw re;if(typeof WebAssembly.Function=="function"){w=WebAssembly.Function,I={i:"i32",j:"i64",f:"f32",d:"f64",p:"i32"},U={parameters:[],results:m[0]=="v"?[]:[I[m[0]]]};for(var F=1;F<m.length;++F)U.parameters.push(I[m[F]]);m=new w(U,l)}else{for(w=[1],I=m.slice(0,1),m=m.slice(1),U={i:127,p:127,j:126,f:125,d:124},w.push(96),F=m.length,128>F?w.push(F):w.push(F%128|128,F>>7),F=0;F<m.length;++F)w.push(U[m[F]]);I=="v"?w.push(0):w.push(1,U[I]),m=[0,97,115,109,1,0,0,0,1],I=w.length,128>I?m.push(I):m.push(I%128|128,I>>7),m.push.apply(m,w),m.push(2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0),m=new WebAssembly.Module(new Uint8Array(m)),m=new WebAssembly.Instance(m,{e:{f:l}}).exports.f}w=y,Te.set(w,m),gt[w]=Te.get(w)}return yt.set(l,y),y}var _r={n:function(l,m,y){return Er(async()=>{await r.Sa(l,m,y)})},a:function(l,m,y){throw l>>>=0,new Ot(l).Ma(m>>>0,y>>>0),Kt=l,Xe++,Kt},g:function(){return 0},J:function(){},z:function(){},B:function(){},L:function(){return 0},H:function(){},C:function(){},F:function(){},m:function(){},A:function(){},x:function(){},I:function(){},y:function(){},M:()=>!0,q:function(l,m,y){l=m+2097152>>>0<4194305-!!l?(l>>>0)+4294967296*m:NaN,y>>>=0,l=new Date(1e3*l),D[y>>2>>>0]=l.getUTCSeconds(),D[y+4>>2>>>0]=l.getUTCMinutes(),D[y+8>>2>>>0]=l.getUTCHours(),D[y+12>>2>>>0]=l.getUTCDate(),D[y+16>>2>>>0]=l.getUTCMonth(),D[y+20>>2>>>0]=l.getUTCFullYear()-1900,D[y+24>>2>>>0]=l.getUTCDay(),D[y+28>>2>>>0]=(l.getTime()-Date.UTC(l.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(l,m,y){l=m+2097152>>>0<4194305-!!l?(l>>>0)+4294967296*m:NaN,y>>>=0,l=new Date(1e3*l),D[y>>2>>>0]=l.getSeconds(),D[y+4>>2>>>0]=l.getMinutes(),D[y+8>>2>>>0]=l.getHours(),D[y+12>>2>>>0]=l.getDate(),D[y+16>>2>>>0]=l.getMonth(),D[y+20>>2>>>0]=l.getFullYear()-1900,D[y+24>>2>>>0]=l.getDay(),D[y+28>>2>>>0]=(mt(l.getFullYear())?xr:Ut)[l.getMonth()]+l.getDate()-1|0,D[y+36>>2>>>0]=-(60*l.getTimezoneOffset()),m=new Date(l.getFullYear(),6,1).getTimezoneOffset();var w=new Date(l.getFullYear(),0,1).getTimezoneOffset();D[y+32>>2>>>0]=(m!=w&&l.getTimezoneOffset()==Math.min(w,m))|0},s:function(l){l>>>=0;var m=new Date(D[l+20>>2>>>0]+1900,D[l+16>>2>>>0],D[l+12>>2>>>0],D[l+8>>2>>>0],D[l+4>>2>>>0],D[l>>2>>>0],0),y=D[l+32>>2>>>0],w=m.getTimezoneOffset(),I=new Date(m.getFullYear(),6,1).getTimezoneOffset(),U=new Date(m.getFullYear(),0,1).getTimezoneOffset(),F=Math.min(U,I);return 0>y?D[l+32>>2>>>0]=+(I!=U&&F==w):0<y!=(F==w)&&(I=Math.max(U,I),m.setTime(m.getTime()+6e4*((0<y?F:I)-w))),D[l+24>>2>>>0]=m.getDay(),D[l+28>>2>>>0]=(mt(m.getFullYear())?xr:Ut)[m.getMonth()]+m.getDate()-1|0,D[l>>2>>>0]=m.getSeconds(),D[l+4>>2>>>0]=m.getMinutes(),D[l+8>>2>>>0]=m.getHours(),D[l+12>>2>>>0]=m.getDate(),D[l+16>>2>>>0]=m.getMonth(),D[l+20>>2>>>0]=m.getYear(),l=m.getTime()/1e3,ir((He=l,1<=+Math.abs(He)?0<He?+Math.floor(He/4294967296)>>>0:~~+Math.ceil((He-+(~~He>>>0))/4294967296)>>>0:0)),l>>>0},o:function(){return-52},p:function(){},v:function(l,m,y){function w(J){return(J=J.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?J[1]:"GMT"}y>>>=0;var I=new Date().getFullYear(),U=new Date(I,0,1),F=new Date(I,6,1);I=U.getTimezoneOffset();var re=F.getTimezoneOffset();te[l>>>0>>2>>>0]=60*Math.max(I,re),D[m>>>0>>2>>>0]=+(I!=re),l=w(U),m=w(F),l=_t(l),m=_t(m),re<I?(te[y>>2>>>0]=l,te[y+4>>2>>>0]=m):(te[y>>2>>>0]=m,te[y+4>>2>>>0]=l)},e:()=>{G("")},b:function(l,m,y){return l>>>=0,m=Xt(m>>>0,y>>>0),zt[l].apply(null,m)},j:function(l,m,y){return l>>>=0,m=Xt(m>>>0,y>>>0),zt[l].apply(null,m)},h:function(){return Date.now()},w:function(){return 4294901760},c:()=>performance.now(),K:function(l,m,y){return m>>>=0,oe.copyWithin(l>>>0>>>0,m>>>0,m+(y>>>0)>>>0)},u:function(l){l>>>=0;var m=oe.length;if(4294901760<l)return!1;for(var y=1;4>=y;y*=2){var w=m*(1+.2/y);w=Math.min(w,l+100663296);var I=Math;w=Math.max(l,w);e:{I=I.min.call(I,4294901760,w+(65536-w%65536)%65536)-V.buffer.byteLength+65535>>>16;try{V.grow(I),ve();var U=1;break e}catch{}U=void 0}if(U)return!0}return!1},D:function(l,m){l>>>=0,m>>>=0;var y=0;return Zt().forEach(function(w,I){var U=m+y;for(I=te[l+4*I>>2>>>0]=U,U=0;U<w.length;++U)ee[I++>>0>>>0]=w.charCodeAt(U);ee[I>>0>>>0]=0,y+=w.length+1}),0},E:function(l,m){l>>>=0,m>>>=0;var y=Zt();te[l>>2>>>0]=y.length;var w=0;return y.forEach(function(I){w+=I.length+1}),te[m>>2>>>0]=w,0},f:()=>52,l:function(){return 52},t:function(){return 70},k:function(l,m,y,w){m>>>=0,y>>>=0,w>>>=0;for(var I=0,U=0;U<y;U++){var F=te[m>>2>>>0],re=te[m+4>>2>>>0];m+=8;for(var J=0;J<re;J++){var ae=oe[F+J>>>0],ne=Ve[l];ae===0||ae===10?((l===1?k:O)(Et(ne,0)),ne.length=0):ne.push(ae)}I+=re}return te[w>>2>>>0]=I,0},G:le,d:function(l,m,y,w){return le(l>>>0,m>>>0,y>>>0,w>>>0)},i:function(l,m,y,w){let I=Te.length;l=new Uint8Array(oe.slice(l+m,l+y));try{var U=new WebAssembly.Module(l),F=new WebAssembly.Instance(U,{env:{memory:V}}),re;for(re in F.exports)or(F.exports[re]);return I<Te.length?I:w}catch(J){return console.log(J),w}}};(function(){function l(y){if(y=y.exports,y=Sr(y),B=y=dn(y),V=B.N,ve(),Te=B.sa,Be.unshift(B.O),qe--,r.monitorRunDependencies&&r.monitorRunDependencies(qe),qe==0&&(Ke!==null&&(clearInterval(Ke),Ke=null),Ye)){var w=Ye;Ye=null,w()}return y}var m={a:_r};if(qe++,r.monitorRunDependencies&&r.monitorRunDependencies(qe),r.instantiateWasm)try{return r.instantiateWasm(m,l)}catch(y){O("Module.instantiateWasm callback failed with error: "+y),a(y)}return vt(m,function(y){l(y.instance)}).catch(a),{}})(),r._OrtInit=(l,m)=>(r._OrtInit=B.P)(l,m),r._OrtGetLastError=(l,m)=>(r._OrtGetLastError=B.Q)(l,m),r._OrtCreateSessionOptions=(l,m,y,w,I,U,F,re,J,ae)=>(r._OrtCreateSessionOptions=B.R)(l,m,y,w,I,U,F,re,J,ae),r._OrtAppendExecutionProvider=(l,m)=>(r._OrtAppendExecutionProvider=B.S)(l,m),r._OrtAddFreeDimensionOverride=(l,m,y)=>(r._OrtAddFreeDimensionOverride=B.T)(l,m,y),r._OrtAddSessionConfigEntry=(l,m,y)=>(r._OrtAddSessionConfigEntry=B.U)(l,m,y),r._OrtReleaseSessionOptions=l=>(r._OrtReleaseSessionOptions=B.V)(l),r._OrtCreateSession=(l,m,y)=>(r._OrtCreateSession=B.W)(l,m,y),r._OrtReleaseSession=l=>(r._OrtReleaseSession=B.X)(l),r._OrtGetInputOutputCount=(l,m,y)=>(r._OrtGetInputOutputCount=B.Y)(l,m,y),r._OrtGetInputName=(l,m)=>(r._OrtGetInputName=B.Z)(l,m),r._OrtGetOutputName=(l,m)=>(r._OrtGetOutputName=B._)(l,m),r._OrtFree=l=>(r._OrtFree=B.$)(l),r._OrtCreateTensor=(l,m,y,w,I,U)=>(r._OrtCreateTensor=B.aa)(l,m,y,w,I,U),r._OrtGetTensorData=(l,m,y,w,I)=>(r._OrtGetTensorData=B.ba)(l,m,y,w,I),r._OrtReleaseTensor=l=>(r._OrtReleaseTensor=B.ca)(l),r._OrtCreateRunOptions=(l,m,y,w)=>(r._OrtCreateRunOptions=B.da)(l,m,y,w),r._OrtAddRunConfigEntry=(l,m,y)=>(r._OrtAddRunConfigEntry=B.ea)(l,m,y),r._OrtReleaseRunOptions=l=>(r._OrtReleaseRunOptions=B.fa)(l),r._OrtCreateBinding=l=>(r._OrtCreateBinding=B.ga)(l),r._OrtBindInput=(l,m,y)=>(r._OrtBindInput=B.ha)(l,m,y),r._OrtBindOutput=(l,m,y,w)=>(r._OrtBindOutput=B.ia)(l,m,y,w),r._OrtClearBoundOutputs=l=>(r._OrtClearBoundOutputs=B.ja)(l),r._OrtReleaseBinding=l=>(r._OrtReleaseBinding=B.ka)(l),r._OrtRunWithBinding=(l,m,y,w,I)=>(r._OrtRunWithBinding=B.la)(l,m,y,w,I),r._OrtRun=(l,m,y,w,I,U,F,re)=>(r._OrtRun=B.ma)(l,m,y,w,I,U,F,re),r._OrtEndProfiling=l=>(r._OrtEndProfiling=B.na)(l),r._JsepOutput=(l,m,y)=>(r._JsepOutput=B.oa)(l,m,y),r._JsepGetNodeName=l=>(r._JsepGetNodeName=B.pa)(l);var Ft=r._malloc=l=>(Ft=r._malloc=B.qa)(l),ar=r._free=l=>(ar=r._free=B.ra)(l),ir=l=>(ir=B.ta)(l),sr=()=>(sr=B.ua)(),ur=l=>(ur=B.va)(l),Fe=l=>(Fe=B.wa)(l),Lt=l=>(Lt=B.ya)(l),Ht=()=>(Ht=B.za)(),Pr=l=>(Pr=B.Aa)(l),Qe=()=>(Qe=B.Ba)();r.___start_em_js=927291,r.___stop_em_js=928064;function dn(l){l=Object.assign({},l);var m=w=>()=>w()>>>0,y=w=>I=>w(I)>>>0;return l.__errno_location=m(l.__errno_location),l.malloc=y(l.malloc),l.stackSave=m(l.stackSave),l.stackAlloc=y(l.stackAlloc),l}r.stackAlloc=Fe,r.stackSave=sr,r.stackRestore=ur,r.addFunction=or,r.UTF8ToString=De,r.stringToUTF8=(l,m,y)=>Jt(l,oe,m,y),r.lengthBytesUTF8=Vt;var Le;Ye=function l(){Le||lr(),Le||(Ye=l)};function lr(){function l(){if(!Le&&(Le=!0,r.calledRun=!0,!W)){if(Tt(Be),o(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),r.postRun)for(typeof r.postRun=="function"&&(r.postRun=[r.postRun]);r.postRun.length;){var m=r.postRun.shift();Se.unshift(m)}Tt(Se)}}if(!(0<qe)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;)Ue();Tt(be),0<qe||(r.setStatus?(r.setStatus("Running..."),setTimeout(function(){setTimeout(function(){r.setStatus("")},1),l()},1)):l())}}if(r.preInit)for(typeof r.preInit=="function"&&(r.preInit=[r.preInit]);0<r.preInit.length;)r.preInit.pop()();return lr(),t.ready}})();typeof No=="object"&&typeof On=="object"?On.exports=Uo:typeof define=="function"&&define.amd&&define([],()=>Uo)});var Fo=dr(()=>{});var Lo=dr(()=>{});var Ho={};Vr(Ho,{cpus:()=>hl});var hl,jo=K(()=>{hl=void 0});var Yo=dr((Ko,En)=>{"use strict";var qo=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){function r(){return ve.buffer!=Se.buffer&&Ce(),Se}function o(){return ve.buffer!=Se.buffer&&Ce(),Ue}function a(){return ve.buffer!=Se.buffer&&Ce(),qe}function u(){return ve.buffer!=Se.buffer&&Ce(),Ke}function i(){return ve.buffer!=Se.buffer&&Ce(),Ye}function d(){return ve.buffer!=Se.buffer&&Ce(),G}function f(){return ve.buffer!=Se.buffer&&Ce(),pe}function h(){return ve.buffer!=Se.buffer&&Ce(),Ge}var c=t,C,b;c.ready=new Promise((n,s)=>{C=n,b=s}),c.jsepInit=(n,s,p,g,v,T,M,N)=>{c.oc=n,c.Wb=s,c.Yb=p,c.Lb=g,c.Xb=v,c.cb=T,c.Zb=M,c.$b=N,s=(L,j,Q)=>(...ce)=>{let fe=at,E=j?.();ce=L(...ce);let ie=j?.();return E!==ie&&(L=ie,Q(E),j=Q=null),at!=fe?tl():ce},p=L=>async(...j)=>{try{if(c.Cb)throw Error("Session already started");let Q=c.Cb={cc:j[0],errors:[]},ce=await L(...j);if(c.Cb!==Q)throw Error("Session mismatch");n.flush();let fe=Q.errors;if(0<fe.length){let E=await Promise.all(fe);if(E=E.filter(ie=>ie),0<E.length)throw Error(E.join(`\n`))}return ce}finally{c.Cb=null}},c._OrtRun=p(s(c._OrtRun,()=>c._OrtRun,L=>c._OrtRun=L)),c._OrtRunWithBinding=p(s(c._OrtRunWithBinding,()=>c._OrtRunWithBinding,L=>c._OrtRunWithBinding=L)),c._OrtBindInput=s(c._OrtBindInput,()=>c._OrtBindInput,L=>c._OrtBindInput=L),c.jsepRegisterBuffer=(L,j,Q,ce)=>n.registerBuffer(L,j,Q,ce),c.jsepUnregisterBuffers=L=>{n.unregisterBuffers(L)},c.jsepGetBuffer=L=>n.getBuffer(L),c.jsepCreateDownloader=(L,j,Q)=>n.createDownloader(L,j,Q)};var $=Object.assign({},c),S="./this.program",x=(n,s)=>{throw s},A=typeof window=="object",k=typeof importScripts=="function",O=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",P=c.ENVIRONMENT_IS_PTHREAD||!1,R="";function V(n){return c.locateFile?c.locateFile(n,R):R+n}var B,W,q;if(O){var ee=(An(),qt(Cn)),oe=(Tn(),qt(In));R=k?oe.dirname(R)+"/":__dirname+"/",B=(s,p)=>(s=Et(s)?new URL(s):oe.normalize(s),ee.readFileSync(s,p?void 0:"utf8")),q=s=>(s=B(s,!0),s.buffer||(s=new Uint8Array(s)),s),W=(s,p,g,v=!0)=>{s=Et(s)?new URL(s):oe.normalize(s),ee.readFile(s,v?void 0:"utf8",(T,M)=>{T?g(T):p(v?M.buffer:M)})},!c.thisProgram&&1<process.argv.length&&(S=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),x=(s,p)=>{throw process.exitCode=s,p},c.inspect=()=>"[Emscripten Module object]";let n;try{n=Fo()}catch(s){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),s}global.Worker=n.Worker}else(A||k)&&(k?R=self.location.href:typeof document<"u"&&document.currentScript&&(R=document.currentScript.src),typeof e<"u"&&e&&(R=e),R.indexOf("blob:")!==0?R=R.substr(0,R.replace(/[?#].*/,"").lastIndexOf("/")+1):R="",O||(B=n=>{var s=new XMLHttpRequest;return s.open("GET",n,!1),s.send(null),s.responseText},k&&(q=n=>{var s=new XMLHttpRequest;return s.open("GET",n,!1),s.responseType="arraybuffer",s.send(null),new Uint8Array(s.response)}),W=(n,s,p)=>{var g=new XMLHttpRequest;g.open("GET",n,!0),g.responseType="arraybuffer",g.onload=()=>{g.status==200||g.status==0&&g.response?s(g.response):p()},g.onerror=p,g.send(null)}));O&&typeof performance>"u"&&(global.performance=Lo().performance);var D=console.log.bind(console),te=console.error.bind(console);O&&(D=(...n)=>ee.writeSync(1,n.join(" ")+`\n`),te=(...n)=>ee.writeSync(2,n.join(" ")+`\n`));var Ie=D,Z=te;Object.assign(c,$),$=null,typeof WebAssembly!="object"&&Xe("no native wasm support detected");var ve,Te,be=!1,Be,Se,Ue,qe,Ke,Ye,G,pe,de,Ne,Ge;function Ce(){var n=ve.buffer;c.HEAP8=Se=new Int8Array(n),c.HEAP16=qe=new Int16Array(n),c.HEAPU8=Ue=new Uint8Array(n),c.HEAPU16=Ke=new Uint16Array(n),c.HEAP32=Ye=new Int32Array(n),c.HEAPU32=G=new Uint32Array(n),c.HEAPF32=pe=new Float32Array(n),c.HEAPF64=Ge=new Float64Array(n),c.HEAP64=de=new BigInt64Array(n),c.HEAPU64=Ne=new BigUint64Array(n)}var Pe=16777216;if(5242880<=Pe||Xe("INITIAL_MEMORY should be larger than STACK_SIZE, was "+Pe+"! (STACK_SIZE=5242880)"),P)ve=c.wasmMemory;else if(ve=new WebAssembly.Memory({initial:Pe/65536,maximum:65536,shared:!0}),!(ve.buffer instanceof SharedArrayBuffer))throw Z("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),O&&Z("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Ce(),Pe=ve.buffer.byteLength;var vt=[],He=[],zt=[],nt=0,Tt=null,Ot=null;function Kt(){if(nt--,nt==0&&(Tt!==null&&(clearInterval(Tt),Tt=null),Ot)){var n=Ot;Ot=null,n()}}function Xe(n){throw n="Aborted("+n+")",Z(n),be=!0,Be=1,n=new WebAssembly.RuntimeError(n+". Build with -sASSERTIONS for more info."),b(n),n}var Yt=n=>n.startsWith("data:application/octet-stream;base64,"),Et=n=>n.startsWith("file://"),De;De="ort-wasm-simd-threaded.wasm",Yt(De)||(De=V(De));function Vt(n){if(q)return q(n);throw"both async and sync fetching of the wasm failed"}function Jt(n){if(A||k){if(typeof fetch=="function"&&!Et(n))return fetch(n,{credentials:"same-origin"}).then(s=>{if(!s.ok)throw"failed to load wasm binary file at \'"+n+"\'";return s.arrayBuffer()}).catch(()=>Vt(n));if(W)return new Promise((s,p)=>{W(n,g=>s(new Uint8Array(g)),p)})}return Promise.resolve().then(()=>Vt(n))}function mt(n,s,p){return Jt(n).then(g=>WebAssembly.instantiate(g,s)).then(g=>g).then(p,g=>{Z(`failed to asynchronously prepare wasm: ${g}`),Xe(g)})}function xr(n,s){var p=De;return typeof WebAssembly.instantiateStreaming!="function"||Yt(p)||Et(p)||O||typeof fetch!="function"?mt(p,n,s):fetch(p,{credentials:"same-origin"}).then(g=>WebAssembly.instantiateStreaming(g,n).then(s,function(v){return Z(`wasm streaming compile failed: ${v}`),Z("falling back to ArrayBuffer instantiation"),mt(p,n,s)}))}var Ut={1441368:n=>{c.cb("Abs",n,void 0)},1441419:n=>{c.cb("Neg",n,void 0)},1441470:n=>{c.cb("Floor",n,void 0)},1441523:n=>{c.cb("Ceil",n,void 0)},1441575:n=>{c.cb("Reciprocal",n,void 0)},1441633:n=>{c.cb("Sqrt",n,void 0)},1441685:n=>{c.cb("Exp",n,void 0)},1441736:n=>{c.cb("Erf",n,void 0)},1441787:n=>{c.cb("Sigmoid",n,void 0)},1441842:n=>{c.cb("Log",n,void 0)},1441893:n=>{c.cb("Sin",n,void 0)},1441944:n=>{c.cb("Cos",n,void 0)},1441995:n=>{c.cb("Tan",n,void 0)},1442046:n=>{c.cb("Asin",n,void 0)},1442098:n=>{c.cb("Acos",n,void 0)},1442150:n=>{c.cb("Atan",n,void 0)},1442202:n=>{c.cb("Sinh",n,void 0)},1442254:n=>{c.cb("Cosh",n,void 0)},1442306:n=>{c.cb("Asinh",n,void 0)},1442359:n=>{c.cb("Acosh",n,void 0)},1442412:n=>{c.cb("Atanh",n,void 0)},1442465:n=>{c.cb("Tanh",n,void 0)},1442517:n=>{c.cb("Not",n,void 0)},1442568:(n,s,p)=>{c.cb("ClipV10",n,{min:s,max:p})},1442640:n=>{c.cb("Clip",n,void 0)},1442692:(n,s)=>{c.cb("Elu",n,{alpha:s})},1442750:n=>{c.cb("Relu",n,void 0)},1442802:(n,s)=>{c.cb("LeakyRelu",n,{alpha:s})},1442866:(n,s)=>{c.cb("ThresholdedRelu",n,{alpha:s})},1442936:n=>{c.Zb(n)},1442970:(n,s)=>c.$b(n,s,c.Cb.cc,c.Cb.errors),1443082:(n,s)=>{c.cb("Cast",n,{to:s})},1443140:n=>{c.cb("Add",n,void 0)},1443191:n=>{c.cb("Sub",n,void 0)},1443242:n=>{c.cb("Mul",n,void 0)},1443293:n=>{c.cb("Div",n,void 0)},1443344:n=>{c.cb("Pow",n,void 0)},1443395:n=>{c.cb("Equal",n,void 0)},1443448:n=>{c.cb("Greater",n,void 0)},1443503:n=>{c.cb("GreaterOrEqual",n,void 0)},1443565:n=>{c.cb("Less",n,void 0)},1443617:n=>{c.cb("LessOrEqual",n,void 0)},1443676:(n,s,p,g,v)=>{c.cb("ReduceMean",n,{keepDims:!!s,noopWithEmptyAxes:!!p,axes:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[]})},1443840:(n,s,p,g,v)=>{c.cb("ReduceMax",n,{keepDims:!!s,noopWithEmptyAxes:!!p,axes:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[]})},1444003:(n,s,p,g,v)=>{c.cb("ReduceMin",n,{keepDims:!!s,noopWithEmptyAxes:!!p,axes:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[]})},1444166:(n,s,p,g,v)=>{c.cb("ReduceProd",n,{keepDims:!!s,noopWithEmptyAxes:!!p,axes:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[]})},1444330:(n,s,p,g,v)=>{c.cb("ReduceSum",n,{keepDims:!!s,noopWithEmptyAxes:!!p,axes:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[]})},1444493:(n,s,p,g,v)=>{c.cb("ReduceL1",n,{keepDims:!!s,noopWithEmptyAxes:!!p,axes:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[]})},1444655:(n,s,p,g,v)=>{c.cb("ReduceL2",n,{keepDims:!!s,noopWithEmptyAxes:!!p,axes:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[]})},1444817:(n,s,p,g,v)=>{c.cb("ReduceLogSum",n,{keepDims:!!s,noopWithEmptyAxes:!!p,axes:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[]})},1444983:(n,s,p,g,v)=>{c.cb("ReduceSumSquare",n,{keepDims:!!s,noopWithEmptyAxes:!!p,axes:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[]})},1445152:(n,s,p,g,v)=>{c.cb("ReduceLogSumExp",n,{keepDims:!!s,noopWithEmptyAxes:!!p,axes:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[]})},1445321:n=>{c.cb("Where",n,void 0)},1445374:(n,s,p)=>{c.cb("Transpose",n,{perm:s?Array.from(i().subarray(p>>>0,p+s>>>0)):[]})},1445487:(n,s,p,g,v,T,M,N,L,j,Q,ce,fe)=>{c.cb("Conv",n,{format:L?"NHWC":"NCHW",auto_pad:s,dilations:[p],group:g,kernel_shape:[v],pads:T?Array.from(i().subarray(M>>>0,M+T>>>0)):[],strides:[N],w_is_const:()=>!!r()[j>>>0],activation:Ve(Q),activation_params:ce?Array.from(f().subarray(fe>>>0,fe+ce>>>0)):[]})},1445868:(n,s,p,g,v,T,M,N,L,j,Q,ce,fe,E,ie,we)=>{c.cb("Conv",n,{format:ce?"NHWC":"NCHW",auto_pad:s,dilations:[p,g],group:v,kernel_shape:[T,M],pads:N?Array.from(i().subarray(L>>>0,L+N>>>0)):[],strides:[j,Q],w_is_const:()=>!!r()[fe>>>0],activation:Ve(E),activation_params:ie?Array.from(f().subarray(we>>>0,we+ie>>>0)):[]})},1446270:(n,s,p,g,v,T,M,N,L,j,Q,ce,fe,E,ie)=>{c.cb("ConvTranspose",n,{format:L?"NHWC":"NCHW",autoPad:s,dilations:[p],group:g,kernel_shape:[v],pads:[T,M],strides:[N],wIsConst:()=>!!r()[j>>>0],outputPadding:Q?Array.from(i().subarray(ce>>>0,ce+Q>>>0)):[],outputShape:fe?Array.from(i().subarray(E>>>0,E+fe>>>0)):[],activation:Ve(ie)})},1446684:(n,s,p,g,v,T,M,N,L,j,Q,ce,fe,E)=>{c.cb("ConvTranspose",n,{format:N?"NHWC":"NCHW",autoPad:s,dilations:Array.from(i().subarray(p>>>0,p+2>>>0)),group:g,kernelShape:Array.from(i().subarray(v>>>0,v+2>>>0)),pads:Array.from(i().subarray(T>>>0,T+4>>>0)),strides:Array.from(i().subarray(M>>>0,M+2>>>0)),wIsConst:()=>!!r()[L>>>0],outputPadding:0<j?Array.from(i().subarray(Q>>>0,Q+j>>>0)):[],outputShape:0<ce?Array.from(i().subarray(fe>>>0,fe+ce>>>0)):[],activation:Ve(E)})},1447241:(n,s,p,g,v,T,M,N,L,j,Q,ce,fe,E,ie)=>{c.cb("ConvTranspose",n,{format:L?"NHWC":"NCHW",autoPad:s,dilations:[p],group:g,kernel_shape:[v],pads:[T,M],strides:[N],wIsConst:()=>!!r()[j>>>0],outputPadding:Q?Array.from(i().subarray(ce>>>0,ce+Q>>>0)):[],outputShape:fe?Array.from(i().subarray(E>>>0,E+fe>>>0)):[],activation:Ve(ie)})},1447655:(n,s,p,g,v,T,M,N,L,j,Q,ce,fe,E)=>{c.cb("ConvTranspose",n,{format:N?"NHWC":"NCHW",autoPad:s,dilations:Array.from(i().subarray(p>>>0,p+2>>>0)),group:g,kernelShape:Array.from(i().subarray(v>>>0,v+2>>>0)),pads:Array.from(i().subarray(T>>>0,T+4>>>0)),strides:Array.from(i().subarray(M>>>0,M+2>>>0)),wIsConst:()=>!!r()[L>>>0],outputPadding:0<j?Array.from(i().subarray(Q>>>0,Q+j>>>0)):[],outputShape:0<ce?Array.from(i().subarray(fe>>>0,fe+ce>>>0)):[],activation:Ve(E)})},1448212:(n,s)=>{c.cb("GlobalAveragePool",n,{format:s?"NHWC":"NCHW"})},1448303:(n,s,p,g,v,T,M,N,L,j,Q,ce,fe,E,ie,we)=>{c.cb("AveragePool",n,{format:we?"NHWC":"NCHW",auto_pad:s,ceil_mode:p,count_include_pad:g,storage_order:v,dilations:[T,M],kernel_shape:[N,L],pads:[j,Q,ce,fe],strides:[E,ie]})},1448587:(n,s)=>{c.cb("GlobalAveragePool",n,{format:s?"NHWC":"NCHW"})},1448678:(n,s,p,g,v,T,M,N,L,j,Q,ce,fe,E,ie,we)=>{c.cb("AveragePool",n,{format:we?"NHWC":"NCHW",auto_pad:s,ceil_mode:p,count_include_pad:g,storage_order:v,dilations:[T,M],kernel_shape:[N,L],pads:[j,Q,ce,fe],strides:[E,ie]})},1448962:(n,s)=>{c.cb("GlobalMaxPool",n,{format:s?"NHWC":"NCHW"})},1449049:(n,s,p,g,v,T,M,N,L,j,Q,ce,fe,E,ie,we)=>{c.cb("MaxPool",n,{format:we?"NHWC":"NCHW",auto_pad:s,ceil_mode:p,count_include_pad:g,storage_order:v,dilations:[T,M],kernel_shape:[N,L],pads:[j,Q,ce,fe],strides:[E,ie]})},1449329:(n,s)=>{c.cb("GlobalMaxPool",n,{format:s?"NHWC":"NCHW"})},1449416:(n,s,p,g,v,T,M,N,L,j,Q,ce,fe,E,ie,we)=>{c.cb("MaxPool",n,{format:we?"NHWC":"NCHW",auto_pad:s,ceil_mode:p,count_include_pad:g,storage_order:v,dilations:[T,M],kernel_shape:[N,L],pads:[j,Q,ce,fe],strides:[E,ie]})},1449696:(n,s,p,g,v)=>{c.cb("Gemm",n,{alpha:s,beta:p,transA:g,transB:v})},1449800:n=>{c.cb("MatMul",n,void 0)},1449854:(n,s,p,g)=>{c.cb("ArgMax",n,{keepDims:!!s,selectLastIndex:!!p,axis:g})},1449962:(n,s,p,g)=>{c.cb("ArgMin",n,{keepDims:!!s,selectLastIndex:!!p,axis:g})},1450070:(n,s)=>{c.cb("Softmax",n,{axis:s})},1450133:(n,s)=>{c.cb("Concat",n,{axis:s})},1450193:(n,s,p,g,v)=>{c.cb("Split",n,{axis:s,numOutputs:p,splitSizes:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[]})},1450338:n=>{c.cb("Expand",n,void 0)},1450392:(n,s)=>{c.cb("Gather",n,{axis:Number(s)})},1450463:(n,s)=>{c.cb("GatherElements",n,{axis:Number(s)})},1450542:(n,s,p,g,v,T,M,N,L,j,Q)=>{c.cb("Resize",n,{antialias:s,axes:p?Array.from(i().subarray(g>>>0,g+p>>>0)):[],coordinateTransformMode:Ve(v),cubicCoeffA:T,excludeOutside:M,extrapolationValue:N,keepAspectRatioPolicy:Ve(L),mode:Ve(j),nearestMode:Ve(Q)})},1450893:(n,s,p,g,v,T,M)=>{c.cb("Slice",n,{starts:s?Array.from(i().subarray(p>>>0,p+s>>>0)):[],ends:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[],axes:T?Array.from(i().subarray(M>>>0,M+T>>>0)):[]})},1451124:n=>{c.cb("Tile",n,void 0)},1451176:(n,s,p)=>{c.cb("LayerNormalization",n,{axis:Number(s),epsilon:Number(p)})},1451283:(n,s,p)=>{c.cb("InstanceNormalization",n,{epsilon:s,format:p?"NHWC":"NCHW"})},1451397:(n,s,p)=>{c.cb("InstanceNormalization",n,{epsilon:s,format:p?"NHWC":"NCHW"})},1451511:n=>{c.cb("Range",n,void 0)},1451564:(n,s)=>{c.cb("Einsum",n,{equation:Ve(s)})},1451645:(n,s,p,g,v)=>{c.cb("Pad",n,{mode:s,value:p,pads:g?Array.from(i().subarray(v>>>0,v+g>>>0)):[]})},1451777:n=>{c.cb("Gelu",n,void 0)},1451829:n=>{c.cb("BiasAdd",n,void 0)},1451884:n=>{c.cb("BiasSplitGelu",n,void 0)},1451945:(n,s)=>{c.cb("SkipLayerNormalization",n,{epsilon:s})},1452026:n=>c.Wb(n),1452059:n=>c.Yb(n),1452091:(n,s,p)=>{c.Lb(n,s,p,!0)},1452130:(n,s,p)=>{c.Lb(n,s,p)}};function _t(n){this.name="ExitStatus",this.message=`Program terminated with exit(${n})`,this.status=n}var Pt=n=>{n.terminate(),n.onmessage=()=>{}},Xt=n=>{if(le.zb.length==0){var s=V("ort-wasm-simd-threaded.worker.js");s=new Worker(s),le.zb.push(s),le.ac(le.zb[0])}if(s=le.zb.pop(),!s)return 6;le.wb.push(s),le.nb[n.vb]=s,s.vb=n.vb;var p={cmd:"run",start_routine:n.dc,arg:n.Rb,pthread_ptr:n.vb};return O&&s.unref(),s.postMessage(p,n.kc),0},Ze=0,Zt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Nt=(n,s,p)=>{s>>>=0;var g=s+p;for(p=s;n[p]&&!(p>=g);)++p;if(16<p-s&&n.buffer&&Zt)return Zt.decode(n.buffer instanceof SharedArrayBuffer?n.slice(s,p):n.subarray(s,p));for(g="";s<p;){var v=n[s++];if(v&128){var T=n[s++]&63;if((v&224)==192)g+=String.fromCharCode((v&31)<<6|T);else{var M=n[s++]&63;v=(v&240)==224?(v&15)<<12|T<<6|M:(v&7)<<18|T<<12|M<<6|n[s++]&63,65536>v?g+=String.fromCharCode(v):(v-=65536,g+=String.fromCharCode(55296|v>>10,56320|v&1023))}}else g+=String.fromCharCode(v)}return g},Ve=(n,s)=>(n>>>=0)?Nt(o(),n,s):"";function Qt(n){if(P)return Oe(0,1,n);Be=n,0<Ze||(le.ec(),be=!0),x(n,new _t(n))}var Gt=n=>{if(Be=n,P)throw Sr(n),"unwind";Qt(n)};function cn(){vt.unshift(()=>{nt++,Kt()})}var le={zb:[],wb:[],Qb:[],nb:{},Fb(){P?(le.receiveObjectTransfer=le.bc,le.threadInitTLS=le.Pb,le.setExitStatus=le.Ob):cn()},Ob:n=>{Be=n},pc:["$terminateWorker"],ec:()=>{for(var n of le.wb)Pt(n);for(n of le.zb)Pt(n);le.zb=[],le.wb=[],le.nb=[]},Nb:n=>{var s=n.vb;delete le.nb[s],le.zb.push(n),le.wb.splice(le.wb.indexOf(n),1),n.vb=0,wn(s)},bc(){},Pb(){le.Qb.forEach(n=>n())},ac:n=>new Promise(s=>{n.onmessage=T=>{T=T.data;var M=T.cmd;if(T.targetThread&&T.targetThread!=Dr()){var N=le.nb[T.targetThread];N?N.postMessage(T,T.transferList):Z(`Internal error! Worker sent a message "${M}" to target pthread ${T.targetThread}, but that thread no longer exists!`)}else M==="checkMailbox"?Mt():M==="spawnThread"?Xt(T):M==="cleanupThread"?((T=le.nb[T.thread])||Xe(),le.Nb(T)):M==="killThread"?(T=T.thread,M=le.nb[T],delete le.nb[T],Pt(M),wn(T),le.wb.splice(le.wb.indexOf(M),1),M.vb=0):M==="cancelThread"?le.nb[T.thread].postMessage({cmd:"cancel"}):M==="loaded"?(n.loaded=!0,s(n)):M==="alert"?alert(`Thread ${T.threadId}: ${T.text}`):T.target==="setimmediate"?n.postMessage(T):M==="callHandler"?c[T.handler](...T.args):M&&Z(`worker sent an unknown command ${M}`)},n.onerror=T=>{throw Z(`worker sent an error! ${T.filename}:${T.lineno}: ${T.message}`),T},O&&(n.on("message",T=>n.onmessage({data:T})),n.on("error",T=>n.onerror(T)));var p=[],g=[],v;for(v of g)c.hasOwnProperty(v)&&p.push(v);n.postMessage({cmd:"load",handlers:p,urlOrBlob:c.mainScriptUrlOrBlob||e,wasmMemory:ve,wasmModule:Te})})};c.PThread=le;var ht=n=>{for(;0<n.length;)n.shift()(c)};c.establishStackSpace=()=>{var n=Dr(),s=d()[n+52>>>2>>>0];n=d()[n+56>>>2>>>0],Ro(s,s-n),Wr(s)};function Sr(n){if(P)return Oe(1,0,n);Gt(n)}c.invokeEntryPoint=(n,s)=>{n=Mo.apply(null,[n,s]),0<Ze?le.Ob(n):vn(n)};function ot(n){this.Ab=n-24,this.lc=function(s){d()[this.Ab+4>>>2>>>0]=s},this.Ib=function(s){d()[this.Ab+8>>>2>>>0]=s},this.Fb=function(s,p){this.Hb(),this.lc(s),this.Ib(p)},this.Hb=function(){d()[this.Ab+16>>>2>>>0]=0}}var je=0,Cr=0;function Rt(n,s,p,g){return P?Oe(2,1,n,s,p,g):er(n,s,p,g)}function er(n,s,p,g){if(n>>>=0,s>>>=0,p>>>=0,g>>>=0,typeof SharedArrayBuffer>"u")return Z("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var v=[];return P&&v.length===0?Rt(n,s,p,g):(n={dc:p,vb:n,Rb:g,kc:v},P?(n.nc="spawnThread",postMessage(n,v),0):Xt(n))}function tr(n,s,p){return P?Oe(3,1,n,s,p):0}function Ar(n,s){if(P)return Oe(4,1,n,s)}var $t=n=>{for(var s=0,p=0;p<n.length;++p){var g=n.charCodeAt(p);127>=g?s++:2047>=g?s+=2:55296<=g&&57343>=g?(s+=4,++p):s+=3}return s},Ir=(n,s,p,g)=>{if(p>>>=0,!(0<g))return 0;var v=p;g=p+g-1;for(var T=0;T<n.length;++T){var M=n.charCodeAt(T);if(55296<=M&&57343>=M){var N=n.charCodeAt(++T);M=65536+((M&1023)<<10)|N&1023}if(127>=M){if(p>=g)break;s[p++>>>0]=M}else{if(2047>=M){if(p+1>=g)break;s[p++>>>0]=192|M>>6}else{if(65535>=M){if(p+2>=g)break;s[p++>>>0]=224|M>>12}else{if(p+3>=g)break;s[p++>>>0]=240|M>>18,s[p++>>>0]=128|M>>12&63}s[p++>>>0]=128|M>>6&63}s[p++>>>0]=128|M&63}}return s[p>>>0]=0,p-v},rr=(n,s,p)=>Ir(n,o(),s,p);function Tr(n,s){if(P)return Oe(5,1,n,s)}function Or(n,s,p){if(P)return Oe(6,1,n,s,p)}function Er(n,s,p){return P?Oe(7,1,n,s,p):0}function gt(n,s){if(P)return Oe(8,1,n,s)}function yt(n,s,p){if(P)return Oe(9,1,n,s,p)}function nr(n,s,p,g){if(P)return Oe(10,1,n,s,p,g)}function or(n,s,p,g){if(P)return Oe(11,1,n,s,p,g)}function _r(n,s,p,g){if(P)return Oe(12,1,n,s,p,g)}function Ft(n){if(P)return Oe(13,1,n)}function ar(n,s){if(P)return Oe(14,1,n,s)}function ir(n,s,p){if(P)return Oe(15,1,n,s,p)}var sr=n=>{if(n===null)return"null";var s=typeof n;return s==="object"||s==="array"||s==="function"?n.toString():""+n},ur,Fe=n=>{for(var s="";o()[n>>>0];)s+=ur[o()[n++>>>0]];return s},Lt={},Ht={},Pr={},Qe;function dn(n,s,p={}){var g=s.name;if(!n)throw new Qe(`type "${g}" must have a positive integer typeid pointer`);if(Ht.hasOwnProperty(n)){if(p.Ub)return;throw new Qe(`Cannot register type \'${g}\' twice`)}Ht[n]=s,delete Pr[n],Lt.hasOwnProperty(n)&&(s=Lt[n],delete Lt[n],s.forEach(v=>v()))}function Le(n,s,p={}){if(!("argPackAdvance"in s))throw new TypeError("registerType registeredInstance requires argPackAdvance");dn(n,s,p)}var lr=(n,s,p)=>{switch(s){case 1:return p?g=>r()[g>>>0>>>0]:g=>o()[g>>>0>>>0];case 2:return p?g=>a()[g>>>1>>>0]:g=>u()[g>>>1>>>0];case 4:return p?g=>i()[g>>>2>>>0]:g=>d()[g>>>2>>>0];case 8:return p?g=>de[g>>>3]:g=>Ne[g>>>3];default:throw new TypeError(`invalid integer width (${s}): ${n}`)}};function l(){this.ub=[void 0],this.Kb=[]}var m=new l;function y(n){n>>>=0,n>=m.Ab&&--m.get(n).Mb===0&&m.Ib(n)}var w=n=>{if(!n)throw new Qe("Cannot use deleted val. handle = "+n);return m.get(n).value},I=n=>{switch(n){case void 0:return 1;case null:return 2;case!0:return 3;case!1:return 4;default:return m.Hb({Mb:1,value:n})}};function U(n){return this.fromWireType(i()[n>>>2>>>0])}var F=(n,s)=>{switch(s){case 4:return function(p){return this.fromWireType(f()[p>>>2>>>0])};case 8:return function(p){return this.fromWireType(h()[p>>>3>>>0])};default:throw new TypeError(`invalid float width (${s}): ${n}`)}};function re(n){return this.fromWireType(d()[n>>>2>>>0])}var J=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,ae=(n,s)=>{for(var p=n>>1,g=p+s/2;!(p>=g)&&u()[p>>>0];)++p;if(p<<=1,32<p-n&&J)return J.decode(o().slice(n,p));for(p="",g=0;!(g>=s/2);++g){var v=a()[n+2*g>>>1>>>0];if(v==0)break;p+=String.fromCharCode(v)}return p},ne=(n,s,p)=>{if(p===void 0&&(p=2147483647),2>p)return 0;p-=2;var g=s;p=p<2*n.length?p/2:n.length;for(var v=0;v<p;++v){var T=n.charCodeAt(v);a()[s>>>1>>>0]=T,s+=2}return a()[s>>>1>>>0]=0,s-g},me=n=>2*n.length,ye=(n,s)=>{for(var p=0,g="";!(p>=s/4);){var v=i()[n+4*p>>>2>>>0];if(v==0)break;++p,65536<=v?(v-=65536,g+=String.fromCharCode(55296|v>>10,56320|v&1023)):g+=String.fromCharCode(v)}return g},_=(n,s,p)=>{if(s>>>=0,p===void 0&&(p=2147483647),4>p)return 0;var g=s;p=g+p-4;for(var v=0;v<n.length;++v){var T=n.charCodeAt(v);if(55296<=T&&57343>=T){var M=n.charCodeAt(++v);T=65536+((T&1023)<<10)|M&1023}if(i()[s>>>2>>>0]=T,s+=4,s+4>p)break}return i()[s>>>2>>>0]=0,s-g},se=n=>{for(var s=0,p=0;p<n.length;++p){var g=n.charCodeAt(p);55296<=g&&57343>=g&&++p,s+=4}return s},he=n=>{if(!be)try{if(n(),!(0<Ze))try{P?vn(Be):Gt(Be)}catch(s){s instanceof _t||s=="unwind"||x(1,s)}}catch(s){s instanceof _t||s=="unwind"||x(1,s)}};function et(n){n>>>=0,typeof Atomics.mc=="function"&&(Atomics.mc(i(),n>>>2,n).value.then(Mt),n+=128,Atomics.store(i(),n>>>2,1))}c.__emscripten_thread_mailbox_await=et;var Mt=()=>{var n=Dr();n&&(et(n),he(()=>Po()))};c.checkMailbox=Mt;var Gu=n=>{var s=$n();return n=n(),Wr(s),n};function Oe(n,s){var p=arguments.length-2,g=arguments;return Gu(()=>{for(var v=2*p,T=xn(8*v),M=T>>>3,N=0;N<p;N++){var L=g[2+N];typeof L=="bigint"?(de[M+2*N]=1n,de[M+2*N+1]=L):(de[M+2*N]=0n,h()[M+2*N+1>>>0]=L)}return _o(n,v,T,s)})}var pn=[],Rr=(n,s)=>{var p=Ht[n];if(p===void 0)throw n=Oo(n),p=Fe(n),it(n),new Qe(s+" has unknown type "+p);return p},Fu={},fn=n=>{var s=Fu[n];return s===void 0?Fe(n):s},mn=[],oo=()=>typeof globalThis=="object"?globalThis:Function("return this")(),Lu=n=>{var s=mn.length;return mn.push(n),s},Hu=(n,s)=>{for(var p=Array(n),g=0;g<n;++g)p[g]=Rr(d()[s+4*g>>>2>>>0],"parameter "+g);return p},ao=n=>{if(n===void 0)return"_unknown";n=n.replace(/[^a-zA-Z0-9_]/g,"$");var s=n.charCodeAt(0);return 48<=s&&57>=s?`_${n}`:n};function ju(n,s){return n=ao(n),{[n]:function(){return s.apply(this,arguments)}}[n]}function qu(n){var s=Function;if(!(s instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof s} which is not a function`);var p=ju(s.name||"unknownFunctionName",function(){});return p.prototype=s.prototype,p=new p,n=s.apply(p,n),n instanceof Object?n:p}var Ku=n=>{for(var s="",p=0;p<n;++p)s+=(p!==0?", ":"")+"arg"+p;var g="return function emval_allocator_"+n+`(constructor, argTypes, args) {\n  var HEAPU32 = getMemory();\n`;for(p=0;p<n;++p)g+="var argType"+p+" = requireRegisteredType(HEAPU32[((argTypes)>>>2)], \'parameter "+p+`\');\nvar arg`+p+" = argType"+p+`.readValueFromPointer(args);\nargs += argType`+p+`[\'argPackAdvance\'];\nargTypes += 4;\n`;return new Function("requireRegisteredType","Module","valueToHandle","getMemory",g+("var obj = new constructor("+s+`);\nreturn valueToHandle(obj);\n}\n`))(Rr,c,I,()=>d())},io={},jt=n=>n%4===0&&(n%100!==0||n%400===0),so=[0,31,60,91,121,152,182,213,244,274,305,335],uo=[0,31,59,90,120,151,181,212,243,273,304,334];function lo(n,s,p,g,v,T,M){return P?Oe(16,1,n,s,p,g,v,T,M):-52}function co(n,s,p,g,v,T){if(P)return Oe(17,1,n,s,p,g,v,T)}var po=n=>{var s=$t(n)+1,p=cr(s);return p&&rr(n,p,s),p},hn=[],fo=(n,s)=>{hn.length=0;for(var p;p=o()[n++>>>0];){var g=p!=105;g&=p!=112,s+=g&&s%8?4:0,hn.push(p==112?d()[s>>>2>>>0]:p==106?de[s>>>3]:p==105?i()[s>>>2>>>0]:h()[s>>>3>>>0]),s+=g?8:4}return hn},gn={},mo=()=>{if(!yn){var n={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:S||"./this.program"},s;for(s in gn)gn[s]===void 0?delete n[s]:n[s]=gn[s];var p=[];for(s in n)p.push(`${s}=${n[s]}`);yn=p}return yn},yn;function ho(n,s){if(P)return Oe(18,1,n,s);n>>>=0,s>>>=0;var p=0;return mo().forEach((g,v)=>{var T=s+p;for(v=d()[n+4*v>>>2>>>0]=T,T=0;T<g.length;++T)r()[v++>>>0>>>0]=g.charCodeAt(T);r()[v>>>0>>>0]=0,p+=g.length+1}),0}function go(n,s){if(P)return Oe(19,1,n,s);n>>>=0,s>>>=0;var p=mo();d()[n>>>2>>>0]=p.length;var g=0;return p.forEach(v=>g+=v.length+1),d()[s>>>2>>>0]=g,0}function yo(n){return P?Oe(20,1,n):52}function bo(n,s,p,g){return P?Oe(21,1,n,s,p,g):52}function wo(n,s,p,g){return P?Oe(22,1,n,s,p,g):70}var Yu=[null,[],[]];function vo(n,s,p,g){if(P)return Oe(23,1,n,s,p,g);s>>>=0,p>>>=0,g>>>=0;for(var v=0,T=0;T<p;T++){var M=d()[s>>>2>>>0],N=d()[s+4>>>2>>>0];s+=8;for(var L=0;L<N;L++){var j=o()[M+L>>>0],Q=Yu[n];j===0||j===10?((n===1?Ie:Z)(Nt(Q,0)),Q.length=0):Q.push(j)}v+=N}return d()[g>>>2>>>0]=v,0}var $o=[31,29,31,30,31,30,31,31,30,31,30,31],xo=[31,28,31,30,31,30,31,31,30,31,30,31];function Ju(n){var s=Array($t(n)+1);return Ir(n,s,0,s.length),s}var Xu=(n,s)=>{r().set(n,s>>>0)};function So(n,s,p,g){function v(E,ie,we){for(E=typeof E=="number"?E.toString():E||"";E.length<ie;)E=we[0]+E;return E}function T(E,ie){return v(E,ie,"0")}function M(E,ie){function we(Vo){return 0>Vo?-1:0<Vo?1:0}var kt;return(kt=we(E.getFullYear()-ie.getFullYear()))===0&&(kt=we(E.getMonth()-ie.getMonth()))===0&&(kt=we(E.getDate()-ie.getDate())),kt}function N(E){switch(E.getDay()){case 0:return new Date(E.getFullYear()-1,11,29);case 1:return E;case 2:return new Date(E.getFullYear(),0,3);case 3:return new Date(E.getFullYear(),0,2);case 4:return new Date(E.getFullYear(),0,1);case 5:return new Date(E.getFullYear()-1,11,31);case 6:return new Date(E.getFullYear()-1,11,30)}}function L(E){var ie=E.xb;for(E=new Date(new Date(E.yb+1900,0,1).getTime());0<ie;){var we=E.getMonth(),kt=(jt(E.getFullYear())?$o:xo)[we];if(ie>kt-E.getDate())ie-=kt-E.getDate()+1,E.setDate(1),11>we?E.setMonth(we+1):(E.setMonth(0),E.setFullYear(E.getFullYear()+1));else{E.setDate(E.getDate()+ie);break}}return we=new Date(E.getFullYear()+1,0,4),ie=N(new Date(E.getFullYear(),0,4)),we=N(we),0>=M(ie,E)?0>=M(we,E)?E.getFullYear()+1:E.getFullYear():E.getFullYear()-1}n>>>=0,s>>>=0,p>>>=0,g>>>=0;var j=d()[g+40>>>2>>>0];g={ic:i()[g>>>2>>>0],hc:i()[g+4>>>2>>>0],Db:i()[g+8>>>2>>>0],Jb:i()[g+12>>>2>>>0],Eb:i()[g+16>>>2>>>0],yb:i()[g+20>>>2>>>0],tb:i()[g+24>>>2>>>0],xb:i()[g+28>>>2>>>0],qc:i()[g+32>>>2>>>0],fc:i()[g+36>>>2>>>0],jc:j?Ve(j):""},p=Ve(p),j={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var Q in j)p=p.replace(new RegExp(Q,"g"),j[Q]);var ce="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),fe="January February March April May June July August September October November December".split(" ");j={"%a":E=>ce[E.tb].substring(0,3),"%A":E=>ce[E.tb],"%b":E=>fe[E.Eb].substring(0,3),"%B":E=>fe[E.Eb],"%C":E=>T((E.yb+1900)/100|0,2),"%d":E=>T(E.Jb,2),"%e":E=>v(E.Jb,2," "),"%g":E=>L(E).toString().substring(2),"%G":E=>L(E),"%H":E=>T(E.Db,2),"%I":E=>(E=E.Db,E==0?E=12:12<E&&(E-=12),T(E,2)),"%j":E=>{for(var ie=0,we=0;we<=E.Eb-1;ie+=(jt(E.yb+1900)?$o:xo)[we++]);return T(E.Jb+ie,3)},"%m":E=>T(E.Eb+1,2),"%M":E=>T(E.hc,2),"%n":()=>`\n`,"%p":E=>0<=E.Db&&12>E.Db?"AM":"PM","%S":E=>T(E.ic,2),"%t":()=>"	","%u":E=>E.tb||7,"%U":E=>T(Math.floor((E.xb+7-E.tb)/7),2),"%V":E=>{var ie=Math.floor((E.xb+7-(E.tb+6)%7)/7);if(2>=(E.tb+371-E.xb-2)%7&&ie++,ie)ie==53&&(we=(E.tb+371-E.xb)%7,we==4||we==3&&jt(E.yb)||(ie=1));else{ie=52;var we=(E.tb+7-E.xb-1)%7;(we==4||we==5&&jt(E.yb%400-1))&&ie++}return T(ie,2)},"%w":E=>E.tb,"%W":E=>T(Math.floor((E.xb+7-(E.tb+6)%7)/7),2),"%y":E=>(E.yb+1900).toString().substring(2),"%Y":E=>E.yb+1900,"%z":E=>{E=E.fc;var ie=0<=E;return E=Math.abs(E)/60,(ie?"+":"-")+("0000"+(E/60*100+E%60)).slice(-4)},"%Z":E=>E.jc,"%%":()=>"%"},p=p.replace(/%%/g,"\\0\\0");for(Q in j)p.includes(Q)&&(p=p.replace(new RegExp(Q,"g"),j[Q](g)));return p=p.replace(/\\0\\0/g,"%"),Q=Ju(p),Q.length>s?0:(Xu(Q,n),Q.length-1)}var Mr=n=>{try{n()}catch(s){Xe(s)}};function Zu(){var n=X,s={},p;for(p in n)(function(g){var v=n[g];s[g]=typeof v=="function"?function(){kr.push(g);try{return v.apply(null,arguments)}finally{be||(kr.pop()===g||Xe(),at&&xt===1&&kr.length===0&&(xt=0,Ze+=1,Mr(Bo),typeof Fibers<"u"&&Fibers.rc()))}}:v})(p);return s}var xt=0,at=null,Co=0,kr=[],Ao={},Io={},Qu=0,bn=null,el=[];function tl(){return new Promise((n,s)=>{bn={resolve:n,reject:s}})}function rl(){var n=cr(65548),s=n+12;d()[n>>>2>>>0]=s,d()[n+4>>>2>>>0]=s+65536,s=kr[0];var p=Ao[s];return p===void 0&&(p=Qu++,Ao[s]=p,Io[p]=s),s=p,i()[n+8>>>2>>>0]=s,n}function nl(){var n=i()[at+8>>>2>>>0];return n=X[Io[n]],--Ze,n()}function ol(n){if(!be){if(xt===0){var s=!1,p=!1;n((g=0)=>{if(!be&&(Co=g,s=!0,p)){xt=2,Mr(()=>Do(at)),typeof Browser<"u"&&Browser.Gb.Tb&&Browser.Gb.resume(),g=!1;try{var v=nl()}catch(N){v=N,g=!0}var T=!1;if(!at){var M=bn;M&&(bn=null,(g?M.reject:M.resolve)(v),T=!0)}if(g&&!T)throw v}}),p=!0,s||(xt=1,at=rl(),typeof Browser<"u"&&Browser.Gb.Tb&&Browser.Gb.pause(),Mr(()=>ko(at)))}else xt===2?(xt=0,Mr(Wo),it(at),at=null,el.forEach(g=>he(g))):Xe(`invalid state: ${xt}`);return Co}}function al(n){return ol(s=>{n().then(s)})}le.Fb();for(var To=Array(256),Br=0;256>Br;++Br)To[Br]=String.fromCharCode(Br);ur=To,Qe=c.BindingError=class extends Error{constructor(n){super(n),this.name="BindingError"}},c.InternalError=class extends Error{constructor(n){super(n),this.name="InternalError"}},Object.assign(l.prototype,{get(n){return this.ub[n]},has(n){return this.ub[n]!==void 0},Hb(n){var s=this.Kb.pop()||this.ub.length;return this.ub[s]=n,s},Ib(n){this.ub[n]=void 0,this.Kb.push(n)}}),m.ub.push({value:void 0},{value:null},{value:!0},{value:!1}),m.Ab=m.ub.length,c.count_emval_handles=()=>{for(var n=0,s=m.Ab;s<m.ub.length;++s)m.ub[s]!==void 0&&++n;return n};var il=[Qt,Sr,Rt,tr,Ar,Tr,Or,Er,gt,yt,nr,or,_r,Ft,ar,ir,lo,co,ho,go,yo,bo,wo,vo],sl={ta:function(n,s,p){return al(async()=>{await c.Xb(n,s,p)})},b:function(n,s,p){throw n>>>=0,new ot(n).Fb(s>>>0,p>>>0),je=n,Cr++,je},fa:function(n){Eo(n>>>0,!k,1,!A,131072,!1),le.Pb()},D:function(n){n>>>=0,P?postMessage({cmd:"cleanupThread",thread:n}):((n=le.nb[n])||Xe(),le.Nb(n))},X:er,u:tr,la:Ar,T:Tr,V:Or,M:Er,ja:gt,ca:yt,ia:nr,F:or,U:_r,R:Ft,ka:ar,S:ir,I:function(n,s,p,g,v){n>>>=0,s>>>=0,p>>>=0,s=Fe(s);var T=s.indexOf("u")!=-1;T&&(v=(1n<<64n)-1n),Le(n,{name:s,fromWireType:M=>M,toWireType:function(M,N){if(typeof N!="bigint"&&typeof N!="number")throw new TypeError(`Cannot convert "${sr(N)}" to ${this.name}`);if(N<g||N>v)throw new TypeError(`Passing a number "${sr(N)}" from JS side to C/C++ side to an argument of type "${s}", which is outside the valid range [${g}, ${v}]!`);return N},argPackAdvance:8,readValueFromPointer:lr(s,p,!T),Bb:null})},ra:function(n,s,p,g){n>>>=0,s=Fe(s>>>0),Le(n,{name:s,fromWireType:function(v){return!!v},toWireType:function(v,T){return T?p:g},argPackAdvance:8,readValueFromPointer:function(v){return this.fromWireType(o()[v>>>0])},Bb:null})},qa:function(n,s){n>>>=0,s=Fe(s>>>0),Le(n,{name:s,fromWireType:p=>{var g=w(p);return y(p),g},toWireType:(p,g)=>I(g),argPackAdvance:8,readValueFromPointer:U,Bb:null})},H:function(n,s,p){n>>>=0,p>>>=0,s=Fe(s>>>0),Le(n,{name:s,fromWireType:g=>g,toWireType:(g,v)=>v,argPackAdvance:8,readValueFromPointer:F(s,p),Bb:null})},w:function(n,s,p,g,v){if(n>>>=0,p>>>=0,s=Fe(s>>>0),v===-1&&(v=4294967295),v=N=>N,g===0){var T=32-8*p;v=N=>N<<T>>>T}var M=s.includes("unsigned")?function(N,L){return L>>>0}:function(N,L){return L};Le(n,{name:s,fromWireType:v,toWireType:M,argPackAdvance:8,readValueFromPointer:lr(s,p,g!==0),Bb:null})},p:function(n,s,p){function g(T){var M=d()[T>>>2>>>0];return T=d()[T+4>>>2>>>0],new v(r().buffer,T,M)}n>>>=0;var v=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][s];p=Fe(p>>>0),Le(n,{name:p,fromWireType:g,argPackAdvance:8,readValueFromPointer:g},{Ub:!0})},J:function(n,s){n>>>=0,s=Fe(s>>>0);var p=s==="std::string";Le(n,{name:s,fromWireType:function(g){var v=d()[g>>>2>>>0],T=g+4;if(p)for(var M=T,N=0;N<=v;++N){var L=T+N;if(N==v||o()[L>>>0]==0){if(M=Ve(M,L-M),j===void 0)var j=M;else j+=String.fromCharCode(0),j+=M;M=L+1}}else{for(j=Array(v),N=0;N<v;++N)j[N]=String.fromCharCode(o()[T+N>>>0]);j=j.join("")}return it(g),j},toWireType:function(g,v){v instanceof ArrayBuffer&&(v=new Uint8Array(v));var T=typeof v=="string";if(!(T||v instanceof Uint8Array||v instanceof Uint8ClampedArray||v instanceof Int8Array))throw new Qe("Cannot pass non-string to std::string");var M=p&&T?$t(v):v.length,N=cr(4+M+1),L=N+4;if(d()[N>>>2>>>0]=M,p&&T)rr(v,L,M+1);else if(T)for(T=0;T<M;++T){var j=v.charCodeAt(T);if(255<j)throw it(L),new Qe("String has UTF-16 code units that do not fit in 8 bits");o()[L+T>>>0]=j}else for(T=0;T<M;++T)o()[L+T>>>0]=v[T];return g!==null&&g.push(it,N),N},argPackAdvance:8,readValueFromPointer:re,Bb(g){it(g)}})},B:function(n,s,p){if(n>>>=0,s>>>=0,p>>>=0,p=Fe(p),s===2)var g=ae,v=ne,T=me,M=()=>u(),N=1;else s===4&&(g=ye,v=_,T=se,M=()=>d(),N=2);Le(n,{name:p,fromWireType:L=>{for(var j=d()[L>>>2>>>0],Q=M(),ce,fe=L+4,E=0;E<=j;++E){var ie=L+4+E*s;(E==j||Q[ie>>>N]==0)&&(fe=g(fe,ie-fe),ce===void 0?ce=fe:(ce+=String.fromCharCode(0),ce+=fe),fe=ie+s)}return it(L),ce},toWireType:(L,j)=>{if(typeof j!="string")throw new Qe(`Cannot pass non-string to C++ string type ${p}`);var Q=T(j),ce=cr(4+Q+s);return d()[ce>>>2]=Q>>N,v(j,ce+4,Q+s),L!==null&&L.push(it,ce),ce},argPackAdvance:8,readValueFromPointer:U,Bb(L){it(L)}})},sa:function(n,s){n>>>=0,s=Fe(s>>>0),Le(n,{Vb:!0,name:s,argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})},oa:()=>!0,P:function(n,s){n>>>=0,n==s>>>0?setTimeout(()=>Mt()):P?postMessage({targetThread:n,cmd:"checkMailbox"}):(n=le.nb[n])&&n.postMessage({cmd:"checkMailbox"})},Y:function(n,s,p,g){s>>>=0,p/=2,pn.length=p,g=g>>>0>>>3;for(var v=0;v<p;v++)pn[v]=de[g+2*v]?de[g+2*v+1]:h()[g+2*v+1>>>0];return n=0>n?Ut[-n-1]:il[n],le.Sb=s,s=n.apply(null,pn),le.Sb=0,s},ea:et,na:function(n){O&&le.nb[n>>>0].ref()},v:function(n,s,p){s>>>=0,p>>>=0,n=w(n>>>0),s=Rr(s,"emval::as");var g=[],v=I(g);return d()[p>>>2>>>0]=v,s.toWireType(g,n)},l:function(n,s,p,g,v){p>>>=0,g>>>=0,v>>>=0,n=mn[n>>>0],s=w(s>>>0),p=fn(p);var T=[];return n=n(s,p,T,v),T.length&&(d()[g>>>2>>>0]=I(T)),n},c:y,L:function(n,s){return s>>>=0,n=w(n>>>0),s=w(s),n==s},q:function(n){return n>>>=0,n===0?I(oo()):(n=fn(n),I(oo()[n]))},k:function(n,s){s=Hu(n,s>>>0);var p=s.shift();n--;for(var g=["retType"],v=[p],T="",M=0;M<n;++M)T+=(M!==0?", ":"")+"arg"+M,g.push("argType"+M),v.push(s[M]);M=p.name+"_$"+s.map(j=>j.name).join("_")+"$";var N="return function "+ao("methodCaller_"+M)+`(handle, name, destructors, args) {\n`,L=0;for(M=0;M<n;++M)N+="    var arg"+M+" = argType"+M+".readValueFromPointer(args"+(L?"+"+L:"")+`);\n`,L+=s[M].argPackAdvance;for(N+="    var rv = handle[name]("+T+`);\n`,M=0;M<n;++M)s[M].deleteObject&&(N+="    argType"+M+".deleteObject(arg"+M+`);\n`);return p.Vb||(N+=`    return retType.toWireType(destructors, rv);\n`),g.push(N+`};\n`),n=qu(g).apply(null,v),Lu(n)},t:function(n,s){return s>>>=0,n=w(n>>>0),s=w(s),I(n[s])},h:function(n){n>>>=0,4<n&&(m.get(n).Mb+=1)},r:function(n,s,p,g){p>>>=0,g>>>=0,n=w(n>>>0);var v=io[s];return v||(v=Ku(s),io[s]=v),v(n,p,g)},x:function(){return I([])},m:function(n){n=w(n>>>0);for(var s=Array(n.length),p=0;p<n.length;p++)s[p]=n[p];return I(s)},e:function(n){return I(fn(n>>>0))},j:function(){return I({})},i:function(n){n>>>=0;for(var s=w(n);s.length;){var p=s.pop();s.pop()(p)}y(n)},g:function(n,s,p){s>>>=0,p>>>=0,n=w(n>>>0),s=w(s),p=w(p),n[s]=p},d:function(n,s){return s>>>=0,n=Rr(n>>>0,"_emval_take_value"),n=n.readValueFromPointer(s),I(n)},$:function(n,s){n=-9007199254740992>n||9007199254740992<n?NaN:Number(n),s>>>=0,n=new Date(1e3*n),i()[s>>>2>>>0]=n.getUTCSeconds(),i()[s+4>>>2>>>0]=n.getUTCMinutes(),i()[s+8>>>2>>>0]=n.getUTCHours(),i()[s+12>>>2>>>0]=n.getUTCDate(),i()[s+16>>>2>>>0]=n.getUTCMonth(),i()[s+20>>>2>>>0]=n.getUTCFullYear()-1900,i()[s+24>>>2>>>0]=n.getUTCDay(),n=(n.getTime()-Date.UTC(n.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,i()[s+28>>>2>>>0]=n},aa:function(n,s){n=-9007199254740992>n||9007199254740992<n?NaN:Number(n),s>>>=0,n=new Date(1e3*n),i()[s>>>2>>>0]=n.getSeconds(),i()[s+4>>>2>>>0]=n.getMinutes(),i()[s+8>>>2>>>0]=n.getHours(),i()[s+12>>>2>>>0]=n.getDate(),i()[s+16>>>2>>>0]=n.getMonth(),i()[s+20>>>2>>>0]=n.getFullYear()-1900,i()[s+24>>>2>>>0]=n.getDay();var p=(jt(n.getFullYear())?so:uo)[n.getMonth()]+n.getDate()-1|0;i()[s+28>>>2>>>0]=p,i()[s+36>>>2>>>0]=-(60*n.getTimezoneOffset()),p=new Date(n.getFullYear(),6,1).getTimezoneOffset();var g=new Date(n.getFullYear(),0,1).getTimezoneOffset();n=(p!=g&&n.getTimezoneOffset()==Math.min(g,p))|0,i()[s+32>>>2>>>0]=n},ba:function(n){n>>>=0;var s=new Date(i()[n+20>>>2>>>0]+1900,i()[n+16>>>2>>>0],i()[n+12>>>2>>>0],i()[n+8>>>2>>>0],i()[n+4>>>2>>>0],i()[n>>>2>>>0],0),p=i()[n+32>>>2>>>0],g=s.getTimezoneOffset(),v=new Date(s.getFullYear(),6,1).getTimezoneOffset(),T=new Date(s.getFullYear(),0,1).getTimezoneOffset(),M=Math.min(T,v);return 0>p?i()[n+32>>>2>>>0]=+(v!=T&&M==g):0<p!=(M==g)&&(v=Math.max(T,v),s.setTime(s.getTime()+6e4*((0<p?M:v)-g))),i()[n+24>>>2>>>0]=s.getDay(),p=(jt(s.getFullYear())?so:uo)[s.getMonth()]+s.getDate()-1|0,i()[n+28>>>2>>>0]=p,i()[n>>>2>>>0]=s.getSeconds(),i()[n+4>>>2>>>0]=s.getMinutes(),i()[n+8>>>2>>>0]=s.getHours(),i()[n+12>>>2>>>0]=s.getDate(),i()[n+16>>>2>>>0]=s.getMonth(),i()[n+20>>>2>>>0]=s.getYear(),BigInt(s.getTime()/1e3)},Z:lo,_:co,O:function(n,s,p){function g(j){return(j=j.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?j[1]:"GMT"}n>>>=0,s>>>=0,p>>>=0;var v=new Date().getFullYear(),T=new Date(v,0,1),M=new Date(v,6,1);v=T.getTimezoneOffset();var N=M.getTimezoneOffset(),L=Math.max(v,N);d()[n>>>2>>>0]=60*L,i()[s>>>2>>>0]=+(v!=N),n=g(T),s=g(M),n=po(n),s=po(s),N<v?(d()[p>>>2>>>0]=n,d()[p+4>>>2>>>0]=s):(d()[p>>>2>>>0]=s,d()[p+4>>>2>>>0]=n)},o:()=>{Xe("")},f:function(n,s,p){return n>>>=0,s=fo(s>>>0,p>>>0),Ut[n].apply(null,s)},K:function(n,s,p){return n>>>=0,s=fo(s>>>0,p>>>0),Ut[n].apply(null,s)},E:()=>{},G:()=>Date.now(),ma:()=>{throw Ze+=1,"unwind"},Q:function(){return 4294901760},n:()=>performance.timeOrigin+performance.now(),z:()=>O?(jo(),qt(Ho)).cpus().length:navigator.hardwareConcurrency,N:function(n){n>>>=0;var s=o().length;if(n<=s||4294901760<n)return!1;for(var p=1;4>=p;p*=2){var g=s*(1+.2/p);g=Math.min(g,n+100663296);var v=Math;g=Math.max(n,g);e:{v=(v.min.call(v,4294901760,g+(65536-g%65536)%65536)-ve.buffer.byteLength+65535)/65536;try{ve.grow(v),Ce();var T=1;break e}catch{}T=void 0}if(T)return!0}return!1},ga:ho,ha:go,W:Gt,y:yo,C:bo,da:wo,A:vo,a:ve||c.wasmMemory,pa:So,s:function(n,s,p,g){return So(n>>>0,s>>>0,p>>>0,g>>>0)}},X=function(){var n={a:sl};return nt++,xr(n,function(s){var p=s.module;X=s.instance.exports,X=Zu(),X=ul(),le.Qb.push(X.$a),He.unshift(X.ua),Te=p,Kt()}).catch(b),{}}();c._OrtInit=(n,s)=>(c._OrtInit=X.va)(n,s),c._OrtGetLastError=(n,s)=>(c._OrtGetLastError=X.wa)(n,s),c._OrtCreateSessionOptions=(n,s,p,g,v,T,M,N,L,j)=>(c._OrtCreateSessionOptions=X.xa)(n,s,p,g,v,T,M,N,L,j),c._OrtAppendExecutionProvider=(n,s)=>(c._OrtAppendExecutionProvider=X.ya)(n,s),c._OrtAddFreeDimensionOverride=(n,s,p)=>(c._OrtAddFreeDimensionOverride=X.za)(n,s,p),c._OrtAddSessionConfigEntry=(n,s,p)=>(c._OrtAddSessionConfigEntry=X.Aa)(n,s,p),c._OrtReleaseSessionOptions=n=>(c._OrtReleaseSessionOptions=X.Ba)(n),c._OrtCreateSession=(n,s,p)=>(c._OrtCreateSession=X.Ca)(n,s,p),c._OrtReleaseSession=n=>(c._OrtReleaseSession=X.Da)(n),c._OrtGetInputOutputCount=(n,s,p)=>(c._OrtGetInputOutputCount=X.Ea)(n,s,p),c._OrtGetInputName=(n,s)=>(c._OrtGetInputName=X.Fa)(n,s),c._OrtGetOutputName=(n,s)=>(c._OrtGetOutputName=X.Ga)(n,s),c._OrtFree=n=>(c._OrtFree=X.Ha)(n),c._OrtCreateTensor=(n,s,p,g,v,T)=>(c._OrtCreateTensor=X.Ia)(n,s,p,g,v,T),c._OrtGetTensorData=(n,s,p,g,v)=>(c._OrtGetTensorData=X.Ja)(n,s,p,g,v),c._OrtReleaseTensor=n=>(c._OrtReleaseTensor=X.Ka)(n),c._OrtCreateRunOptions=(n,s,p,g)=>(c._OrtCreateRunOptions=X.La)(n,s,p,g),c._OrtAddRunConfigEntry=(n,s,p)=>(c._OrtAddRunConfigEntry=X.Ma)(n,s,p),c._OrtReleaseRunOptions=n=>(c._OrtReleaseRunOptions=X.Na)(n),c._OrtCreateBinding=n=>(c._OrtCreateBinding=X.Oa)(n),c._OrtBindInput=(n,s,p)=>(c._OrtBindInput=X.Pa)(n,s,p),c._OrtBindOutput=(n,s,p,g)=>(c._OrtBindOutput=X.Qa)(n,s,p,g),c._OrtClearBoundOutputs=n=>(c._OrtClearBoundOutputs=X.Ra)(n),c._OrtReleaseBinding=n=>(c._OrtReleaseBinding=X.Sa)(n),c._OrtRunWithBinding=(n,s,p,g,v)=>(c._OrtRunWithBinding=X.Ta)(n,s,p,g,v),c._OrtRun=(n,s,p,g,v,T,M,N)=>(c._OrtRun=X.Ua)(n,s,p,g,v,T,M,N),c._OrtEndProfiling=n=>(c._OrtEndProfiling=X.Va)(n),c._JsepOutput=(n,s,p)=>(c._JsepOutput=X.Wa)(n,s,p),c._JsepGetNodeName=n=>(c._JsepGetNodeName=X.Xa)(n);var Dr=c._pthread_self=()=>(Dr=c._pthread_self=X.Ya)(),cr=c._malloc=n=>(cr=c._malloc=X.Za)(n),it=c._free=n=>(it=c._free=X._a)(n);c.__emscripten_tls_init=()=>(c.__emscripten_tls_init=X.$a)();var Oo=n=>(Oo=X.ab)(n);c.__embind_initialize_bindings=()=>(c.__embind_initialize_bindings=X.bb)();var Eo=c.__emscripten_thread_init=(n,s,p,g,v,T)=>(Eo=c.__emscripten_thread_init=X.db)(n,s,p,g,v,T);c.__emscripten_thread_crashed=()=>(c.__emscripten_thread_crashed=X.eb)();var _o=(n,s,p,g)=>(_o=X.fb)(n,s,p,g),wn=n=>(wn=X.gb)(n),vn=c.__emscripten_thread_exit=n=>(vn=c.__emscripten_thread_exit=X.hb)(n),Po=c.__emscripten_check_mailbox=()=>(Po=c.__emscripten_check_mailbox=X.ib)(),Ro=(n,s)=>(Ro=X.jb)(n,s),$n=()=>($n=X.kb)(),Wr=n=>(Wr=X.lb)(n),xn=n=>(xn=X.mb)(n),Mo=c.dynCall_ii=(n,s)=>(Mo=c.dynCall_ii=X.ob)(n,s),ko=n=>(ko=X.pb)(n),Bo=()=>(Bo=X.qb)(),Do=n=>(Do=X.rb)(n),Wo=()=>(Wo=X.sb)();c.___start_em_js=1452163,c.___stop_em_js=1452324;function ul(){var n=X;n=Object.assign({},n);var s=g=>()=>g()>>>0,p=g=>v=>g(v)>>>0;return n.__errno_location=s(n.__errno_location),n.Ya=s(n.Ya),n.Za=p(n.Za),n.ab=p(n.ab),n.kb=s(n.kb),n.mb=p(n.mb),n}c.wasmMemory=ve,c.stackAlloc=xn,c.stackSave=$n,c.stackRestore=Wr,c.keepRuntimeAlive=()=>0<Ze,c.UTF8ToString=Ve,c.stringToUTF8=rr,c.lengthBytesUTF8=$t,c.ExitStatus=_t,c.PThread=le;var zr;Ot=function n(){zr||zo(),zr||(Ot=n)};function zo(){0<nt||(P?(C(c),P||ht(He),startWorker(c)):(ht(vt),0<nt||zr||(zr=!0,c.calledRun=!0,be||(P||ht(He),C(c),P||ht(zt)))))}return zo(),t.ready}})();typeof Ko=="object"&&typeof En=="object"?En.exports=qo:typeof define=="function"&&define.amd&&define([],()=>qo)});var Jo=dr((rp,gl)=>{gl.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\\n\'});var Rn,fr,mr,Nr,hr,ra,Mn,We=K(()=>{"use strict";Rn=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},fr=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},mr=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],Nr=e=>{switch(e){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},hr=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},ra=e=>e==="float32"||e==="int32"||e==="int64"||e==="bool"||e==="float16"||e==="uint32",Mn=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var Al,Il,na,oa,aa,Tl,Ee,St=K(()=>{"use strict";We();Al=["V","I","W","E","F"],Il=(e,t)=>{console.log(`[${Al[e]},${new Date().toISOString()}]${t}`)},aa=(e,t)=>{na=e,oa=t},Tl=(e,t)=>{let r=hr(e),o=hr(na);r>=o&&Il(r,typeof t=="function"?t():t)},Ee=(...e)=>{oa&&Tl(...e)}});var ia,sa=K(()=>{"use strict";We();ia=(e,t)=>new(Nr(t))(e)});var ua=K(()=>{"use strict"});var Gr,Ol,la,Bn,kn,ca,da=K(()=>{"use strict";St();ua();Gr=e=>Math.ceil(e/16)*16,Ol=1,la=()=>Ol++,Bn=async(e,t,r,o)=>{let a=Gr(r),u=e.device.createBuffer({size:a,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let i=e.getCommandEncoder();e.endComputePass(),i.copyBufferToBuffer(t,0,u,0,a),e.flush(),await u.mapAsync(GPUMapMode.READ);let d=u.getMappedRange();if(o){let f=o();return f.set(new Uint8Array(d,0,r)),f}else return new Uint8Array(d.slice(0,r))}finally{u.destroy()}},kn=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(t,r){let o=r.buffer,a=r.byteOffset,u=r.byteLength,i=Gr(u),d=this.storageCache.get(t);if(!d)throw new Error("gpu data for uploading does not exist");if(d.originalSize!==u)throw new Error(`inconsistent data size. gpu data size=${d.originalSize}, data size=${u}`);let f=this.backend.device.createBuffer({mappedAtCreation:!0,size:i,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),h=f.getMappedRange();new Uint8Array(h).set(new Uint8Array(o,a,u)),f.unmap();let c=this.backend.getCommandEncoder();this.backend.endComputePass(),c.copyBufferToBuffer(f,0,d.gpuData.buffer,0,i),Ee("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(f)}memcpy(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("source gpu data for memcpy does not exist");let a=this.storageCache.get(r);if(!a)throw new Error("destination gpu data for memcpy does not exist");if(o.originalSize!==a.originalSize)throw new Error("inconsistent source and destination gpu data size");let u=Gr(o.originalSize),i=this.backend.getCommandEncoder();this.backend.endComputePass(),i.copyBufferToBuffer(o.gpuData.buffer,0,a.gpuData.buffer,0,u)}registerExternalBuffer(t,r,o){let a;if(o){if(a=this.externalBuffers.get(o),a===void 0)throw new Error("previous buffer is not registered");if(t===o)return Ee("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${a}, buffer is the same, skip.`),a;this.externalBuffers.delete(o)}else a=la();return this.storageCache.set(a,{gpuData:{id:a,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,a),Ee("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${a}, registered.`),a}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),Ee("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let o=Gr(t),a,u=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,i=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(u||i){let f=u?this.freeBuffers:this.freeUniformBuffers,h=f.get(o);h||(h=[],f.set(o,h)),h.length>0?a=h.pop():a=this.backend.device.createBuffer({size:o,usage:r})}else a=this.backend.device.createBuffer({size:o,usage:r});let d={id:la(),type:0,buffer:a};return this.storageCache.set(d.id,{gpuData:d,originalSize:t}),Ee("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${d.id}`),d}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error("releasing data does not exist");return Ee("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("data does not exist");await Bn(this.backend,o.gpuData.buffer,o.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();this.buffersForUploadingPending=[];for(let t of this.buffersPending)(t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(t.size).push(t):(t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(t.size).push(t):t.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},ca=(...e)=>new kn(...e)});var Dn,ue,Me=K(()=>{"use strict";Dn=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this._cacheKey}},ue=e=>new Dn(e)});var Wn,st,z,Bt,Fr,Lr,Hr,ge=K(()=>{"use strict";Wn=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},st=class{static calcShape(t,r,o=!1){let a=t.length,u=r.length;if(a===0)return r;if(u===0)return t;let i=Math.max(t.length,r.length),d=new Array(i);if(o){if(a<2||u<2)return;let f=Wn.calcMatMulShape([t[a-2],t[a-1]],[r[u-2],r[u-1]]);if(f===void 0)return;[d[i-2],d[i-1]]=f}for(let f=o?3:1;f<=i;f++){let h=a-f<0?1:t[a-f],c=u-f<0?1:r[u-f];if(h!==c&&h>1&&c>1)return;d[i-f]=Math.max(h,c)}return d}static isValidBroadcast(t,r){let o=t.length,a=r.length;if(o>a)return!1;for(let u=1;u<=o;u++)if(t[o-u]!==1&&t[o-u]!==r[a-u])return!1;return!0}},z=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,o){let a=1;for(let u=r;u<o;u++){if(t[u]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");a*=t[u]}return a}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let o=new Array(r);o[r-1]=1,o[r-2]=t[r-1];for(let a=r-3;a>=0;--a)o[a]=o[a+1]*t[a+1];return o}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(o=>this.normalizeAxis(o,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(o=>t[o]):t.slice().reverse()}static padShape(t,r){let o=t.length;return t.map((a,u)=>a+r[u]+r[u+o])}static areEqual(t,r){return t.length!==r.length?!1:t.every((o,a)=>o===r[a])}},Bt=class e{static adjustPoolAttributes(t,r,o,a,u,i){if(!t&&o.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let d=0;d<r.length-2;d++)d>=o.length?o.push(r[d+2]):o[d]=r[d+2];for(let d=0;d<o.length;d++)if(d<a.length){if(a[d]<0)throw new Error("strides should be greater than or equal to 1")}else a.push(1);for(let d=0;d<o.length;d++)if(d<u.length){if(u[d]<0)throw new Error("dilations should be greater than or equal to 1")}else u.push(1);for(let d=0;d<o.length*2;d++)if(d<i.length){if(i[d]<0)throw new Error("pad should be greater than or equal to 1")}else i.push(0);for(let d=0;d<o.length;d++){if(o[d]<=0)throw new Error("kernel shapes need to be greater than 0");if(i[d]>=o[d]||i[d+o.length]>=o[d])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,o,a,u,i,d){if(d){if(u.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(a.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let f=0;f<t.length-2;f++)e.adjustPadAndReturnShape(t[f+(i?1:2)],r[f],o[f],a[f],u,f,f+t.length-2,d)}}static computePoolOutputShape(t,r,o,a,u,i,d){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let f=[r[0],r[1]];return e.computeShapeHelper(t,r,f,o,a,u,i,d),f}static computeConvOutputShape(t,r,o,a,u,i,d){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let f=[t[0],r[0]];return e.computeShapeHelper(!1,t,f,o,a,u,i,d),f}static computeShapeHelper(t,r,o,a,u,i,d,f){if(t)for(let h=0;h<r.length-2;h++)o.push(1);else for(let h=0;h<r.length-2;h++)o.push(e.adjustPadAndReturnShape(r[h+2],a[h],u[h],i[h],d,h,h+r.length-2,f))}static adjustPadAndReturnShape(t,r,o,a,u,i,d,f){let h=o*(a-1)+1;if(f&&f!=="NOTSET")switch(f){case"VALID":return u[i]=0,u[d]=0,Math.floor((t-h)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(o!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let C=((t+r-1)/r-1)*r+a-t;return u[i]=Math.floor(f==="SAME_LOWER"?(C+1)/2:C/2),u[d]=C-u[i],Math.floor((t+C-a)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+u[i]+u[d]-h)/r+1)}},Fr=class{static getShapeOfGemmResult(t,r,o,a,u){if(t.length!==2||o.length!==2)throw new Error("shape need to be of size 2");let i,d,f;r?(i=t[1],d=t[0]):(i=t[0],d=t[1]);let h=-1;if(a?(f=o[0],h=1):(f=o[1],h=0),o[h]!==d)throw new Error("dimension mismatch");if(i<=0||f<=0||d<=0)throw new Error("invalid shape specified");if(u&&!st.isValidBroadcast(u,[i,f]))throw new Error("gemm: invalid bias shape for broadcast");return[i,f,d]}},Lr=-34028234663852886e22,Hr=34028234663852886e22});var El,pa,ke,ut,bt,tt,Dt,Ct,fa,H,Y,zn,ma,Vn,wt,$e=K(()=>{"use strict";We();ge();El=64,pa=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},ke=(e,t=1)=>{let r=pa(e,t);return typeof r=="string"?r:r[0]},ut=e=>e.length===0?[]:[{type:"uint32",data:e},{type:"uint32",data:z.computeStrides(e)}],bt=e=>e%4===0?4:e%2===0?2:1,tt=(e="f32",t,r="0")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,Dt=(e,t,r)=>e==="f32"?r:t===1?`f32(${r})`:`vec${t}f(${r})`,Ct=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,fa=(e,t,r,o,a)=>{let u=typeof r=="number",i=u?r:r.length,d=[...new Array(i).keys()],f=i<2?"u32":i<=4?`vec${i}<u32>`:`array<u32, ${i}>`,h=pa(t,a),c=typeof h=="string"?h:h[1],C=typeof h=="string"?h:h[0],b={indices:f,value:c,storage:C,tensor:t},$=G=>typeof G=="string"?G:`${G}u`,S={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},x=u?"uniforms.":"",A=`${x}${e}_shape`,k=`${x}${e}_strides`,O="";for(let G=0;G<i-1;G++)O+=`\n    let dim${G} = current / ${k}[${G}];\n    let rest${G} = current % ${k}[${G}];\n    indices[${G}] = dim${G};\n    current = rest${G};\n    `;O+=`indices[${i-1}] = current;`;let P=i<2?"":`\n  fn o2i_${e}(offset: u32) -> ${b.indices} {\n    var indices: ${b.indices};\n    var current = offset;\n    ${O}\n    return indices;\n  }`,R=G=>(S.offsetToIndices=!0,i<2?G:`o2i_${e}(${G})`),V=[];if(i>=2)for(let G=i-1;G>=0;G--)V.push(`${k}[${G}] * (indices[${G}])`);let B=i<2?"":`\n  fn i2o_${e}(indices: ${b.indices}) -> u32 {\n    return ${V.join("+")};\n  }`,W=G=>(S.indicesToOffset=!0,i<2?G:`i2o_${e}(${G})`),q=(...G)=>i===0?"0u":`${b.indices}(${G.map($).join(",")})`,ee=(G,pe)=>i<2?`${G}`:`${G}[${pe}]`,oe=(G,pe,de)=>i<2?`${G}=${de};`:`${G}[${pe}]=${de};`,D={},te=(G,pe)=>{S.broadcastedIndicesToOffset=!0;let de=`${pe.name}broadcastedIndicesTo${e}Offset`;if(de in D)return`${de}(${G})`;let Ne=[];for(let Ge=i-1;Ge>=0;Ge--){let Ce=pe.indicesGet("outputIndices",Ge+pe.rank-i);Ne.push(`${ee(k,Ge)} * (${Ce} % ${ee(A,Ge)})`)}return D[de]=`fn ${de}(outputIndices: ${pe.type.indices}) -> u32 {\n             return ${Ne.length>0?Ne.join("+"):"0u"};\n           }`,`${de}(${G})`},Ie=(G,pe)=>(()=>{if(b.storage===b.value)return`${e}[${G}]=${pe};`;if(b.storage==="vec2<u32>"&&b.value==="i32")return`${e}[${G}]=vec2<u32>(u32(${pe}), select(0u, 0xFFFFFFFFu, ${pe} < 0));`;if(b.storage==="vec2<u32>"&&b.value==="u32")return`${e}[${G}]=vec2<u32>(u32(${pe}), 0u);`;if(b.storage==="u32"&&b.value==="vec4<bool>")return`${e}[${G}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${pe}));`;throw new Error(`not supported combination of storage type ${b.storage} and value type ${b.value} yet`)})(),Z=G=>(()=>{if(b.storage===b.value)return`${e}[${G}]`;if(b.storage==="vec2<u32>"&&b.value==="i32")return`i32(${e}[${G}].x)`;if(b.storage==="vec2<u32>"&&b.value==="u32")return`u32(${e}[${G}].x)`;if(b.storage==="u32"&&b.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${G}] & 0xFFu), bool(${e}[${G}] & 0xFF00u), bool(${e}[${G}] & 0xFF0000u), bool(${e}[${G}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${b.storage} and value type ${b.value} yet`)})(),ve=i<2?"":`\n  fn get_${e}ByIndices(indices: ${b.indices}) -> ${c} {\n    return ${Z(`i2o_${e}(indices)`)};\n  }`,Te=i<2?"":(()=>{let G=d.map(de=>`d${de}: u32`).join(", "),pe=d.map(de=>`d${de}`).join(", ");return`\n  fn get_${e}(${G}) -> ${c} {\n    return get_${e}ByIndices(${q(pe)});\n  }`})(),be=(...G)=>{if(G.length!==i)throw new Error(`indices length must be ${i}`);let pe=G.map($).join(",");return i===0?Z("0u"):i===1?Z(pe[0]):(S.get=!0,S.getByIndices=!0,S.indicesToOffset=!0,`get_${e}(${pe})`)},Be=G=>i<2?Z(G):(S.getByIndices=!0,S.indicesToOffset=!0,`get_${e}ByIndices(${G})`),Se=i<2?"":`\n  fn set_${e}ByIndices(indices: ${b.indices}, value: ${c}) {\n    ${Ie(`i2o_${e}(indices)`,"value")}\n  }`,Ue=i<2?"":(()=>{let G=d.map(de=>`d${de}: u32`).join(", "),pe=d.map(de=>`d${de}`).join(", ");return`\n  fn set_${e}(${G}, value: ${c}) {\n    set_${e}ByIndices(${q(pe)}, value);\n  }`})();return{impl:()=>{let G=[];return u||(G.push(`const ${A} = ${b.indices}(${r.join(",")});`),G.push(`const ${k} = ${b.indices}(${z.computeStrides(r).join(",")});`)),S.offsetToIndices&&G.push(P),S.indicesToOffset&&G.push(B),S.broadcastedIndicesToOffset&&Object.values(D).forEach(pe=>G.push(pe)),S.set&&G.push(Ue),S.setByIndices&&G.push(Se),S.get&&G.push(Te),S.getByIndices&&G.push(ve),G.join(`\n`)},type:b,offsetToIndices:R,indicesToOffset:W,broadcastedIndicesToOffset:te,indices:q,indicesGet:ee,indicesSet:oe,set:(...G)=>{if(G.length!==i+1)throw new Error(`indices length must be ${i}`);let pe=G[i];if(typeof pe!="string")throw new Error("value must be string");let de=G.slice(0,i).map($).join(",");return i===0?Ie("0u",pe):i===1?Ie(de[0],pe):(S.set=!0,S.setByIndices=!0,S.indicesToOffset=!0,`set_${e}(${de}, ${pe})`)},setByOffset:Ie,setByIndices:(G,pe)=>i<2?Ie(G,pe):(S.setByIndices=!0,S.indicesToOffset=!0,`set_${e}ByIndices(${G}, ${pe});`),get:be,getByOffset:Z,getByIndices:Be,usage:o?"input":"output",name:e,strides:k,shape:A,rank:i}},H=(e,t,r,o=1)=>fa(e,t,r,!0,o),Y=(e,t,r,o=1)=>fa(e,t,r,!1,o),zn=class{constructor(t){this.normalizedDispatchGroup=t;this.indicesHelpers=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=El){let r=typeof t=="number"?t:t[0],o=typeof t=="number"?1:t[1],a=typeof t=="number"?1:t[2],u=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,i=u?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>`,d=u?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${r*o*a}u + local_index;`;return`@compute @workgroup_size(${r}, ${o}, ${a})\n  fn main(${i}) {\n    ${d}\n  `}declareVariable(t,r){this.indicesHelpers.push(t),t.rank!==0&&(t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:t.type.indices}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:t.type.indices}));let o=t.usage==="input"?"read":"read_write",a=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${o}> ${t.name}: array<${a}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`\n`)}registerUniform(t,r){return this.uniforms.push({name:t,type:r}),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:r,type:o}of this.uniforms)t.push(`${r}:${o}`);return`\n      struct Uniforms { ${t.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.indicesHelpers.map(t=>t.impl()).join(`\n`)}},ma=e=>new zn(e),Vn=(e,t)=>{let r=e.length,o=[];for(let a=0;a<r;a++){let u=r-1-a,i=e[u]||1;(t[t.length-1-a]||1)>1&&i===1&&o.unshift(u)}return o},wt=e=>e<=4});var _l,ha,Pl,Rl,At,ga,ya,gr=K(()=>{"use strict";ge();Me();$e();_l=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},ha=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,Pl=(e,t)=>z.sortBasedOnPerm(e,ha(e.length,t)),Rl=(e,t,r,o)=>{let a=[];a.push(`fn perm(i: ${o.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let u=0;u<t;++u)a.push(r.indicesSet("a",e[u],`i[${u}]`));return a.push("return a;}"),a.join(`\n`)},At=(e,t)=>{let r=e.dataType,o=e.dims.length,a=ha(o,t),u=wt(o),i=Pl(e.dims,a),d=u?i.length:i,f=u?o:e.dims,h=Y("output",r,d),c=H("a",r,f),C=b=>`\n  ${b.registerUniform("output_size","u32").declareVariables(c,h)}\n\n  ${Rl(a,o,c,h)}\n\n  ${b.mainStart()}\n    ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${h.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${h.setByOffset("global_idx",c.getByIndices("aIndices"))}\n  }`;return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:u?["rank"]:["dims"]},getRunData:b=>{let $=z.size(i);return{outputs:[{dims:i,dataType:b[0].dataType}],dispatchGroup:{x:Math.ceil($/64)},programUniforms:u?[{type:"uint32",data:$},...ut(b[0].dims),...ut(i)]:[{type:"uint32",data:$}]}},getShaderSource:C}},ga=(e,t)=>{_l(e.inputs),e.compute(At(e.inputs[0],t.perm))},ya=e=>ue({perm:e.perm})});var Ml,kl,Bl,Dl,Wl,zl,Vl,Ul,Nl,Gl,lt,ba,wa,va,$a,xa,Sa,Ca,Aa,Ia,Ta,Oa=K(()=>{"use strict";ge();$e();jr();gr();Ml={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},kl={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Bl={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Dl={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Wl=(e,t)=>{let r=[];for(let o=t-e;o<t;++o)r.push(o);return r},zl=(e,t)=>{let r=[],o=e.length;for(let u=0;u<o;u++)t.indexOf(u)===-1&&r.push(e[u]);let a=t.map(u=>e[u]);return[r,a]},Vl=(e,t)=>{let r=e.length+t.length,o=[],a=0;for(let u=0;u<r;u++)t.indexOf(u)===-1?o.push(e[a++]):o.push(1);return o},Ul=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},Nl=(e,t)=>{let r=[];if(!Ul(e,t)){for(let o=0;o<t;++o)e.indexOf(o)===-1&&r.push(o);e.forEach(o=>r.push(o))}return r},Gl=(e,t,r,o,a,u,i)=>{let d=r[0].dims,f=z.size(u),h=z.size(i),c=H("_A",r[0].dataType,d),C=Y("output",a,u),b=32,$=`\n          var<workgroup> aBestValues : array<${C.type.storage}, ${b}>;\n       `;return{name:e,shaderCache:t,getShaderSource:x=>`\n        ${x.registerUniform("reduceSize","u32").declareVariables(c,C)}\n        ${$}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${x.mainStart(b)}\n          let local_idx = local_id.x;\n\n          let outputIndex = global_idx / ${b};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = ${C.type.storage}(${Bl[o]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${b}) {\n           let candidate = ${C.type.storage}(${c.getByOffset("offset + k")});\n           bestValue = ${Ml[o]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${b}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${kl[o]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${C.setByOffset("outputIndex",`${o==="mean"?`bestValue / ${C.type.storage}(uniforms.reduceSize)`:`${Dl[o]}`}`)};\n         }\n        }`,getRunData:()=>({outputs:[{dims:u,dataType:a}],dispatchGroup:{x:f},programUniforms:[{type:"uint32",data:h}]})}},lt=(e,t,r,o)=>{let a=e.inputs.length===1?r:Un(e.inputs,r),u=a.axes;u.length===0&&!a.noopWithEmptyAxes&&(u=e.inputs[0].dims.map(($,S)=>S));let i=z.normalizeAxes(u,e.inputs[0].dims.length),d=i,f=e.inputs[0],h=Nl(d,e.inputs[0].dims.length);h.length>0&&(f=e.compute(At(e.inputs[0],h),{inputs:[0],outputs:[-1]})[0],d=Wl(d.length,f.dims.length));let[c,C]=zl(f.dims,d),b=c;a.keepDims&&(b=Vl(c,i)),e.compute(Gl(t,{hint:a.cacheKey,inputDependencies:["type"]},[f],o,e.inputs[0].dataType,b,C),{inputs:[f]})},ba=(e,t)=>{lt(e,"ReduceMeanShared",t,"mean")},wa=(e,t)=>{lt(e,"ReduceL1Shared",t,"l1")},va=(e,t)=>{lt(e,"ReduceL2Shared",t,"l2")},$a=(e,t)=>{lt(e,"ReduceLogSumExpShared",t,"logSumExp")},xa=(e,t)=>{lt(e,"ReduceMaxShared",t,"max")},Sa=(e,t)=>{lt(e,"ReduceMinShared",t,"min")},Ca=(e,t)=>{lt(e,"ReduceProdShared",t,"prod")},Aa=(e,t)=>{lt(e,"ReduceSumShared",t,"sum")},Ia=(e,t)=>{lt(e,"ReduceSumSquareShared",t,"sumSquare")},Ta=(e,t)=>{lt(e,"ReduceLogSumShared",t,"logSum")}});var ct,Fl,qr,Un,dt,Ll,Hl,jl,ql,Kl,Yl,Jl,Xl,Zl,Ql,pt,Ea,_a,Pa,Ra,Ma,ka,Ba,Da,Wa,za,rt,jr=K(()=>{"use strict";ge();Me();$e();Oa();ct=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Fl=e=>["","",`var value = ${e.getByOffset("inputOffset")};`,""],qr=(e,t,r,o,a,u,i=!1,d=!1)=>{let f=[],h=r[0].dims,c=z.normalizeAxes(a,r[0].dims.length),C=!d&&c.length===0;h.forEach((W,q)=>{C||c.indexOf(q)>=0?i&&f.push(1):f.push(W)});let b=[],$=H("_A",r[0].dataType,h),S=Y("output",u,f),x=o($,S,c),A=`inputOffset = ${$.indicesToOffset("inputIndices")};`,k=`let ${A};`,O=`var ${A};`,P=x[1]===""?"":O,R=(x[1]===""?k:A)+`\n`+x[2];for(let W=0,q=0;W<r[0].dims.length;W++)C||c.indexOf(W)>=0?(i&&q++,R=`for(var j${W}: u32 = 0; j${W} < ${r[0].dims[W]}; j${W}++) {\n                ${x[2].includes("lastIndex")?`let lastIndex = j${W};`:""}\n                ${$.indicesSet("inputIndices",W,`j${W}`)}\n                ${R}\n              }`):(b.push(`${$.indicesSet("inputIndices",W,S.indicesGet("outputIndices",q))};`),q++);let V=z.size(f);return{name:e,shaderCache:t,getShaderSource:W=>`\n        ${W.declareVariables($,S)}\n\n        ${W.mainStart()}\n          ${W.guardAgainstOutOfBoundsWorkgroupSizes(V)}\n          var inputIndices: ${$.type.indices};\n          let outputIndices = ${S.offsetToIndices("global_idx")};\n\n          ${b.join(`\n`)}\n          ${x[0]}       // init ops for reduce max/min\n          ${P}\n          ${x[1]}\n          ${R}\n          ${x[3]}\n          ${x.length===4?S.setByOffset("global_idx","value"):x.slice(4).join(`\n`)}\n        }`,getRunData:()=>({outputs:[{dims:f,dataType:u}],dispatchGroup:{x:Math.ceil(V/64)}})}},Un=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(o=>r.push(Number(o))),ue({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},dt=(e,t,r,o)=>{let a=e.inputs,u=a.length===1?r:Un(a,r);e.compute(qr(t,{hint:u.cacheKey},[a[0]],u.noopWithEmptyAxes&&u.axes.length===0?Fl:o,u.axes,a[0].dataType,u.keepDims,u.noopWithEmptyAxes),{inputs:[0]})},Ll=(e,t)=>{ct(e.inputs),dt(e,"ReduceLogSum",t,(o,a)=>[`var value = ${a.type.storage}(0);`,"",`value += ${o.getByOffset("inputOffset")};`,"value = log(value);"])},Hl=(e,t)=>{ct(e.inputs),dt(e,"ReduceL1",t,(o,a)=>[`var value = ${a.type.storage}(0);`,"",`value += abs(${o.getByOffset("inputOffset")});`,""])},jl=(e,t)=>{ct(e.inputs),dt(e,"ReduceL2",t,(o,a)=>[`var t = ${a.type.value}(0); var value = ${a.type.value}(0);`,"",`t = ${o.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])},ql=(e,t)=>{ct(e.inputs),dt(e,"ReduceLogSumExp",t,(o,a)=>[`var value = ${a.type.storage}(0);`,"",`value += exp(${o.getByOffset("inputOffset")});`,"value = log(value);"])},Kl=(e,t)=>{ct(e.inputs),dt(e,"ReduceMax",t,(o,a,u)=>{let i=[];for(let d=0;d<o.rank;d++)(u.indexOf(d)>=0||u.length===0)&&i.push(o.indicesSet("inputIndices",d,0));return[`${i.join(`\n`)}`,`var value = ${o.getByOffset("inputOffset")};`,`value = max(value, ${o.getByOffset("inputOffset")});`,""]})},Yl=(e,t)=>{ct(e.inputs),dt(e,"ReduceMean",t,(o,a,u)=>{let i=1;for(let d=0;d<o.rank;d++)(u.indexOf(d)>=0||u.length===0)&&(i*=e.inputs[0].dims[d]);return["var sum = f32(0);","",`sum += f32(${o.getByOffset("inputOffset")});`,`let value = ${a.type.value}(sum / ${i});`]})},Jl=(e,t)=>{ct(e.inputs),dt(e,"ReduceMin",t,(o,a,u)=>{let i=[];for(let d=0;d<o.rank;d++)(u.indexOf(d)>=0||u.length===0)&&i.push(`inputIndices[${d}] = 0;`);return[`${i.join(`\n`)}`,`var value = ${o.getByOffset("inputOffset")};`,`value = min(value, ${o.getByOffset("inputOffset")});`,""]})},Xl=(e,t)=>{ct(e.inputs),dt(e,"ReduceProd",t,(o,a)=>[`var value = ${a.type.storage}(1);`,"",`value *= ${o.getByOffset("inputOffset")};`,""])},Zl=(e,t)=>{ct(e.inputs),dt(e,"ReduceSum",t,(o,a)=>[`var value = ${a.type.storage}(0);`,"",`value += ${o.getByOffset("inputOffset")};`,""])},Ql=(e,t)=>{ct(e.inputs),dt(e,"ReduceSumSquare",t,(o,a)=>[`var t = ${a.type.value}(0); var value = ${a.type.value}(0);`,"",`t = ${o.getByOffset("inputOffset")}; value += t * t;`,""])},pt=(e,t,r)=>{if(t.length===0)return!!r;let o=1,a=1;for(let u=0;u<t.length;u++)t.indexOf(u)===-1?o*=e[u]:a*=e[u];return a<32&&o>1024},Ea=(e,t)=>{pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Yl(e,t):ba(e,t)},_a=(e,t)=>{pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Hl(e,t):wa(e,t)},Pa=(e,t)=>{pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?jl(e,t):va(e,t)},Ra=(e,t)=>{pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ql(e,t):$a(e,t)},Ma=(e,t)=>{pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Kl(e,t):xa(e,t)},ka=(e,t)=>{pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Jl(e,t):Sa(e,t)},Ba=(e,t)=>{pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Xl(e,t):Ca(e,t)},Da=(e,t)=>{pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Zl(e,t):Aa(e,t)},Wa=(e,t)=>{pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Ql(e,t):Ia(e,t)},za=(e,t)=>{pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Ll(e,t):Ta(e,t)},rt=e=>ue(e)});var Va,Ua,Na,Ga,Nn,Fa=K(()=>{"use strict";We();Me();jr();Va=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},Ua=(e,t)=>ue({axis:t.axis,keepDims:t.keepDims,selectLastIndex:t.selectLastIndex}),Na=(e,t)=>{Va(e.inputs);let r=(a,u,i)=>{let d=[];for(let f=0;f<a.rank;f++)(i.indexOf(f)>=0||i.length===0)&&d.push(`inputIndices[${f}] = 0;`);return[`${d.join(`\n`)}`,`var value = ${a.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${a.getByOffset("inputOffset")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${a.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",u.setByOffset("global_idx","bestIndex")]},o=e.inputs.length===1?t:Ua(e.inputs,t);e.compute(qr("ArgMin",{hint:o.cacheKey},[e.inputs[0]],r,[o.axis],7,o.keepDims),{inputs:[0]})},Ga=(e,t)=>{Va(e.inputs);let r=(a,u,i)=>{let d=[];for(let f=0;f<a.rank;f++)(i.indexOf(f)>=0||i.length===0)&&d.push(`inputIndices[${f}] = 0;`);return[`${d.join(`\n`)}`,`var value = ${a.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${a.getByOffset("inputOffset")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${a.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",u.setByOffset("global_idx","bestIndex")]},o=e.inputs.length===1?t:Ua(e.inputs,t);e.compute(qr("argMax",{hint:o.cacheKey},[e.inputs[0]],r,[o.axis],7,o.keepDims),{inputs:[0]})},Nn=e=>ue(e)});var ec,tc,La,Ha=K(()=>{"use strict";ge();$e();ec=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},tc=e=>{let t=e[0].dims,r=e[0].dims[2],o=z.size(t)/4,a=e[0].dataType,u=H("input",a,t,4),i=H("bias",a,[r],4),d=H("residual",a,t,4),f=Y("output",a,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:c=>`\n  const channels = ${r}u / 4;\n  ${c.declareVariables(u,i,d,f)}\n\n  ${c.mainStart()}\n    ${c.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n    let value = ${u.getByOffset("global_idx")}\n      + ${i.getByOffset("global_idx % channels")} + ${d.getByOffset("global_idx")};\n    ${f.setByOffset("global_idx","value")}\n  }`}},La=e=>{ec(e.inputs),e.compute(tc(e.inputs))}});var rc,xe,ja,qa,Ka,Ya,Ja,Xa,Za,Qa,ei,Gn,nc,ti,ri,ni,oi,Kr,ai,Yr,ii,si,ui,li,ci,di,pi,fi,mi,hi,gi,yi,bi,wi,vi,$i,xi,Fn=K(()=>{"use strict";We();ge();Me();$e();rc=(e,t,r,o,a,u)=>{let i=Math.ceil(t/4),d="";typeof a=="string"?d=`${a}(a)`:d=a("a");let f=H("inputData",r,[i],4),h=Y("outputData",o,[i],4);return`\n      ${e.registerUniform("vec_size","u32").declareVariables(f,h)}\n\n  ${u??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n\n    let a = ${f.getByOffset("global_idx")};\n    ${h.setByOffset("global_idx",d)}\n  }`},xe=(e,t,r,o,a,u=e.dataType)=>({name:t,shaderCache:{hint:a,inputDependencies:["type"]},getShaderSource:i=>rc(i,z.size(e.dims),e.dataType,u,r,o),getRunData:i=>({outputs:[{dims:e.dims,dataType:u}],dispatchGroup:{x:Math.ceil(z.size(i[0].dims)/64/4)},programUniforms:[{type:"uint32",data:Math.ceil(z.size(e.dims)/4)}]})}),ja=e=>{e.compute(xe(e.inputs[0],"Abs","abs"))},qa=e=>{e.compute(xe(e.inputs[0],"Acos","acos"))},Ka=e=>{e.compute(xe(e.inputs[0],"Acosh","acosh"))},Ya=e=>{e.compute(xe(e.inputs[0],"Asin","asin"))},Ja=e=>{e.compute(xe(e.inputs[0],"Asinh","asinh"))},Xa=e=>{e.compute(xe(e.inputs[0],"Atan","atan"))},Za=e=>{e.compute(xe(e.inputs[0],"Atanh","atanh"))},Qa=e=>ue(e),ei=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${t.to}`)}e.compute(xe(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},Gn=(e,t)=>{let r=ke(e.inputs[0].dataType);e.compute(xe(e.inputs[0],"Clip",o=>`clamp(${o}, clip_min_, clip_max_)`,`\n    const clip_min_: vec4<${r}> = vec4(${r}(${t.min}));\n    const clip_max_: vec4<${r}> = vec4(${r}(${t.max}));\n`,t.cacheKey),{inputs:[0]})},nc=e=>{let t=e.length>=2?e[1].getFloat32Array()[0]:Lr,r=e.length>=3?e[2].getFloat32Array()[0]:Hr;return ue({min:t,max:r})},ti=e=>{let t=nc(e.inputs);Gn(e,t)},ri=e=>{e.compute(xe(e.inputs[0],"Ceil","ceil"))},ni=e=>{e.compute(xe(e.inputs[0],"Cos","cos"))},oi=e=>{e.compute(xe(e.inputs[0],"Cosh","cosh"))},Kr=e=>ue(e),ai=(e,t)=>{e.compute(xe(e.inputs[0],"Elu",r=>`elu_vf32(${r})`,`\n  const elu_alpha_: f32 = f32(${t.alpha});\n\n  fn elu_f32(a: f32) -> f32 {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},Yr=(e,t="f32")=>`\nconst r0: ${t} = 0.3275911;\nconst r1: ${t} = 0.254829592;\nconst r2: ${t} = -0.284496736;\nconst r3: ${t} = 1.421413741;\nconst r4: ${t} = -1.453152027;\nconst r5: ${t} = 1.061405429;\n\nfn erf_vf32(v: ${e}) -> ${e} {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,ii=e=>{let t=ke(e.inputs[0].dataType);e.compute(xe(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,Yr(`vec4<${t}>`,t)))},si=e=>{e.compute(xe(e.inputs[0],"Exp","exp"))},ui=e=>{e.compute(xe(e.inputs[0],"Floor","floor"))},li=e=>{let t=ke(e.inputs[0].dataType);e.compute(xe(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,Yr(`vec4<${t}>`,t)))},ci=(e,t)=>{e.compute(xe(e.inputs[0],"LeakyRelu",r=>`select(leaky_relu_alpha_ * ${r}, ${r}, ${r} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${t.alpha});`,t.cacheKey))},di=e=>{e.compute(xe(e.inputs[0],"Not",t=>`!${t}`))},pi=e=>{e.compute(xe(e.inputs[0],"Neg",t=>`-${t}`))},fi=e=>{e.compute(xe(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},mi=e=>{e.compute(xe(e.inputs[0],"Relu",t=>`select(vec4<f32>(0.0), ${t}, ${t} > vec4<f32>(0.0))`))},hi=e=>{e.compute(xe(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},gi=e=>{e.compute(xe(e.inputs[0],"Sin","sin"))},yi=e=>{e.compute(xe(e.inputs[0],"Sinh","sinh"))},bi=e=>{e.compute(xe(e.inputs[0],"Sqrt","sqrt"))},wi=e=>{e.compute(xe(e.inputs[0],"Tan","tan"))},vi=e=>{e.compute(xe(e.inputs[0],"Tanh","tanh"))},$i=(e,t)=>(e.compute(xe(e.inputs[0],"ThresholdedRelu",r=>`select(vec4<f32>(0.0), ${r}, ${r} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${t.alpha});`,t.cacheKey)),0),xi=e=>{e.compute(xe(e.inputs[0],"Log","log"))}});var ac,ic,Si,Ci=K(()=>{"use strict";ge();$e();Fn();ac=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},ic=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=H("input",e[0].dataType,e[0].dims,4),o=H("bias",e[0].dataType,[e[0].dims[2]],4),a=Y("output",e[0].dataType,t,4),u=z.size(t)/4;return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:d=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${d.declareVariables(r,o,a)}\n\n  ${Yr("vec4f")}\n\n  ${d.mainStart()}\n    ${d.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${a.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},Si=e=>{ac(e.inputs),e.compute(ic(e.inputs))}});var sc,uc,ft,Ai,Ii,Ti,Oi,Ei,_i,Pi,Ri,Mi,ki,Bi=K(()=>{"use strict";We();ge();$e();sc=(e,t,r,o,a,u,i,d,f,h,c,C)=>{let b,$;typeof i=="string"?b=$=(V,B)=>`${i}((${V}),(${B}))`:typeof i=="function"?b=$=i:(b=i.scalar,$=i.vector);let S=c?t.length:t,x=c?r.length:r,A=c?o.length:o,k=Y("outputData",h,A,4),O=H("aData",d,S,4),P=H("bData",f,x,4),R;if(a)if(u){let V=z.size(t)===1,B=z.size(r)===1;V||B?R=k.setByOffset("global_idx",$(V?`${O.type.value}(${O.getByOffset("0")}.x)`:O.getByOffset("global_idx"),B?`${P.type.value}(${P.getByOffset("0")}.x)`:P.getByOffset("global_idx"))):R=`\n            let outputIndices = ${k.offsetToIndices("global_idx * 4u")};\n            let offsetA = ${O.broadcastedIndicesToOffset("outputIndices",k)};\n            let offsetB = ${P.broadcastedIndicesToOffset("outputIndices",k)};\n            ${k.setByOffset("global_idx",$(O.getByOffset("offsetA / 4u"),P.getByOffset("offsetB / 4u")))}\n          `}else R=k.setByOffset("global_idx",$(O.getByOffset("global_idx"),P.getByOffset("global_idx")));else{if(!u)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let V=(B,W,q="")=>{let ee=`aData[indexA${W}][componentA${W}]`,oe=`bData[indexB${W}][componentB${W}]`;return`\n            let outputIndices${W} = ${k.offsetToIndices(`global_idx * 4u + ${W}u`)};\n            let offsetA${W} = ${O.broadcastedIndicesToOffset(`outputIndices${W}`,k)};\n            let offsetB${W} = ${P.broadcastedIndicesToOffset(`outputIndices${W}`,k)};\n            let indexA${W} = offsetA${W} / 4u;\n            let indexB${W} = offsetB${W} / 4u;\n            let componentA${W} = offsetA${W} % 4u;\n            let componentB${W} = offsetB${W} % 4u;\n            ${B}[${W}] = ${q}(${b(ee,oe)});\n          `};h===9?R=`\n            var data = vec4<u32>(0);\n            ${V("data",0,"u32")}\n            ${V("data",1,"u32")}\n            ${V("data",2,"u32")}\n            ${V("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:R=`\n            ${V("outputData[global_idx]",0)}\n            ${V("outputData[global_idx]",1)}\n            ${V("outputData[global_idx]",2)}\n            ${V("outputData[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(O,P,k)}\n\n        ${C??""}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${R}\n      }`},uc=(e,t,r,o,a,u,i=r.dataType)=>{let d=!z.areEqual(r.dims,o.dims),f=r.dims,h=z.size(r.dims),c=!1,C=[d];if(d){let $=st.calcShape(r.dims,o.dims,!1);if(!$)throw new Error("Can\'t perform binary op on the given tensors");f=$,h=z.size(f);let S=z.size(r.dims)===1,x=z.size(o.dims)===1;C.push(S),C.push(x);let A=1;for(let k=1;k<f.length;k++){let O=r.dims[r.dims.length-k]??1,P=o.dims[o.dims.length-k]??1;if(O===P)A*=O;else break}(A%4===0||S||x)&&(c=!0)}else c=!0;C.push(c);let b=wt(r.dims.length)&&wt(o.dims.length)&&wt(f.length);return{name:e,shaderCache:{hint:t+C.map($=>$.toString()).join("_"),inputDependencies:b?["rank","rank"]:["dims","dims"]},getShaderSource:$=>sc($,r.dims,o.dims,f,c,d,a,r.dataType,o.dataType,i,b,u),getRunData:()=>({outputs:[{dims:f,dataType:i}],dispatchGroup:{x:Math.ceil(h/64/4)},programUniforms:b?[{type:"uint32",data:Math.ceil(z.size(f)/4)},...ut(r.dims),...ut(o.dims),...ut(f)]:[{type:"uint32",data:Math.ceil(z.size(f)/4)}]})}},ft=(e,t,r,o,a,u)=>{e.compute(uc(t,a??"",e.inputs[0],e.inputs[1],r,o,u))},Ai=e=>{ft(e,"Add",(t,r)=>`${t}+${r}`)},Ii=e=>{ft(e,"Div",(t,r)=>`${t}/${r}`)},Ti=e=>{ft(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Oi=e=>{ft(e,"Mul",(t,r)=>`${t}*${r}`)},Ei=e=>{let t=H("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;ft(e,"Pow",{scalar:(o,a)=>`pow_custom(${o},${a})`,vector:(o,a)=>`pow_vector_custom(${o},${a})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},_i=e=>{ft(e,"Sub",(t,r)=>`${t}-${r}`)},Pi=e=>{ft(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},Ri=e=>{ft(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},Mi=e=>{ft(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},ki=e=>{ft(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var cc,dc,pc,fc,Di,Wi,zi=K(()=>{"use strict";ge();Me();$e();cc=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].dataType,r=e[0].dims.length;for(let o of e){if(o.dataType!==t)throw new Error("input tensors should be one type");if(o.dims.length!==r)throw new Error("input tensors should have the same shape")}},dc=(e,t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,pc=(e,t)=>{let r=e.length,o=[];for(let a=0;a<r;++a){let u=t.setByOffset("global_idx",e[a].getByIndices("indices"));r===1?o.push(u):a===0?o.push(`if (inputIndex == ${a}u) { ${u} }`):a===r-1?o.push(`else { ${u} }`):o.push(`else if (inputIndex == ${a}) { ${u} }`)}return o.join(`\n`)},fc=(e,t)=>{let r=e[0].dims.slice();if(t>=r.length||t<-1*r.length)throw new Error("axis specified for concat doesn\'t match input dimensionality");let o=t<0?r.length+t:t,a=r.slice(0);for(let R=1;R<e.length;R++){let V=e[R].dims.slice();for(let B=0;B<r.length;B++)if(B===o)a[o]+=V[B];else if(r[B]!==V[B])throw new Error("non concat dimensions must match")}let u=z.size(a),i=new Array(e.length),d=new Array(e.length),f=e[0].dataType,h=0,c=[],C=[],b=[],$=[{type:"uint32",data:u}];for(let R=0;R<e.length;++R)h+=e[R].dims[o],i[R]=h,b.push(wt(e[R].dims.length)),C.push(b[R]?e[R].dims.length:e[R].dims),d[R]=H(`input${R}`,f,C[R]),c.push(b[R]?"rank":"dims"),$.push({type:"uint32",data:i[R]});for(let R=0;R<e.length;++R)b[R]&&$.push(...ut(e[R].dims));let S=wt(a.length);S&&$.push(...ut(a));let x=S?a.length:a,A=Y("output",f,x),k=A.indicesGet("indices",o),O=Array.from(Array(i.length).keys()).map(R=>`uniforms.sizeInConcatAxis${R}`).join(","),P=R=>`\n\n  ${(()=>{R.registerUniform("outputSize","u32");for(let V=0;V<e.length;V++)R.registerUniform(`sizeInConcatAxis${V}`,"u32");return R.declareVariables(...d,A)})()}\n\n  ${dc(i.length,O)}\n\n  ${R.mainStart()}\n    ${R.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n    var indices = ${A.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${k});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${i.length}u>(${O});\n      ${k} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${pc(d,A)}\n  }`;return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:c},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:$}),getShaderSource:P}},Di=(e,t)=>{cc(e.inputs),e.compute(fc(e.inputs,t.axis))},Wi=e=>ue({axis:e.axis})});var It,Jr,Wt=K(()=>{"use strict";ge();It=(e,t)=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:`value = max(value, ${t}(0.0));`};case"Sigmoid":return{activationFunction:"",applyActivation:`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`};case"Clip":return{activationFunction:`const clip_min_=${t}(${e.clipMin});const clip_max_=${t}(${e.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},Jr=e=>{let t=e?.activation||"";if(t==="Clip"){let[r,o]=e?.activation_params||[Lr,Hr];return{activation:t,clipMax:o,clipMin:r,activationCacheKey:`${t}:${r},${o}`}}return{activation:t,activationCacheKey:t}}});var ze,Xr,Zr=K(()=>{"use strict";ze=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Xr=e=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      `});var Qr,Ln=K(()=>{"use strict";Qr=`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));\n}\n`});var mc,hc,yr,Vi,gc,br,yc,en,wr=K(()=>{"use strict";ge();$e();Wt();Zr();mc=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,hc=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,yr=(e,t,r="f32",o,a=!1,u=32,i=!1,d=32)=>{let f=t[1]*e[1],h=t[0]*e[0],c=a?f:u,C=a?u:f,b=c/t[0],$=u/t[1];if(!((a&&b===4&&e[1]===4||!a&&(b===3||b===4))&&c%t[0]===0&&u%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${a} is true, innerElementSize ${b} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${b} must be 3 or 4.\n  tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}. tileInner ${u} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${b}<${r}>, ${c/b}>, ${C}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${r}>, ${h/e[0]}>, ${u}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${b};\nconst tileInner = ${u};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${i?"0":"i32(globalId.z)"};\n  ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${f};\n\n  let numTiles = ${i?`${Math.ceil(d/u)}`:"(dimInner - 1) / tileInner + 1"};\n  var kStart = ${i?`i32(globalId.z) * ${d}`:"0"};\n\n  var acc: array<vec4<${r}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${$};\n  for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${mc(a,o)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${$}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${o?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${b===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${hc(a,b)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},Vi=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,gc=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",br=(e,t,r="f32",o,a=!1,u=32,i=!1,d=32,f=!1)=>{let h=e[1]*t[1],c=e[0]*t[0],C=a?h:u,b=a?u:h;if(!(b%t[1]===0&&C%t[0]===0&&u%t[1]===0))throw new Error(`tileAHight ${b} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${C} must be divisible by workgroupSize[0]${t[0]}, tileInner ${u} must be divisible by workgroupSize[1]${t[1]}`);let $=b/t[1],S=C/t[0],x=u/t[1],A=f?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${h};\n    let globalColStart = i32(workgroupId.x) * ${c};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${b}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${C}; inputCol = inputCol + ${t[0]}) {\n          ${Vi(a,o)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${u}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${o?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${r}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${a?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${h};\n\nlet tileRowA = i32(localId.y) * ${$};\nlet tileColA = i32(localId.x) * ${S};\nlet tileRowB = i32(localId.y) * ${x};\n// Loop over shared dimension.\nfor (var t = 0; t < numTiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${$}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${S}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Vi(a,o)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${x}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${o?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${r}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${gc(a)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${r}, ${C}>, ${b}>;\n  var<workgroup> mm_Bsub : array<array<${r}, ${c}>, ${u}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${u};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${i?"0":"i32(globalId.z)"};\n    ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n    let numTiles = ${i?`${Math.ceil(d/u)}`:"(dimInner - 1) / tileInner + 1"};\n    var kStart = ${i?`i32(globalId.z) * ${d}`:"0"};\n\n    var acc : array<array<${r}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${A}\n  }\n`},yc=(e,t,r,o,a,u=!1)=>{let i=a[0],d=a[1],f=a[2],h=o[0],c=o[1],C=o[2],b=o[3],$=Vn(i,f),S=Vn(d,f),x=ke(o[0].type.tensor),A=()=>{let P=c.rank,R=h.rank,V=`var aIndices: ${c.type.indices};`;for(let B=P-2-1,W=R-1;B>=0;B--,W--)V+=`\naIndices[${B}] = ${R>1?`batchIndices[${W}]`:"batchIndices"};`;return $.forEach(B=>{V+=`\naIndices[${B}] = 0;`}),V+=`\naIndices[${P-2}] = u32(row);\n                   aIndices[${P-1}] = u32(colIn);`,V},k=()=>{let P=C.rank,R=h.rank,V=`var bIndices: ${C.type.indices};`;for(let B=P-2-1,W=R-1;B>=0;B--,W--)V+=`\nbIndices[${B}] = ${R>1?`batchIndices[${W}]`:"batchIndices"};`;return S.forEach(B=>{V+=`\nbIndices[${B}] = 0;`}),V+=`\nbIndices[${P-2}] = u32(row);\n                   bIndices[${P-1}] = u32(colIn);`,V};return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${h.type.indices}) -> ${ze(e,x)} {\n      var value = ${ze(e,x)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimAOuter && col < dimInner)\n      {\n        ${A()}\n        value = ${c.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${h.type.indices}) -> ${ze(e,x)} {\n      var value = ${ze(e,x)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimInner && col < dimBOuter)\n      {\n        ${k()}\n        value = ${C.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${ze(e,x)}) {\n      let col = colIn * ${e};\n      if (row < dimAOuter && col < dimBOuter) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${u?"bias[colIn]":`${ze(e,x)}(bias[row])`};`:""}\n        ${r}\n        ${b.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},en=(e,t,r,o,a=!1)=>{let u=e[0].dims,i=e[1].dims,d=u.slice(0,-2),f=i.slice(0,-2),h=o?o.slice(0,-2):r.slice(0,-2),c=H("batchDims",e[0].dataType,h),C=[c],b=[d,f,h],$=z.size(h),S=u[u.length-2],x=u[u.length-1],A=i[i.length-1],k=x%4===0&&A%4===0,O=S<=8?[4,1,1]:[4,4,1],P=[8,8,1],R=[Math.ceil(A/P[0]/O[0]),Math.ceil(S/P[1]/O[1]),Math.ceil($/P[2]/O[2])],V=ke(e[0].dataType),B=k?4:1,W=H("a",e[0].dataType,[...d,S,x/B],B),q=H("b",e[1].dataType,[...f,x,A/B],B),ee=Y("result",e[0].dataType,[$,S,A/B],B);C.push(W),C.push(q),C.push(ee);let oe=[W,q],D=e.length>2,{activationFunction:te,applyActivation:Ie}=It(t,ee.type.value),Z=yc(B,D,Ie,C,b,a);if(D){let Te=a?B:1;oe.push(H("bias",e[2].dataType,e[2].dims,Te))}let ve=Te=>`\n  const dimAOuter: i32 = ${S};\n  const dimBOuter: i32 = ${A};\n  const dimInner: i32 = ${x};\n  ${Te.declareVariables(...oe,ee)}\n  ${te}\n  ${Z}\n  ${k?yr(O,P,V,c):br(O,P,V,c)}\n                   ${c.impl()}`;return{name:"MatMul",shaderCache:{hint:t.activationCacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:R[0],y:R[1],z:R[2]}}),getShaderSource:ve}}});var bc,Ui,Ni=K(()=>{"use strict";St();ge();$e();Wt();Zr();Ln();wr();bc=(e,t,r,o,a=!1,u,i=4,d=4,f=4,h="f32")=>{let c=D=>{switch(D){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${h}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${D} is not supported.`)}},C=D=>{switch(D){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${D} is not supported.`)}},b=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,$=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,S=e?"xShape[1]":"xShape[2]",x=e?"xShape[2]":"xShape[3]",A=e?"row":"col",k=e?"col":"row",O=`\n    let inChannels = wShape[2];\n    let outWidth = ${e?"outShape[2]":"outShape[3]"};\n    let outRow = ${A} / outWidth;\n    let outCol = ${A} % outWidth;\n\n    let WRow = ${k} / (filterDims[1] * inChannels);\n    let WCol = ${k} / inChannels % filterDims[1];\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\n    let xCh = ${k} % inChannels;\n    var resData = ${ze(i,h)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the \'same\' padding type.\n    if (xRow >= 0 && xRow < ${S} && xCol >= 0 && xCol < ${x}) {\n      ${b}\n      let xIndex = getIndexFromCoords4D(coord, xShape);\n      ${c(i)}\n    }\n    return resData;`,P=e?t&&o?`\n    let col = colIn * ${i};\n    ${O}`:`\n    let col = colIn * ${i};\n    if (row < dimAOuter && col < dimInner) {\n      ${O}\n    }\n    return ${ze(i,h)}(0.0);`:o&&r?`\n    let col = colIn * ${i};\n    ${O}`:`\n    let col = colIn * ${i};\n    if (row < dimInner && col < dimBOuter) {\n      ${O}\n    }\n    return ${ze(i,h)}(0.0);`,R=`${C(d)}`,V=ze(f,h),B=e?ze(i,h):ze(d,h),W=e?ze(d,h):ze(i,h),{activationFunction:q,applyActivation:ee}=It(u,V);return`\n    ${q}\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${B} {\n      ${e?P:R}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${W} {\n      ${e?R:P}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${V}) {\n      let col = colIn * ${f};\n      if (row < dimAOuter && col < dimBOuter)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${$}\n      ${Xr(a)}\n      ${ee}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},Ui=(e,t,r,o,a,u,i,d)=>{let f=t.format==="NHWC",h=f?e[0].dims[3]:e[0].dims[1],c=r[0],C=f?r[2]:r[3],b=f?r[1]:r[2],$=f?r[3]:r[1],S=f&&(h%4===0||h%3===0)&&$%4===0,x=f?$:C*b,A=f?C*b:$,k=[8,8,1],O=o<=8?[4,1,1]:[4,4,1],P=[Math.ceil(x/k[0]/O[0]),Math.ceil(A/k[1]/O[1]),Math.ceil(c/k[2]/O[2])];Ee("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${P}`);let R=S?f&&h%4!==0?3:4:O[0],V=k[1]*O[1],B=k[0]*O[0],W=Math.max(k[0]*R,k[1]),q=o%V===0,ee=a%B===0,oe=u%W===0,D=S?[R,4,4]:[1,1,1],te=ke(e[0].dataType),Ie=[`@group(0) @binding(0) var<storage, read> x: array<${S&&R===4?`vec4<${te}>`:te}>;`,`@group(0) @binding(1) var<storage, read> w: array<${S?`vec4<${te}>`:te}>;`],Z=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${S?`vec4<${te}>`:te}) {\n        result[flatIndex] = ${S?`vec4<${te}>`:te}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${S?`vec4<${te}>`:te}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${S?"/ 4":""}, value);\n      }`;return i&&(Ie.push(`@group(0) @binding(2) var<storage, read> bias: array<${S?`vec4<${te}>`:te}>;`),Z+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${S?`vec4<${te}>`:te} {\n          return bias[coords.${f?"w":"y"}${S?"/ 4":""}];\n        }`),{name:"Conv2DMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:P[0],y:P[1],z:P[2]}}),getShaderSource:()=>`\n        ${Qr}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${Ie.join("")}\n        @group(0) @binding(${Ie.length}) var<storage, read_write> result: array<${S?`vec4<${te}>`:te}>;\n        //@group(0) @binding(${Ie.length+1}) var<uniform> uniforms: Uniforms;\n\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${z.computeStrides(r).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[0]}, ${t.kernelShape[1]});\n        const pad : vec2<i32> = vec2<i32>(${t.pads[0]}, ${t.pads[1]});\n        const stride : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${o};\n        const dimBOuter : i32 = ${a};\n        const dimInner : i32 = ${u};\n        ${Z}\n        ${bc(f,q,ee,oe,i,t,D[0],D[1],D[2],te)}\n            ${S?yr(O,k,te,void 0,!f,W):br(O,k,te,void 0,!f,W,!1,void 0,d)}`}}});var Hn,Gi=K(()=>{"use strict";ge();$e();qn();Wt();Hn=(e,t,r)=>{let o=e.length>2,a=o?"value += b[output_channel];":"",u=e[0].dims,i=e[1].dims,d=i[0]/t.group,f=t.format==="NHWC",h=jn(u,i,t.dilations,t.pads,t.strides,f),c=z.size(h),C=Y("output",e[0].dataType,h),{activationFunction:b,applyActivation:$}=It(t,C.type.value),S=H("x",e[0].dataType,u),x=H("w",e[1].dataType,i),A=[S,x];o&&A.push(H("b",e[2].dataType,e[2].dims));let k=O=>`\n  const strides: vec2<u32> = vec2(${t.strides[0]}u, ${t.strides[1]}u);\n  const pads: vec2<u32> = vec2(${t.pads[0]}u, ${t.pads[1]}u);\n\n  ${O.declareVariables(...A,C)}\n\n  ${b}\n\n  ${O.mainStart()}\n    ${O.guardAgainstOutOfBoundsWorkgroupSizes(c)}\n\n    let outputIndices = ${C.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${f?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${f?1:2}], outputIndices[${f?2:3}]) * strides - pads;\n    let group_id: u32 = output_channel / ${d}u;\n\n    var value: ${C.type.value} = ${C.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < ${i[1]}u; wInChannel++) {\n      let input_channel = group_id * ${i[1]}u + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < ${i[2]}u; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * ${t.dilations[0]}u;\n\n        if (xHeight < 0u || xHeight >= ${u[f?1:2]}u) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < ${i[3]}u; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * ${t.dilations[1]}u;\n          if (xWidth < 0u || xWidth >= ${u[f?2:3]}u) {\n            continue;\n          }\n\n          let xVal = ${f?S.get("batch","xHeight","xWidth","input_channel"):S.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${x.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${a}\n    ${$}\n    ${C.setByOffset("global_idx","value")}\n  }`;return{name:"GroupedConv",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r?r(h):h,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)}}),getShaderSource:k}}});var jn,Fi,wc,Li,Kn,vc,$c,Yn,qn=K(()=>{"use strict";ge();Me();Ni();wr();Gi();Wt();gr();jn=(e,t,r,o,a,u)=>{let i=e[0],d=e.slice(u?1:2,u?3:4),f=d.length,h=t[0],C=t.slice(2).map((S,x)=>S+(S-1)*(r[x]-1)),$=d.map((S,x)=>S+o[x]+o[x+f]).map((S,x)=>Math.floor((S-C[x]+a[x])/a[x]));return $.splice(0,0,i),$.splice(u?3:1,0,h),$},Fi=[2,3,1,0],wc=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[1]*t.group;if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let a=e[0].dims.length-2;if(t.dilations.length!==a)throw new Error(`dilations should be ${a}D`);if(t.strides.length!==a)throw new Error(`strides should be ${a}D`);if(t.pads.length!==a*2)throw new Error(`pads should be ${a*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},Li=(e,t)=>{let r=e.kernelShape.slice();for(let u=2;u<t[1].dims.length;++u)r[u-2]===0&&(r[u-2]=t[1].dims[u]);let o=e.pads.slice();Bt.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,o,e.format==="NHWC",e.autoPad);let a=Object.assign({},e);return Object.assign(a,{kernelShape:r,pads:o,cacheKey:e.cacheKey}),a},Kn=e=>{let t=Jr(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],a=e.dilations,u=e.group,i=e.kernel_shape,d=e.pads,f=e.strides,h=e.w_is_const();return ue({autoPad:o,format:r,dilations:a,group:u,kernelShape:i,pads:d,strides:f,wIsConst:h,...t})},vc=(e,t,r)=>{let o=Li(r,t);if(r.group!==1){e.compute(Hn(t,o));return}let a=r.format==="NHWC",u=t.length===3,i=t[0].dims[a?1:2],d=t[0].dims[a?2:3],f=t[0].dims[a?3:1],h=t[1].dims[2],c=t[1].dims[3],C=jn(t[0].dims,t[1].dims,r.dilations,o.pads,r.strides,a),b=C[a?1:2],$=C[a?2:3],S=C[a?3:1],x=a&&h===i&&c===d&&r.pads[0]===0&&r.pads[1]===0;if(x||h===1&&c===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let B=C[0],W,q,ee,oe=[];if(a){let D=e.kernelCustomData.wT??e.compute(At(t[1],Fi),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=D),x){let te=i*d*f;W=t[0].reshape([1,B,te]),q=D.reshape([1,te,S]),ee=[1,B,S]}else W=t[0].reshape([B,i*d,f]),q=D.reshape([1,f,S]),ee=[B,b*$,S];oe.push(W),oe.push(q)}else W=t[0].reshape([B,f,i*d]),q=t[1].reshape([1,S,f]),ee=[B,S,b*$],oe.push(q),oe.push(W);u&&oe.push(t[2]),e.compute(en(oe,o,C,ee,a),{inputs:oe});return}let A=!0,k=e.kernelCustomData.wT??e.compute(At(t[1],Fi),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=k);let O=[t[0],k];u&&O.push(t[2]);let P=a?b*$:S,R=a?S:b*$,V=h*c*f;e.compute(Ui(O,o,C,P,R,V,u,A),{inputs:O})},$c=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&o.push(e.inputs[2]);let a=[0,t.pads[0],0,t.pads[1]],u=[1].concat(t.strides),i=[1].concat(t.dilations),d=[1].concat(t.kernelShape),f=Li({...t,pads:a,strides:u,dilations:i,kernelShape:d},o);e.compute(Hn(o,f,h=>r?[h[0],h[2],h[3]]:[]))},Yn=(e,t)=>{wc(e.inputs,t),e.inputs[0].dims.length===3?$c(e,t):vc(e,e.inputs,t)}});var xc,Hi,ji=K(()=>{"use strict";St();ge();Wt();Zr();Ln();wr();xc=(e,t=!1,r,o=4)=>{let a=ze(o,"f32"),u=O=>{switch(O){case 1:return"return W[getIndexFromCoords4D(coord, wShape)];";case 4:return`\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            `;default:throw new Error(`innerElementSize ${O} is not supported.`)}},i=e?`\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      `:`\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      `,d=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,f=e?"outBackprop[1]":"outBackprop[2]",h=e?"outBackprop[2]":"outBackprop[3]",c=e?"row":"col",C=e?"col":"row",b=`\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      let outRow = ${c} / outWidth;\n      let outCol = ${c} % outWidth;\n\n      let WRow = ${C} / (filterDims[1] * inChannels);\n      let WCol = ${C} / inChannels % filterDims[1];\n      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);\n      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);\n      if (xR < 0.0 || xR >= f32(${f}) || fract(xR) > 0.0) {\n        return ${a}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${h}) || fract(xC) > 0.0) {\n        return ${a}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${C} % inChannels;\n      ${i}\n      return x[getIndexFromCoords4D(coord, xShape)/${o}];`,$=e?`\n      let col = colIn * ${o};\n      if (row < dimAOuter && col < dimInner) {\n        ${b}\n      }\n      return ${a}(0.0);`:`\n      let col = colIn * ${o};\n      if (row < dimInner && col < dimBOuter) {\n        ${b}\n      }\n      return ${a}(0.0);`,S=`\n      let col = colIn * ${o};\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);\n      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];\n      if (${e?"row < dimInner && col < dimBOuter":"row < dimInner && col < dimAOuter"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${u(o)}\n      }\n      return ${a}(0.0);\n      `,{activationFunction:x,applyActivation:A}=It(r,a);return`\n      ${x}\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${a} {\n    ${e?$:S}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${a} {\n    ${e?S:$}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${a}) {\n    let col = colIn * ${o};\n    if (row < dimAOuter && col < dimBOuter) {\n      var value = valueInput;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${d}\n      ${Xr(t)}\n      ${A}\n      result[getIndexFromCoords4D(coords, outShape)/${o}] = value;\n    }\n  }`},Hi=(e,t,r,o,a,u,i,d)=>{let f=t.format==="NHWC",h=f?e[0].dims[3]:e[0].dims[1],c=r[0],C=f?r[2]:r[3],b=f?r[1]:r[2],$=f?r[3]:r[1],S=f?h%4===0&&$%4===0:C%4===0&&$%4===0,x=f?$:C*b,A=f?C*b:$,k=S?[8,8,1]:[x<=4||A<=4?4:16,x>4&&A<=4?4:16,1],O=S?[4,4,1]:[x<=4?1:4,x>4&&A<=4?1:4,1],P=[Math.ceil(x/k[0]/O[0]),Math.ceil(A/k[1]/O[1]),Math.ceil(c/k[2]/O[2])];Ee("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${P}`);let R=S?4:1,V=Math.max(k[0]*R,k[1]),B=[`@group(0) @binding(0) var<storage, read> x: array<${S?"vec4<f32>":"f32"}>;`,"@group(0) @binding(1) var<storage, read> W: array<f32>;"],W="";return i&&(B.push(`@group(0) @binding(2) var<storage, read> bias: array<${S?"vec4<f32>":"f32"}>;`),W+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${S?"vec4<f32>":"f32"} {\n          return bias[coords.${f?"w":"y"}${S?"/ 4":""}];\n        }`),{name:"Conv2DTransposeMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:P[0],y:P[1],z:P[2]}}),getShaderSource:()=>`\n        ${Qr}\n        ${B.join(`\n`)}\n        @group(0) @binding(${B.length}) var<storage, read_write> result: array<${S?"vec4<f32>":"f32"}>;\n        const outBackprop : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${z.computeStrides(r).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[f?1:2]}, ${t.kernelShape[f?2:3]});\n        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(\n              ${t.dilations[0]<=1?0:(t.kernelShape[f?1:2]-1)*(t.dilations[0]-1)},\n              ${t.dilations[1]<=1?0:(t.kernelShape[f?2:3]-1)*(t.dilations[1]-1)});\n        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${t.pads[0]+t.pads[2]})/2,\n                                         i32(effectiveFilterDims[1]) - 1 - (${t.pads[1]+t.pads[3]})/2);\n        const strides : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${o};\n        const dimBOuter : i32 = ${a};\n        const dimInner : i32 = ${u};\n        ${W}\n        ${xc(f,i,t,R)}\n        ${S?yr(O,k,"f32",void 0,!f,V):br(O,k,"f32",void 0,!f,V,!1,void 0,d)}`}}});var Sc,Jn,qi=K(()=>{"use strict";St();ge();$e();Sc=(e,t,r,o,a,u,i=!1,d)=>{let f=r.format==="NHWC",h=f?1:2,c=f?2:3,C=f?3:1,b=z.size(o),$=i?2:1,S=r.group,x=t[1].dims,A=x[0]/S,k=x[1],O=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${i?`vec4<${d}>`:d}) {\n    result[flatIndex] = ${i?`vec4<${d}>`:d}(value);\n  }`;a&&(O+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${i?`vec4<${d}>`:d} {\n      return bias[coords.${f?"w":"y"}${i?"/ 4":""}];\n    }`);let P=i?4:1,R=H("W",t[1].dataType,t[1].dims,P),V=H("Dy",t[0].dataType,t[0].dims,P),B=[V,R];a&&B.push(H("bias",t[2].dataType,[o[C]],P));let W=Y("result",t[0].dataType,o,P),q=`{\n        let batch: u32 = ${u?"global_id.z":"workgroup_id.z"} / outShape[1];\n        let r = ${u?"global_id.z":"workgroup_id.z"} % outShape[1];\n        let c = ${u?"global_id.y":"workgroup_id.y"} * ${$};\n        let d1: u32 = ${u?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${d}>, ${$}>;\n        for (var i = 0; i < ${$}; i++) {\n          dotProd[i] = vec4<${d}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {\n          var dyR = (${d}(dyCorner.x) + ${d}(wR)) / ${d}(strides.x);\n          let wRPerm = filterDims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${d}(outBackprop[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {\n            let dyC = (${d}(dyCorner.y) + ${d}(wC)) / ${d}(strides.y);\n            let dyC2 = (${d}(dyCorner.y) + 1.0 + ${d}(wC)) / ${d}(strides.y);\n            let wCPerm = filterDims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${d}(outBackprop[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${d}(outBackprop[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${V.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${V.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${d}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = outBackprop[${C}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${V.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${R.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${V.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${$}; i = i + 1) {\n          let value = dotProd[i] + ${a?"bias[c+i]":"0.0"};\n          ${W.set("batch","r","c + i","d1","value")};\n        }\n      }`,ee=`\n          let outputIndices = ${W.offsetToIndices("global_idx")};\n          let batch = ${W.indicesGet("outputIndices",0)};\n          let d1 = ${W.indicesGet("outputIndices",C)};\n          let r = ${W.indicesGet("outputIndices",h)};\n          let c = ${W.indicesGet("outputIndices",c)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / ${k};\n          let wOutChannel = d1 - groupId * ${k};\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = 0.0;\n          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {\n            if (wR % dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${d}(dyRCorner) + ${d}(wR)) / ${d}(strides[0]);\n            let wRPerm = filterDims.x - 1 - wR / dilations.x;\n            if (dyR < 0.0 || dyR >= ${d}(outBackprop[${h}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {\n              if (wC % dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${d}(dyCCorner) + ${d}(wC)) / ${d}(strides.y);\n              let wCPerm = filterDims.y - 1 - wC / dilations.y;\n              if (dyC < 0.0 || dyC >= ${d}(outBackprop[${c}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * ${A};\n              for (var d2: u32 = 0; d2 < ${A}; d2 = d2 + 1) {\n                let xValue = ${f?V.get("batch","idyR","idyC","inputChannel"):V.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${R.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${a?"bias[d1]":"0.0"};\n          ${W.setByOffset("global_idx","value")};\n        `;return`\n  ${e.declareVariables(...B,W)}\n  ${O}\n  const outShape : vec4<u32> = vec4<u32>(${o.join(",")});\n  const outBackprop : vec4<u32> = vec4<u32>(${t[0].dims.join(",")});\n  const strides : vec2<u32> = vec2<u32>(${r.strides[0]}, ${r.strides[1]});\n  const filterDims : vec2<u32> = vec2<u32>(${r.kernelShape[f?1:2]}, ${r.kernelShape[f?2:3]});\n  const dilations : vec2<u32> = vec2<u32>(${r.dilations[0]}, ${r.dilations[1]});\n  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(\n          ${r.dilations[0]<=1?0:(r.kernelShape[f?1:2]-1)*(r.dilations[0]-1)},\n          ${r.dilations[1]<=1?0:(r.kernelShape[f?2:3]-1)*(r.dilations[1]-1)});\n  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,\n                                     i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)};\n  ${i?q:ee}}`},Jn=(e,t,r)=>{let o=e.length>2,a=t.outputShape,u=z.size(a),i=[Math.ceil(u/64),1,1];Ee("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${i}`);let d=ke(e[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:t.cacheKey},getRunData:()=>({dispatchGroup:{x:i[0],y:i[1],z:i[2]},outputs:[{dims:r?r(a):a,dataType:e[0].dataType}]}),getShaderSource:f=>Sc(f,e,t,a,o,i[1]===1&&i[2]===1,!1,d)}}});var Cc,Ac,Ic,Ki,Yi,Tc,Oc,Ec,_c,Ji,Xi=K(()=>{"use strict";Me();ji();qi();Wt();gr();Cc=(e,t,r,o,a,u)=>(e-1)*t+r+(o-1)*a+1-u,Ac=(e,t,r,o,a)=>{let u=Math.floor(e/2);t==="SAME_UPPER"?(r[o]=u,r[a]=e-u):t==="SAME_LOWER"&&(r[o]=e-u,r[a]=u)},Ic=(e,t,r,o,a,u,i,d,f,h)=>{let c=e.length-2,C=h.length===0;if(f.length===0)for(let S=0;S<c;++S)f.push(0);let b=e[0],$=t[d?3:1]*a;for(let S=0,x=e.length-c-(d?1:0);S<c;++S,++x){let A=e[x],k=C?A*i[S]:h[S],O=Cc(A,i[S],u[S],t[x],r[S],k);Ac(O,o,u,S,S+c),C&&h.push(i[S]*(A-1)+f[S]+(t[x]-1)*r[S]+1-u[S]-u[S+c])}h.splice(0,0,b),h.splice(d?3:1,0,$)},Ki=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((b,$)=>b*$,1)===0){r.length=0;for(let b=2;b<t[1].dims.length;++b)r.push(t[1].dims[b])}let o=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(o?3:1,0,t[1].dims[1]);let a=e.pads.slice(),u=e.outputShape.slice(),i=e.outputPadding.slice(),d=t[0].dims,f=e.dilations.slice();if(f.reduce((b,$)=>b+$,0)===0){let b=t[0].dims.length-2;f=new Array(b).fill(1)}let h=e.strides.slice();if(h.reduce((b,$)=>b+$,0)===0){let b=t[0].dims.length-2;h=new Array(b).fill(1)}Ic(d,r,f,e.autoPad,e.group,a,h,o,i,u);let c=Object.assign({},e),C=e.cacheKey+[r.join("n,"),a.join(","),h.join(","),i.join(","),u.join(","),f.join(",")].join("_");return Object.assign(c,{kernelShape:r,pads:a,outputPadding:i,outputShape:u,dilations:f,strides:h,cacheKey:C}),c},Yi=e=>{let t=Jr(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],a=e.dilations,u=e.group,i=e.kernelShape,d=e.pads,f=e.strides,h=e.wIsConst(),c=e.outputPadding,C=e.outputShape;return ue({autoPad:o,format:r,dilations:a,group:u,kernelShape:i,outputPadding:c,outputShape:C,pads:d,strides:f,wIsConst:h,...t})},Tc=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[0];if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let a=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==a))throw new Error("invalid bias");let u=e[0].dims.length-2;if(t.dilations.reduce((c,C)=>c+C,0)>0&&t.dilations.length!==u)throw new Error(`dilations should be ${u}D`);if(t.strides.reduce((c,C)=>c+C,0)>0&&t.strides.length!==u)throw new Error(`strides should be ${u}D`);if(t.pads.reduce((c,C)=>c+C,0)>0&&t.pads.length!==u*2)throw new Error(`pads should be ${u*2}D`);if(t.outputPadding.length!==u&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${u}D`);if(t.kernelShape.reduce((c,C)=>c+C,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},Oc=[2,3,1,0],Ec=(e,t,r)=>{let o=Ki(r,t),a=r.format==="NHWC",u=t.length===3;if(o.group!==1){e.compute(Jn(t,o));return}let i=o.outputShape,d=i[a?1:2],f=i[a?2:3],h=i[a?3:1],c=t[1].dims[2],C=t[1].dims[3],b=t[0].dims[a?3:1],$=a?d*f:h,S=a?h:d*f,x=c*C*b,A=!0,k=e.kernelCustomData.wT??e.compute(At(t[1],Oc),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=k);let O=[t[0],k];u&&(!a&&t[2].dims.length===1?O.push(t[2].reshape([t[2].dims[0],1,1])):O.push(t[2])),e.compute(Hi(O,o,i,$,S,x,u,A),{inputs:O})},_c=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];o.length===3&&o.push(e.inputs[2]);let a=t.kernelShape;(a.length===0||a[0]===0)&&(a=[e.inputs[1].dims[2]]);let u=t.dilations;(u.length===0||u[0]===0)&&(u=[1]);let i=t.strides;(i.length===0||i[0]===0)&&(i=[1]);let d=t.pads;d.length===0&&(d=[0,0]),d=[0,d[0],0,d[1]],i=[1].concat(i),u=[1].concat(u),a=[1].concat(a);let f=Ki({...t,pads:d,strides:i,dilations:u,kernelShape:a},o);e.compute(Jn(o,f,h=>r?[h[0],h[2],h[3]]:[h[0],h[1],h[3]]))},Ji=(e,t)=>{Tc(e.inputs,t),e.inputs[0].dims.length===3?_c(e,t):Ec(e,e.inputs,t)}});var Xn,tn,Zi,Pc,Rc,Zn,Qn,Mc,Qi,es,ts=K(()=>{"use strict";ge();Me();$e();Xn="[a-zA-Z]|\\\\.\\\\.\\\\.",tn="("+Xn+")+",Zi="^"+tn+"$",Pc="("+tn+",)*"+tn,Rc="^"+Pc+"$",Zn=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let o=this.symbolToIndices.get(t);o===void 0?o=[r]:o.push(r),this.symbolToIndices.set(t,o)}},Qn=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[o,a]=r.includes("->")?r.split("->",2):[r,""];if(!o.match(RegExp(Rc)))throw new Error("Invalid LHS term");if(o.split(",").forEach((d,f)=>{let h=t[f].dims.slice();if(!d.match(RegExp(Zi)))throw new Error("Invalid LHS term");let c=this.processTerm(d,!0,h,f);this.lhs.push(c)}),a==="")a+=[...this.symbolToInfo.entries()].filter(([d,f])=>f.count===1||d==="...").map(([d])=>d).join("");else if(!a.match(RegExp(tn)))throw new Error("Invalid RHS");a.match(RegExp(Xn,"g"))?.forEach(d=>{if(d==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let f=this.symbolToInfo.get(d);if(f===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(f.dimValue)}}),this.rhs=this.processTerm(a,!0,this.outputDims)}addSymbol(t,r,o){let a=this.symbolToInfo.get(t);if(a!==void 0){if(a.dimValue!==r&&a.count!==1)throw new Error("Dimension mismatch");a.count++,a.inputIndices.push(o)}else a={count:1,dimValue:r,inputIndices:[o]};this.symbolToInfo.set(t,a)}processTerm(t,r,o,a=-1){let u=o.length,i=!1,d=[],f=0;if(!t.match(RegExp(Zi))&&!r&&t!=="")throw new Error("Invalid LHS term");let h=t.match(RegExp(Xn,"g")),c=new Zn(a);return h?.forEach((C,b)=>{if(C==="..."){if(i)throw new Error("Only one ellipsis is allowed per input term");i=!0;let $=u-h.length+1;if($<0)throw new Error("Ellipsis out of bounds");if(d=o.slice(f,f+$),this.hasEllipsis){if(this.ellipsisDims.length!==d.length||this.ellipsisDims.toString()!==d.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=d;else throw new Error("Ellipsis must be specified in the LHS");for(let S=0;S<d.length;S++){let x=String.fromCharCode("0".charCodeAt(0)+b);c.addSymbol(x,b+S),this.addSymbol(x,o[f++],a)}}else c.addSymbol(C,b),this.addSymbol(C,o[f++],a)}),c}},Mc=(e,t)=>{let r=e[0].dataType,o=new Array(e.length);for(let P=0;P<e.length;++P)o[P]=H(`input${P}`,r,e[P].dims);let a=t.outputDims,u=z.size(a),i=Y("output",r,a),d=[],f=Array.from(t.rhs.symbolToIndices.keys()),h="var prod = 1.0;",c="var sum = 0.0;",C="sum += prod;",b=[],$=[],S=[],x=[],A=t.symbolToInfo.size===f.length;t.symbolToInfo.forEach((P,R)=>{if(f.includes(R)){let V=f.indexOf(R);t.lhs.forEach((B,W)=>{if(P.inputIndices.includes(W)){let q=B.symbolToIndices.get(R);if(q===void 0)throw new Error("Invalid symbol error");q.forEach(ee=>{d.push(`${o[W].indicesSet(`input${W}Indices`,ee,i.indicesGet("outputIndices",V))}`)})}})}else t.lhs.forEach((V,B)=>{let W=t.symbolToInfo.get(R);if(W===void 0)throw new Error("Invalid symbol error");if(W.inputIndices.includes(B)){let q=V.symbolToIndices.get(R);if(q===void 0)throw new Error("Invalid symbol error");q.forEach(ee=>{b.push(`${o[B].indicesSet(`input${B}Indices`,ee,`${R}`)}`)}),x.push(`prod *= ${o[B].getByIndices(`input${B}Indices`)};`)}}),$.push(`for(var ${R}: u32 = 0; ${R} < ${t.symbolToInfo.get(R)?.dimValue}; ${R}++) {`),S.push("}")});let k=A?[...d,`let sum = ${o.map((P,R)=>P.getByIndices(`input${R}Indices`)).join(" * ")};`]:[...d,c,...$,...b,h,...x,C,...S],O=P=>`\n      ${P.declareVariables(...o,i)}\n\n      ${P.mainStart()}\n        ${P.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n        var outputIndices = ${i.offsetToIndices("global_idx")};\n        ${o.map((R,V)=>`var input${V}Indices: ${o[V].type.indices};`).join(`\n`)}\n        ${k.join(`\n`)};\n        ${i.setByOffset("global_idx","sum")};\n      }`;return{name:"Einsum",shaderCache:{hint:t.equation},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:O}},Qi=(e,t)=>{let r=new Qn(e.inputs,t.equation);e.compute(Mc(e.inputs,r))},es=e=>{let t=e.equation.replace(/\\s+/g,"");return ue({equation:t})}});var kc,rs,Bc,Dc,ns,os=K(()=>{"use strict";ge();$e();kc=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=r.length<t.length?0:r.length-t.length,a=t.length<r.length?0:t.length-r.length;for(;o<r.length&&a<t.length;++o,++a)if(r[o]!==t[a]&&r[o]!==1&&t[a]!==1)throw new Error("Expand requires shape to be broadcastable to input")},rs=(e,t)=>{let r=e.length-t.length,o=[];for(let a=0;a<r;++a)o.push(e[a]);for(let a=0;a<t.length;++a)o.push(t[a]===1?e[a+r]:t[a]);return o},Bc=(e,t)=>e.length>t.length?rs(e,t):rs(t,e),Dc=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=Bc(t,r),a=z.size(o),u=e[0].dataType,i=H("input",u,t),d=Y("output",u,o),f=h=>`\n  const inputShape = ${i.indices(...t)};\n  ${h.declareVariables(i,d)}\n  ${h.mainStart()}\n  ${h.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n    let outputIndices = ${d.offsetToIndices("global_idx")};\n    var inputIndices: ${i.type.indices};\n    for (var i = 0; i < ${t.length}; i++) {\n      if (${i.indicesGet("inputShape","i")} == 1) {\n        ${i.indicesSet("inputIndices","i",0)}\n      } else {\n        ${i.indicesSet("inputIndices","i",d.indicesGet("outputIndices",`i + ${o.length-t.length}`))}\n      }\n    }\n    ${d.setByOffset("global_idx",i.getByIndices("inputIndices"))}\n  }`;return{name:"Expand",shaderCache:{hint:`${o}`},getShaderSource:f,getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}})}},ns=e=>{kc(e.inputs),e.compute(Dc(e.inputs),{inputs:[0]})}});var Wc,zc,as,is,ss=K(()=>{"use strict";ge();Me();$e();Wc=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},zc=(e,t)=>{let r=e[0].dims,o=e[1].dims,a=r.length,u=z.normalizeAxis(t.axis,a),i=r.slice(0);i.splice(u,1,...o);let d=r[u],f=z.size(i),h=H("data",e[0].dataType,e[0].dims),c=H("inputIndices",e[1].dataType,e[1].dims),C=Y("output",e[0].dataType,i),b=()=>{let S=o.length,x=`var indicesIndices  = ${c.type.indices}(0);`;for(let A=0;A<S;A++)x+=`${S>1?`indicesIndices[${A}]`:"indicesIndices"} = ${i.length>1?`outputIndices[${u+A}]`:"outputIndices"};`;x+=`\n        var idx = ${c.getByIndices("indicesIndices")};\n        if (idx < 0) {\n          idx = idx + ${d};\n        }\n        var dataIndices = ${h.type.indices}(0);\n      `;for(let A=0,k=0;A<a;A++)A===u?(x+=`${a>1?`dataIndices[${A}]`:"dataIndices"} = u32(idx);`,k+=S):(x+=`${a>1?`dataIndices[${A}]`:"dataIndices"} = ${i.length>1?`outputIndices[${k}]`:"outputIndices"};`,k++);return x},$=S=>`\n      ${S.declareVariables(h,c,C)}\n      ${S.mainStart()}\n        ${S.guardAgainstOutOfBoundsWorkgroupSizes(f)}\n        let outputIndices = ${C.offsetToIndices("global_idx")};\n        ${b()};\n        let value = ${h.getByIndices("dataIndices")};\n        ${C.setByOffset("global_idx","value")};\n      }`;return{name:"Gather",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)}}),getShaderSource:$}},as=e=>ue({axis:e.axis}),is=(e,t)=>{let r=e.inputs;Wc(r),e.compute(zc(e.inputs,t))}});var Vc,Uc,us,ls,cs=K(()=>{"use strict";ge();Me();$e();Vc=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},Uc=(e,t)=>{let r=e[0].dims,o=e[0].dataType,a=r.length,u=z.computeStrides(r),i=z.size(r),d=e[1].dims,f=e[1].dataType,h=z.size(d),c=z.normalizeAxis(t.axis,a),C=r[c],b=d.slice(0),$=z.size(b),S=H("input",o,r),x=H("indices",f,[h]),A=Y("output",o,b),k=O=>`\n      const inputStrides = array<u32, ${u.length}>(${u.map(P=>`${P}u`).join(",")});\n      ${O.declareVariables(S,x,A)}\n      ${O.mainStart()}\n      ${O.guardAgainstOutOfBoundsWorkgroupSizes($)}\n\n      let outputIndices = ${A.offsetToIndices("global_idx")};\n\n      var idx = ${x.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + ${C};\n      }\n\n      var srcOffset = u32(0);\n\n      for (var i = 0; i < ${r.length}; i++) {\n        if (i == ${c}) {\n          srcOffset +=  u32(idx) * inputStrides[i];\n        } else {\n          srcOffset += ${A.indicesGet("outputIndices","i")} * inputStrides[i];\n        }\n      }\n\n      // Should never hit this with valid values in indices\n      // This is a guard against malicious data in the indices input\n      if (srcOffset < 0 || srcOffset >= ${i}) {\n        return;\n      }\n\n      output[global_idx] = input[srcOffset];\n  }`;return{name:"GatherElements",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:b,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil($/64)}}),getShaderSource:k}},us=e=>ue({axis:e.axis}),ls=(e,t)=>{let r=e.inputs;Vc(r),e.compute(Uc(e.inputs,t))}});var Nc,Gc,Fc,ds,ps,fs=K(()=>{"use strict";ge();Me();$e();Nc=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},Gc=(e,t,r)=>{if(r.length===0)return"0u";let o=r.length===1&&e!==1||r.length===2&&r[0]!==e,a=r[r.length-1]!==t,u="0u";return o||(u+=`+ m * ${r[r.length-1]}u`),a||(u+="+n"),u},Fc=(e,t)=>{let r=e[0].dims.slice(),o=e[1].dims.slice(),[a,u,i]=Fr.getShapeOfGemmResult(r,t.transA,o,t.transB,e.length===3?e[2].dims:void 0),d=[a,u];if(!d)throw new Error("Can\'t use gemm on the given tensors");let f=z.size(d),h="";t.transA&&t.transB?h="value += a[k * M + m] * b[n * K + k];":t.transA&&!t.transB?h="value += a[k * M + m] * b[k * N + n];":!t.transA&&t.transB?h="value += a[m * K + k] * b[n * K + k];":!t.transA&&!t.transB&&(h="value += a[m * K + k] * b[k * N + n];");let c=ke(e[0].dataType),C=t.alpha===1?"":"value *= alpha;",b=e.length===3?`value += beta * c[${Gc(a,u,e[2].dims)}];`:"",$=[`@group(0) @binding(0) var<storage, read> a : array<${c}>;`,`@group(0) @binding(1) var<storage, read> b : array<${c}>;`];e.length===3&&$.push(`@group(0) @binding(2) var<storage, read> c : array<${c}>;`);let S=x=>`\n  const M: u32 = ${a}u;\n  const N: u32 = ${u}u;\n  const K: u32 = ${i}u;\n  const alpha = ${c}(${t.alpha});\n  const beta = ${c}(${t.beta});\n\n  ${$.join(`\n`)}\n  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${c}>;\n\n  ${x.mainStart()}\n    ${x.guardAgainstOutOfBoundsWorkgroupSizes(f)}\n\n    let m = global_id.x / N;\n    let n = global_id.x % N;\n\n    var value = ${c}(0);\n    for (var k: u32 = 0u; k<${i}u; k++) {\n      ${h}\n    }\n\n    ${C}\n    ${b}\n    output[global_id.x] = value;\n\n  }`;return{name:"Gemm",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)}}),getShaderSource:S}},ds=(e,t)=>{Nc(e.inputs),e.compute(Fc(e.inputs,t))},ps=e=>ue(e)});var Lc,Hc,jc,qc,ms,hs,gs=K(()=>{"use strict";We();ge();Me();$e();Lc={name:"InstanceNormalization"},Hc=(e,t)=>{let r=e[0].dims,o=r,a=2,u=z.sizeToDimension(r,a),i=z.sizeFromDimension(r,a),d=r[1],f=H("x",e[0].dataType,[r[0],r[1],i]),h=H("scale",e[1].dataType,e[1].dims),c=H("bias",e[2].dataType,e[2].dims),C=Y("output",e[0].dataType,[r[0],r[1],i]),b=[f,h,c,C],$=f.type.value,S=64,x=A=>`\n\n  const C: u32 = ${d};\n  const normSize: u32 = ${i};\n  const epsilon: f32 = ${t.epsilon};\n  var<workgroup> meanShared : ${$};\n  var<workgroup> squaredNormShared : ${$};\n  var<workgroup> workgroupShared : array<${$}, ${S}>;\n  const workgroupSize = ${S}u;\n  ${A.declareVariables(...b)}\n  ${A.mainStart(S)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / C;\n    let channel = norm % C;\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial: ${$} = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      initial = initial + ${f.get("batch","channel","h")};\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = workgroupShared[0] / ${$}(normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let deviation =  ${f.get("batch","channel","h")} - meanShared;\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = workgroupShared[0];\n    }\n    workgroupBarrier();\n\n    let invStdDev = 1 / sqrt(squaredNormShared / ${$}(normSize) + epsilon);\n    let channelScale = invStdDev * ${h.getByOffset("channel")};\n    let channelShift = ${c.getByOffset("channel")} - meanShared * channelScale;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let value = ${f.get("batch","channel","h")} * channelScale + channelShift;\n      ${C.set("batch","channel","h","value")};\n    }\n  }`;return{...Lc,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:u}}),getShaderSource:x}},jc=(e,t,r,o,a,u,i,d)=>{let f=bt(i),h=H("input",t.dataType,t.dims,f),c=H("scale",r.dataType,r.dims,f),C=H("bias",o.dataType,o.dims,f),b=64,$=f===1?"vec2f":`mat2x${f}f`,S=f===1?"f32":`vec${f}f`,x=(V,B)=>`${$}(${V}, ${B})`,A=a*i/f,k=Math.ceil(u/b),O=V=>`\n  const H: u32 = ${u};\n  const C: u32 = ${i/f};\n  const imageSize: u32 = ${u*i/f};\n\n  ${V.declareVariables(h)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${$}>;\n\n  ${V.mainStart(b)}\n    let currentImageNumber = global_idx / ${b} / C;\n    let currentChannelNumber = (global_idx / ${b}) % C;\n    let wgId = global_idx % ${b};\n    let wgOffset = wgId * ${k};\n    if (wgOffset >= H) {\n        return;\n    }\n    let wgMax = min(wgOffset + ${k}, H);\n\n    let offset = currentImageNumber * imageSize + currentChannelNumber;\n    var sum = ${tt("f32",f)};\n    var squaredSum = ${tt("f32",f)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${S}(input[offset + i * C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${x("sum","squaredSum")};\n  }`,P=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:f,n:a,h:u,c:i})},getRunData:()=>({outputs:[{dims:[a,i,b,2],dataType:1}],dispatchGroup:{x:a*i/f}}),getShaderSource:O},{inputs:[t],outputs:[-1]})[0],R=V=>`\n  const H: u32 = ${u};\n  const C: u32 = ${i/f};\n  const imageSize: u32 = ${b*i/f};\n  const epsilon: f32 = ${d};\n\n  @group(0) @binding(0) var<storage, read> input : array<${$}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${c.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${C.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${$}>;\n\n  ${V.mainStart()}\n    ${V.guardAgainstOutOfBoundsWorkgroupSizes(A)}\n    let currentImageNumber = global_idx / C;\n    let currentChannelNumber = global_idx % C;\n\n    let offset = currentImageNumber * imageSize;\n    var sum = ${tt("f32",f)};\n    var squaredSum = ${tt("f32",f)};\n    for (var i: u32 = 0; i < ${b}; i++) {\n        let value = input[offset + i + currentChannelNumber * ${b}];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(H);\n    squaredSum = squaredSum / f32(H);\n    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);\n    let channelScale = invStdDev * ${S}(scale[currentChannelNumber]);\n    let channelShift = ${S}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${x("channelScale","channelShift")};\n  }`;return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:f,n:a,h:u,c:i,epsilon:d})},getRunData:()=>({outputs:[{dims:[a,i,2],dataType:1}],dispatchGroup:{x:Math.ceil(A/64)}}),getShaderSource:R},{inputs:[P,r,o],outputs:[-1]})[0]},qc=(e,t,r)=>{let o=t[0].dims,a=o,u=o[0],i=o[o.length-1],d=z.sizeFromDimension(o,1)/i,f=bt(i),h=z.size(a)/f,c=H("input",t[0].dataType,t[0].dims,f),C=Y("output",t[0].dataType,a,f),b=ke(t[0].dataType),$=f===1?"vec2f":`mat2x${f}f`,S=f===1?b:`vec${f}<${b}>`,x=jc(e,t[0],t[1],t[2],u,d,i,r.epsilon),A=k=>`\n  const H: u32 = ${d};\n  const C: u32 = ${i/f};\n\n  @group(0) @binding(0) var<storage, read> input : array<${c.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${$}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${C.type.storage}>;\n\n  ${k.mainStart()}\n    let currentImageNumber = global_idx / (C * H);\n    let currentChannelNumber = global_idx % C;\n\n    let scaleOffset = currentImageNumber * C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${S}(scale[0]), ${S}(scale[1]));\n  }`;e.compute({name:"InstanceNormalization",shaderCache:{hint:`${r.cacheKey}`},getRunData:()=>({outputs:[{dims:a,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)}}),getShaderSource:A},{inputs:[t[0],x]})},ms=e=>ue({epsilon:e.epsilon,format:e.format}),hs=(e,t)=>{t.format==="NHWC"?qc(e,e.inputs,t):e.compute(Hc(e.inputs,t))}});var Kc,Yc,ys,bs,ws=K(()=>{"use strict";We();ge();Me();$e();Kc=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},Yc=(e,t,r)=>{let o=e[0].dims,a=e[1],u=e[2],i=o,d=z.normalizeAxis(t.axis,o.length),f=z.sizeToDimension(o,d),h=z.sizeFromDimension(o,d),c=z.size(a.dims),C=u?z.size(u.dims):0;if(c!==h||u&&C!==h)throw new Error(`Size of X.shape()[axis:] == ${h}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${c} and bias size of ${C}`);let b=[];for(let R=0;R<o.length;++R)R<d?b.push(o[R]):b.push(1);let $=bt(h),S=ke(e[0].dataType),x=[H("x",e[0].dataType,e[0].dims,$),H("scale",a.dataType,a.dims,$)];u&&x.push(H("bias",u.dataType,u.dims,$)),x.push(Y("output",e[0].dataType,i,$));let A=r>1,k=r>2;A&&x.push(Y("meanDataOutput",1,b)),k&&x.push(Y("invStdOutput",1,b));let O=R=>`\n  const normSize: f32 = ${h};\n  const normSizeVectorized: u32 = ${h/$};\n  const epsilon: f32 = ${t.epsilon};\n\n  ${R.declareVariables(...x)}\n  ${R.mainStart()}\n    ${R.guardAgainstOutOfBoundsWorkgroupSizes(f)}\n    let offset = global_idx * normSizeVectorized;\n    var meanVector = ${tt("f32",$)};\n    var meanSquareVector = ${tt("f32",$)};\n\n    for (var h: u32 = 0u; h < normSizeVectorized; h++) {\n      let value = ${Dt(S,$,"x[h + offset]")};\n      meanVector += value;\n      meanSquareVector += value * value;\n    }\n    let mean = ${Ct("meanVector",$)} / normSize;\n    let meanSquare = sqrt(${Ct("meanSquareVector",$)} \n      / normSize - mean * mean + epsilon);\n\n    for (var j: u32 = 0; j < normSizeVectorized; j++) {\n      let f32input = ${Dt(S,$,"x[j + offset]")};\n      let f32scale = ${Dt(S,$,"scale[j]")};\n      output[j + offset] = ${x[0].type.value}((f32input - mean) / meanSquare * f32scale\n        ${u?`+ ${Dt(S,$,"bias[j]")}`:""}\n      );\n    }\n\n    ${A?"meanDataOutput[global_idx] = mean":""};\n    ${k?"invStdOutput[global_idx] = 1 / meanSquare":""};\n  }`,P=[{dims:i,dataType:e[0].dataType}];return A&&P.push({dims:b,dataType:1}),k&&P.push({dims:b,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${t.cacheKey}|${r}|${e.length}`},getRunData:()=>({outputs:P,dispatchGroup:{x:Math.ceil(f/64)}}),getShaderSource:O}},ys=e=>ue({axis:e.axis,epsilon:e.epsilon}),bs=(e,t)=>{Kc(e.inputs),e.compute(Yc(e.inputs,t,e.outputCount))}});var Jc,vs,$s=K(()=>{"use strict";ge();wr();Jc=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},vs=e=>{Jc(e.inputs);let t=st.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can\'t use matmul on the given tensors");e.compute(en(e.inputs,{activation:"",activationCacheKey:""},t))}});var Xc,Zc,Qc,ed,td,rd,nd,od,ad,xs,Ss,Cs=K(()=>{"use strict";We();ge();Me();$e();Xc=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1)throw new Error("Input type must be float.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},Zc=(e,t,r,o,a,u,i)=>{let d=r.length,f="";for(let h=d-1;h>=0;--h)f+=`\n            k = i32(${e.indicesGet("indices",h)}) - ${a[h]};\n            if (k < 0) {\n              break;\n            }\n            if (k >= ${r[h]}) {\n              break;\n            }\n            offset += k * ${o[h]};\n        `;return`\n          value = ${u}(${i});\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${f}\n            value = x[offset];\n          }\n      `},Qc=(e,t,r,o,a)=>{let u=r.length,i="";for(let d=u-1;d>=0;--d)i+=`\n                k = i32(${e.indicesGet("indices",d)}) - ${a[d]};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = ${2*(r[d]-1)};\n                  k = k % _2n_1;\n                  if(k >= ${r[d]}) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * ${o[d]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${i}\n              value = x[offset];\n          `},ed=(e,t,r,o,a)=>{let u=r.length,i="";for(let d=u-1;d>=0;--d)i+=`\n                k = i32(${e.indicesGet("indices",d)}) - ${a[d]};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= ${r[d]}) {\n                  k = ${r[d]-1};\n                }\n                offset += k * ${o[d]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${i}\n              value = x[offset];\n          `},td=(e,t,r,o,a)=>{let u=r.length,i="";for(let d=u-1;d>=0;--d)i+=`\n                k = i32(${e.indicesGet("indices",d)}) - ${a[d]};\n                if (k < 0)  {\n                  k += ${r[d]};\n                }\n                if (k >= ${r[d]}) {\n                  k -= ${r[d]};\n                }\n                offset += k * ${o[d]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${i}\n              value = x[offset];\n          `},rd=(e,t,r,o,a,u)=>{switch(a.mode){case 0:return Zc(e,t,r,o,a.pads,u,a.value);case 1:return Qc(e,t,r,o,a.pads);case 2:return ed(e,t,r,o,a.pads);case 3:return td(e,t,r,o,a.pads);default:throw new Error("Invalid mode")}},nd=(e,t,r,o)=>{let a=t[0].dims,u=z.padShape(a.slice(),r.pads),i=z.size(u),d=z.computeStrides(a),f=Y("output",t[0].dataType,u),h=H("x",t[0].dataType,a),c=rd(f,u,a,d,r,o);return`\n              ${e.declareVariables(h,f)}\n              ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n\n              let indices = ${f.offsetToIndices("global_idx")};\n\n              var value = ${o}(0);\n              ${c}\n              output[global_idx] = value;\n          }`},od=(e,t)=>{let r=z.padShape(e[0].dims.slice(),t.pads);return{name:"Pad",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(z.size(r)/64)}}),getShaderSource:o=>nd(o,e,t,"f32")}},ad=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),o=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,a=e[0].dims.length,u=new Int32Array(2*a).fill(0);if(e.length>=4){let d=e[3].getBigInt64Array();for(let f=0;f<d.length;f++)u[Number(d[f])]=Number(r[f]),u[Number(d[f])+a]=Number(r[f+d.length])}else r.forEach((d,f)=>u[Number(f)]=Number(d));let i=[];return u.forEach(d=>i.push(d)),ue({mode:t.mode,value:o,pads:i})}else return t},xs=(e,t)=>{Xc(e.inputs);let r=ad(e.inputs,t);e.compute(od(e.inputs,r),{inputs:[0]})},Ss=e=>{let t=e.mode,r=e.value,o=e.pads;return ue({mode:t,value:r,pads:o})}});var rn,As,Is,Ts,Os,Es,_s,Ps,Rs,Ms,ks,Bs,Ds,Ws,zs,Vs=K(()=>{"use strict";ge();Me();$e();rn=e=>{if(!e||e.length!==1)throw new Error("Pool ops requires 1 input.");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("Pool ops supports 1-D or 2-D inputs only for now.")},As=(e,t,r)=>{let o=t.format==="NHWC",a=e.dims.slice();o&&a.splice(1,0,a.pop());let u=Object.hasOwnProperty.call(t,"dilations"),i=t.kernelShape.slice(),d=t.strides.slice(),f=u?t.dilations.slice():[],h=t.pads.slice();Bt.adjustPoolAttributes(r,a,i,d,f,h);let c=Bt.computePoolOutputShape(r,a,d,f,i,h,t.autoPad),C=Object.assign({},t);u?Object.assign(C,{kernelShape:i,strides:d,pads:h,dilations:f,cacheKey:t.cacheKey}):Object.assign(C,{kernelShape:i,strides:d,pads:h,cacheKey:t.cacheKey});let b=c.slice();return b.push(b.splice(1,1)[0]),[C,o?b:c]},Is=(e,t,r,o,a,u,i,d)=>{let f=a.format==="NHWC",h=r,c=t.type.value,C=h.length,b=z.size(o),$=Y("output",t.type.tensor,o);if(a.kernelShape.length<=2){let S=a.kernelShape[a.kernelShape.length-1],x=a.strides[a.strides.length-1],A=a.pads[a.pads.length/2-1],k=a.pads[a.pads.length-1],O=C-(f?2:1),P="",R="",V="";if(A+k!==0?P=`\n                for (var i: u32 = 0u; i < ${S}u; i++) {\n                  xIndices[${O}] = indices[${O}] * ${x} - ${A} + i;\n                  if (xIndices[${O}] < 0 || xIndices[${O}] >= ${h[O]}) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${u}\n                }`:P=`\n                for (var i: u32 = 0u; i < ${S}u; i++) {\n                  xIndices[${O}] = indices[${O}] * ${x} - ${A} + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${u}\n                }`,a.kernelShape.length===2){let W=a.kernelShape[a.kernelShape.length-2],q=a.strides[a.strides.length-2],ee=a.pads[a.pads.length/2-2],oe=a.pads[a.pads.length-2],D=C-(f?3:2),te=h[D];ee+oe!==0?R=`\n                for (var j: u32 = 0u; j < ${W}u; j++) {\n                  xIndices[${D}] = indices[${D}] * ${q} - ${ee} + j;\n                  if (xIndices[${D}] < 0 || xIndices[${D}] >= ${te}) {\n                    pad+= ${S};\n                    continue;\n                  }\n              `:R=`\n                for (var j: u32 = 0u; j < ${W}u; j++) {\n                  xIndices[${D}] = indices[${D}] * ${q} - ${ee} + j;\n                `,V=`\n              }\n            `}return`\n            ${e.declareVariables(t,$)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n\n              let indices = ${$.offsetToIndices("global_idx")};\n              var xIndices = ${$.offsetToIndices("global_idx")};\n\n              var value: ${c} = ${c}(${d});\n              var pad = 0;\n              ${R}\n              ${P}\n              ${V}\n              ${i}\n\n              output[global_idx] = value;\n            }`}else{if(f)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let S=z.size(a.kernelShape),x=z.computeStrides(a.kernelShape),A=x.length,k=a.pads.length,O=a.pads.reduce((V,B)=>V+B),P="";return O?P=`\n                if (xIndices[j] >= inputDims[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${u}\n              }`:P=`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${u}\n            `,`\n            ${e.declareVariables(t,$)}\n\n            const pads = array<u32, ${k}>(${a.pads.map(V=>`${V}u`).join(",")});\n            const inputDims = array<u32, ${C}>(${h.map(V=>`${V}u`).join(",")});\n            const kernelStrides = array<u32, ${A}>(${x.map(V=>`${V}u`).join(",")});\n            const strides = array<u32, ${A}>(${a.strides.map(V=>`${V}u`).join(",")});\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n\n              let indices = ${$.offsetToIndices("global_idx")};\n              let xIndices = ${$.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${A}>;\n\n              var value = ${$.type.value}(${d});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < ${S}u; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${A-1}u; j++) {\n                  offsets[j] = offset / kernelStrides[j];\n                  offset -= offsets[j] * kernelStrides[j];\n                }\n                offsets[${A-1}] = offset;\n\n                isPad = false;\n                for (var j = ${C-A}u; j < ${C}u; j++) {\n                  xIndices[j] = indices[j] * strides[j - ${C-A}u]\n                    + offsets[j - ${C-A}u] - pads[j - 2u];\n                  ${P}\n              }\n              ${i}\n\n              output[global_idx] = value;\n            }`}},Ts=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Os=(e,t,r,o)=>{let[a,u]=As(t,o,r),i=z.size(a.kernelShape),d=H("x",t.dataType,t.dims),f=d.type.value,h="value += x_val;",c="";return a.countIncludePad?c+=`value /= ${f}(${i});`:c+=`value /= ${f}(${i} - pad);`,{name:e,shaderCache:{hint:o.cacheKey},getRunData:()=>({outputs:[{dims:u,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(z.size(u)/64)}}),getShaderSource:C=>Is(C,d,t.dims,u,a,h,c,"0.0")}},Es=e=>{let t=e.count_include_pad!==0,r=Ts(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return ue({countIncludePad:t,...r})},_s=(e,t)=>{rn(e.inputs),e.compute(Os("AveragePool",e.inputs[0],!1,t))},Ps={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},Rs=e=>{let t=e.format;return{format:t,...Ps,cacheKey:t}},Ms=(e,t)=>{rn(e.inputs),e.compute(Os("GlobalAveragePool",e.inputs[0],!0,t))},ks=(e,t,r,o)=>{let[a,u]=As(t,o,r),i=`\n      value = max(x_val, value);\n    `,d="",f=H("x",t.dataType,t.dims);return{name:e,shaderCache:{hint:o.cacheKey},getRunData:()=>({outputs:[{dims:u,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(z.size(u)/64)}}),getShaderSource:h=>Is(h,f,t.dims,u,a,i,d,"-1e5")}},Bs=(e,t)=>{rn(e.inputs),e.compute(ks("MaxPool",e.inputs[0],!1,t))},Ds=e=>{let t=e.storage_order,r=e.dilations,o=Ts(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(o.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return ue({storageOrder:t,dilations:r,...o})},Ws=e=>{let t=e.format;return{format:t,...Ps,cacheKey:t}},zs=(e,t)=>{rn(e.inputs),e.compute(ks("GlobalMaxPool",e.inputs[0],!0,t))}});var nn=K(()=>{});var Us=K(()=>{nn()});var Ns,Gs=K(()=>{Ns="1.17.0"});var Fs,eo,Ls=K(()=>{Gs();Fs="warning",eo={wasm:{},webgl:{},webgpu:{},versions:{common:Ns},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);Fs=e}},get logLevel(){return Fs}};Object.defineProperty(eo,"logLevel",{enumerable:!0})});var Hs,js=K(()=>{Ls();Hs=eo});var qs=K(()=>{});var Ks=K(()=>{on()});var Js=K(()=>{});var Xs=K(()=>{on()});var on=K(()=>{qs();Ks();Js();Xs()});var an=K(()=>{on()});var Zs=K(()=>{nn();an()});var Qs=K(()=>{Zs()});var eu=K(()=>{});var tu=K(()=>{nn();an()});var ru=K(()=>{tu()});var nu=K(()=>{Us();js();Qs();an();eu();ru()});var ld,cd,ou,au=K(()=>{"use strict";nu();We();$e();ld=(e,t,r)=>{let o=e===t,a=e<t&&r<0,u=e>t&&r>0;if(o||a||u)throw new Error("Range these inputs\' contents are invalid.")},cd=(e,t,r,o)=>{let a=Math.abs(Math.ceil((t-e)/r)),u=[a],i=a,d=Y("output",o,u),f=d.type.storage,h=c=>`\n        ${c.declareVariables(d)}\n        ${c.mainStart()}\n        ${c.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n        output[global_idx] = ${f}(${e}) + ${f}(global_idx) * ${f}(${r});\n      }`;return{name:"Range",shaderCache:{hint:[e,t,r].map(c=>c.toString()).join("_")},getShaderSource:h,getRunData:()=>({outputs:[{dims:u,dataType:o}],dispatchGroup:{x:Math.ceil(i/64)}})}},ou=e=>{let t=0,r=0,o=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],o=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],o=e.inputs[2].getFloat32Array()[0]),Hs.webgpu.validateInputContent&&ld(t,r,o),e.compute(cd(t,r,o,e.inputs[0].dataType),{inputs:[]})}});var dd,pd,fd,md,hd,gd,yd,bd,wd,vd,$d,xd,Sd,Cd,Ad,iu,su,uu=K(()=>{"use strict";ge();Me();$e();dd=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},pd=(e,t,r)=>{t.every(a=>a>=0&&a<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let o=new Array(r).fill(1);return t.forEach((a,u)=>o[a]=e[u]),o},fd=(e,t,r,o,a,u)=>{let[i,d,f]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],h=e[0].dims.length;if(i>0&&e.length>i&&e[i].dims.length>0)e[i].getFloat32Array().forEach(c=>u.push(c));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(d>0&&e.length>d&&e[d].dims.length>0){if(e[d].getFloat32Array().forEach(c=>o.push(c)),o.length!==0&&o.length!==h&&r>=18&&o.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");dd(o,t),t.axes.length>0&&pd(o,t.axes,h).forEach((c,C)=>o[C]=c)}if(f>0&&e.length>f&&(e[f].getBigInt64Array().forEach(c=>a.push(Number(c))),a.length!==h||r>=18&&a.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(o.length!==t.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(a.length!==t.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(typeof o<"u"&&typeof a<"u"&&o.length>0&&a.length>h)throw new Error("Resize requires only of scales or sizes to be specified")},md=e=>"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(e){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`\n`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",hd=(e,t)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",gd=(e,t,r)=>{let o=new Array(r).fill(0).concat(new Array(r).fill(1)),a=e.length===0?o:e.slice();return t.length>0?(t.forEach((u,i)=>{o[u]=a[i],o[i+r]=a[t.length+i]}),o):a},yd=(e,t,r,o)=>{let a=[];if(r.length>0)if(o.length>0){if(e.forEach(u=>a.push(u)),Math.max(...o)>e.length)throw new Error("axes is out of bound");o.forEach((u,i)=>a[u]=r[i])}else r.forEach(u=>a.push(u));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");a=e.map((u,i)=>Math.round(u*t[i]))}return a},bd=(e,t,r,o)=>{let a=(()=>{switch(o.keepAspectRatioPolicy){case"not_larger":return o.axes.length>0?Math.min(...o.axes.map(i=>r[i]),Number.MAX_VALUE):Math.min(...r,Number.MAX_VALUE);case"not_smaller":return o.axes.length>0?Math.max(...o.axes.map(i=>r[i]),Number.MIN_VALUE):Math.max(...r,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${o.keepAspectRatioPolicy} is not supported`)}})();r.fill(1,0,r.length);let u=e.slice();return o.axes.length>0?(o.axes.forEach(i=>r[i]=a),o.axes.forEach(i=>u[i]=Math.round(e[i]*r[i]))):(r.fill(a,0,r.length),u.forEach((i,d)=>u[d]=Math.round(i*r[d]))),u},wd=(e,t,r,o,a)=>`\n    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> array<f32, ${r.length}> {\n      const inputShape = array<u32, ${t.length}>(${t.map(u=>`${u}u`).join(",")});\n      const outputShape = array<u32, ${r.length}>(${r.map(u=>`${u}u`).join(",")});\n      const scales = array<f32, ${o.length}>(${o.map(u=>`${u}f`).join(",")});\n      const roi = array<f32, ${a.length}>(${a.map(u=>`${u}f`).join(",")});\n      var originalIndices: array<f32, ${r.length}>;\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var outputIndex = ${r.length===1?"outputIndices":"outputIndices[i]"};\n        if (scales[i] == 1.0) {\n          originalIndices[i] = f32(outputIndex);\n        } else {\n          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${t.length}]);\n        }\n      }\n      return originalIndices;\n    }`,vd=(e,t,r,o,a,u,i)=>`\n    fn calculateInputIndicesFromOutputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n        const inputShape = array<u32, ${r.length}>(${r.map(d=>`${d}u`).join(",")});\n        const outputShape = array<u32, ${o.length}>(${o.map(d=>`${d}u`).join(",")});\n        const scales = array<f32, ${a.length}>(${a.map(d=>`${d}f`).join(",")});\n        const roi = array<f32, ${u.length}>(${u.map(d=>`${d}f`).join(",")});\n        var inputIndices: ${e.type.indices};\n        for (var i:u32 = 0; i < ${o.length}; i++) {\n          var outputIndex = ${o.length===1?"outputIndices":"outputIndices[i]"};\n          var inputIndex: u32;\n          if (scales[i] == 1.0) {\n            inputIndex = outputIndex;\n          } else {\n            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${r.length}]);\n            if (!${i} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {\n              if (original_idx < 0) {\n                inputIndex = 0;\n              } else if (original_idx > (f32(inputShape[i]) - 1)) {\n                inputIndex = inputShape[i] - 1;\n              } else {\n                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));\n              }\n            } else {\n              inputIndex = u32(original_idx);\n            }\n          }\n          ${e.indicesSet("inputIndices","i","inputIndex")}\n        }\n        return inputIndices;\n    }`,$d=(e,t)=>`\n    fn checkInputIndices(inputIndices: ${e.type.indices}) -> bool {\n      const inputShape = array<u32, ${t.length}>(${t.map(r=>`${r}u`).join(",")});\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var inputIndex = ${t.length===1?"inputIndices":"inputIndices[i]"};\n        if (inputIndex < 0 || inputIndex >= inputShape[i]) {\n          return false;\n        }\n      }\n      return true;\n    }`,xd=(e,t,r,o,a,u,i)=>{let[d,f,h,c]=r.length===2?[-1,0,1,-1]:a[1]===1?[0,2,3,1]:[0,1,2,3];return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {\n      var inputIndices: ${e.type.indices};\n      inputIndices[${f}] = max(0, min(row, ${r[f]} - 1));\n      inputIndices[${h}] = max(0, min(col, ${r[h]} - 1));\n      if (${r.length} > 2) {\n        inputIndices[${c}] = channel;\n        inputIndices[${d}] = batch;\n      };\n      return input[${e.indicesToOffset("inputIndices")}];\n    }\n\n    fn bilinearInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);\n      var row:f32 = originalIndices[${f}];\n      var col:f32 = originalIndices[${h}];\n      if (${u} && (row < 0 || row > (${r[f]} - 1) || col < 0 || col > ${r[h]} - 1)) {\n        return ${i};\n      }\n      row = max(0, min(row, ${r[f]} - 1));\n      col = max(0, min(col, ${r[h]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = 0;\n      var batch: u32 = 0;\n      if (${r.length>2}) {\n        channel = u32(originalIndices[${c}]);\n        batch = u32(originalIndices[${d}]);\n      }\n      var x11: f32 = getInputValue(batch, channel, row1, col1);\n      var x12: f32 = getInputValue(batch, channel, row1, col2);\n      var x21: f32 = getInputValue(batch, channel, row2, col1);\n      var x22: f32 = getInputValue(batch, channel, row2, col2);\n      var dx1: f32 = row - f32(row1);\n      var dx2: f32 = f32(row2 ) - row;\n      var dy1 = col - f32(col1);\n      var dy2 = f32(col2) - col;\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},Sd=(e,t,r,o,a,u,i,d,f,h)=>{let[c,C]=r.length===2?[0,1]:a[1]===1?[2,3]:[1,2],b=$=>{let S=$===c?"row":"col";return`\n      fn ${S}CubicInterpolation(inputIndices: ${e.type.indices}, outputIndices: ${t.type.indices}) -> f32 {\n        var outputIndex = ${o.length===1?"outputIndices":`outputIndices[${$}]`};\n        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${a[$]},\n        f32(${o[$]}), f32(${r[$]}), ${u[$]}, ${u[$]} + ${r.length});\n        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${d} && (originalIdx < 0 || originalIdx > (${r[$]} - 1))) {\n          return ${f};\n        }\n        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${S}: f32 = originalIdx + f32(i);\n          if (${S} < 0 || ${S} >= ${r[$]}) {\n            if (${h}) {\n              coefs[i + 1] = 0.0;\n              continue;\n            } else if (${d}) {\n              return ${f};\n            } else {\n              ${S} = max(0, min(${S}, ${r[$]} - 1));\n            }\n          }\n          var inputIndicesCopy: ${e.type.indices} = inputIndices;\n          inputIndicesCopy[${$}] = u32(${S});\n          data[i + 1] = ${$===c?`input[${e.indicesToOffset("inputIndicesCopy")}];`:`\n                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);`}\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${b(c)};\n    ${b(C)};\n  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {\n    var absS = abs(s);\n    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: f32 = 1.0 - absS;\n    var twoMinusAbsS: f32 = 2.0 - absS;\n    var onePlusAbsS: f32 = 1.0 + absS;\n    coeffs[0] = ((${i} * onePlusAbsS - 5 * ${i}) * onePlusAbsS + 8 * ${i}) * onePlusAbsS - 4 * ${i};\n    coeffs[1] = ((${i} + 2) * absS - (${i} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${i} + 2) * oneMinusAbsS - (${i} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${i} * twoMinusAbsS - 5 * ${i}) * twoMinusAbsS + 8 * ${i}) * twoMinusAbsS - 4 * ${i};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {\n    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n    var inputIndices: ${e.type.indices} = outputIndices;\n    return colCubicInterpolation(inputIndices, outputIndices);\n  }\n    `},Cd=(e,t,r,o,a,u)=>{let i=e.dims,d=gd(u,t.axes,i.length),f=yd(i,o,a,t.axes),h=o.slice();o.length===0&&(h=i.map((A,k)=>A===0?1:f[k]/A),t.keepAspectRatioPolicy!=="stretch"&&(f=bd(i,f,h,t)));let c=Y("output",e.dataType,f),C=H("input",e.dataType,i),b=z.size(f),$=i.length===f.length&&i.every((A,k)=>A===f[k]),S=t.coordinateTransformMode==="tf_crop_and_resize",x=A=>`\n      ${$?"":`\n      ${md(t.coordinateTransformMode)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${$d(C,i)};\n              ${hd(t.nearestMode,r)};\n              ${vd(C,c,i,f,h,d,S)};\n              `;case"linear":return`\n              ${wd(c,i,f,h,d)};\n              ${xd(C,c,i,f,h,S,t.extrapolationValue)};\n              `;case"cubic":return`\n            ${Sd(C,c,i,f,h,d,t.cubicCoeffA,S,t.extrapolationValue,t.excludeOutside)};\n            `;default:throw Error("Invalid resize mode")}})()};\n      `}\n      ${A.declareVariables(C,c)}\n      ${A.mainStart()}\n        ${A.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n        ${$?"output[global_idx] = input[global_idx];":`\n        let outputIndices = ${c.offsetToIndices("global_idx")};\n        var inputIndices: ${C.type.indices};\n        ${(()=>{switch(t.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);\n                if (checkInputIndices(inputIndices)) {\n                  output[global_idx] = input[${C.indicesToOffset("inputIndices")}];\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n        `}\n      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${h.length>0?h:""}|${a.length>0?a:""}|${$}`},getShaderSource:x,getRunData:()=>({outputs:[{dims:f,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(b/64)}})}},Ad=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},iu=(e,t)=>{let r=[],o=[],a=[],u=Ad(e);fd(e.inputs,t,u,r,o,a),e.compute(Cd(e.inputs[0],t,u,r,o,a),{inputs:[0]})},su=e=>{let t=e.antialias,r=e.axes,o=e.coordinateTransformMode,a=e.cubicCoeffA,u=e.excludeOutside!==0,i=e.extrapolationValue,d=e.keepAspectRatioPolicy,f=e.mode,h=e.nearestMode===""?"simple":e.nearestMode;return ue({antialias:t,axes:r,coordinateTransformMode:o,cubicCoeffA:a,excludeOutside:u,extrapolationValue:i,keepAspectRatioPolicy:d,mode:f,nearestMode:h})}});var Id,Td,lu,cu,du=K(()=>{"use strict";We();ge();Me();$e();Id=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],r=e[1],o=e[2];if(t.dataType!==r.dataType||t.dataType!==o.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let a=t.dims[t.dims.length-1],u=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==a)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==u)throw new Error("Skip must have the same sequence length as input");if(o.dims.length!==1)throw new Error("Gamma must be 1D");if(o.dims[o.dims.length-1]!==a)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let i=e[3];if(i.dims.length!==1)throw new Error("Beta must be 1D");if(i.dims[i.dims.length-1]!==a)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let i=e[4];if(i.dims.length!==1)throw new Error("Bias must be 1D");if(i.dims[i.dims.length-1]!==a)throw new Error("Bias must have the same hidden size as input")}},Td=(e,t,r,o)=>{let a=e[0].dims,u=z.size(a),i=a,d=u,f=a.slice(-1)[0],h=o?a.slice(0,-1).concat(1):[],c=e.length>3,C=e.length>4,b=o&&r>1,$=o&&r>2,S=r>3,x=bt(f),A=[H("x",e[0].dataType,e[0].dims,x),H("skip",e[1].dataType,e[1].dims,x),H("gamma",e[2].dataType,e[2].dims,x)];c&&A.push(H("beta",e[3].dataType,e[3].dims,x)),C&&A.push(H("bias",e[4].dataType,e[4].dims,x)),A.push(Y("output",e[0].dataType,i,x)),b&&A.push(Y("meanOutput",1,h)),$&&A.push(Y("invStdOutput",1,h)),S&&A.push(Y("inputSkipBiasSum",e[0].dataType,i,x));let k=ke(e[0].dataType),O=R=>`\n      const hiddenSize: f32 = ${f};\n      const hiddenSizeVectorized: u32 = ${f/x};\n      const epsilon: f32 = ${t.epsilon};\n\n      ${R.declareVariables(...A)}\n\n      ${R.mainStart()}\n        ${R.guardAgainstOutOfBoundsWorkgroupSizes(d/f)}\n        let offset = global_idx * hiddenSizeVectorized;\n        var sum = ${tt("f32",x)};\n        var squareSum = ${tt("f32",x)};\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          let skipValue = skip[offset + i];\n          let biasValue = ${C?"bias[i]":"0.0"};\n          let inputValue = x[offset + i];\n          let value = inputValue + skipValue + biasValue;\n          ${S?"inputSkipBiasSum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32Value = ${Dt(k,x,"value")};\n          sum += f32Value;\n          squareSum += f32Value * f32Value;\n        }\n        let mean = ${Ct("sum",x)} / hiddenSize;\n        let variance = sqrt(${Ct("squareSum",x)} / hiddenSize - mean * mean + epsilon);\n        ${b?"meanOutput[global_idx] = mean;":""}\n        ${$?"invStdOutput[global_idx] = 1.0 / variance;":""}\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          output[offset + i] = (output[offset + i] - ${k}(mean)) / ${k}(variance) * gamma[i]\n           + ${c?"beta[i]":"0.0"};\n        }\n      }`,P=[{dims:i,dataType:e[0].dataType}];return r>1&&P.push({dims:h,dataType:1}),r>2&&P.push({dims:h,dataType:1}),r>3&&P.push({dims:a,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:t.cacheKey},getShaderSource:O,getRunData:()=>({outputs:P,dispatchGroup:{x:Math.ceil(d/f/64)}})}},lu=(e,t)=>{Id(e.inputs);let o=[0];e.outputCount>1&&o.push(-3),e.outputCount>2&&o.push(-3),e.outputCount>3&&o.push(3),e.compute(Td(e.inputs,t,e.outputCount,!1),{outputs:o})},cu=e=>{let t=e.epsilon;return ue({epsilon:t})}});var Od,sn,Ed,pu,_d,Pd,fu,mu,hu=K(()=>{"use strict";We();ge();Me();$e();Od=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,o)=>{if(e[o+1].dataType!==6&&e[o+1].dataType!==7)throw new Error(`Input ${o} must be an array of int32 or int64`)})},sn=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(o=>r.push(Number(o)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(o=>r.push(Number(o)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},Ed=(e,t)=>{if(e.length>1){let r=sn(e,1),o=sn(e,2),a=sn(e,3);return a.length===0&&(a=[...Array(e[0].dims.length).keys()]),ue({starts:r,ends:o,axes:a})}else return t},pu=(e,t,r,o,a)=>{let u=e;return e<0&&(u+=r[o[t]]),a[t]<0?Math.max(0,Math.min(u,r[o[t]]-1)):Math.max(0,Math.min(u,r[o[t]]))},_d=(e,t,r,o)=>`fn calculateInputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n          var inputIndices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${r.length}; i >= 0; i--) {\n            var outputIndex = ${o.length===1?"outputIndices":"outputIndices[i]"};\n            var inputIndex = outputIndex * steps[i] + starts[i] + carry;\n            carry = inputIndex / inputShape[i];\n            inputIndex = inputIndex % inputShape[i];\n            if (signs[i] < 0) {\n              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];\n            }\n            ${r.length===1?"inputIndices":"inputIndices[i]"} = inputIndex;\n          }\n          return inputIndices;\n      }`,Pd=(e,t)=>{let r=e[0].dims,o=z.size(r),a=t.axes.length>0?z.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],u=sn(e,4);u.forEach(x=>x!==0||(()=>{throw new Error("step cannot be 0")})),u.length===0&&(u=Array(a.length).fill(1));let i=t.starts.map((x,A)=>pu(x,A,r,a,u)),d=t.ends.map((x,A)=>pu(x,A,r,a,u));if(a.length!==r.length)for(let x=0;x<r.length;++x)a.includes(x)||(i.splice(x,0,0),d.splice(x,0,r[x]),u.splice(x,0,1));let f=u.map(x=>Math.sign(x));u.forEach((x,A,k)=>{if(x<0){let O=(d[A]-i[A])/x,P=i[A],R=P+O*u[A];i[A]=R,d[A]=P,k[A]=-x}});let h=r.slice(0);a.forEach((x,A)=>{h[x]=Math.ceil((d[x]-i[x])/u[x])});let c={dims:h,dataType:e[0].dataType},C=Y("output",e[0].dataType,h),b=H("input",e[0].dataType,r),$=z.size(h),S=x=>`\n      ${x.declareVariables(b,C)}\n        const signs = array<i32, ${f.length}>(${f.map(A=>`${A}i`).join(",")});\n        const starts = array<u32, ${i.length}>(${i.map(A=>`${A}u`).join(",")});\n        const ends = array<u32, ${d.length}>(${d.map(A=>`${A}u`).join(",")});\n        const steps = array<u32, ${u.length}>(${u.map(A=>`${A}u`).join(",")});\n        const inputShape = array<u32, ${r.length}>(${r.map(A=>`${A}u`).join(",")});\n\n        ${_d(b,C,r,h)}\n        ${x.mainStart()}\n          ${x.guardAgainstOutOfBoundsWorkgroupSizes($)}\n          let outputIndices = ${C.offsetToIndices("global_idx")};\n          let inputIndices = calculateInputIndices(outputIndices);\n          ${C.setByOffset("global_idx",b.getByIndices("inputIndices"))}\n      }`;return{name:"Slice",shaderCache:{hint:`${t.cacheKey}|${e[4]?.dims??""}`},getShaderSource:S,getRunData:()=>({outputs:[c],dispatchGroup:{x:Math.ceil(o/64)}})}},fu=(e,t)=>{Od(e.inputs,t);let r=Ed(e.inputs,t);e.compute(Pd(e.inputs,r),{inputs:[0]})},mu=e=>{let t=e.starts,r=e.ends,o=e.axes;return ue({starts:t,ends:r,axes:o})}});var Rd,Md,gu,yu,bu=K(()=>{"use strict";ge();Me();$e();Rd=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},Md=(e,t)=>{let r=e.dims,o=z.size(r),a=64,u=t.axis;if(u<0&&(u=r.length+u),u<r.length-1)throw new Error("softmax only supports last axis for now.");let i=r[u],d=o/i,f=bt(i),h=i/f,c=(A,k)=>k===4?`max(max(${A}.x, ${A}.y), max(${A}.z, ${A}.w))`:k===2?`max(${A}.x, ${A}.y)`:k===3?`max(max(${A}.x, ${A}.y), ${A}.z)`:A,C=H("x",e.dataType,e.dims,f),b=Y("result",e.dataType,e.dims,f),$=C.type.value,S=ke(e.dataType)==="f32"?`var threadMax = ${$}(-3.402823e+38f);`:`var threadMax = ${$}(-65504.0h);`,x=A=>`\n      var<workgroup> rowMaxShared : ${$};\n      var<workgroup> rowSumShared : ${$};\n      var<workgroup> threadShared : array<${$}, ${a}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${$} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${$}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${A.registerUniform("packedCols","i32").declareVariables(C,b)}\n      ${A.mainStart()}\n        let gindex = i32(global_id.x);\n        let lindex = i32(local_id.x);\n        const wg = ${a};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${S}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${$}(${c("threadShared[0]",f)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${$}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${$}(${Ct("threadShared[0]",f)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`;return{name:"Softmax",shaderCache:{hint:`${f}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:r,dataType:e.dataType}],dispatchGroup:{x:d},programUniforms:[{type:"uint32",data:h}]}),getShaderSource:x}},gu=(e,t)=>{Rd(e.inputs),e.compute(Md(e.inputs[0],t))},yu=e=>ue({axis:e.axis})});var kd,Bd,Dd,Wd,zd,wu,vu,$u=K(()=>{"use strict";ge();Me();$e();kd=e=>{if(!e||e.length<1)throw new Error("too few inputs")},Bd=(e,t)=>{let r=[],o=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(a=>r.push(Number(a))),o=r.length),ue({numOutputs:o,axis:t.axis,splitSizes:r})},Dd=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < sizeInConcatAxis[i]) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,Wd=e=>{let t=e.length,r=[];for(let o=0;o<t;++o){let a=e[o].setByIndices("indices","input[global_idx]");t===1?r.push(a):o===0?r.push(`if (outputNumber == ${o}u) { ${a} }`):o===t-1?r.push(`else { ${a} }`):r.push(`else if (outputNumber == ${o}) { ${a} }`)}return`\n      fn writeBufferData(outputNumber: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${r.join(`\n`)}\n      }`},zd=(e,t)=>{let r=e[0].dims,o=z.size(r),a=e[0].dataType,u=r.length,i=t.axis,d=i<0?r.length+i:i,f=new Array(t.numOutputs),h=H("input",a,r),c=new Array(t.numOutputs),C=[],b=[],$=0;for(let A=0;A<t.numOutputs;A++){$+=t.splitSizes[A],c[A]=$;let k=r.slice();k[t.axis]=t.splitSizes[A],b.push(k),f[A]=Y(`output${A}`,a,b[A]),C.push({dims:b[A],dataType:e[0].dataType})}let S=u<2?"indices":`indices[${d}]`,x=A=>`\n  ${A.declareVariables(h,...f)}\n  const sizeInConcatAxis = array<u32, ${c.length}>(${c.map(k=>`${k}u`).join(",")});\n  ${Dd(c.length)}\n  ${Wd(f)}\n\n  ${A.mainStart()}\n    ${A.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n\n    var indices = ${h.offsetToIndices("global_idx")};\n    let outputNumber = calculateOutputIndex(${S});\n    if (outputNumber != 0) {\n        ${S} -= sizeInConcatAxis[outputNumber - 1u];\n    }\n    writeBufferData(outputNumber, indices, global_idx);\n  }`;return{name:"Split",shaderCache:{hint:t.cacheKey},getShaderSource:x,getRunData:()=>({outputs:C,dispatchGroup:{x:Math.ceil(o/64)}})}},wu=(e,t)=>{kd(e.inputs);let r=e.inputs.length===1?t:Bd(e.inputs,t);e.compute(zd(e.inputs,r),{inputs:[0]})},vu=e=>{let t=e.axis,r=e.splitSizes,o=e.numOutputs<0?r.length:e.numOutputs;if(o!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ue({axis:t,numOutputs:o,splitSizes:r})}});var xu,Vd,Ud,Nd,Su,Cu=K(()=>{"use strict";We();ge();$e();xu=e=>Array.from(e.getBigInt64Array(),Number),Vd=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(xu(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Ud=(e,t)=>{let r=[];for(let o=0;o<e.length;++o)r.push(e[o]*t[o]);return r},Nd=e=>{let t=e[0].dims,r=xu(e[1]),o=Ud(t,r),a=z.size(o),u=e[0].dataType,i=H("input",u,t),d=Y("output",u,o),f=h=>`\n      const inputShape = ${i.indices(...t)};\n      ${h.declareVariables(i,d)}\n      ${h.mainStart()}\n      ${h.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n      let outputIndices = ${d.offsetToIndices("global_idx")};\n      var inputIndices: ${i.type.indices};\n      for (var i = 0; i < ${t.length}; i++) {\n        let inputDimValue = ${d.indicesGet("outputIndices","i")}  % ${i.indicesGet("inputShape","i")};\n\n        ${i.indicesSet("inputIndices","i","inputDimValue")}\n      }\n      ${d.setByOffset("global_idx",i.getByIndices("inputIndices"))}\n    }`;return{name:"Tile",shaderCache:{hint:`${r}`},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:f}},Su=e=>{Vd(e.inputs),e.compute(Nd(e.inputs),{inputs:[0]})}});var Gd,Fd,Au,Iu=K(()=>{"use strict";We();ge();$e();Gd=(e,t,r,o,a)=>{let u=z.size(r),i=Math.ceil(u/4),d=Y("outputData",a,r,4),f=H("aData",t[1].dataType,t[1].dims,4),h=H("bData",t[2].dataType,t[2].dims,4),c=H("cData",t[0].dataType,t[0].dims,4),C,b=($,S,x)=>`select(${S}, ${$}, ${x})`;if(!o)C=d.setByOffset("global_idx",b(f.getByOffset("global_idx"),h.getByOffset("global_idx"),c.getByOffset("global_idx")));else{let $=(S,x,A="")=>{let k=`aData[indexA${x}][componentA${x}]`,O=`bData[indexB${x}][componentB${x}]`,P=`bool(cData[indexC${x}] & ${4278190080>>>(3-x)*8}u)`;return`\n            let outputIndices${x} = ${d.offsetToIndices(`global_idx * 4u + ${x}u`)};\n            let offsetA${x} = ${f.broadcastedIndicesToOffset(`outputIndices${x}`,d)};\n            let offsetB${x} = ${h.broadcastedIndicesToOffset(`outputIndices${x}`,d)};\n            let offsetC${x} = ${c.broadcastedIndicesToOffset(`outputIndices${x}`,d)};\n            let indexA${x} = offsetA${x} / 4u;\n            let indexB${x} = offsetB${x} / 4u;\n            let indexC${x} = offsetC${x} / 4u;\n            let componentA${x} = offsetA${x} % 4u;\n            let componentB${x} = offsetB${x} % 4u;\n            ${S}[${x}] = ${A}(${b(k,O,P)});\n          `};a===9?C=`\n            var data = vec4<u32>(0);\n            ${$("data",0,"u32")}\n            ${$("data",1,"u32")}\n            ${$("data",2,"u32")}\n            ${$("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:C=`\n            ${$("outputData[global_idx]",0)}\n            ${$("outputData[global_idx]",1)}\n            ${$("outputData[global_idx]",2)}\n            ${$("outputData[global_idx]",3)}\n          `}return`\n        ${e.declareVariables(c,f,h,d)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n        ${C}\n      }`},Fd=e=>{let t=e[1].dims,r=e[2].dims,o=e[0].dims,a=e[1].dataType,u=!(z.areEqual(t,r)&&z.areEqual(r,o)),i=t,d=z.size(t);if(u){let f=st.calcShape(st.calcShape(t,r,!1),o,!1);if(!f)throw new Error("Can\'t perform where op on the given tensors");i=f,d=z.size(i)}return{name:"Where",getShaderSource:f=>Gd(f,e,i,u,a),getRunData:()=>({outputs:[{dims:i,dataType:a}],dispatchGroup:{x:Math.ceil(d/64/4)}})}},Au=e=>{e.compute(Fd(e.inputs))}});var Tu,Ou=K(()=>{"use strict";Fa();Ha();Ci();Bi();zi();qn();Xi();ts();os();ss();cs();fs();gs();ws();$s();Cs();Vs();au();jr();uu();du();hu();bu();$u();Cu();gr();Fn();Iu();Tu=new Map([["Abs",[ja]],["Acos",[qa]],["Acosh",[Ka]],["Add",[Ai]],["ArgMax",[Ga,Nn]],["ArgMin",[Na,Nn]],["Asin",[Ya]],["Asinh",[Ja]],["Atan",[Xa]],["Atanh",[Za]],["AveragePool",[_s,Es]],["BiasAdd",[La]],["BiasSplitGelu",[Si]],["Cast",[ei,Qa]],["Ceil",[ri]],["ClipV10",[Gn]],["Clip",[ti]],["Concat",[Di,Wi]],["Conv",[Yn,Kn]],["ConvTranspose",[Ji,Yi]],["Cos",[ni]],["Cosh",[oi]],["Div",[Ii]],["Einsum",[Qi,es]],["Elu",[ai,Kr]],["Equal",[Ti]],["Erf",[ii]],["Exp",[si]],["Expand",[ns]],["Floor",[ui]],["FusedConv",[Yn,Kn]],["Gather",[is,as]],["GatherElements",[ls,us]],["Gelu",[li]],["Gemm",[ds,ps]],["GlobalAveragePool",[Ms,Rs]],["GlobalMaxPool",[zs,Ws]],["Greater",[Pi]],["GreaterOrEqual",[Mi]],["InstanceNormalization",[hs,ms]],["LayerNormalization",[bs,ys]],["LeakyRelu",[ci,Kr]],["Less",[Ri]],["LessOrEqual",[ki]],["Log",[xi]],["MatMul",[vs]],["MaxPool",[Bs,Ds]],["Mul",[Oi]],["Neg",[pi]],["Not",[di]],["Pad",[xs,Ss]],["Pow",[Ei]],["Range",[ou]],["Reciprocal",[fi]],["ReduceMin",[ka,rt]],["ReduceMean",[Ea,rt]],["ReduceMax",[Ma,rt]],["ReduceSum",[Da,rt]],["ReduceProd",[Ba,rt]],["ReduceL1",[_a,rt]],["ReduceL2",[Pa,rt]],["ReduceLogSum",[za,rt]],["ReduceLogSumExp",[Ra,rt]],["ReduceSumSquare",[Wa,rt]],["Relu",[mi]],["Resize",[iu,su]],["Sigmoid",[hi]],["Sin",[gi]],["Sinh",[yi]],["Slice",[fu,mu]],["SkipLayerNormalization",[lu,cu]],["Split",[wu,vu]],["Sqrt",[bi]],["Softmax",[gu,yu]],["Sub",[_i]],["Tan",[wi]],["Tanh",[vi]],["ThresholdedRelu",[$i,Kr]],["Tile",[Su]],["Transpose",[ga,ya]],["Where",[Au]]])});var un,Eu=K(()=>{"use strict";We();St();$e();un=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,o,a,u,i,d){let f=this.backend.device,h=this.backend.getComputePassEncoder();h.setPipeline(t.computePipeline);let c=[];for(let b of a)c.push({binding:c.length,resource:{buffer:b.buffer}});for(let b of u)c.push({binding:c.length,resource:{buffer:b.buffer}});d&&c.push({binding:c.length,resource:d});let C=f.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:c,label:t.programInfo.name});if(h.setBindGroup(0,C),h.dispatchWorkgroups(...i),this.backend.pendingDispatchNumber++,this.backend.isQueryEnabled()){typeof this.backend.queryData>"u"&&(this.backend.queryData=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let b=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.querySet,0,2,this.backend.queryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.queryData.buffer,0,b.buffer,0,this.backend.querySetCount*8),this.backend.flush();let $=this.backend.currentKernelId,S=this.backend.kernels.get($),x=`[${S[0]}] ${S[1]}`;b.buffer.mapAsync(GPUMapMode.READ).then(()=>{let A=new BigUint64Array(b.buffer.getMappedRange()),k=A[0],O=A[1];b.buffer.unmap(),typeof this.backend.queryTimeBase>"u"&&(this.backend.queryTimeBase=k);let P=Number(k-this.backend.queryTimeBase),R=Number(O-this.backend.queryTimeBase);if(!Number.isSafeInteger(P)||!Number.isSafeInteger(R))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(b.id);let V="";r.forEach((W,q)=>{V+=`input[${q}]: [${W.dims}] | ${fr(W.dataType)}, `});let B="";o.forEach((W,q)=>{B+=`output[${q}]: [${W.dims}] | ${fr(W.dataType)}, `}),console.log(`[profiling] kernel "${$}|${x}" ${V}${B}execution time: ${R-P} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(t,r){let o=this.backend.device,a=[];o.features.has("shader-f16")&&a.push("enable f16;");let u=ma(r),i=t.getShaderSource(u),d=`${a.join(`\n`)}\n${u.additionalImplementations}\n${i}`,f=o.createShaderModule({code:d,label:t.name});Ee("verbose",()=>`[WebGPU] ${t.name} shader code: ${d}`);let h=o.createComputePipeline({compute:{module:f,entryPoint:"main"},layout:"auto",label:t.name});return{programInfo:t,computePipeline:h}}normalizeDispatchGroupSize(t){let r=typeof t=="number"?t:t.x,o=typeof t=="number"?1:t.y||1,a=typeof t=="number"?1:t.z||1,u=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=u&&o<=u&&a<=u)return[r,o,a];let i=r*o*a,d=Math.ceil(Math.sqrt(i));if(d>u){if(d=Math.ceil(Math.cbrt(i)),d>u)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[d,d,d]}else return[d,d,1]}}});var Ld,Hd,ln,_u=K(()=>{"use strict";St();sa();da();Ou();Eu();Ld=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let o=0;o<e.length;++o){let a=e[o].dataType;switch(t[o]){case"none":{r.push("");break}case"type":{r.push(`${a}`);break}case"rank":{let u=e[o].dims.length;r.push(`${a};${u}`);break}case"dims":{let u=e[o].dims.join(",");r.push(`${a};${u}`);break}default:throw new Error(`unsupported input dependency: ${t[o]}`)}}return r.join("|")},Hd=(e,t,r)=>{let o=e.name;return e.shaderCache?.hint&&(o+="["+e.shaderCache.hint+"]"),o+=":"+r+`:${Ld(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,o},ln=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.querySetCount=2;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let r=await navigator.gpu.requestAdapter();if(!r)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=t;let o=[],a={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:o};r.features.has("timestamp-query")&&o.push("timestamp-query"),r.features.has("shader-f16")&&o.push("shader-f16"),this.device=await r.requestDevice(a),this.gpuDataManager=ca(this),this.programManager=new un(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,aa(t.logLevel,!!t.debug),this.device.onuncapturederror=u=>{u.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${u.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t={};this.isQueryEnabled()&&(typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}isQueryEnabled(){return!!(this.device.features.has("timestamp-query")&&this.env.webgpu.profilingMode==="default")}run(t,r,o,a,u){let i=[];for(let O=0;O<r.length;++O){let P=this.gpuDataManager.get(r[O].data);if(!P)throw new Error(`no GPU data for input: ${r[O].data}`);i[O]=P}let{outputs:d,dispatchGroup:f,programUniforms:h}=t.getRunData(r),c=o.length===0?d.map((O,P)=>P):o;if(c.length!==d.length)throw new Error(`Output size ${c.length} must be equal to ${d.length}.`);let C=[],b=[];for(let O=0;O<d.length;++O){if(!Number.isInteger(c[O])||c[O]<-3||c[O]>=d.length)throw new Error(`Invalid output index: ${c[O]}`);if(c[O]===-3)continue;let P=c[O]===-1,R=c[O]===-2,V=P||R?u(d[O].dataType,d[O].dims):a(c[O],d[O].dataType,d[O].dims),B=this.gpuDataManager.get(V.data);if(!B)throw new Error(`no GPU data for output: ${V.data}`);if(P&&this.temporaryData.push(B),R){let W=this.kernelPersistentData.get(this.currentKernelId);W||(W=[],this.kernelPersistentData.set(this.currentKernelId,W)),W.push(B)}C.push(V),b.push(B)}let $;if(h){let O=0,P=0,R=[],V=1;h.forEach(q=>{let ee=typeof q.data=="number"?[q.data]:q.data;if(ee.length===0)return;let oe;switch(ee.length){case 1:oe=4;break;case 2:oe=8;break;case 3:oe=16;break;case 4:oe=16;break;case 5:oe=16;break;case 6:oe=16;break;default:throw new Error(`unsupported data length: ${ee.length}`)}(P===5||P===6)&&(oe=16),oe>V&&(V=oe),O=Math.ceil(O/oe)*oe,P=ee.length,R.push(O),O+=ee.length*4}),O=Math.ceil(O/V)*V;let B=new ArrayBuffer(O);h.forEach((q,ee)=>{let oe=R[ee],D=typeof q.data=="number"?[q.data]:q.data;q.type==="int32"?new Int32Array(B,oe,D.length).set(D):q.type==="uint32"?new Uint32Array(B,oe,D.length).set(D):new Float32Array(B,oe,D.length).set(D)});let W=this.gpuDataManager.create(O,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(W.buffer,0,B,0,O),this.gpuDataManager.release(W.id),$={offset:0,size:O,buffer:W.buffer}}let S=this.programManager.normalizeDispatchGroupSize(f),x=S[1]===1&&S[2]===1,A=Hd(t,r,x),k=this.programManager.getArtifact(A);return k||(k=this.programManager.build(t,S),this.programManager.setArtifact(A,k)),Ee("info",()=>`[ProgramManager] run "${t.name}" (key=${A}) with ${S[0]}x${S[1]}x${S[2]}`),this.programManager.run(k,r,C,i,b,S,$),C}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,o,a){let u=Tu.get(t);if(!u)throw new Error(`kernel not implemented: ${t}`);this.kernels.set(r,[t,a,u[0],[u[1],o]])}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let o of r)this.gpuDataManager.release(o.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,o){let a=this.kernels.get(t);if(!a)throw new Error(`kernel not created: ${t}`);let[u,i,d,f]=a;if(this.currentKernelId!==null)throw new Error(`kernel "[${u}] ${i}" is not allowed to be called recursively`);this.currentKernelId=t,f[0]&&(f[1]=f[0](f[1]),f[0]=void 0),Ee("info",()=>`[WebGPU] Start to run kernel "[${u}] ${i}"...`);let h=this.env.debug;this.temporaryData=[];try{return h&&this.device.pushErrorScope("validation"),d(r,f[1]),0}catch(c){return o.push(Promise.resolve(`[WebGPU] Kernel "[${u}] ${i}" failed. ${c}`)),1}finally{h&&o.push(this.device.popErrorScope().then(c=>c?`GPU validation error for kernel "[${u}] ${i}": ${c.message}`:null));for(let c of this.temporaryData)this.gpuDataManager.release(c.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,o,a){let u=this.sessionExternalDataMapping.get(t);u||(u=new Map,this.sessionExternalDataMapping.set(t,u));let i=u.get(r),d=this.gpuDataManager.registerExternalBuffer(o,a,i?.[1]);return u.set(r,[d,o]),d}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(o=>this.gpuDataManager.unregisterExternalBuffer(o[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,o){return async()=>{let a=await Bn(this,t,r);return ia(a.buffer,o)}}}});var Pu={};Vr(Pu,{init:()=>jd});var vr,to,jd,Ru=K(()=>{"use strict";We();_u();St();ge();vr=class e{constructor(t,r,o,a){this.module=t;this.dataType=r;this.data=o;this.dims=a}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=z.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=z.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=z.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(z.size(t)!==z.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},to=class{constructor(t,r,o){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;let a=t.HEAPU32,u=o>>2;this.opKernelContext=a[u++];let i=a[u++];this.outputCount=a[u++],this.customDataOffset=a[u++],this.customDataSize=a[u++];let d=[];for(let f=0;f<i;f++){let h=a[u++],c=a[u++],C=a[u++],b=[];for(let $=0;$<C;$++)b.push(a[u++]);d.push(new vr(t,h,c,b))}this.inputs=d}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,r){let o=r?.inputs?.map(d=>typeof d=="number"?this.inputs[d]:d)??this.inputs,a=r?.outputs??[],u=(d,f,h)=>new vr(this.module,f,this.output(d,h),h),i=(d,f)=>{let h=mr(d);if(!h)throw new Error(`Unsupported data type: ${d}`);let c=h*z.size(f);return new vr(this.module,d,this.backend.gpuDataManager.create(c).id,f)};return this.backend.run(t,o,a,u,i)}output(t,r){let o=this.module.stackSave();try{let a=this.module.stackAlloc((1+r.length)*4),u=a>>2;this.module.HEAPU32[u++]=r.length;for(let i=0;i<r.length;i++)this.module.HEAPU32[u++]=r[i];return this.module._JsepOutput(this.opKernelContext,t,a)}catch(a){throw new Error(`Failed to generate kernel\'s output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${a}`)}finally{this.module.stackRestore(o)}}},jd=async(e,t)=>{let r=e.jsepInit;if(r&&navigator.gpu){if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let o=new ln;await o.initialize(t),r(o,a=>o.alloc(a),a=>o.free(a),(a,u,i,d=!1)=>{if(d)Ee("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${a}, dst=${u}, size=${i}`),o.memcpy(a,u);else{Ee("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${a}, gpuDataId=${u}, size=${i}`);let f=e.HEAPU8.subarray(a,a+i);o.upload(u,f)}},async(a,u,i)=>{Ee("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${a}, dataOffset=${u}, size=${i}`),await o.download(a,()=>e.HEAPU8.subarray(u,u+i))},(a,u,i)=>o.createKernel(a,u,i,t.debug||t.webgpu.profilingMode==="default"?e.UTF8ToString(e._JsepGetNodeName(u)):`${u}`),a=>o.releaseKernel(a),(a,u,i,d)=>{Ee("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${i}, kernel=${a}, contextDataOffset=${u}`);let f=new to(e,o,u);return o.computeKernel(a,f,d)})}}});var Zo;Zo=Go();var yl=Yo(),_n,Pn=!1,Ur=!1,Xo=!1,bl=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},wl=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},vl=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Qo=async e=>{if(Pn)return Promise.resolve();if(Ur)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(Xo)throw new Error("previous call to \'initializeWebAssembly()\' failed.");Ur=!0;let t=e.initTimeout,r=e.numThreads,o=e.simd,a=r>1&&bl(),u=o&&wl(),i=e.wasmPaths,d=typeof i=="string"?i:void 0,f=vl(u,a),h=typeof i=="object"?i[f]:void 0,c=!1,C=[];if(t>0&&C.push(new Promise(b=>{setTimeout(()=>{c=!0,b()},t)})),C.push(new Promise((b,$)=>{let S=a?yl:Zo,x={locateFile:(A,k)=>{if(a&&A.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Jo()],{type:"text/javascript"}));if(A.endsWith(".wasm")){if(h)return h;let O=d??k;return f==="ort-wasm-simd.wasm"?O+"ort-wasm-simd.jsep.wasm":f==="ort-wasm-simd-threaded.wasm"?O+"ort-wasm-simd-threaded.jsep.wasm":O+f}return k+A}};if(a)if(typeof Blob>"u")x.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let A=`var ortWasmThreaded=${S.toString()};`;x.mainScriptUrlOrBlob=new Blob([A],{type:"text/javascript"})}S(x).then(A=>{Ur=!1,Pn=!0,_n=A,b()},A=>{Ur=!1,Xo=!0,$(A)})})),await Promise.race(C),c)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},_e=()=>{if(Pn&&_n)return _n;throw new Error("WebAssembly is not initialized yet.")};var Re=(e,t)=>{let r=_e(),o=r.lengthBytesUTF8(e)+1,a=r._malloc(o);return r.stringToUTF8(e,a,o),t.push(a),a},pr=(e,t,r,o)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([a,u])=>{let i=t?t+a:a;if(typeof u=="object")pr(u,i+".",r,o);else if(typeof u=="string"||typeof u=="number")o(i,u.toString());else if(typeof u=="boolean")o(i,u?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof u}`)})},Ae=e=>{let t=_e(),r=t.stackSave();try{let o=t.stackAlloc(8);t._OrtGetLastError(o,o+4);let a=t.HEAP32[o/4],u=t.HEAPU32[o/4+1],i=u?t.UTF8ToString(u):"";throw new Error(`${e} ERROR_CODE: ${a}, ERROR_MESSAGE: ${i}`)}finally{t.stackRestore(r)}};var ea=e=>{let t=_e(),r=0,o=[],a=e||{};try{if(e?.logSeverityLevel===void 0)a.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)a.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(a.terminate=!1);let u=0;return e?.tag!==void 0&&(u=Re(e.tag,o)),r=t._OrtCreateRunOptions(a.logSeverityLevel,a.logVerbosityLevel,!!a.terminate,u),r===0&&Ae("Can\'t create run options."),e?.extra!==void 0&&pr(e.extra,"",new WeakSet,(i,d)=>{let f=Re(i,o),h=Re(d,o);t._OrtAddRunConfigEntry(r,f,h)!==0&&Ae(`Can\'t set a run config entry: ${i} - ${d}.`)}),[r,o]}catch(u){throw r!==0&&t._OrtReleaseRunOptions(r),o.forEach(i=>t._free(i)),u}};var $l=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},xl=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Sl=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},Cl=(e,t,r)=>{for(let o of t){let a=typeof o=="string"?o:o.name;switch(a){case"xnnpack":a="XNNPACK";break;case"webnn":if(a="WEBNN",typeof o!="string"){let i=o;if(i?.deviceType){let d=Re("deviceType",r),f=Re(i.deviceType,r);_e()._OrtAddSessionConfigEntry(e,d,f)!==0&&Ae(`Can\'t set a session config entry: \'deviceType\' - ${i.deviceType}.`)}if(i?.numThreads){let d=i.numThreads;(typeof d!="number"||!Number.isInteger(d)||d<0)&&(d=0);let f=Re("numThreads",r),h=Re(d.toString(),r);_e()._OrtAddSessionConfigEntry(e,f,h)!==0&&Ae(`Can\'t set a session config entry: \'numThreads\' - ${i.numThreads}.`)}if(i?.powerPreference){let d=Re("powerPreference",r),f=Re(i.powerPreference,r);_e()._OrtAddSessionConfigEntry(e,d,f)!==0&&Ae(`Can\'t set a session config entry: \'powerPreference\' - ${i.powerPreference}.`)}}break;case"webgpu":if(a="JS",typeof o!="string"){let i=o;if(i?.preferredLayout){if(i.preferredLayout!=="NCHW"&&i.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${i.preferredLayout}`);let d=Re("preferredLayout",r),f=Re(i.preferredLayout,r);_e()._OrtAddSessionConfigEntry(e,d,f)!==0&&Ae(`Can\'t set a session config entry: \'preferredLayout\' - ${i.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${a}`)}let u=Re(a,r);_e()._OrtAppendExecutionProvider(e,u)!==0&&Ae(`Can\'t append execution provider: ${a}.`)}},ta=e=>{let t=_e(),r=0,o=[],a=e||{};Sl(a);try{let u=$l(a.graphOptimizationLevel??"all"),i=xl(a.executionMode??"sequential"),d=typeof a.logId=="string"?Re(a.logId,o):0,f=a.logSeverityLevel??2;if(!Number.isInteger(f)||f<0||f>4)throw new Error(`log serverity level is not valid: ${f}`);let h=a.logVerbosityLevel??0;if(!Number.isInteger(h)||h<0||h>4)throw new Error(`log verbosity level is not valid: ${h}`);let c=typeof a.optimizedModelFilePath=="string"?Re(a.optimizedModelFilePath,o):0;if(r=t._OrtCreateSessionOptions(u,!!a.enableCpuMemArena,!!a.enableMemPattern,i,!!a.enableProfiling,0,d,f,h,c),r===0&&Ae("Can\'t create session options."),a.executionProviders&&Cl(r,a.executionProviders,o),a.freeDimensionOverrides)for(let[C,b]of Object.entries(a.freeDimensionOverrides)){if(typeof C!="string")throw new Error(`free dimension override name must be a string: ${C}`);if(typeof b!="number"||!Number.isInteger(b)||b<0)throw new Error(`free dimension override value must be a non-negative integer: ${b}`);let $=Re(C,o);t._OrtAddFreeDimensionOverride(r,$,b)!==0&&Ae(`Can\'t set a free dimension override: ${C} - ${b}.`)}return a.extra!==void 0&&pr(a.extra,"",new WeakSet,(C,b)=>{let $=Re(C,o),S=Re(b,o);t._OrtAddSessionConfigEntry(r,$,S)!==0&&Ae(`Can\'t set a session config entry: ${C} - ${b}.`)}),[r,o]}catch(u){throw r!==0&&t._OrtReleaseSessionOptions(r),o.forEach(i=>t._free(i)),u}};We();var ku=!1,qd=e=>{let t=_e(),r=t.stackSave();try{let o=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,o,o+4)!==0&&Ae("Can\'t get session input/output count."),[t.HEAP32[o/4],t.HEAP32[o/4+1]]}finally{t.stackRestore(r)}},Kd=(e,t)=>{_e()._OrtInit(e,t)!==0&&Ae("Can\'t initialize onnxruntime.")},Bu=async e=>{Kd(e.wasm.numThreads,hr(e.logLevel));{let t=(Ru(),qt(Pu)).init;await t(_e(),e)}ku=!0},$r=new Map,Du=()=>ku,ro=e=>{let t=_e(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},no=(e,t)=>{let r=_e(),o=0,a=0,u=0,i=[],d=[],f=[];try{[a,i]=ta(t),o=r._OrtCreateSession(e[0],e[1],a),o===0&&Ae("Can\'t create a session.");let[h,c]=qd(o),C=[],b=[],$=[];for(let x=0;x<h;x++){let A=r._OrtGetInputName(o,x);A===0&&Ae("Can\'t get an input name."),d.push(A),C.push(r.UTF8ToString(A))}for(let x=0;x<c;x++){let A=r._OrtGetOutputName(o,x);A===0&&Ae("Can\'t get an output name."),f.push(A);let k=r.UTF8ToString(A);b.push(k);{let O=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[k]??"cpu";if(O!=="cpu"&&O!=="cpu-pinned"&&O!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${O}.`);$.push(O)}}let S=null;return $.some(x=>x==="gpu-buffer")&&(u=r._OrtCreateBinding(o),u===0&&Ae("Can\'t create IO binding."),S={handle:u,outputPreferredLocations:$,outputPreferredLocationsEncoded:$.map(x=>Mn(x))}),$r.set(o,[o,d,f,S]),[o,C,b]}catch(h){throw d.forEach(c=>r._OrtFree(c)),f.forEach(c=>r._OrtFree(c)),u!==0&&r._OrtReleaseBinding(u),o!==0&&r._OrtReleaseSession(o),h}finally{r._free(e[0]),a!==0&&r._OrtReleaseSessionOptions(a),i.forEach(h=>r._free(h))}},Wu=(e,t)=>{let r=ro(e);return no(r,t)},zu=e=>{let t=_e(),r=$r.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[o,a,u,i]=r;i&&t._OrtReleaseBinding(i.handle),t.jsepUnregisterBuffers?.(e),a.forEach(d=>t._OrtFree(d)),u.forEach(d=>t._OrtFree(d)),t._OrtReleaseSession(o),$r.delete(e)},Mu=(e,t,r,o,a)=>{if(!e){t.push(0);return}let u=_e(),i=e[0],d=e[1],f=e[3],h,c;if(i==="string"&&f==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(f==="gpu-buffer"){let $=e[2].gpuBuffer,S=mr(Rn(i));c=d.reduce((x,A)=>x*A,1)*S,h=u.jsepRegisterBuffer(o,a,$,c)}else{let $=e[2];if(Array.isArray($)){c=4*$.length,h=u._malloc(c),r.push(h);let S=h/4;for(let x=0;x<$.length;x++){if(typeof $[x]!="string")throw new TypeError(`tensor data at index ${x} is not a string`);u.HEAPU32[S++]=Re($[x],r)}}else c=$.byteLength,h=u._malloc(c),r.push(h),u.HEAPU8.set(new Uint8Array($.buffer,$.byteOffset,c),h)}let C=u.stackSave(),b=u.stackAlloc(4*d.length);try{let $=b/4;d.forEach(x=>u.HEAP32[$++]=x);let S=u._OrtCreateTensor(Rn(i),h,c,b,d.length,Mn(f));S===0&&Ae(`Can\'t create tensor for input/output. session=${o}, index=${a}.`),t.push(S)}finally{u.stackRestore(C)}},Vu=async(e,t,r,o,a,u)=>{let i=_e(),d=$r.get(e);if(!d)throw new Error(`cannot run inference. invalid session id: ${e}`);let[f,h,c,C]=d,b=t.length,$=o.length,S=0,x=[],A=[],k=[],O=[],P=i.stackSave(),R=i.stackAlloc(b*4),V=i.stackAlloc(b*4),B=i.stackAlloc($*4),W=i.stackAlloc($*4);try{[S,x]=ea(u);for(let Z=0;Z<b;Z++)Mu(r[Z],A,O,e,t[Z]);for(let Z=0;Z<$;Z++)Mu(a[Z],k,O,e,b+o[Z]);let q=R/4,ee=V/4,oe=B/4,D=W/4;for(let Z=0;Z<b;Z++)i.HEAPU32[q++]=A[Z],i.HEAPU32[ee++]=h[t[Z]];for(let Z=0;Z<$;Z++)i.HEAPU32[oe++]=k[Z],i.HEAPU32[D++]=c[o[Z]];if(C){let{handle:Z,outputPreferredLocations:ve,outputPreferredLocationsEncoded:Te}=C;if(h.length!==b)throw new Error(`input count from feeds (${b}) is expected to be always equal to model\'s input count (${h.length}).`);for(let be=0;be<b;be++){let Be=t[be];await i._OrtBindInput(Z,h[Be],A[be])!==0&&Ae(`Can\'t bind input[${be}] for session=${e}.`)}for(let be=0;be<$;be++){let Be=o[be];a[be]?.[3]?i._OrtBindOutput(Z,c[Be],k[be],0)!==0&&Ae(`Can\'t bind pre-allocated output[${be}] for session=${e}.`):i._OrtBindOutput(Z,c[Be],0,Te[Be])!==0&&Ae(`Can\'t bind output[${be}] to ${ve[be]} for session=${e}.`)}}let te;C?te=await i._OrtRunWithBinding(f,C.handle,$,B,S):te=await i._OrtRun(f,V,R,b,W,$,B,S),te!==0&&Ae("failed to call OrtRun().");let Ie=[];for(let Z=0;Z<$;Z++){let ve=i.HEAPU32[B/4+Z];if(ve===k[Z]){Ie.push(a[Z]);continue}let Te=i.stackSave(),be=i.stackAlloc(4*4),Be=!1,Se,Ue=0;try{i._OrtGetTensorData(ve,be,be+4,be+8,be+12)!==0&&Ae(`Can\'t access output tensor data on index ${Z}.`);let Ke=be/4,Ye=i.HEAPU32[Ke++];Ue=i.HEAPU32[Ke++];let G=i.HEAPU32[Ke++],pe=i.HEAPU32[Ke++],de=[];for(let Ce=0;Ce<pe;Ce++)de.push(i.HEAPU32[G/4+Ce]);i._OrtFree(G);let Ne=de.reduce((Ce,Pe)=>Ce*Pe,1);Se=fr(Ye);let Ge=C?.outputPreferredLocations[o[Z]];if(Se==="string"){if(Ge==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Ce=[],Pe=Ue/4;for(let vt=0;vt<Ne;vt++){let He=i.HEAPU32[Pe++],zt=vt===Ne-1?void 0:i.HEAPU32[Pe]-He;Ce.push(i.UTF8ToString(He,zt))}Ie.push([Se,de,Ce,"cpu"])}else if(Ge==="gpu-buffer"&&Ne>0){let Ce=i.jsepGetBuffer(Ue),Pe=mr(Ye);if(Pe===void 0||!ra(Se))throw new Error(`Unsupported data type: ${Se}`);Be=!0,Ie.push([Se,de,{gpuBuffer:Ce,download:i.jsepCreateDownloader(Ce,Ne*Pe,Se),dispose:()=>{i._OrtReleaseTensor(ve)}},"gpu-buffer"])}else{let Ce=Nr(Se),Pe=new Ce(Ne);new Uint8Array(Pe.buffer,Pe.byteOffset,Pe.byteLength).set(i.HEAPU8.subarray(Ue,Ue+Pe.byteLength)),Ie.push([Se,de,Pe,"cpu"])}}finally{i.stackRestore(Te),Se==="string"&&Ue&&i._free(Ue),Be||i._OrtReleaseTensor(ve)}}return C&&i._OrtClearBoundOutputs(C.handle),Ie}finally{i.stackRestore(P),A.forEach(q=>i._OrtReleaseTensor(q)),k.forEach(q=>i._OrtReleaseTensor(q)),O.forEach(q=>i._free(q)),S!==0&&i._OrtReleaseRunOptions(S),x.forEach(q=>i._free(q))}},Uu=e=>{let t=_e(),r=$r.get(e);if(!r)throw new Error("invalid session id");let o=r[0],a=t._OrtEndProfiling(o);a===0&&Ae("Can\'t get an profile file name."),t._OrtFree(a)},Nu=e=>{let t=[];for(let r of e){let o=r[2];!Array.isArray(o)&&"buffer"in o&&t.push(o.buffer)}return t};self.onmessage=e=>{switch(e.data.type){case"init-wasm":try{Qo(e.data.in).then(()=>postMessage({type:"init-wasm"}),t=>postMessage({type:"init-wasm",err:t}))}catch(t){postMessage({type:"init-wasm",err:t})}break;case"init-ort":try{Bu(e.data.in).then(()=>postMessage({type:"init-ort"}),t=>postMessage({type:"init-ort",err:t}))}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{let{model:t}=e.data.in,r=ro(t);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{let{modeldata:t,options:r}=e.data.in,o=no(t,r);postMessage({type:"create_finalize",out:o})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{let{model:t,options:r}=e.data.in,o=Wu(t,r);postMessage({type:"create",out:o})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{let t=e.data.in;zu(t),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{let{sessionId:t,inputIndices:r,inputs:o,outputIndices:a,options:u}=e.data.in;Vu(t,r,o,a,u).then(i=>{postMessage({type:"run",out:i},Nu(i))},i=>{postMessage({type:"run",err:i})})}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{let t=e.data.in;Uu(t),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}break;case"is-ort-env-initialized":try{let t=Du();postMessage({type:"is-ort-env-initialized",out:t})}catch(t){postMessage({type:"is-ort-env-initialized",err:t})}break;default:}};})();\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n'});var Dr,Pt,ga,Cu,Eu,xu,wu,Tu,$u,Su,Iu,Au,_u,Ou,qr,OT,ma,Ry,My,Ly,Ny,Pu,Fy,zy,Gy,Vy,Du=M(()=>{"use strict";Lt();ky();Gn();Dr=()=>!!we.wasm.proxy&&typeof document<"u",ga=!1,Cu=!1,Eu=!1,Tu=[],$u=[],Su=[],Iu=[],Au=[],_u=[],Ou=[],qr=()=>{if(ga||!Cu||Eu||!Pt)throw new Error("worker not ready")},OT=r=>{switch(r.data.type){case"init-wasm":ga=!1,r.data.err?(Eu=!0,xu[1](r.data.err)):(Cu=!0,xu[0]());break;case"init-ort":r.data.err?wu[1](r.data.err):wu[0]();break;case"create_allocate":r.data.err?Tu.shift()[1](r.data.err):Tu.shift()[0](r.data.out);break;case"create_finalize":r.data.err?$u.shift()[1](r.data.err):$u.shift()[0](r.data.out);break;case"create":r.data.err?Su.shift()[1](r.data.err):Su.shift()[0](r.data.out);break;case"release":r.data.err?Iu.shift()[1](r.data.err):Iu.shift()[0]();break;case"run":r.data.err?Au.shift()[1](r.data.err):Au.shift()[0](r.data.out);break;case"end-profiling":r.data.err?_u.shift()[1](r.data.err):_u.shift()[0]();break;case"is-ort-env-initialized":r.data.err?Ou.shift()[1](r.data.err):Ou.shift()[0](r.data.out);break;default:}},ma=typeof document<"u"?document?.currentScript?.src:void 0,Ry=async()=>{if(Dr()){if(Cu)return;if(ga)throw new Error("multiple calls to 'initWasm()' detected.");if(Eu)throw new Error("previous call to 'initWasm()' failed.");return ga=!0,we.wasm.wasmPaths===void 0&&ma&&ma.indexOf("blob:")!==0&&(we.wasm.wasmPaths=ma.substr(0,+ma.lastIndexOf("/")+1)),new Promise((r,e)=>{Pt?.terminate();let n=URL.createObjectURL(new Blob([By()],{type:"text/javascript"}));Pt=new Worker(n,{name:"ort-wasm-proxy-worker"}),Pt.onerror=o=>e(o),Pt.onmessage=OT,URL.revokeObjectURL(n),xu=[r,e];let t={type:"init-wasm",in:we.wasm};Pt.postMessage(t)})}else return sm(we.wasm)},My=async r=>{if(Dr())return qr(),new Promise((e,n)=>{wu=[e,n];let t={type:"init-ort",in:r};Pt.postMessage(t)});await Ay(r)},Ly=async r=>Dr()?(qr(),new Promise((e,n)=>{Tu.push([e,n]);let t={type:"create_allocate",in:{model:r}};Pt.postMessage(t,[r.buffer])})):yu(r),Ny=async(r,e)=>Dr()?(qr(),new Promise((n,t)=>{$u.push([n,t]);let o={type:"create_finalize",in:{modeldata:r,options:e}};Pt.postMessage(o)})):vu(r,e),Pu=async(r,e)=>{if(Dr()){if(e?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return qr(),new Promise((n,t)=>{Su.push([n,t]);let o={type:"create",in:{model:r,options:e}};Pt.postMessage(o,[r.buffer])})}else return Oy(r,e)},Fy=async r=>{if(Dr())return qr(),new Promise((e,n)=>{Iu.push([e,n]);let t={type:"release",in:r};Pt.postMessage(t)});Cy(r)},zy=async(r,e,n,t,o,i)=>{if(Dr()){if(n.some(s=>s[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(o.some(s=>s))throw new Error("pre-allocated output tensor is not supported for proxy.");return qr(),new Promise((s,a)=>{Au.push([s,a]);let u=n,l={type:"run",in:{sessionId:r,inputIndices:e,inputs:u,outputIndices:t,options:i}};Pt.postMessage(l,Dy(u))})}else return Ey(r,e,n,t,o,i)},Gy=async r=>{if(Dr())return qr(),new Promise((e,n)=>{_u.push([e,n]);let t={type:"end-profiling",in:r};Pt.postMessage(t)});Py(r)},Vy=async()=>Dr()?(qr(),new Promise((r,e)=>{Ou.push([r,e]);let n={type:"is-ort-env-initialized"};Pt.postMessage(n)})):_y()});var ba,Wy,CT,ya,Uy=M(()=>{"use strict";Lt();Du();pt();Wy=(r,e)=>{switch(r.location){case"cpu":return[r.type,r.dims,r.data,"cpu"];case"gpu-buffer":return[r.type,r.dims,{gpuBuffer:r.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${r.location} for ${e()}`)}},CT=r=>{switch(r[3]){case"cpu":return new ft(r[0],r[2],r[1]);case"gpu-buffer":{let e=r[0];if(!Yi(e))throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);let{gpuBuffer:n,download:t,dispose:o}=r[2];return ft.fromGpuBuffer(n,{dataType:e,dims:r[1],download:t,dispose:o})}default:throw new Error(`invalid data location: ${r[3]}`)}},ya=class{async createSessionAllocate(e){let n=await fetch(e);if(n.status!==200)throw new Error(`failed to load model: ${e}`);let t=await n.arrayBuffer();return Ly(new Uint8Array(t))}async loadModel(e,n){if(await Vy()||(ba||(ba=My(we)),await ba,ba=void 0),typeof e=="string")if(typeof process<"u"&&process.versions&&process.versions.node){let t=await(void 0)(e);[this.sessionId,this.inputNames,this.outputNames]=await Pu(t,n)}else{let t=await this.createSessionAllocate(e);[this.sessionId,this.inputNames,this.outputNames]=await Ny(t,n)}else[this.sessionId,this.inputNames,this.outputNames]=await Pu(e,n)}async dispose(){return Fy(this.sessionId)}async run(e,n,t){let o=[],i=[];Object.entries(e).forEach(m=>{let b=m[0],x=m[1],y=this.inputNames.indexOf(b);if(y===-1)throw new Error(`invalid input '${b}'`);o.push(x),i.push(y)});let s=[],a=[];Object.entries(n).forEach(m=>{let b=m[0],x=m[1],y=this.outputNames.indexOf(b);if(y===-1)throw new Error(`invalid output '${b}'`);s.push(x),a.push(y)});let u=o.map((m,b)=>Wy(m,()=>`input "${this.inputNames[i[b]]}"`)),l=s.map((m,b)=>m?Wy(m,()=>`output "${this.outputNames[a[b]]}"`):null),c=await zy(this.sessionId,i,u,a,l,t),h={};for(let m=0;m<c.length;m++)h[this.outputNames[a[m]]]=s[m]??CT(c[m]);return h}startProfiling(){}endProfiling(){Gy(this.sessionId)}}});var ET,va,Hy=M(()=>{"use strict";Lt();Du();Uy();ET=()=>{if((typeof we.wasm.initTimeout!="number"||we.wasm.initTimeout<0)&&(we.wasm.initTimeout=0),typeof we.wasm.simd!="boolean"&&(we.wasm.simd=!0),typeof we.wasm.proxy!="boolean"&&(we.wasm.proxy=!1),typeof we.wasm.numThreads!="number"||!Number.isInteger(we.wasm.numThreads)||we.wasm.numThreads<=0){let r=typeof navigator>"u"?(void 0)().length:navigator.hardwareConcurrency;we.wasm.numThreads=Math.min(4,Math.ceil((r||1)/2))}},va=class{async init(){ET(),await Ry()}async createInferenceSessionHandler(e,n){let t=new ya;return await t.loadModel(e,n),Promise.resolve(t)}}});var jy={};Mr(jy,{wasmBackend:()=>PT});var PT,qy=M(()=>{"use strict";Hy();PT=new va});var kT={};Mr(kT,{InferenceSession:()=>Ml,Tensor:()=>ft,TrainingSession:()=>zl,default:()=>DT,env:()=>we,registerBackend:()=>ur});Lt();Lt();Lt();var Vl="1.17.0";var DT=Ra;{let r=(qh(),Ar(jh)).onnxjsBackend;ur("webgl",r,-10)}{let r=(qy(),Ar(jy)).wasmBackend;typeof navigator<"u"&&navigator.gpu&&ur("webgpu",r,5),ur("cpu",r,10),ur("wasm",r,10),ur("xnnpack",r,9),ur("webnn",r,9)}Object.defineProperty(we.versions,"web",{value:Vl,enumerable:!0});return Ar(kT);})();
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/*! Bundled license information:

long/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=ort.all.min.js.map
